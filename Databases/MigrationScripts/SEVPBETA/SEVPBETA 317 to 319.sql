/*
This is the migration script to update the database with the set of uncommitted changes you selected.

You can customize the script, and your edits will be used in deployment.
The following objects will be affected:
  dbo.bAPTH, dbo.bAPTL, dbo.bPMSL, dbo.bPMOL, dbo.bPREH, dbo.bSLCO,
  dbo.vAPAUPayeeTaxPaymentATO, dbo.vAPAUPayerTaxPaymentATO, dbo.vPMSubmittal,
  dbo.vPMSubmittalPackage, dbo.vSLClaimHeader, dbo.vSLClaimItem,
  dbo.vPRAULimitsAndRates, dbo.vPRCraftClassAllowance,
  dbo.vPRCraftClassTemplateAllowance, dbo.vPRCraftMasterAllowance,
  dbo.vPRCraftTemplateAllowance, dbo.vPREmplPeriodsWithoutPay,
  dbo.vfPRRateDefault, dbo.vfAPAUATOAddressGet, dbo.APAUPayeeTaxPaymentATO,
  dbo.APAUPayerTaxPaymentATO, dbo.PMSCOTotal, dbo.PREmplPeriodsWithoutPay,
  dbo.PRAULimitsAndRates, dbo.udxrefAPVendor, dbo.udxrefARCustomer,
  dbo.vwMckNewProject, dbo.vspAPAUATOAmendedDateVal,
  dbo.vspSLClaimUpdateAPGridFill, dbo.bspPMSLInitialize, dbo.vspHQCOInfoGetVal,
  dbo.vspPRAUItemVal, dbo.vspAPT5018XML,
  dbo.vspVACompanyCopyWizardGetParentTables, dbo.bspAPPurge,
  dbo.bspVAWDNotifier, dbo.vspAPTaxablePaymentUpdate,
  dbo.vspAPAUATOPayeeTaxPaymentsInit, dbo.vspPRProcessArrearsPayback,
  dbo.vspPMInterfacePOCONum, dbo.vspPR_AU_Standard,
  dbo.vspPR_AU_ETP_Pre83TaxFreeGet, dbo.vspPR_AU_ETP_RedundancyTaxFreeGet,
  dbo.vspPMPCOApprovePMSL, dbo.vspPR_AU_TaxYearWagesGet,
  dbo.vspPR_AU_Redundancy, dbo.vspPRGetEmplNoTimecardsForArrears,
  dbo.bspEMBFVal_Usage, dbo.vspPRAUPAYGItemSetup, dbo.vspPR_AU_Death,
  dbo.vrptPRPAYGPaymentDetails, dbo.bspPRProcessFed, dbo.bspEMBFRevBdownVal,
  dbo.vspSLValForPMOL, dbo.vspPR_AU_ETP_CapAmtsGet,
  dbo.vspPR_AU_UnderPreservationAgeYN, dbo.vspPR_AU_ETP_LimitsAndRatesGet,
  dbo.vspEMACProcess, dbo.vspAPTaxablePaymentGridFill,
  dbo.vspPMSendSearchAvailableDocuments, dbo.bspAPLBVal, dbo.bspPRRMInit,
  dbo.vspPREmplPWPDateVal, dbo.vspPR_AU_Unfair, dbo.vspAPT5018PRINT,
  dbo.vspPRAUPAYGItemVal, dbo.vspPR_AU_Marginal_PAYG,
  dbo.vspSMWorkCompletedLaborUpdate, dbo.vspAPAUATOPayerTaxYearVal,
  dbo.vspAPAUATOExportGet, dbo.bspMSIBVal, dbo.vspPR_AU_Invalidity,
  dbo.bspPRProcess, dbo.vspIMUploadAPDB, dbo.vspIMUploadHeaderDetailPay,
  dbo.vspPMSLGetNextSLVal, dbo.vspAPAUATOClearAmendedEFile,
  dbo.vspSMWorkCompletedLaborCreate, dbo.vspPRLoadAllowances,
  dbo.vspPRProcessArrears, dbo.vspSMGLDistributionPost,
  dbo.vspPRDaysWithoutPayGet, dbo.vspPR_AU_ETP_TaxComputations,
  dbo.vspPR_AU_ETP_TaxRatesGet, dbo.vspPMSLGetNextSLSeq,
  dbo.vspPRAUPAYGEmplItemAmountsGet, dbo.vspPR_AU_ETP_InvalidityTaxFreeGet,
  dbo.vspAPTaxableTaxYearVal, dbo.vspAPTaxableCreditorVal,
  dbo.vspSLClaimNoTotalsGet, dbo.vspPRLoadAllowanceHoursAggregated,
  dbo.vspSLClaimBalForwardCreate
*/

SET NUMERIC_ROUNDABORT OFF
GO
SET ANSI_PADDING, ANSI_WARNINGS, CONCAT_NULL_YIELDS_NULL, ARITHABORT, QUOTED_IDENTIFIER, ANSI_NULLS ON
GO
PRINT N'Dropping foreign keys from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [FK_vSLClaimItem_bSLHD]
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [FK_vSLClaimItem_vSLClaimHeader]
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [FK_vSLClaimItem_bSLIT]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [PK_vSLClaimItem]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_ClaimToDateUnits]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_ClaimToDateAmt]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_UnitsClaimed]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_AmtClaimed]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_UnitsApproved]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_AmtApproved]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_ApproveRetPct]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_RetApproved]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_TaxAmount]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_CurUnitCost]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_CurUnits]
GO
PRINT N'Dropping constraints from [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] DROP CONSTRAINT [DF_vSLClaimItem_CurCost]
GO
PRINT N'Dropping index [IX_vSLClaimItem_KeyID] from [dbo].[vSLClaimItem]'
GO
DROP INDEX [IX_vSLClaimItem_KeyID] ON [dbo].[vSLClaimItem]
GO
PRINT N'Dropping index [IX_vSLClaimItem_SL] from [dbo].[vSLClaimItem]'
GO
DROP INDEX [IX_vSLClaimItem_SL] ON [dbo].[vSLClaimItem]
GO
PRINT N'Dropping index [IX_vSLClaimItem_ClaimNo] from [dbo].[vSLClaimItem]'
GO
DROP INDEX [IX_vSLClaimItem_ClaimNo] ON [dbo].[vSLClaimItem]
GO
PRINT N'Dropping index [IX_vSLClaimItem_SLItem] from [dbo].[vSLClaimItem]'
GO
DROP INDEX [IX_vSLClaimItem_SLItem] ON [dbo].[vSLClaimItem]
GO
PRINT N'Refreshing [dbo].[JCJP]'
GO
EXEC sp_refreshview N'[dbo].[JCJP]'
GO
PRINT N'Refreshing [dbo].[JCID]'
GO
EXEC sp_refreshview N'[dbo].[JCID]'
GO
PRINT N'Refreshing [dbo].[JCCM]'
GO
EXEC sp_refreshview N'[dbo].[JCCM]'
GO
PRINT N'Refreshing [dbo].[JCCI]'
GO
EXEC sp_refreshview N'[dbo].[JCCI]'
GO
PRINT N'Refreshing [dbo].[JCCH]'
GO
EXEC sp_refreshview N'[dbo].[JCCH]'
GO
PRINT N'Refreshing [dbo].[JCCD]'
GO
EXEC sp_refreshview N'[dbo].[JCCD]'
GO
PRINT N'Refreshing [dbo].[HQCO]'
GO
EXEC sp_refreshview N'[dbo].[HQCO]'
GO
PRINT N'Refreshing [dbo].[brvJCProgressVSBilled]'
GO
EXEC sp_refreshview N'[dbo].[brvJCProgressVSBilled]'
GO
PRINT N'Refreshing [dbo].[RPRPShared]'
GO
EXEC sp_refreshview N'[dbo].[RPRPShared]'
GO
PRINT N'Refreshing [dbo].[HQSA]'
GO
EXEC sp_refreshview N'[dbo].[HQSA]'
GO
PRINT N'Refreshing [dbo].[DDDTShared]'
GO
EXEC sp_refreshview N'[dbo].[DDDTShared]'
GO
PRINT N'Refreshing [dbo].[DDSLShared]'
GO
EXEC sp_refreshview N'[dbo].[DDSLShared]'
GO
PRINT N'Refreshing [dbo].[DDDU]'
GO
EXEC sp_refreshview N'[dbo].[DDDU]'
GO
PRINT N'Refreshing [dbo].[HQSAExclusions]'
GO
EXEC sp_refreshview N'[dbo].[HQSAExclusions]'
GO
PRINT N'Refreshing [dbo].[HQMA]'
GO
EXEC sp_refreshview N'[dbo].[HQMA]'
GO
PRINT N'Altering [dbo].[bPREH]'
GO
ALTER TABLE [dbo].[bPREH] ADD
[RecentRehireDate] [dbo].[bDate] NULL,
[RecentSeparationDate] [dbo].[bDate] NULL,
[SeparationRedundancyRetirement] [dbo].[bYN] NOT NULL CONSTRAINT [DF_bPREH_SeparationRedundancyRetirement] DEFAULT ('N')
GO
PRINT N'Refreshing [dbo].[HQRS]'
GO
EXEC sp_refreshview N'[dbo].[HQRS]'
GO
PRINT N'Refreshing [dbo].[PRTP]'
GO
EXEC sp_refreshview N'[dbo].[PRTP]'
GO
PRINT N'Refreshing [dbo].[PRTE]'
GO
EXEC sp_refreshview N'[dbo].[PRTE]'
GO
PRINT N'Refreshing [dbo].[PREH]'
GO
EXEC sp_refreshview N'[dbo].[PREH]'
GO
PRINT N'Refreshing [dbo].[PREC]'
GO
EXEC sp_refreshview N'[dbo].[PREC]'
GO
PRINT N'Refreshing [dbo].[PRCT]'
GO
EXEC sp_refreshview N'[dbo].[PRCT]'
GO
PRINT N'Refreshing [dbo].[PRCP]'
GO
EXEC sp_refreshview N'[dbo].[PRCP]'
GO
PRINT N'Refreshing [dbo].[PRCM]'
GO
EXEC sp_refreshview N'[dbo].[PRCM]'
GO
PRINT N'Refreshing [dbo].[PRCE]'
GO
EXEC sp_refreshview N'[dbo].[PRCE]'
GO
PRINT N'Refreshing [dbo].[PRCR]'
GO
EXEC sp_refreshview N'[dbo].[PRCR]'
GO
PRINT N'Refreshing [dbo].[PRIN]'
GO
EXEC sp_refreshview N'[dbo].[PRIN]'
GO
PRINT N'Refreshing [dbo].[PRCO]'
GO
EXEC sp_refreshview N'[dbo].[PRCO]'
GO
PRINT N'Refreshing [dbo].[JCTI]'
GO
EXEC sp_refreshview N'[dbo].[JCTI]'
GO
PRINT N'Refreshing [dbo].[JCJM]'
GO
EXEC sp_refreshview N'[dbo].[JCJM]'
GO
PRINT N'Refreshing [dbo].[JCCO]'
GO
EXEC sp_refreshview N'[dbo].[JCCO]'
GO
PRINT N'Refreshing [dbo].[PRPC]'
GO
EXEC sp_refreshview N'[dbo].[PRPC]'
GO
PRINT N'Refreshing [dbo].[EMCO]'
GO
EXEC sp_refreshview N'[dbo].[EMCO]'
GO
PRINT N'Refreshing [dbo].[EMRC]'
GO
EXEC sp_refreshview N'[dbo].[EMRC]'
GO
PRINT N'Refreshing [dbo].[EMEM]'
GO
EXEC sp_refreshview N'[dbo].[EMEM]'
GO
PRINT N'Refreshing [dbo].[EMEH]'
GO
EXEC sp_refreshview N'[dbo].[EMEH]'
GO
PRINT N'Refreshing [dbo].[EMLH]'
GO
EXEC sp_refreshview N'[dbo].[EMLH]'
GO
PRINT N'Refreshing [dbo].[EMLB]'
GO
EXEC sp_refreshview N'[dbo].[EMLB]'
GO
PRINT N'Refreshing [dbo].[PRTB]'
GO
EXEC sp_refreshview N'[dbo].[PRTB]'
GO
PRINT N'Refreshing [dbo].[HQBC]'
GO
EXEC sp_refreshview N'[dbo].[HQBC]'
GO
PRINT N'Refreshing [dbo].[PRTZGrid]'
GO
EXEC sp_refreshview N'[dbo].[PRTZGrid]'
GO
PRINT N'Refreshing [dbo].[PRDP]'
GO
EXEC sp_refreshview N'[dbo].[PRDP]'
GO
PRINT N'Refreshing [dbo].[PRMyTimesheetDetail]'
GO
EXEC sp_refreshview N'[dbo].[PRMyTimesheetDetail]'
GO
PRINT N'Refreshing [dbo].[PRMyTimesheet]'
GO
EXEC sp_refreshview N'[dbo].[PRMyTimesheet]'
GO
PRINT N'Rebuilding [dbo].[vSLClaimItem]'
GO
CREATE TABLE [dbo].[tmp_rg_xx_vSLClaimItem]
(
[KeyID] [bigint] NOT NULL IDENTITY(1, 1),
[SLCo] [dbo].[bCompany] NOT NULL,
[SL] [varchar] (30) COLLATE Latin1_General_BIN NOT NULL,
[ClaimNo] [int] NOT NULL,
[SLItem] [dbo].[bItem] NOT NULL,
[ClaimToDateUnits] [dbo].[bUnits] NOT NULL CONSTRAINT [DF_vSLClaimItem_ClaimToDateUnits] DEFAULT ((0)),
[ClaimToDateAmt] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vSLClaimItem_ClaimToDateAmt] DEFAULT ((0)),
[ClaimUnits] [dbo].[bUnits] NOT NULL CONSTRAINT [DF_vSLClaimItem_UnitsClaimed] DEFAULT ((0)),
[ClaimAmount] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vSLClaimItem_AmtClaimed] DEFAULT ((0)),
[ApproveUnits] [dbo].[bUnits] NOT NULL CONSTRAINT [DF_vSLClaimItem_UnitsApproved] DEFAULT ((0)),
[ApproveAmount] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vSLClaimItem_AmtApproved] DEFAULT ((0)),
[ApproveRetPct] [dbo].[bPct] NOT NULL CONSTRAINT [DF_vSLClaimItem_ApproveRetPct] DEFAULT ((0)),
[ApproveRetention] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vSLClaimItem_RetApproved] DEFAULT ((0)),
[TaxAmount] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vSLClaimItem_TaxAmount] DEFAULT ((0)),
[Notes] [varchar] (max) COLLATE Latin1_General_BIN NULL,
[UniqueAttchID] [uniqueidentifier] NULL,
[Description] [dbo].[bDesc] NULL,
[UM] [dbo].[bUM] NOT NULL,
[CurUnitCost] [dbo].[bUnitCost] NOT NULL CONSTRAINT [DF_vSLClaimItem_CurUnitCost] DEFAULT ((0)),
[CurUnits] [dbo].[bUnits] NOT NULL CONSTRAINT [DF_vSLClaimItem_CurUnits] DEFAULT ((0)),
[CurCost] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vSLClaimItem_CurCost] DEFAULT ((0)),
[TaxGroup] [dbo].[bGroup] NULL,
[TaxCode] [dbo].[bTaxCode] NULL,
[TaxType] [tinyint] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET IDENTITY_INSERT [dbo].[tmp_rg_xx_vSLClaimItem] ON
GO
INSERT INTO [dbo].[tmp_rg_xx_vSLClaimItem]([KeyID], [SLCo], [SL], [ClaimNo], [SLItem], [ClaimToDateUnits], [ClaimToDateAmt], [ClaimUnits], [ClaimAmount], [ApproveUnits], [ApproveAmount], [ApproveRetPct], [ApproveRetention], [TaxAmount], [Notes], [UniqueAttchID], [Description], [UM], [CurUnitCost], [CurUnits], [CurCost], [TaxGroup], [TaxCode], [TaxType]) SELECT [KeyID], [SLCo], [SL], [ClaimNo], [SLItem], [ClaimToDateUnits], [ClaimToDateAmt], [ClaimUnits], [ClaimAmount], [ApproveUnits], [ApproveAmount], [ApproveRetPct], [ApproveRetention], [TaxAmount], [Notes], [UniqueAttchID], [Description], [UM], [CurUnitCost], [CurUnits], [CurCost], [TaxGroup], [TaxCode], [TaxType] FROM [dbo].[vSLClaimItem]
GO
SET IDENTITY_INSERT [dbo].[tmp_rg_xx_vSLClaimItem] OFF
GO
DECLARE @idVal BIGINT
SELECT @idVal = IDENT_CURRENT(N'[dbo].[vSLClaimItem]')
IF @idVal IS NOT NULL
    DBCC CHECKIDENT(N'[dbo].[tmp_rg_xx_vSLClaimItem]', RESEED, @idVal)
GO
DROP TABLE [dbo].[vSLClaimItem]
GO
EXEC sp_rename N'[dbo].[tmp_rg_xx_vSLClaimItem]', N'vSLClaimItem'
GO
PRINT N'Creating primary key [PK_vSLClaimItem] on [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] ADD CONSTRAINT [PK_vSLClaimItem] PRIMARY KEY CLUSTERED  ([SLCo], [SL], [ClaimNo], [SLItem]) ON [PRIMARY]
GO
PRINT N'Creating index [IX_vSLClaimItem_KeyID] on [dbo].[vSLClaimItem]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_vSLClaimItem_KeyID] ON [dbo].[vSLClaimItem] ([KeyID]) ON [PRIMARY]
GO
PRINT N'Creating index [IX_vSLClaimItem_SL] on [dbo].[vSLClaimItem]'
GO
CREATE NONCLUSTERED INDEX [IX_vSLClaimItem_SL] ON [dbo].[vSLClaimItem] ([SLCo], [SL]) ON [PRIMARY]
GO
PRINT N'Creating index [IX_vSLClaimItem_ClaimNo] on [dbo].[vSLClaimItem]'
GO
CREATE NONCLUSTERED INDEX [IX_vSLClaimItem_ClaimNo] ON [dbo].[vSLClaimItem] ([SLCo], [SL], [ClaimNo]) ON [PRIMARY]
GO
PRINT N'Creating index [IX_vSLClaimItem_SLItem] on [dbo].[vSLClaimItem]'
GO
CREATE NONCLUSTERED INDEX [IX_vSLClaimItem_SLItem] ON [dbo].[vSLClaimItem] ([SLCo], [SL], [SLItem]) ON [PRIMARY]
GO
PRINT N'Altering [dbo].[vSLClaimHeader]'
GO
ALTER TABLE [dbo].[vSLClaimHeader] ADD
[DueDate] [dbo].[bDate] NULL
GO
PRINT N'Altering [dbo].[vspSLClaimNoTotalsGet]'
GO


ALTER  proc [dbo].[vspSLClaimNoTotalsGet]
/***********************************************************
* Created By:	GF 09/06/2012 TK-17944
* Modified By:	GF 03/29/2013 TFS-45348 balance forward claim changes
*
*
* USAGE:
* gets subcontract totals, subcontract claim totals, and subcontract previous claim totals
* this procedure is not used for validation.
*
*
* INPUT PARAMETERS
* SLCo   		SL Company
* SL    		Subcontract
* ClaimNo		CLaim Number
*
*
* OUTPUT PARAMETERS
* @OrigContractAmt	Subcontract - Original Cost
* @CurrContractAmt	Subcontract - Current Cost
* @VariationAmt		Current Cost minus Original Cost
*
* @PriorAmtClaimed
* @ThisClaim
* @TimsClaimRet
* @SLTotalClaimed	
* @SLTotalClaimedRet
* @PriorAmtApproved
* @ApprovedAmount
* @ApprovedAmountRet
* @SLTotalApproved
* @SLTotalApprovedRet
*
* @PriorRetClaimed
* @PriorRetApproved
* @PriorTaxAmount
* @SLTotalTaxAmount
*
* @RetentionBudget
* @RetentionTaken
* @RetentionRemain
*
* ----invoice details
* @InvoiceNo
* @InvoiceTotal
* @InvoiceTax
* @InvoiceDate
* @InvoiceDueDate
* @InvoiceType
* @ApprovalStatus
*
* ----payment details
* @PymtCheckNo 
* @PymtCheckDate
* @PymtPaidAmt 
* @PymtRetCheckNo 
* @PymtRetCheckDate 
* @PymtRetPaidAmt
*
*
* @msg				error message if error occurs or claim description
*
* RETURN VALUE
*   0         success
*   1         Failure
*****************************************************/
(@SLCo bCompany = NULL, @SL VARCHAR(30) = NULL, @ClaimNo INT = NULL,
 ----SL totals
 @OrigContractAmt bDollar = 0 OUTPUT,
 @CurrContractAmt bDollar = 0 OUTPUT,
 @VariationAmt bDollar = 0 OUTPUT,
 ----claim totals
 @PriorAmtClaimed bDollar = 0 OUTPUT,
 @ThisClaim bDollar = 0 OUTPUT,
 @ThisClaimRet bDollar = 0 OUTPUT,
 @SLTotalClaimed bDollar = 0 OUTPUT,
 @SLTotalClaimedRet bDollar = 0 OUTPUT,
 @PriorAmtApproved bDollar = 0 OUTPUT,
 @ApprovedAmount bDollar = 0 OUTPUT,
 @ApprovedAmountRet bDollar = 0 OUTPUT,
 @SLTotalApproved bDollar = 0 OUTPUT,
 @SLTotalApprovedRet bDollar = 0 OUTPUT,
 @PriorRetClaimed bDollar = 0 OUTPUT,
 @PriorRetApproved bDollar = 0 OUTPUT,
 @PriorTaxAmount bDollar = 0 OUTPUT,
 @SLTotalTaxAmount bDollar = 0 OUTPUT,
 ----SL retention
 @RetentionBudget bDollar = 0 OUTPUT,
 @RetentionTaken bDollar = 0 OUTPUT,
 @RetentionRemain bDollar = 0 OUTPUT,
 ----invoice details
 @InvoiceNo VARCHAR(20) = NULL OUTPUT,
 @InvoiceTotal bDollar = 0 OUTPUT,
 @InvoiceTax bDollar = 0 OUTPUT,
 @InvoiceDate VARCHAR(20) = NULL OUTPUT,
 @InvoiceDueDate VARCHAR(20) = NULL OUTPUT,
 @InvoiceType VARCHAR(50) = NULL OUTPUT,
 @ApprovalStatus VARCHAR(50) = NULL OUTPUT,
 ----payment details
 @PymtCheckNo VARCHAR(10) = NULL OUTPUT,
 @PymtCheckDate	VARCHAR(20) = NULL OUTPUT,
 @PymtPaidAmt bDollar = 0 OUTPUT,
 @PymtRetCheckNo VARCHAR(10) = NULL OUTPUT,
 @PymtRetCheckDate VARCHAR(20) = NULL OUTPUT,
 @PymtRetPaidAmt bDollar = 0 OUTPUT, 
 @Msg VARCHAR(255) OUTPUT)
AS
SET NOCOUNT ON

DECLARE @rcode INT, @UIStatus INTEGER, @AppCount INTEGER,
		@RejCount INTEGER, @TtlCount INTEGER, @CMRefCount INTEGER,
		@ClaimKeyId BIGINT,
		@APTDKeyId BIGINT, @InvDate SMALLDATETIME, @DueDate SMALLDATETIME


SET @rcode = 0
SET @OrigContractAmt = 0
SET @CurrContractAmt = 0
SET @VariationAmt = 0
SET @SLTotalClaimed	= 0
SET @SLTotalClaimedRet  = 0
SET @SLTotalApproved = 0
SET @SLTotalApprovedRet = 0
SET @SLTotalTaxAmount = 0
SET @PriorAmtClaimed = 0
SET @PriorRetClaimed = 0
SET @PriorAmtApproved = 0
SET @PriorRetApproved = 0
SET @PriorTaxAmount = 0
SET @ThisClaim = 0
SET @ThisClaimRet = 0
SET @ApprovedAmount = 0
SET @ApprovedAmountRet = 0
SET	@RetentionBudget = 0
SET @RetentionTaken = 0
SET @RetentionRemain = 0

SET @InvoiceNo = NULL
SET @InvoiceTotal = 0
SET @InvoiceTax = 0
set @InvoiceDate = NULL
SET @InvoiceDueDate = NULL
SET @InvoiceType = NULL
SET @ApprovalStatus = NULL
SET @UIStatus = 10
SET @AppCount = 0
SET @RejCount = 0
SET @TtlCount = 0
SET @PymtCheckNo = NULL
SET @PymtCheckDate = NULL
SET @PymtPaidAmt = 0
SET @PymtRetCheckNo = NULL
SET @PymtRetCheckDate = NULL
SET @PymtRetPaidAmt = 0 
SET @CMRefCount = 0
SET @ClaimKeyId = NULL
SET @APTDKeyId = NULL
SET @InvDate = NULL
SET @DueDate = NULL
 
---- check key values
IF @SLCo IS NULL OR @SL IS NULL OR @ClaimNo IS NULL GOTO vspexit

---- claim header info
SELECT @Msg = [Description]
		,@ClaimKeyId = KeyID
FROM dbo.vSLClaimHeader
WHERE SLCo = @SLCo
	AND SL = @SL
	AND ClaimNo = @ClaimNo
IF @@ROWCOUNT = 0 SET @ClaimKeyId = 0


---- get subcontract totals from SL Items (SLIT)
SELECT @OrigContractAmt = ISNULL(SUM(OrigCost), 0)
	  ,@CurrContractAmt = ISNULL(SUM(CurCost), 0)
	  ,@RetentionBudget = RetentionBudget
	  ,@RetentionTaken = RetentionTaken
	  ,@RetentionRemain = RetentionRemain
FROM dbo.bSLIT
OUTER APPLY dbo.vfSLClaimRetTotals (@SLCo, @SL, @ClaimNo)
WHERE SLCo = @SLCo
	AND SL = @SL
GROUP BY RetentionBudget, RetentionTaken, RetentionRemain

---- variation amount is current minus original
SET @VariationAmt = @CurrContractAmt - @OrigContractAmt


---- claim amounts
SELECT @ThisClaim		  = ISNULL(SUM(i.ClaimAmount), 0)
	  ,@ApprovedAmount	  = ISNULL(SUM(i.ApproveAmount), 0)
	  ,@ApprovedAmountRet = ISNULL(SUM(i.ApproveRetention), 0)
FROM dbo.vSLClaimItem i
INNER JOIN dbo.vSLClaimHeader h ON h.SLCo = i.SLCo AND h.SL = i.SL AND h.ClaimNo=i.ClaimNo
WHERE i.SLCo = @SLCo
	AND i.SL = @SL
	AND i.ClaimNo = @ClaimNo	

---- subcontract claim totals
SELECT @SLTotalClaimed	   = ISNULL(SUM(i.ClaimAmount), 0)
	  ,@SLTotalApproved	   = ISNULL(SUM(i.ApproveAmount), 0)
	  ,@SLTotalApprovedRet = ISNULL(SUM(i.ApproveRetention), 0)
	  ,@SLTotalTaxAmount   = ISNULL(SUM(i.TaxAmount), 0)
FROM dbo.vSLClaimItem i
INNER JOIN dbo.vSLClaimHeader h ON h.SLCo = i.SLCo AND h.SL = i.SL AND h.ClaimNo=i.ClaimNo
WHERE i.SLCo = @SLCo
	AND i.SL = @SL
	AND h.ClaimStatus <> 20 ----denied
	

---- subcontract claim prior totals
SELECT @PriorAmtClaimed  = ISNULL(SUM(i.ClaimAmount), 0)
	  ,@PriorAmtApproved = ISNULL(SUM(i.ApproveAmount), 0)
	  ,@PriorRetApproved = ISNULL(SUM(i.ApproveRetention), 0)
	  ,@PriorTaxAmount   = ISNULL(SUM(i.TaxAmount), 0)
FROM dbo.vSLClaimItem i
INNER JOIN dbo.vSLClaimHeader h ON h.SLCo = i.SLCo AND h.SL = i.SL AND h.ClaimNo=i.ClaimNo
WHERE i.SLCo = @SLCo
	AND i.SL = @SL
	---- HOW DO WE APPLY CLAIM DATE FOR NEW CLAIMS???
	AND i.ClaimNo < @ClaimNo
	AND h.ClaimStatus <> 20 ----denied


---- TFS-45348 claim 0 (balance forward) invoice details
IF @ClaimNo = 0 AND  (SELECT COUNT(*) FROM dbo.bAPTH WHERE SLKeyID = @ClaimKeyId) > 1
	BEGIN
		SET @InvoiceType = 'AP Posted Transaction'
		SET @InvoiceNo = 'Multiple'
		SET @InvDate = NULL
		SET @DueDate = NULL
        
		SELECT @InvoiceTotal = SUM(ISNULL(APTL.GrossAmt,0))
			   ,@InvoiceTax = SUM(ISNULL(APTL.TaxAmt,0))
		FROM dbo.bAPTL APTL
		WHERE APTL.SLKeyID = @ClaimKeyId
	END      
ELSE
	BEGIN
	---- Invoice Type
	SELECT @InvoiceType = 
			CASE WHEN APHB.BatchSeq IS NOT NULL	THEN 'AP Entry Batch'
					WHEN APUI.UISeq IS NOT NULL	THEN 'AP Unapproved Invoices'
					WHEN APTL.APTrans IS NOT NULL THEN 'AP Posted Transaction'
					ELSE NULL
					END
	FROM dbo.vSLClaimHeader h
	LEFT JOIN dbo.bAPHB APHB ON h.KeyID = APHB.SLKeyID
	LEFT JOIN dbo.bAPUI APUI ON h.KeyID = APUI.SLKeyID
	LEFT JOIN dbo.bAPTL APTL ON h.KeyID = APTL.SLKeyID
	WHERE h.KeyID = @ClaimKeyId


	---- AP Entry Batch Info
	IF @InvoiceType = 'AP Entry Batch'
		BEGIN
		SELECT  @InvoiceNo = APHB.APRef,
				@InvDate = APHB.InvDate,
				@DueDate = APHB.DueDate,
				@InvoiceTotal = ISNULL(APHB.InvTotal,0),
				@InvoiceTax = SUM(ISNULL(APLB.TaxAmt,0))
		FROM dbo.bAPHB APHB
		INNER JOIN dbo.bAPLB APLB ON APLB.SLKeyID=APHB.SLKeyID
		WHERE APHB.SLKeyID = @ClaimKeyId
		GROUP BY APHB.APRef, APHB.InvDate, APHB.DueDate, APHB.InvTotal
		END

	---- AP Posted Transaction Info
	IF @InvoiceType = 'AP Posted Transaction'
		BEGIN
		SELECT TOP 1 @InvoiceNo	= APTH.APRef,
				@InvDate	= APTH.InvDate,
				@DueDate	= APTH.DueDate,
				@InvoiceTotal	= ISNULL(APTH.InvTotal, 0),
				@InvoiceTax		= SUM(ISNULL(APTL.TaxAmt,0))
		FROM dbo.bAPTH APTH
		INNER JOIN dbo.bAPTL APTL ON APTH.APCo=APTL.APCo AND APTH.Mth=APTL.Mth AND APTH.APTrans=APTL.APTrans
		WHERE APTL.SLKeyID = @ClaimKeyId
		GROUP BY APTH.APRef, APTH.InvDate, APTH.DueDate, APTH.InvTotal
		END

	---- AP Unapproved Invoice Info
	IF @InvoiceType = 'AP Unapproved Invoices'
		BEGIN

		---- get unapproved invoice info
		SELECT TOP 1 @InvoiceNo	= APUI.APRef
					,@InvDate = APUI.InvDate
					,@DueDate = APUI.DueDate
					,@InvoiceTotal = ISNULL(APUI.InvTotal, 0)
					,@InvoiceTax = SUM(ISNULL(APUL.TaxAmt,0))
		FROM dbo.bAPUI APUI
		INNER JOIN dbo.bAPUL APUL ON APUL.APCo=APUI.APCo AND APUL.UIMth=APUI.UIMth AND APUL.UISeq=APUI.UISeq
		WHERE APUI.SLKeyID = @ClaimKeyId
		GROUP BY APUI.APRef, APUI.InvDate, APUI.DueDate, APUI.InvTotal      

		---- set default status
		SET @ApprovalStatus = 'Unapproved'
		---- get AP Unapproved Invoice Status
		SELECT @TtlCount = ISNULL(COUNT(DISTINCT TTL.KeyID),0)
				,@AppCount = ISNULL(COUNT(DISTINCT APP.KeyID),0)
				,@RejCount = ISNULL(COUNT(DISTINCT REJ.KeyID),0)
				,@ApprovalStatus = CASE WHEN @RejCount = 1 THEN 'Rejected'
										WHEN @AppCount = @TtlCount THEN 'Approved'
										WHEN @AppCount > 0 AND @RejCount = 0 AND @AppCount < @TtlCount THEN 'Partially Approved'
										ELSE 'Unapproved'
										END
		FROM dbo.bAPUI APUI
		LEFT  JOIN dbo.bAPUR TTL ON APUI.APCo=TTL.APCo AND APUI.UIMth=TTL.UIMth AND APUI.UISeq=TTL.UISeq
		LEFT  JOIN dbo.bAPUR REJ ON APUI.APCo=REJ.APCo AND APUI.UIMth=REJ.UIMth AND APUI.UISeq=REJ.UISeq AND REJ.Rejected = 'Y'
		LEFT  JOIN dbo.bAPUR APP ON APUI.APCo=APP.APCo AND APUI.UIMth=APP.UIMth AND APUI.UISeq=APP.UISeq AND APP.ApprvdYN = 'Y'
		WHERE APUI.SLKeyID = @ClaimKeyId  
		END
	END
  
  
  
        
---- format invoice dates for international
IF @InvDate IS NOT NULL
	BEGIN
	SET @InvoiceDate = dbo.vfDateOnlyAsStringUsingStyle(@InvDate, @SLCo, DEFAULT)
	END

IF @DueDate IS NOT NULL
	BEGIN
	SET @InvoiceDueDate = dbo.vfDateOnlyAsStringUsingStyle(@DueDate, @SLCo, DEFAULT)
	END


SET @PymtCheckNo = NULL
SET @PymtCheckDate = NULL
SET @PymtPaidAmt = 0
---- payment details - invoice
SELECT @APTDKeyId = MAX(CMRefCount)
	FROM (
		 SELECT (CASE WHEN d.PayCategory IS NULL
	 				THEN (CASE WHEN d.PayType <> c.RetPayType AND ISNULL(COUNT(DISTINCT d.CMRef),0) = 1
							   THEN d.KeyID WHEN ISNULL(COUNT(DISTINCT d.CMRef),0) > 1 THEN -999 ELSE 0 END)
					ELSE (CASE WHEN d.PayType <> p.RetPayType AND ISNULL(COUNT(DISTINCT d.CMRef),0) = 1
							   THEN d.KeyID WHEN ISNULL(COUNT(DISTINCT d.CMRef),0) > 1 THEN -999 ELSE 0 END)
				END) CMRefCount

			FROM dbo.bAPTD d WITH (NOLOCK)
			INNER JOIN dbo.bAPTL l ON l.APCo=d.APCo AND l.Mth=d.Mth AND l.APTrans=d.APTrans AND l.APLine=d.APLine
			INNER JOIN dbo.bAPCO c WITH (NOLOCK) ON c.APCo = d.APCo
			LEFT  JOIN dbo.bAPPC p WITH (NOLOCK) ON p.APCo=d.APCo AND p.PayCategory=d.PayCategory
			WHERE l.SLKeyID = @ClaimKeyId
				AND d.[Status] = 3 ----paid
			GROUP BY d.PayCategory, d.PayType, c.RetPayType, p.RetPayType, d.KeyID
			) xx

---- if the key id = -999 then we have more than one distinct CM Reference
IF ISNULL(@APTDKeyId,0) = -999
	BEGIN
	SET @PymtCheckNo = 'Multiple'
	SET @PymtCheckDate = 'Multiple'
	END
ELSE
	BEGIN
	SELECT  @PymtCheckNo = APTD.CMRef,
			@PymtCheckDate = dbo.vfDateOnlyAsStringUsingStyle(APTD.PaidDate, @SLCo, DEFAULT)
	FROM dbo.bAPTD APTD WITH (NOLOCK)
	WHERE APTD.KeyID = @APTDKeyId
	END

---- get invoice paid amount
SELECT @PymtPaidAmt	= SUM(ISNULL(APTD.Amount,0))
FROM dbo.bAPTD APTD
INNER JOIN dbo.bAPTL APTL ON APTL.APCo=APTD.APCo AND APTL.Mth=APTD.Mth AND APTL.APTrans=APTD.APTrans AND APTL.APLine = APTD.APLine
INNER JOIN dbo.bAPCO APCO WITH (NOLOCK) ON APCO.APCo = APTD.APCo
LEFT  JOIN dbo.bAPPC APPC WITH (NOLOCK) ON APPC.APCo=APTD.APCo AND APPC.PayCategory=APTD.PayCategory
WHERE APTL.SLKeyID = @ClaimKeyId
	AND APTD.Status = 3 ----paid
	AND (
		(APTD.PayCategory IS NULL AND APTD.PayType <> APCO.RetPayType)
		OR (APTD.PayCategory IS NOT NULL AND APTD.PayType <> APPC.RetPayType)
		)



SET @PymtRetCheckNo = NULL
SET @PymtRetCheckDate = NULL
SET @PymtRetPaidAmt = 0
---- payment details - retention
SELECT @APTDKeyId = MAX(CMRefCount)
	FROM (
		 SELECT (CASE WHEN d.PayCategory IS NULL
	 				THEN (CASE WHEN d.PayType = c.RetPayType AND ISNULL(COUNT(DISTINCT d.CMRef),0) = 1
							   THEN d.KeyID WHEN ISNULL(COUNT(DISTINCT d.CMRef),0) > 1 THEN -999 ELSE 0 END)
					ELSE (CASE WHEN d.PayType = p.RetPayType AND ISNULL(COUNT(DISTINCT d.CMRef),0) = 1
							   THEN d.KeyID WHEN ISNULL(COUNT(DISTINCT d.CMRef),0) > 1 THEN -999 ELSE 0 END)
				END) CMRefCount

			FROM dbo.bAPTD d WITH (NOLOCK)
			INNER JOIN dbo.bAPTL l ON l.APCo=d.APCo AND l.Mth=d.Mth AND l.APTrans=d.APTrans AND l.APLine=d.APLine
			INNER JOIN dbo.bAPCO c WITH (NOLOCK) ON c.APCo = d.APCo
			LEFT  JOIN dbo.bAPPC p WITH (NOLOCK) ON p.APCo=d.APCo AND p.PayCategory=d.PayCategory
			WHERE l.SLKeyID = @ClaimKeyId
				AND d.[Status] = 3 ----paid
			GROUP BY d.PayCategory, d.PayType, c.RetPayType, p.RetPayType, d.KeyID
			) xx

---- if the key id = -999 then we have more than one distinct CM Reference
IF ISNULL(@APTDKeyId,0) = -999
	BEGIN
	SET @PymtRetCheckNo = 'Multiple'
	SET @PymtRetCheckDate = 'Multiple'
	END
ELSE
	BEGIN
	SELECT  @PymtRetCheckNo = APTD.CMRef,
			@PymtRetCheckDate = dbo.vfDateOnlyAsStringUsingStyle(APTD.PaidDate, @SLCo, DEFAULT)
	FROM dbo.bAPTD APTD WITH (NOLOCK)
	WHERE APTD.KeyID = @APTDKeyId
	END

---- get invoice paid amount
SELECT @PymtRetPaidAmt	= SUM(ISNULL(APTD.Amount,0))
FROM dbo.bAPTD APTD
INNER JOIN dbo.bAPTL APTL ON APTL.APCo=APTD.APCo AND APTL.Mth=APTD.Mth AND APTL.APTrans=APTD.APTrans AND APTL.APLine = APTD.APLine
INNER JOIN dbo.bAPCO APCO WITH (NOLOCK) ON APCO.APCo = APTD.APCo
LEFT  JOIN dbo.bAPPC APPC WITH (NOLOCK) ON APPC.APCo=APTD.APCo AND APPC.PayCategory=APTD.PayCategory
WHERE APTL.SLKeyID = @ClaimKeyId
	AND APTD.Status = 3 ----paid
	AND (
		(APTD.PayCategory IS NULL AND APTD.PayType = APCO.RetPayType)
		OR (APTD.PayCategory IS NOT NULL AND APTD.PayType = APPC.RetPayType)
		)




vspexit:
	if @rcode <> 0 select @Msg = isnull(@Msg,'')
	return @rcode

GO
PRINT N'Refreshing [dbo].[HRER]'
GO
EXEC sp_refreshview N'[dbo].[HRER]'
GO
PRINT N'Refreshing [dbo].[MSPC]'
GO
EXEC sp_refreshview N'[dbo].[MSPC]'
GO
PRINT N'Refreshing [dbo].[MSHC]'
GO
EXEC sp_refreshview N'[dbo].[MSHC]'
GO
PRINT N'Refreshing [dbo].[HQMT]'
GO
EXEC sp_refreshview N'[dbo].[HQMT]'
GO
PRINT N'Refreshing [dbo].[SLIT]'
GO
EXEC sp_refreshview N'[dbo].[SLIT]'
GO
PRINT N'Refreshing [dbo].[PMSL]'
GO
EXEC sp_refreshview N'[dbo].[PMSL]'
GO
PRINT N'Refreshing [dbo].[PMCO]'
GO
EXEC sp_refreshview N'[dbo].[PMCO]'
GO
PRINT N'Refreshing [dbo].[HRCO]'
GO
EXEC sp_refreshview N'[dbo].[HRCO]'
GO
PRINT N'Refreshing [dbo].[DDSG]'
GO
EXEC sp_refreshview N'[dbo].[DDSG]'
GO
PRINT N'Refreshing [dbo].[DDDS]'
GO
EXEC sp_refreshview N'[dbo].[DDDS]'
GO
PRINT N'Refreshing [dbo].[DDBICompanies]'
GO
EXEC sp_refreshview N'[dbo].[DDBICompanies]'
GO
PRINT N'Refreshing [dbo].[PMTM]'
GO
EXEC sp_refreshview N'[dbo].[PMTM]'
GO
PRINT N'Refreshing [dbo].[APVM]'
GO
EXEC sp_refreshview N'[dbo].[APVM]'
GO
PRINT N'Refreshing [dbo].[PCQualifications]'
GO
EXEC sp_refreshview N'[dbo].[PCQualifications]'
GO
PRINT N'Refreshing [dbo].[PMPM]'
GO
EXEC sp_refreshview N'[dbo].[PMPM]'
GO
PRINT N'Refreshing [dbo].[PMIM]'
GO
EXEC sp_refreshview N'[dbo].[PMIM]'
GO
PRINT N'Refreshing [dbo].[PMFM]'
GO
EXEC sp_refreshview N'[dbo].[PMFM]'
GO
PRINT N'Refreshing [dbo].[DDDTc]'
GO
EXEC sp_refreshview N'[dbo].[DDDTc]'
GO
PRINT N'Refreshing [dbo].[RQRR]'
GO
EXEC sp_refreshview N'[dbo].[RQRR]'
GO
PRINT N'Refreshing [dbo].[RQRL]'
GO
EXEC sp_refreshview N'[dbo].[RQRL]'
GO
PRINT N'Refreshing [dbo].[RQQL]'
GO
EXEC sp_refreshview N'[dbo].[RQQL]'
GO
PRINT N'Refreshing [dbo].[POCO]'
GO
EXEC sp_refreshview N'[dbo].[POCO]'
GO
PRINT N'Refreshing [dbo].[RQQR]'
GO
EXEC sp_refreshview N'[dbo].[RQQR]'
GO
PRINT N'Refreshing [dbo].[JCJR]'
GO
EXEC sp_refreshview N'[dbo].[JCJR]'
GO
PRINT N'Refreshing [dbo].[INLM]'
GO
EXEC sp_refreshview N'[dbo].[INLM]'
GO
PRINT N'Refreshing [dbo].[EMDM]'
GO
EXEC sp_refreshview N'[dbo].[EMDM]'
GO
PRINT N'Refreshing [dbo].[VPPartSettingsTemplate]'
GO
EXEC sp_refreshview N'[dbo].[VPPartSettingsTemplate]'
GO
PRINT N'Refreshing [dbo].[PMOM]'
GO
EXEC sp_refreshview N'[dbo].[PMOM]'
GO
PRINT N'Refreshing [dbo].[PMOMPct]'
GO
EXEC sp_refreshview N'[dbo].[PMOMPct]'
GO
PRINT N'Refreshing [dbo].[PRCC]'
GO
EXEC sp_refreshview N'[dbo].[PRCC]'
GO
PRINT N'Refreshing [dbo].[PMSubcontractCO]'
GO
EXEC sp_refreshview N'[dbo].[PMSubcontractCO]'
GO
PRINT N'Refreshing [dbo].[PMPOCO]'
GO
EXEC sp_refreshview N'[dbo].[PMPOCO]'
GO
PRINT N'Altering [dbo].[bPMOL]'
GO
ALTER TABLE [dbo].[bPMOL] ADD
[CreateSL] [dbo].[bYN] NOT NULL CONSTRAINT [DF_bPMOL_CreateSL] DEFAULT ('N')
GO
PRINT N'Refreshing [dbo].[PMOL]'
GO
EXEC sp_refreshview N'[dbo].[PMOL]'
GO
PRINT N'Refreshing [dbo].[PMOI]'
GO
EXEC sp_refreshview N'[dbo].[PMOI]'
GO
PRINT N'Refreshing [dbo].[PMMF]'
GO
EXEC sp_refreshview N'[dbo].[PMMF]'
GO
PRINT N'Refreshing [dbo].[SMWorkOrderScope]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrderScope]'
GO
PRINT N'Refreshing [dbo].[SMWorkOrder]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrder]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedDetail]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedDetail]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedPurchase]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedPurchase]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedPart]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedPart]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedMisc]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedMisc]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedLabor]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedLabor]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedEquipment]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedEquipment]'
GO
PRINT N'Refreshing [dbo].[POIT]'
GO
EXEC sp_refreshview N'[dbo].[POIT]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedAll]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedAll]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedAllCurrent]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedAllCurrent]'
GO
PRINT N'Refreshing [dbo].[SMServiceSite]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceSite]'
GO
PRINT N'Refreshing [dbo].[SMRateTemplate]'
GO
EXEC sp_refreshview N'[dbo].[SMRateTemplate]'
GO
PRINT N'Refreshing [dbo].[SMCustomer]'
GO
EXEC sp_refreshview N'[dbo].[SMCustomer]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompleted]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompleted]'
GO
PRINT N'Refreshing [dbo].[SMServiceCenter]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceCenter]'
GO
PRINT N'Refreshing [dbo].[SMCO]'
GO
EXEC sp_refreshview N'[dbo].[SMCO]'
GO
PRINT N'Refreshing [dbo].[SMStandardItem]'
GO
EXEC sp_refreshview N'[dbo].[SMStandardItem]'
GO
PRINT N'Refreshing [dbo].[SMPayType]'
GO
EXEC sp_refreshview N'[dbo].[SMPayType]'
GO
PRINT N'Refreshing [dbo].[SMLaborCode]'
GO
EXEC sp_refreshview N'[dbo].[SMLaborCode]'
GO
PRINT N'Refreshing [dbo].[SMCostType]'
GO
EXEC sp_refreshview N'[dbo].[SMCostType]'
GO
PRINT N'Refreshing [dbo].[SMTechnician]'
GO
EXEC sp_refreshview N'[dbo].[SMTechnician]'
GO
PRINT N'Refreshing [dbo].[SMMyTimesheetLink]'
GO
EXEC sp_refreshview N'[dbo].[SMMyTimesheetLink]'
GO
PRINT N'Refreshing [dbo].[SMStandardItemDefaultDetail]'
GO
EXEC sp_refreshview N'[dbo].[SMStandardItemDefaultDetail]'
GO
PRINT N'Refreshing [dbo].[DDLHShared]'
GO
EXEC sp_refreshview N'[dbo].[DDLHShared]'
GO
PRINT N'Refreshing [dbo].[PMSC]'
GO
EXEC sp_refreshview N'[dbo].[PMSC]'
GO
PRINT N'Refreshing [dbo].[PMPL]'
GO
EXEC sp_refreshview N'[dbo].[PMPL]'
GO
PRINT N'Refreshing [dbo].[PMIL]'
GO
EXEC sp_refreshview N'[dbo].[PMIL]'
GO
PRINT N'Refreshing [dbo].[HRRM]'
GO
EXEC sp_refreshview N'[dbo].[HRRM]'
GO
PRINT N'Refreshing [dbo].[HRAG]'
GO
EXEC sp_refreshview N'[dbo].[HRAG]'
GO
PRINT N'Refreshing [dbo].[DDUP]'
GO
EXEC sp_refreshview N'[dbo].[DDUP]'
GO
PRINT N'Refreshing [dbo].[HRES]'
GO
EXEC sp_refreshview N'[dbo].[HRES]'
GO
PRINT N'Refreshing [dbo].[GLCO]'
GO
EXEC sp_refreshview N'[dbo].[GLCO]'
GO
PRINT N'Refreshing [dbo].[SMDepartmentOverrides]'
GO
EXEC sp_refreshview N'[dbo].[SMDepartmentOverrides]'
GO
PRINT N'Refreshing [dbo].[APUR]'
GO
EXEC sp_refreshview N'[dbo].[APUR]'
GO
PRINT N'Refreshing [dbo].[APUL]'
GO
EXEC sp_refreshview N'[dbo].[APUL]'
GO
PRINT N'Refreshing [dbo].[MSSurchargeCodeRates]'
GO
EXEC sp_refreshview N'[dbo].[MSSurchargeCodeRates]'
GO
PRINT N'Refreshing [dbo].[EMCD]'
GO
EXEC sp_refreshview N'[dbo].[EMCD]'
GO
PRINT N'Refreshing [dbo].[PMECJC]'
GO
EXEC sp_refreshview N'[dbo].[PMECJC]'
GO
PRINT N'Refreshing [dbo].[PMPMOvrdAddr]'
GO
EXEC sp_refreshview N'[dbo].[PMPMOvrdAddr]'
GO
PRINT N'Refreshing [dbo].[PMPM2]'
GO
EXEC sp_refreshview N'[dbo].[PMPM2]'
GO
PRINT N'Refreshing [dbo].[SLClaimItemVariation]'
GO
EXEC sp_refreshview N'[dbo].[SLClaimItemVariation]'
GO
PRINT N'Refreshing [dbo].[RPRL]'
GO
EXEC sp_refreshview N'[dbo].[RPRL]'
GO
PRINT N'Refreshing [dbo].[PRSQ]'
GO
EXEC sp_refreshview N'[dbo].[PRSQ]'
GO
PRINT N'Refreshing [dbo].[PRGR]'
GO
EXEC sp_refreshview N'[dbo].[PRGR]'
GO
PRINT N'Refreshing [dbo].[PRDT]'
GO
EXEC sp_refreshview N'[dbo].[PRDT]'
GO
PRINT N'Refreshing [dbo].[JCAT]'
GO
EXEC sp_refreshview N'[dbo].[JCAT]'
GO
PRINT N'Refreshing [dbo].[PMOP]'
GO
EXEC sp_refreshview N'[dbo].[PMOP]'
GO
PRINT N'Refreshing [dbo].[JCPM]'
GO
EXEC sp_refreshview N'[dbo].[JCPM]'
GO
PRINT N'Refreshing [dbo].[PCScopePhases]'
GO
EXEC sp_refreshview N'[dbo].[PCScopePhases]'
GO
PRINT N'Refreshing [dbo].[RPRTShared]'
GO
EXEC sp_refreshview N'[dbo].[RPRTShared]'
GO
PRINT N'Refreshing [dbo].[DDFHShared]'
GO
EXEC sp_refreshview N'[dbo].[DDFHShared]'
GO
PRINT N'Refreshing [dbo].[HQTX]'
GO
EXEC sp_refreshview N'[dbo].[HQTX]'
GO
PRINT N'Refreshing [dbo].[HQTL]'
GO
EXEC sp_refreshview N'[dbo].[HQTL]'
GO
PRINT N'Refreshing [dbo].[brvJCTax]'
GO
EXEC sp_refreshview N'[dbo].[brvJCTax]'
GO
PRINT N'Refreshing [dbo].[POItemLine]'
GO
EXEC sp_refreshview N'[dbo].[POItemLine]'
GO
PRINT N'Refreshing [dbo].[POHD]'
GO
EXEC sp_refreshview N'[dbo].[POHD]'
GO
PRINT N'Refreshing [dbo].[INCO]'
GO
EXEC sp_refreshview N'[dbo].[INCO]'
GO
PRINT N'Refreshing [dbo].[GLAC]'
GO
EXEC sp_refreshview N'[dbo].[GLAC]'
GO
PRINT N'Refreshing [dbo].[APLB]'
GO
EXEC sp_refreshview N'[dbo].[APLB]'
GO
PRINT N'Refreshing [dbo].[SLHD]'
GO
EXEC sp_refreshview N'[dbo].[SLHD]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployeeETPAmounts]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployeeETPAmounts]'
GO
PRINT N'Refreshing [dbo].[udRoutingNum]'
GO
EXEC sp_refreshview N'[dbo].[udRoutingNum]'
GO
PRINT N'Refreshing [dbo].[EMWP]'
GO
EXEC sp_refreshview N'[dbo].[EMWP]'
GO
PRINT N'Refreshing [dbo].[PRDL]'
GO
EXEC sp_refreshview N'[dbo].[PRDL]'
GO
PRINT N'Altering [dbo].[vPMSubmittal]'
GO
ALTER TABLE [dbo].[vPMSubmittal] ALTER COLUMN [SpecSection] [varchar] (20) COLLATE Latin1_General_BIN NULL
GO
PRINT N'Refreshing [dbo].[SMDepartment]'
GO
EXEC sp_refreshview N'[dbo].[SMDepartment]'
GO
PRINT N'Refreshing [dbo].[MSSurchargeCodes]'
GO
EXEC sp_refreshview N'[dbo].[MSSurchargeCodes]'
GO
PRINT N'Refreshing [dbo].[PMEC]'
GO
EXEC sp_refreshview N'[dbo].[PMEC]'
GO
PRINT N'Refreshing [dbo].[PMPMArch]'
GO
EXEC sp_refreshview N'[dbo].[PMPMArch]'
GO
PRINT N'Refreshing [dbo].[APWD]'
GO
EXEC sp_refreshview N'[dbo].[APWD]'
GO
PRINT N'Refreshing [dbo].[INMT]'
GO
EXEC sp_refreshview N'[dbo].[INMT]'
GO
PRINT N'Refreshing [dbo].[INLO]'
GO
EXEC sp_refreshview N'[dbo].[INLO]'
GO
PRINT N'Refreshing [dbo].[INBO]'
GO
EXEC sp_refreshview N'[dbo].[INBO]'
GO
PRINT N'Refreshing [dbo].[INBM]'
GO
EXEC sp_refreshview N'[dbo].[INBM]'
GO
PRINT N'Altering [dbo].[bSLCO]'
GO
ALTER TABLE [dbo].[bSLCO] ADD
[AllowExceededClaimEntryYN] [dbo].[bYN] NOT NULL CONSTRAINT [DF_bSLCO_AllowExceededClaimEntryYN] DEFAULT ('N')
GO
PRINT N'Refreshing [dbo].[SLCO]'
GO
EXEC sp_refreshview N'[dbo].[SLCO]'
GO
PRINT N'Refreshing [dbo].[JCCB]'
GO
EXEC sp_refreshview N'[dbo].[JCCB]'
GO
PRINT N'Refreshing [dbo].[brvJCTISigPhs]'
GO
EXEC sp_refreshview N'[dbo].[brvJCTISigPhs]'
GO
PRINT N'Refreshing [dbo].[EMUH]'
GO
EXEC sp_refreshview N'[dbo].[EMUH]'
GO
PRINT N'Refreshing [dbo].[EMUE]'
GO
EXEC sp_refreshview N'[dbo].[EMUE]'
GO
PRINT N'Refreshing [dbo].[EMUC]'
GO
EXEC sp_refreshview N'[dbo].[EMUC]'
GO
PRINT N'Refreshing [dbo].[EMJT]'
GO
EXEC sp_refreshview N'[dbo].[EMJT]'
GO
PRINT N'Refreshing [dbo].[PREHFullName]'
GO
EXEC sp_refreshview N'[dbo].[PREHFullName]'
GO
PRINT N'Refreshing [dbo].[SLClaimHeader]'
GO
EXEC sp_refreshview N'[dbo].[SLClaimHeader]'
GO
PRINT N'Refreshing [dbo].[SLClaimHeaderTotal]'
GO
EXEC sp_refreshview N'[dbo].[SLClaimHeaderTotal]'
GO
PRINT N'Altering [dbo].[vspSLClaimUpdateAPGridFill]'
GO


ALTER proc [dbo].[vspSLClaimUpdateAPGridFill]
/****************************************************************************
* CREATED BY:	GF 10/10/2012 TK-18326 SL Claim Enhancement
* MODIFIED BY:	GF 03/29/2013 TFS-45348 do not display claim zero for update
*				AW 04/23/2013 TFS-47937 Requested that only certified be sent to AP
*
*
* USAGE:
* Fills grid with available SL Claims that can be updated to AP Transaction Entry
* or AP Unapproved Invoices
*
* INPUT PARAMETERS:
* @SLCo				SL Company
* @ProcessName		AP Transaction Entry or AP Unapproved Invoices
* @BeginSL			Beginning subcontract or null
* @EndSL			Ending subcontract or null
* @BeginVendorName	Beginning vendor sort name or null
* @EndVendorName	Ending vendor sort name or null
*
* OUTPUT PARAMETERS:
*	See Select statement below
*
* RETURN VALUE:
* 	0 	    Success
*	1 & message Failure
*
*****************************************************************************/
(@SLCo bCompany = NULL, @ProcessName VARCHAR(128) = NULL, 
 @UpdateAllClaims CHAR(1) = 'N',
 @BeginJCCo bCompany = NULL, @BeginJob bJob = NULL, 
 @EndJCCo bCompany = NULL, @EndJob bJob = NULL,
 @BeginVendorName VARCHAR(20) = NULL, @EndVendorName VARCHAR(20) = NULL)
AS
SET NOCOUNT ON

DECLARE @rcode INT

SET @rcode = 0

IF @UpdateAllClaims IS NULL SET @UpdateAllClaims = 'N'

----"SLClaimUpdateAPTrans", "SLClaimUpdateAPUnapprove"

---- WILL NEED MORE WORK ONCE UPDATES TO AP ARE COMPLETE FOR WHICH CLAIMS ARE AVAILABLE USING STATUS
IF @ProcessName = 'SLClaimUpdateAPUnapprove'
	BEGIN
	/* Fill update grid with valid claims for AP unapproved invoices  */
	select @UpdateAllClaims AS [Update]
		  ,c.SL AS [Subcontract]
		  ,c.ClaimNo AS [Claim No]
		  ,c.[Description] AS [Claim Description]
		  ,SLHD.Job AS [Job]
		  ,JCJM.[Description] AS [Job Description]
		  ,SLHD.Vendor AS [Vendor]
		  ,APVM.Name AS [Name]
		  ,c.ClaimDate AS [Claim Date]
		  ,c.APRef AS [Invoice No.]
		  ,TTL.AmountPayable AS [Amount Payable]
	from dbo.vSLClaimHeader c WITH (NOLOCK)
	INNER JOIN dbo.bSLHD SLHD WITH (NOLOCK) ON SLHD.SLCo=c.SLCo AND SLHD.SL=c.SL
	INNER JOIN dbo.bAPVM APVM WITH (NOLOCK) ON APVM.VendorGroup=SLHD.VendorGroup AND APVM.Vendor=SLHD.Vendor
	INNER JOIN dbo.bJCJM JCJM WITH (NOLOCK) ON JCJM.JCCo=SLHD.JCCo AND JCJM.Job=SLHD.Job
	INNER JOIN dbo.SLClaimHeaderTotal TTL WITH (NOLOCK) ON TTL.SLCo = c.SLCo AND TTL.SL=c.SL AND TTL.ClaimNo=c.ClaimNo
	WHERE c.SLCo = @SLCo
		AND SLHD.JCCo >= ISNULL(@BeginJCCo, SLHD.JCCo)
		AND SLHD.Job >= ISNULL(@BeginJob, SLHD.Job)
		AND SLHD.JCCo <= ISNULL(@EndJCCo, SLHD.JCCo)
		AND SLHD.Job <= ISNULL(@EndJob, SLHD.Job)
		AND APVM.SortName >= ISNULL(@BeginVendorName, APVM.SortName)
		AND APVM.SortName <= ISNULL(@EndVendorName, APVM.SortName)
		AND c.ClaimNo > 0
		AND (c.ClaimStatus <> 20 ----denied
			OR (c.ClaimStatus = 30 AND SLHD.ApprovalRequired = 'N')) ----certified and not required
		--AND c.ClaimStatus NOT IN(20,30) ----denied ,certified
		---- must have an amount payable
		AND (TTL.ApproveAmount <> 0 OR TTL.ApproveTaxAmount <> 0 OR TTL.ApproveRetention <> 0)
		---- display only claims with items
		AND EXISTS(SELECT 1 FROM dbo.vSLClaimItem i WHERE i.SLCo=c.SLCo
						AND i.SL=c.SL AND i.ClaimNo=c.ClaimNo)
		---- SL Claim Key Id must not be in AP
		AND NOT EXISTS(SELECT 1 FROM dbo.bAPUI APUI WHERE APUI.SLKeyID = c.KeyID)
		AND NOT EXISTS(SELECT 1 FROM dbo.bAPTL APTL WHERE APTL.SLKeyID = c.KeyID)
		AND NOT EXISTS(SELECT 1 FROM dbo.bAPHB APHB WHERE APHB.SLKeyID = c.KeyID)
		
	order by c.SL, c.ClaimNo
	END
ELSE
	BEGIN
	/* Fill update grid with valid claims AP transaction entry */
	SELECT @UpdateAllClaims AS [Update]
		  ,c.SL AS [Subcontract]
		  ,c.ClaimNo AS [Claim No]
		  ,c.[Description] AS [Claim Descripiton]
		  ,SLHD.Job AS [Job]
		  ,JCJM.[Description] AS [Job Description]
		  ,SLHD.Vendor AS [Vendor]
		  ,APVM.Name AS [Name]
		  ,c.ClaimDate AS [Claim Date]
		  ,c.APRef AS [Invoice No.]
		  ,TTL.AmountPayable AS [Amount Payable]
	from dbo.vSLClaimHeader c WITH (NOLOCK)
	INNER JOIN dbo.bSLHD SLHD WITH (NOLOCK) ON SLHD.SLCo=c.SLCo AND SLHD.SL=c.SL
	INNER JOIN dbo.bAPVM APVM WITH (NOLOCK) ON APVM.VendorGroup=SLHD.VendorGroup AND APVM.Vendor=SLHD.Vendor
	INNER JOIN dbo.bJCJM JCJM WITH (NOLOCK) ON JCJM.JCCo=SLHD.JCCo AND JCJM.Job=SLHD.Job
	INNER JOIN dbo.SLClaimHeaderTotal TTL WITH (NOLOCK) ON TTL.SLCo = c.SLCo AND TTL.SL=c.SL AND TTL.ClaimNo=c.ClaimNo
	WHERE c.SLCo = @SLCo
		AND SLHD.JCCo >= ISNULL(@BeginJCCo, SLHD.JCCo)
		AND SLHD.Job >= ISNULL(@BeginJob, SLHD.Job)
		AND SLHD.JCCo <= ISNULL(@EndJCCo, SLHD.JCCo)
		AND SLHD.Job <= ISNULL(@EndJob, SLHD.Job)
		AND APVM.SortName >= ISNULL(@BeginVendorName, APVM.SortName)
		AND APVM.SortName <= ISNULL(@EndVendorName, APVM.SortName)
		AND SLHD.ApprovalRequired = 'N' ---- claim approval required
		AND c.ClaimNo > 0
		-- TFS-47937
		AND c.ClaimStatus NOT IN (10,20) ----pending, denied
		---- must have an amount payable
		AND (TTL.ApproveAmount <> 0 OR TTL.ApproveTaxAmount <> 0 OR TTL.ApproveRetention <> 0)	
		---- display only claims with items
		AND EXISTS(SELECT 1 FROM dbo.vSLClaimItem i WHERE i.SLCo=c.SLCo
						AND i.SL=c.SL AND i.ClaimNo=c.ClaimNo)
		---- SL Claim Key Id must not be in AP
		AND NOT EXISTS(SELECT 1 FROM dbo.bAPUI APUI WHERE APUI.SLKeyID = c.KeyID)
		AND NOT EXISTS(SELECT 1 FROM dbo.bAPTL APTL WHERE APTL.SLKeyID = c.KeyID)
		AND NOT EXISTS(SELECT 1 FROM dbo.bAPHB APHB WHERE APHB.SLKeyID = c.KeyID)

	order by c.SL, c.ClaimNo
	END
	
vspexit:
	return @rcode


GO
PRINT N'Refreshing [dbo].[HRET]'
GO
EXEC sp_refreshview N'[dbo].[HRET]'
GO
PRINT N'Refreshing [dbo].[WFNFGrouping]'
GO
EXEC sp_refreshview N'[dbo].[WFNFGrouping]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployeeItemAmounts]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployeeItemAmounts]'
GO
PRINT N'Refreshing [dbo].[PMTS]'
GO
EXEC sp_refreshview N'[dbo].[PMTS]'
GO
PRINT N'Refreshing [dbo].[GLFY]'
GO
EXEC sp_refreshview N'[dbo].[GLFY]'
GO
PRINT N'Refreshing [dbo].[ARCO]'
GO
EXEC sp_refreshview N'[dbo].[ARCO]'
GO
PRINT N'Refreshing [dbo].[PMOPTotalsForCOR]'
GO
EXEC sp_refreshview N'[dbo].[PMOPTotalsForCOR]'
GO
PRINT N'Refreshing [dbo].[JCCT]'
GO
EXEC sp_refreshview N'[dbo].[JCCT]'
GO
PRINT N'Refreshing [dbo].[DDSF]'
GO
EXEC sp_refreshview N'[dbo].[DDSF]'
GO
PRINT N'Refreshing [dbo].[SMDivisionCallType]'
GO
EXEC sp_refreshview N'[dbo].[SMDivisionCallType]'
GO
PRINT N'Refreshing [dbo].[HQRG]'
GO
EXEC sp_refreshview N'[dbo].[HQRG]'
GO
PRINT N'Refreshing [dbo].[MSSurchargeGroupCodes]'
GO
EXEC sp_refreshview N'[dbo].[MSSurchargeGroupCodes]'
GO
PRINT N'Refreshing [dbo].[PMED]'
GO
EXEC sp_refreshview N'[dbo].[PMED]'
GO
PRINT N'Refreshing [dbo].[PMPMInsp]'
GO
EXEC sp_refreshview N'[dbo].[PMPMInsp]'
GO
PRINT N'Refreshing [dbo].[APWDReleaseHoldCode]'
GO
EXEC sp_refreshview N'[dbo].[APWDReleaseHoldCode]'
GO
PRINT N'Refreshing [dbo].[SLCT]'
GO
EXEC sp_refreshview N'[dbo].[SLCT]'
GO
PRINT N'Refreshing [dbo].[ARTL]'
GO
EXEC sp_refreshview N'[dbo].[ARTL]'
GO
PRINT N'Refreshing [dbo].[ARTH]'
GO
EXEC sp_refreshview N'[dbo].[ARTH]'
GO
PRINT N'Refreshing [dbo].[PRTH]'
GO
EXEC sp_refreshview N'[dbo].[PRTH]'
GO
PRINT N'Refreshing [dbo].[PREHName]'
GO
EXEC sp_refreshview N'[dbo].[PREHName]'
GO
PRINT N'Refreshing [dbo].[JCOI]'
GO
EXEC sp_refreshview N'[dbo].[JCOI]'
GO
PRINT N'Refreshing [dbo].[JCOH]'
GO
EXEC sp_refreshview N'[dbo].[JCOH]'
GO
PRINT N'Refreshing [dbo].[HQLT]'
GO
EXEC sp_refreshview N'[dbo].[HQLT]'
GO
PRINT N'Refreshing [dbo].[HQET]'
GO
EXEC sp_refreshview N'[dbo].[HQET]'
GO
PRINT N'Refreshing [dbo].[brvJCCDDetlDesc]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCDDetlDesc]'
GO
PRINT N'Refreshing [dbo].[brvJCUCDrilldown]'
GO
EXEC sp_refreshview N'[dbo].[brvJCUCDrilldown]'
GO
PRINT N'Refreshing [dbo].[RPRS]'
GO
EXEC sp_refreshview N'[dbo].[RPRS]'
GO
PRINT N'Refreshing [dbo].[DDSU]'
GO
EXEC sp_refreshview N'[dbo].[DDSU]'
GO
PRINT N'Refreshing [dbo].[EMEP]'
GO
EXEC sp_refreshview N'[dbo].[EMEP]'
GO
PRINT N'Refreshing [dbo].[INLS]'
GO
EXEC sp_refreshview N'[dbo].[INLS]'
GO
PRINT N'Refreshing [dbo].[INLC]'
GO
EXEC sp_refreshview N'[dbo].[INLC]'
GO
PRINT N'Refreshing [dbo].[HQUM]'
GO
EXEC sp_refreshview N'[dbo].[HQUM]'
GO
PRINT N'Refreshing [dbo].[HQMC]'
GO
EXEC sp_refreshview N'[dbo].[HQMC]'
GO
PRINT N'Refreshing [dbo].[SLHDPM]'
GO
EXEC sp_refreshview N'[dbo].[SLHDPM]'
GO
PRINT N'Refreshing [dbo].[SLCD]'
GO
EXEC sp_refreshview N'[dbo].[SLCD]'
GO
PRINT N'Refreshing [dbo].[SLCB]'
GO
EXEC sp_refreshview N'[dbo].[SLCB]'
GO
PRINT N'Altering [dbo].[vspPMPCOApprovePMSL]'
GO




ALTER PROC [dbo].[vspPMPCOApprovePMSL]
/***********************************************************
* Created By:	GF 06/06/2011 TK-05799
* Modified By:  GF 06/15/2011 TK-06039
*				GF 07/12/2011 TK-06770
*				GF 08/01/2011 TK-07189
*				GP 08/30/2011 TK-07993 added table variable to keep track of which PMSL records don't need SubCOs
*				TL 12/01/2011 TK-10436 add parameter @ReadyForAccounting	
*				JG 12/02/2011 TK-10541 - Notes being concatenated from PMOL records to PMSubcontractCO Detail.
*				GF 02/07/2012 TK-11854 use the SCO approval procedure to set status and data also.
*				GF 02/10/2012 TK-12466 SLItemType should always be 2 - Change
*				GF 03/09/2012 TK-13116 #146042 duplicate of TK-12466 because did not get to 6.4.4
*				DAN SO 03/12/2012 - TK-13118 - Added @CreateChangeOrders and @CreateSingleChangeOrder
*				DAN SO 03/13/2012 - TK-13139 - Added @CreateSingleChangeOrder to SP calls
*				GF 03/30/2012 TK-13768 use the @CreateChangeorders flag
*				GF 05/22/2012 TK-13889 #145421 do not approve SCO if ready for accounting <> 'Y'
*				TRL 12/06/2012 TK-19418  Add Code to approve existing SLSubCO on Approval
*				AJW 03/15/2013 TFS 43659 support new check box for creating a new SL from PMSL
*
*				
* This SP updates any PMSL detail records when a pending
* change order is approved. Will be called from bspPMPCOApprove
* and when a pending change order is manually approved from the
* approved change order grid.
* 
* First cursor is based on PMOL records with a vendor, no subcontract, not interfaced
* and the cost type is one of the subcontract cost types from PM Company Parameters.
* If a matching PMSL record is found, we use the PMSL Sequence and execute the SL
* inititalize procedure to create a new SL or add a new item to an existing SL. Same
* process as if running PM Subcontract Detail and selecting a row then click intialize.
*
* If creating a new subcontract then we do not want to have an SCO created also. Will use the
* IntFlag to indicate when a new subcontract is created so that an SCO is not created also.
*
* Second cursor is based on PMOL records with a SL, no SubCO Number, and not interfaced.
* Must be detail existing in PMSL to create SubCO Number.
* The next SubCO Number will be from PMSubcontractCO for the SLCo and SL.
* Will update all matching PMSL records and assign to the new SubCO Number.
* Then update the SubCO and Sequence in PMOL for the record.			
*				
* INPUT PARAMETERS
* PM Company, Project, PCOType, PCO, PCOItem, ACO, ACOItem, @CreateChangeOrders, @CreateSingleChangeOrder
*
* OUTPUT PARAMETER
* @msg - error message if error occurs
*		
* RETURN VALUE
*   0 - Success
*   1 - Failure
*****************************************************/
(@PMCo bCompany = null, @Project bJob = null, @PCOType bDocType = null,
 @PCO bPCO = null, @PCOItem bPCOItem = null, @ACO bPCO = null,
 @ACOItem bPCOItem = null, @Process CHAR(1) = 'A', @ReadyForAccounting bYN = null, 
  -- TK-13118 --
 @CreateChangeOrders bYN = NULL, @CreateSingleChangeOrder bYN = NULL, 
 @msg VARCHAR(255) OUTPUT)
AS
SET NOCOUNT ON
   
DECLARE @rcode INT, @retcode INT, @retmsg VARCHAR(255),
		@slmsg VARCHAR(60), @opencursor TINYINT, @opencursor2 TINYINT,
		@SL VARCHAR(30), @SLItem bItem, @APCo bCompany, @SubCO SMALLINT, 
		@Vendor bVendor, @Seq INT, @Phase bPhase, @CostType bJCCType,
		@PMOLKeyID BIGINT, @PMOLNotes VARCHAR(MAX), @SubCOStatus VARCHAR(6), @BeginStatus VARCHAR(6),
		@Description VARCHAR(60), @PMSLSeq INT, @SLItemType TINYINT,
		@PhaseGroup bGroup, @PMSLKeyID BIGINT, @LastSL VARCHAR(30),
		----TK-06770
		@SLCostType bJCCType, @SLCostType2 bJCCType, @pmslseqlist VARCHAR(MAX),
		--TK-10436
		 @opencursor3 TINYINT,@PMSubcontractCOKeyID BIGINT,
		--TK-????
		@opencursor4 TINYINT

DECLARE @PMSLWithNewSL TABLE (PMSLKeyID bigint not null)

SET @rcode = 0
SET @opencursor = 0
SET @opencursor2 = 0


IF @PMCo is null
	BEGIN
		SELECT @msg = 'Missing PM Company!', @rcode = 1
		GOTO bspexit
	END

IF @Project is null
	BEGIN
		SELECT @msg = 'Missing Project!', @rcode = 1
		GOTO bspexit
	END

if @PCOType is null
	BEGIN
		SELECT @msg = 'Missing PCO Type!', @rcode = 1
		GOTO bspexit
	END

if @PCO is null
	BEGIN
		SELECT @msg = 'Missing pending change order!', @rcode = 1
		GOTO bspexit
	END

if @PCOItem is null
	BEGIN
		SELECT @msg = 'Missing pending change order item!', @rcode = 1
		GOTO bspexit
	END

IF @ACO is null
	BEGIN
		SELECT @msg = 'Missing approved change order!', @rcode = 1
		GOTO bspexit
	END

IF @ACOItem is null
	BEGIN
		SELECT @msg = 'Missing approved change order item!', @rcode = 1
		GOTO bspexit
	END

---- get PM company info
SELECT  @APCo=APCo,
		@BeginStatus	= BeginStatus,
		----TK-06770
		@SLCostType		= SLCostType,
		@SLCostType2	= SLCostType2
FROM dbo.bPMCO WHERE PMCo=@PMCo
IF @@rowcount = 0
	BEGIN
	SELECT @msg = 'Invalid PM Company.', @rcode = 1
	GOTO bspexit
	END


----TK-06770
SET @pmslseqlist = NULL
---- declare cursor on PMOL rows that have a vendor and no SL and the cost type
---- is one of the 2 PM company defined subcontract cost types
--43659 Jeremy says if SL is null never create an SL or SubCO
--DECLARE bcPMOL CURSOR LOCAL FAST_FORWARD
--	FOR SELECT Phase, CostType, Vendor, KeyID
--	FROM dbo.bPMOL
--	WHERE PMCo = @PMCo
--		AND Project = @Project
--		AND PCOType = @PCOType
--		AND PCO = @PCO
--		AND PCOItem = @PCOItem
--		AND ACO = @ACO
--		AND ACOItem = @ACOItem
--		AND Vendor IS NOT NULL
--		AND Subcontract IS NULL
--		AND InterfacedDate IS NULL
--		AND CostType IN (@SLCostType, @SLCostType2)
		
------ open cursor
--OPEN bcPMOL
--SET @opencursor = 1

--PMOL_Loop:
--FETCH NEXT FROM bcPMOL INTO @Phase, @CostType, @Vendor, @PMOLKeyID

--IF @@FETCH_STATUS <> 0 GOTO PMOL_End

------ check for existence of a PMSL detail record associated to the PMOL record
--SELECT TOP 1 @PMSLSeq = Seq, @PMSLKeyID = KeyID
--FROM dbo.bPMSL
--WHERE PMCo = @PMCo
--	AND Project		= @Project
--	AND PCOType		= @PCOType
--	AND PCO			= @PCO
--	AND PCOItem		= @PCOItem
--	AND ACO			= @ACO
--	AND ACOItem		= @ACOItem
--	AND Phase		= @Phase
--	AND CostType	= @CostType
--	AND Vendor		= @Vendor
--	----TK-07189
--	--AND RecordType	= 'C'
--	AND SL IS NULL
--	AND InterfaceDate IS NULL
	
------ if no records found move to next
--IF @@ROWCOUNT = 0 GOTO PMOL_Loop

------ process one sequence at a time to initialize subcontract detail
--SELECT @pmslseqlist =  ';' + CONVERT(VARCHAR(6),@PMSLSeq) + ';'

------ if we have any PMSL Sequences to create a SL for then use the bspPMSLInitialize procedure
------ TK-07189
--EXEC @retcode = dbo.bspPMSLInitialize @PMCo, @Project, 'X', NULL, @ACO, @ACOItem, @pmslseqlist, 
--				-- TK-13139 --
--				@CreateSingleChangeOrder,
--				@retmsg OUTPUT
------ if error occurs trying to create a SL we will do nothing for now
------ users can manually assign a SL to the detail in PM Subcontract Detail
--if @retcode <> 0  GOTO PMOL_Loop

----keep track of which records have new subcontract
--INSERT @PMSLWithNewSL (PMSLKeyID)
--VALUES (@PMSLKeyID)

------ set to 'C' so that no subco is created in next section
------ when the subcontract status = 3 pending then a new subcontract
------ TK-07189
--UPDATE dbo.bPMSL SET IntFlag	= CASE WHEN l.SL IS NULL THEN 'N' ELSE 'C' END,
--					 ----TK-12466
--					 SLItemType = 2 ----SLItemType = CASE WHEN l.SubCO IS NULL THEN 1 ELSE l.SLItemType END
--FROM dbo.bPMSL l
--INNER JOIN dbo.bSLHD s ON s.SLCo=l.SLCo AND s.SL=l.SL
--WHERE l.KeyID = @PMSLKeyID

------ get SL, SLItem, SubCO, Seq from PMSL
--SELECT  @SL = SL, @SLItem = SLItem, @SubCO = SubCO
--FROM dbo.bPMSL
--WHERE KeyID = @PMSLKeyID


--GOTO PMOL_Loop


--PMOL_End:
--	CLOSE bcPMOL
--	DEALLOCATE bcPMOL
--	SET @opencursor = 0

----TK-13768 do not create SCO
IF @CreateChangeOrders = 'Y' 
BEGIN
---- reset last subcontract
SET @LastSL = NULL
---- declare cursor on PMOL rows that have a SL and no SubCO Number assigned yet
DECLARE bcPMOL2 CURSOR LOCAL FAST_FORWARD
	FOR SELECT PhaseGroup, Phase, CostType, Subcontract, POSLItem, KeyID, Notes
	FROM dbo.bPMOL
	WHERE PMCo = @PMCo
		AND Project = @Project
		AND PCOType = @PCOType
		AND PCO = @PCO
		AND PCOItem = @PCOItem
		AND ACO = @ACO
		AND ACOItem = @ACOItem
		AND Subcontract IS NOT NULL
		AND SubCO IS NULL
		AND InterfacedDate IS NULL
		-- 43659
		AND CreateSL='N'
		
---- open cursor
OPEN bcPMOL2
SET @opencursor2 = 1

PMOL2_Loop:
FETCH NEXT FROM bcPMOL2 INTO @PhaseGroup, @Phase, @CostType, @SL, @SLItem, @PMOLKeyID, @PMOLNotes

IF @@FETCH_STATUS <> 0 GOTO PMOL2_End

---- must have a PMSL record for the PMCo, Project, PCOType, PCO, PCOItem, SL, SLItem
---- if not then no detail to assign to the created SubCO, so why do?
---- we also need the description for the PMSubcontractCO record we will create
SELECT TOP 1 @Description = sl.SLItemDescription, @SLItemType = sl.SLItemType,
			 @PMSLSeq = sl.Seq, @PMSLKeyID = sl.KeyID
FROM dbo.bPMSL sl
----LEFT OUTER JOIN @PMSLWithNewSL new on new.PMSLKeyID = sl.KeyID
WHERE sl.PMCo = @PMCo
	AND sl.Project = @Project
	AND sl.PCOType = @PCOType
	AND sl.PCO = @PCO
	AND sl.PCOItem = @PCOItem
	AND sl.ACO = @ACO
	AND sl.ACOItem = @ACOItem
	AND sl.Phase = @Phase
	AND sl.CostType = @CostType
	AND sl.SL = @SL
	AND sl.SLItem = @SLItem
	AND sl.SLItemType IN (1,2,4)
	AND sl.SubCO IS NULL
	AND sl.InterfaceDate IS NULL
	----TK-13768
	---- if 'C' created in first section
	--AND ISNULL(IntFlag,'N') <> 'C'
	---- don't add SubCOs for new subcontracts found in previous loop
	----TK-13768
	----AND new.PMSLKeyID IS NULL
---- if no subcontract detail goto next
IF @@ROWCOUNT = 0
	BEGIN
	--SELECT 'No subcontract detail'
	GOTO PMOL2_Loop
	END

---- only get next subcontract change order when the last subcontract is different
IF ISNULL(@LastSL,'') <> @SL
	BEGIN
	---- call the subcontract co create procedure to generate next SubCO
	SET @SubCO = NULL
	EXEC @retcode = dbo.vspPMSubcontractCOCreate @PMSLKeyID, @ReadyForAccounting,
					-- TK-13139 --
					@CreateSingleChangeOrder,
					@SubCO OUTPUT, @retmsg OUTPUT
	IF @retcode <> 0
		BEGIN
		SELECT @msg = @retmsg, @rcode = 1
		GOTO bspexit
		END

	IF @SubCO IS NULL
		BEGIN
		SELECT @msg = 'Error occurred generating next SubCO.', @rcode = 1
		GOTO bspexit
		END

	----TK-13889 moved approve SCO to here
	IF @ReadyForAccounting = 'Y'
		BEGIN
		SELECT @PMSubcontractCOKeyID = KeyID
		FROM dbo.vPMSubcontractCO
		WHERE SLCo = @APCo
			AND SL = @SL
			AND SubCO = @SubCO
		IF @@ROWCOUNT = 1
			BEGIN
			EXEC @retcode = dbo.vspPMSubcontractCOApproveSCOs @PMSubcontractCOKeyID, 'Y', NULL, @retmsg OUTPUT
			END
		END
	END

IF ISNUll(@SubCO,'')<>'' or @SubCO <> 0	
	BEGIN
	---- update PMSubcontractCO with concatinated Notes for the Details. TK-10541	
	IF @PMOLNotes IS NOT NULL AND dbo.Trim(@PMOLNotes) <> ''
		BEGIN
			UPDATE dbo.vPMSubcontractCO
			---- Add two spaces between notes
			SET Details = CASE WHEN Details IS NOT NULL THEN Details + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10) ELSE '' END + @PMOLNotes
			WHERE SLCo = @APCo
				AND SL = @SL
				AND SubCO = @SubCO		
		END
	END

---- set last subcontract to current
SET @LastSL = @SL

----TK-13889
---- update PMSL and assign the SubCO to all matching detail records
UPDATE dbo.bPMSL
SET	SubCO = @SubCO, IntFlag = 'C'
WHERE PMCo=@PMCo 
	AND Project=@Project
	AND PCOType=@PCOType 
	AND PCO=@PCO 
	AND PCOItem=@PCOItem
	AND ACO=@ACO 
	AND ACOItem=@ACOItem
	AND Phase = @Phase
	AND CostType = @CostType
	AND SL=@SL 
	AND SLItem=@SLItem
	AND InterfaceDate IS NULL
	

GOTO PMOL2_Loop


PMOL2_End:
	CLOSE bcPMOL2
	DEALLOCATE bcPMOL2
	SET @opencursor2 = 0
END


IF @ReadyForAccounting = 'Y'
	BEGIN
	--declare cursor on PMOL rows that have a SL with assigned SubCO Number 
     DECLARE bcPMOL3 CURSOR LOCAL FAST_FORWARD
	FOR SELECT PhaseGroup, Phase, CostType, Subcontract, SubCO
	FROM dbo.bPMOL
	WHERE PMCo = @PMCo
		AND Project = @Project
		AND PCOType = @PCOType
		AND PCO = @PCO
		AND PCOItem = @PCOItem
		AND ACO = @ACO
		AND ACOItem = @ACOItem
		AND Subcontract IS NOT NULL
		AND SubCO IS NOT NULL
		AND InterfacedDate IS NULL
	
	---- open cursor
	OPEN bcPMOL3
	SET @opencursor3 = 1

	PMOL3_Loop:
	FETCH NEXT FROM bcPMOL3 INTO @PhaseGroup, @Phase, @CostType, @SL, @SubCO

	IF @@FETCH_STATUS <> 0 GOTO PMOL3_End

	------ must have a PMSL record for the PMCo, Project, PCOType, PCO, PCOItem, SL, SubCO
	SELECT sl.SL, sl.SubCO FROM dbo.bPMSL sl
	WHERE sl.PMCo = @PMCo
		AND sl.Project = @Project
		AND sl.PCOType = @PCOType
		AND sl.PCO = @PCO
		AND sl.PCOItem = @PCOItem
		AND sl.ACO = @ACO
		AND sl.ACOItem = @ACOItem
		AND sl.Phase = @Phase
		AND sl.CostType = @CostType
		AND sl.SL = @SL
		AND sl.SLItemType IN (1,2,4)
		AND sl.SubCO = @SubCO
		AND sl.InterfaceDate IS NULL
		IF @@ROWCOUNT = 0
		BEGIN
			GOTO PMOL3_Loop
		END

		SELECT KeyID
		FROM dbo.vPMSubcontractCO
		WHERE SLCo = @APCo AND SL = @SL 	AND SubCO = @SubCO
		IF @@ROWCOUNT = 0
		BEGIN
			GOTO PMOL3_Loop
		END

		--Cycle through Subcontract SubCO's
		DECLARE bcPMOL4 CURSOR LOCAL FAST_FORWARD
		FOR SELECT KeyID
		FROM dbo.vPMSubcontractCO
		WHERE SLCo = @APCo AND SL = @SL 	AND SubCO = @SubCO

		---- open cursor
		OPEN bcPMOL4
		SET @opencursor4 = 1

		PMOL4_Loop:

		FETCH NEXT FROM bcPMOL4 INTO @PMSubcontractCOKeyID

		IF @@FETCH_STATUS <> 0 GOTO PMOL4_End

		EXEC @retcode = dbo.vspPMSubcontractCOApproveSCOs @PMSubcontractCOKeyID, 'Y', NULL, @retmsg OUTPUT
		
		GOTO PMOL4_Loop

		PMOL4_End:
			CLOSE bcPMOL4
			DEALLOCATE bcPMOL4
			SET @opencursor4 = 0
		
	GOTO PMOL3_Loop

	PMOL3_End:
		CLOSE bcPMOL3
		DEALLOCATE bcPMOL3
		SET @opencursor3 = 0
	END


bspexit:
	---- update PMSL and set IntFlag = 'N' if 'C' cleanup
	UPDATE dbo.bPMSL SET IntFlag = NULL
	WHERE PMCo=@PMCo AND Project=@Project AND IntFlag = 'C'
	
	
	IF @opencursor = 1
		BEGIN
		CLOSE bcPMOL
		DEALLOCATE bcPMOL
		SET @opencursor = 0
		END
		
	IF @opencursor2 = 1
		BEGIN
		CLOSE bcPMOL2
		DEALLOCATE bcPMOL2
		SET @opencursor2 = 0
		END

	IF @opencursor3 = 1
		BEGIN
		CLOSE bcPMSL3
		DEALLOCATE bcPMSL3
		SET @opencursor3 = 0
		END
	
	IF @opencursor4 = 1
		BEGIN
		CLOSE bcPMSL4
		DEALLOCATE bcPMSL4
		SET @opencursor4 = 0
		END

	IF @rcode <> 0 SELECT @msg = isnull(@msg,'') 
	RETURN @rcode












GO
PRINT N'Refreshing [dbo].[RQRH]'
GO
EXEC sp_refreshview N'[dbo].[RQRH]'
GO
PRINT N'Refreshing [dbo].[POUnique]'
GO
EXEC sp_refreshview N'[dbo].[POUnique]'
GO
PRINT N'Refreshing [dbo].[INMO]'
GO
EXEC sp_refreshview N'[dbo].[INMO]'
GO
PRINT N'Altering [dbo].[vspSLValForPMOL]'
GO

ALTER proc [dbo].[vspSLValForPMOL]
/***********************************************************
 * CREATED By:	CJW 7/1/98
 * MODIFIED BY: LM 2/3/99 - Fixed to properly validate SL in SLHD - unique by SLCo
 *              GF 07/30/2001 - Fixed to only allow status of open or pending.
 *				GF 03/30/2006 - added @nextslitem as output for 6.x, was done via query statement in 5.x
 *				GF 11/28/2007 - issue #124780 allow for null vendor and return SLVendor as output param.
 *				GF 02/16/2010 - issue #136053 subcontract prebilling
 *				DC 06/25/10 - #135813 - expand subcontract number
 *				Dan S0 06/07/2011 - TK-05850 - added flag to use proc for PMPCOSItemsDetail SL validation
 *				GF 06/18/2011 - TK-00000
 *				GP 06/20/2011 - TK-06041 Added SLItem, UM, and UnitCost outputs
 *				JG 06/23/2011 TK-06041 - Add phase/ct to filter items
 *				JG 06/29/2011 TK-06041 - Added Purchase Units/Amount
 *				JG 07/13/2011 TK-00000 - Changed from Orig values to Cur values
 *				JG 02/21/2012 TK-12755 - Modified the check for Phases and Cost types when the stored value is null.
 *				AW 03/14/2013 TFS-43659 - Allow new SL's if CreateSL is checked otherwise follow original rules
 *
 * USAGE:
 * validates SL, returns SL Description
 * an error is returned if any of the following occurs
 *
 * INPUT PARAMETERS
 *   SLCo  SL Co to validate against
 *   SL to validate
 *   Project
 *   Vendor Group
 *   Vendor
 *
 * OUTPUT PARAMETERS
 * @nextslitem		Next sequential SL Item from SLIT
 * @slvendor		vendor assigned to subcontract
 * @origdate		SL original date
 * @SLExistsYN		Does the SL Exist?
 * @msg      error message if error occurs otherwise Description of SL, Vendor, Vendor group, and Vendor Name
 * RETURN VALUE
 *   0         success
 *   1         Failure
 *****************************************************/
(@pmco bCompany = 0, @slco bCompany = 0, @sl VARCHAR(30) = NULL,
 @project bJob = null, @phase bPhase = NULL, @costtype bJCCType = NULL,
 @vendor bVendor = null,
 @vendorgroup bGroup, @PCOSItemDetailYN char(1) = NULL, @CreateSLYN char(1) = null,
 @nextslitem bItem output, @slvendor bVendor output,
 @origdate bDate = null output, @status tinyint = NULL output,
 @SLItem bItem output, @UM bUM output, @Units bUnits OUTPUT, @UnitCost bUnitCost output, @Amount bDollar OUTPUT, 
 @Phase bPhase output, @CostType bJCCType output, @NewCreateSLYN bYN output,
 @msg varchar(255) output)
as
set nocount on

declare @rcode int, @slvendorgroup bGroup, @maxpmsl bItem, @maxslit bItem,
		----TK-00000
		@Approved CHAR(1), @SLCount int, @DetailCount int, @SLItem1 bItem, @SLItem2 bItem

select @rcode = 0, @status = 0, @maxpmsl = 0, @maxslit = 0, @nextslitem = 0, @SLCount = 0, @DetailCount = 0

if @slco is null
   	begin
   	select @msg = 'Missing SL Company!', @rcode = 1
   	goto bspexit
   	end

if @sl is null
   	begin
   	select @msg = 'Missing SL!', @rcode = 1
   	goto bspexit
   	end

if @project is null
   	begin
   	select @msg = 'Missing Project!', @rcode = 1
   	goto bspexit
   	end

if @vendorgroup is null
   	begin
   	select @msg = 'Missing Vendor Group!', @rcode = 1
   	goto bspexit
   	end

-- TK-05850 --
IF @PCOSItemDetailYN IS NULL
   	BEGIN
   		SELECT @msg = 'Missing PCOSItemDetailYN flag!', @rcode = 1
   		GOTO bspexit
   	END
   	
IF @CreateSLYN IS NULL
   	BEGIN
   		SELECT @msg = 'Missing CreateSLYN flag!', @rcode = 1
   		GOTO bspexit
   	END

SET @NewCreateSLYN = @CreateSLYN
---- get info from SLHD #136053
select @msg = 'New Subcontract'
----#136053
select @msg=Description, @slvendor=Vendor, @slvendorgroup=VendorGroup,
		@origdate=OrigDate, @status=Status,
		----TK-00000
		@Approved = Approved
----#136053
from dbo.SLHD with (nolock) where SLCo=@slco and SL=@sl
if @@rowcount <> 0
	begin
	---- check to see if vendor entered matches the vendor in PM if we have a vendor
	if @slvendorgroup <> @vendorgroup
		begin
		select @msg = 'Vendor Group from SL Header (SLHD) does not match the PM Vendor Group.', @rcode = 1
		goto bspexit
		end
	if isnull(@vendor, @slvendor) <> @slvendor
		begin
		select @msg = 'Vendor entered does not match vendor in SL. ', @rcode = 1
		goto bspexit
		end
	---- check subcontract status allow only(0,3) - open or pending
	if @status not in (0,3)
		begin
		select @msg = 'Subcontract must be New, Open, Pending!', @rcode = 1
		goto bspexit
		END
	----TK-00000
	IF @PCOSItemDetailYN = 'Y'
		BEGIN
		---- check approved flag
		IF @Approved <> 'Y'
			BEGIN
			SET @rcode = 1
			SET @msg = 'Subcontract must be either New or Approved'
			GOTO bspexit
			END
		END
	--TFS-43659 clear the CreateSL flag if SL already exists and passes validation
	IF @CreateSLYN = 'Y'
		BEGIN
			SET @NewCreateSLYN = 'N'
		END
	end
--TFS-43659 we will allow new SLs to be added if CreateSL = 'Y'
ELSE	-- TK-05850 --
	BEGIN
		IF @vendor is null
			BEGIN
			SET @rcode = 1
			SET @msg = 'Vendor required!'
			GOTO bspexit
			END
		IF @PCOSItemDetailYN = 'Y' and @CreateSLYN = 'N'
			BEGIN
			   	SET @NewCreateSLYN = 'Y'
   				GOTO bspexit
			END
	END

-- -- -- get maximum SL Item from PMSL
select @maxpmsl = max(SLItem) from PMSL with (nolock) where SLCo=@slco and SL=@sl
if @maxpmsl is null select @maxpmsl = 0
-- -- -- get maximum SL Item from SLIT
select @maxslit = max(SLItem) from SLIT with (nolock) where SLCo=@slco and SL=@sl
if @maxslit is null select @maxslit = 0
-- -- -- set @nextslitem to larger of two plus one
if @maxpmsl > @maxslit
	select @nextslitem = @maxpmsl + 1
else
	select @nextslitem = @maxslit + 1

set @SLItem = null

--Get a count of how many SL Item records exist for the SL
select DISTINCT @SLItem1 = SLItem 
from dbo.SLIT 
where JCCo = @pmco 
	and Job = @project 
	and SL = @sl 
	AND dbo.vfIsEqual(Phase, ISNULL(@phase, Phase)) & 
		dbo.vfIsEqual(JCCType, ISNULL(@costtype, JCCType)) = 1
SELECT @SLCount = @@ROWCOUNT

select DISTINCT @SLItem2 = SLItem 
from dbo.PMSL 
where PMCo = @pmco 
	and Project = @project 
	and SL = @sl 
	AND dbo.vfIsEqual(Phase, ISNULL(@phase, Phase)) & 
		dbo.vfIsEqual(CostType, ISNULL(@costtype, CostType)) = 1
SELECT @DetailCount = @@ROWCOUNT

if @SLCount is null		set @SLCount = 0
if @DetailCount is null	set @DetailCount = 0

--Check if we can narrow it down to 1 specific item only
if ((@SLCount = 1 AND @DetailCount = 1) AND (@SLItem1 = @SLItem2)) OR (@SLCount = 1 AND @DetailCount = 0)
begin
	select @SLItem = SLItem, @UM = UM, @Units = CurUnits, @UnitCost = CurUnitCost, @Amount = CurCost, @Phase = Phase, @CostType = JCCType 
	from dbo.SLIT 
	where JCCo = @pmco 
		and Job = @project 
		and SL = @sl 
		AND dbo.vfIsEqual(Phase, ISNULL(@phase, Phase)) & 
		dbo.vfIsEqual(JCCType, ISNULL(@costtype, JCCType)) = 1
end
else if @DetailCount = 1 and @SLCount = 0
begin
	select @SLItem = SLItem, @UM = UM, @Units = Units, @UnitCost = UnitCost, @Amount = Amount, @Phase = Phase, @CostType = CostType 
	from dbo.PMSL 
	where PMCo = @pmco 
		and Project = @project 
		and SL = @sl 
		AND dbo.vfIsEqual(Phase, ISNULL(@phase, Phase)) & 
		dbo.vfIsEqual(CostType, ISNULL(@costtype, CostType)) = 1
end
-- Make sure we return at least 1 as our SLItem
if @SLItem is null
	set @SLItem = @nextslitem



bspexit:
	return @rcode
GO
PRINT N'Refreshing [dbo].[INMU]'
GO
EXEC sp_refreshview N'[dbo].[INMU]'
GO
PRINT N'Refreshing [dbo].[JCPD]'
GO
EXEC sp_refreshview N'[dbo].[JCPD]'
GO
PRINT N'Refreshing [dbo].[HRCL]'
GO
EXEC sp_refreshview N'[dbo].[HRCL]'
GO
PRINT N'Refreshing [dbo].[HRAL]'
GO
EXEC sp_refreshview N'[dbo].[HRAL]'
GO
PRINT N'Refreshing [dbo].[HRAI]'
GO
EXEC sp_refreshview N'[dbo].[HRAI]'
GO
PRINT N'Refreshing [dbo].[HRAD]'
GO
EXEC sp_refreshview N'[dbo].[HRAD]'
GO
PRINT N'Refreshing [dbo].[HRAC]'
GO
EXEC sp_refreshview N'[dbo].[HRAC]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployeeMiscItemAmounts]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployeeMiscItemAmounts]'
GO
PRINT N'Refreshing [dbo].[PMTL]'
GO
EXEC sp_refreshview N'[dbo].[PMTL]'
GO
PRINT N'Refreshing [dbo].[PMTC]'
GO
EXEC sp_refreshview N'[dbo].[PMTC]'
GO
PRINT N'Refreshing [dbo].[PMSM]'
GO
EXEC sp_refreshview N'[dbo].[PMSM]'
GO
PRINT N'Refreshing [dbo].[PMRelateRecord]'
GO
EXEC sp_refreshview N'[dbo].[PMRelateRecord]'
GO
PRINT N'Refreshing [dbo].[PMRI]'
GO
EXEC sp_refreshview N'[dbo].[PMRI]'
GO
PRINT N'Refreshing [dbo].[PMRD]'
GO
EXEC sp_refreshview N'[dbo].[PMRD]'
GO
PRINT N'Refreshing [dbo].[PMOH]'
GO
EXEC sp_refreshview N'[dbo].[PMOH]'
GO
PRINT N'Refreshing [dbo].[PMOD]'
GO
EXEC sp_refreshview N'[dbo].[PMOD]'
GO
PRINT N'Refreshing [dbo].[PMOC]'
GO
EXEC sp_refreshview N'[dbo].[PMOC]'
GO
PRINT N'Refreshing [dbo].[PMDistribution]'
GO
EXEC sp_refreshview N'[dbo].[PMDistribution]'
GO
PRINT N'Refreshing [dbo].[PMCD]'
GO
EXEC sp_refreshview N'[dbo].[PMCD]'
GO
PRINT N'Refreshing [dbo].[EMDS]'
GO
EXEC sp_refreshview N'[dbo].[EMDS]'
GO
PRINT N'Refreshing [dbo].[GLAcctNoCompany]'
GO
EXEC sp_refreshview N'[dbo].[GLAcctNoCompany]'
GO
PRINT N'Refreshing [dbo].[JBCO]'
GO
EXEC sp_refreshview N'[dbo].[JBCO]'
GO
PRINT N'Refreshing [dbo].[POCT]'
GO
EXEC sp_refreshview N'[dbo].[POCT]'
GO
PRINT N'Refreshing [dbo].[HQCP]'
GO
EXEC sp_refreshview N'[dbo].[HQCP]'
GO
PRINT N'Refreshing [dbo].[APVC]'
GO
EXEC sp_refreshview N'[dbo].[APVC]'
GO
PRINT N'Refreshing [dbo].[APTL]'
GO
EXEC sp_refreshview N'[dbo].[APTL]'
GO
PRINT N'Refreshing [dbo].[vrvAPCompCode]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPCompCode]'
GO
PRINT N'Refreshing [dbo].[PMOPTotalsOnly]'
GO
EXEC sp_refreshview N'[dbo].[PMOPTotalsOnly]'
GO
PRINT N'Refreshing [dbo].[DDCI]'
GO
EXEC sp_refreshview N'[dbo].[DDCI]'
GO
PRINT N'Refreshing [dbo].[JBIL]'
GO
EXEC sp_refreshview N'[dbo].[JBIL]'
GO
PRINT N'Refreshing [dbo].[HRDP]'
GO
EXEC sp_refreshview N'[dbo].[HRDP]'
GO
PRINT N'Refreshing [dbo].[HRBL]'
GO
EXEC sp_refreshview N'[dbo].[HRBL]'
GO
PRINT N'Refreshing [dbo].[HRBE]'
GO
EXEC sp_refreshview N'[dbo].[HRBE]'
GO
PRINT N'Refreshing [dbo].[SMCallType]'
GO
EXEC sp_refreshview N'[dbo].[SMCallType]'
GO
PRINT N'Refreshing [dbo].[EMMR]'
GO
EXEC sp_refreshview N'[dbo].[EMMR]'
GO
PRINT N'Refreshing [dbo].[EMBF]'
GO
EXEC sp_refreshview N'[dbo].[EMBF]'
GO
PRINT N'Refreshing [dbo].[MSSurchargeGroups]'
GO
EXEC sp_refreshview N'[dbo].[MSSurchargeGroups]'
GO
PRINT N'Refreshing [dbo].[APWH]'
GO
EXEC sp_refreshview N'[dbo].[APWH]'
GO
PRINT N'Refreshing [dbo].[HQMU]'
GO
EXEC sp_refreshview N'[dbo].[HQMU]'
GO
PRINT N'Refreshing [dbo].[SLCTGrid]'
GO
EXEC sp_refreshview N'[dbo].[SLCTGrid]'
GO
PRINT N'Refreshing [dbo].[CMAC]'
GO
EXEC sp_refreshview N'[dbo].[CMAC]'
GO
PRINT N'Refreshing [dbo].[PMPD]'
GO
EXEC sp_refreshview N'[dbo].[PMPD]'
GO
PRINT N'Refreshing [dbo].[JCIP]'
GO
EXEC sp_refreshview N'[dbo].[JCIP]'
GO
PRINT N'Refreshing [dbo].[JCCP]'
GO
EXEC sp_refreshview N'[dbo].[JCCP]'
GO
PRINT N'Refreshing [dbo].[APTD]'
GO
EXEC sp_refreshview N'[dbo].[APTD]'
GO
PRINT N'Refreshing [dbo].[brvJCWIPCashFlow]'
GO
EXEC sp_refreshview N'[dbo].[brvJCWIPCashFlow]'
GO
PRINT N'Refreshing [dbo].[VPCanvasSettingsTemplate]'
GO
EXEC sp_refreshview N'[dbo].[VPCanvasSettingsTemplate]'
GO
PRINT N'Altering [dbo].[vspSMGLDistributionPost]'
GO
-- =============================================
-- Author:		Jacob Van Houten
-- Create date: 4/28/11
-- Description:	This the GL Distribution posting which is currently used by the EM,IN and Misc GL
--				batch postings.
--	Changes:	6/7/13 TFS-52075 JVH Fixed the issue of having misc work completed show up as needing to be processed after wip transfer
-- =============================================
ALTER PROCEDURE [dbo].[vspSMGLDistributionPost]
	@SMCo bCompany, @BatchMth bMonth, @BatchId bBatchID, @PostDate bDate, @msg varchar(255) OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @GLLvl varchar(50), @GLCo bCompany, @GLTrans bTrans, @GLRef bGLRef, @GLSumDesc varchar(60),
		@SMGLDistributionID bigint, @SMWorkCompletedID bigint, @IsMiscellaneousLineType bit, @CostOrRevenue char(1), @IsAccountTransfer bit,
		@SMGLEntryID bigint, @SMGLDetailTransactionID bigint, @ReversingSMGLEntryID bigint, @GLEntryID bigint, @GLEntryIDToDelete bigint

	SELECT @GLLvl = GLLvl, @GLSumDesc = dbo.vfToString(GLSumDesc)
	FROM dbo.vSMCO
	WHERE SMCo = @SMCo

	IF @GLLvl IS NULL
	BEGIN
		SET @msg = 'GL Interface level may not be null'
		RETURN 1
	END
	
	IF @GLLvl IN ('Detail', 'Summary')
		AND EXISTS(SELECT 1 FROM dbo.vSMGLDistribution INNER JOIN dbo.vSMGLEntry ON vSMGLDistribution.SMGLEntryID = vSMGLEntry.SMGLEntryID OR vSMGLDistribution.ReversingSMGLEntryID = vSMGLEntry.SMGLEntryID WHERE vSMGLDistribution.SMCo = @SMCo AND vSMGLDistribution.BatchMonth = @BatchMth AND vSMGLDistribution.BatchId = @BatchId AND vSMGLEntry.Journal IS NULL)
	BEGIN
		SET @msg = 'GL Journal must be set for all gl entries when posting in detail or summary'
		RETURN 1
	END
	
	--Set GL Reference using Batch Id - right justified 10 chars
    SET @GLRef = SPACE(10 - LEN(@BatchId)) + CAST(@BatchId AS varchar)

	DECLARE @SMGLEntriesToDelete TABLE (SMGLEntryID bigint)
	
	DECLARE @SummarizedGLDistributions TABLE (GLCo bCompany, GLAccount bGLAcct, Journal bJrnl, ActDate bDate, [Description] bTransDesc, Amount bDollar, GLTrans bTrans NULL)
	
	BEGIN TRAN
		IF @GLLvl = 'Summary'
		BEGIN
			--Add all the distributions that must be posted in detail according to the gl account
			INSERT @SummarizedGLDistributions
			SELECT vSMGLDetailTransaction.GLCo, vSMGLDetailTransaction.GLAccount, vSMGLEntry.Journal, vSMGLDetailTransaction.ActDate, vSMGLDetailTransaction.[Description], vSMGLDetailTransaction.Amount, NULL AS GLTrans
			FROM dbo.vSMGLDistribution
				INNER JOIN dbo.vSMGLEntry ON vSMGLDistribution.SMGLEntryID = vSMGLEntry.SMGLEntryID OR vSMGLDistribution.ReversingSMGLEntryID = vSMGLEntry.SMGLEntryID
				INNER JOIN dbo.vSMGLDetailTransaction ON vSMGLEntry.SMGLEntryID = vSMGLDetailTransaction.SMGLEntryID
				INNER JOIN dbo.GLAC ON vSMGLDetailTransaction.GLCo = GLAC.GLCo AND vSMGLDetailTransaction.GLAccount = GLAC.GLAcct
			WHERE vSMGLDistribution.SMCo = @SMCo AND vSMGLDistribution.BatchMonth = @BatchMth AND vSMGLDistribution.BatchId = @BatchId AND GLAC.InterfaceDetail = 'Y'

			--Any distributions that don't have to post in detail are now summed up
			INSERT @SummarizedGLDistributions
			SELECT vSMGLDetailTransaction.GLCo, vSMGLDetailTransaction.GLAccount, vSMGLEntry.Journal, @PostDate, @GLSumDesc, SUM(vSMGLDetailTransaction.Amount), NULL AS GLTrans
			FROM dbo.vSMGLDistribution
				INNER JOIN dbo.vSMGLEntry ON vSMGLDistribution.SMGLEntryID = vSMGLEntry.SMGLEntryID OR vSMGLDistribution.ReversingSMGLEntryID = vSMGLEntry.SMGLEntryID
				INNER JOIN dbo.vSMGLDetailTransaction ON vSMGLEntry.SMGLEntryID = vSMGLDetailTransaction.SMGLEntryID
				LEFT JOIN dbo.GLAC ON vSMGLDetailTransaction.GLCo = GLAC.GLCo AND vSMGLDetailTransaction.GLAccount = GLAC.GLAcct
			WHERE vSMGLDistribution.SMCo = @SMCo AND vSMGLDistribution.BatchMonth = @BatchMth AND vSMGLDistribution.BatchId = @BatchId AND ISNULL(GLAC.InterfaceDetail, 'N') <> 'Y'
			GROUP BY vSMGLDetailTransaction.GLCo, vSMGLDetailTransaction.GLAccount, vSMGLEntry.Journal
		END
		
		WorkCompletedUpdate:
		BEGIN
			SELECT TOP 1 @SMGLDistributionID = SMGLDistributionID, @SMWorkCompletedID = SMWorkCompletedID, @CostOrRevenue = CostOrRevenue, @IsAccountTransfer = IsAccountTransfer, @SMGLEntryID = SMGLEntryID, @SMGLDetailTransactionID = SMGLDetailTransactionID, @ReversingSMGLEntryID = ReversingSMGLEntryID
			FROM dbo.vSMGLDistribution
			WHERE SMCo = @SMCo AND BatchMonth = @BatchMth AND BatchId = @BatchId
			IF @@rowcount = 1
			BEGIN
				IF @GLLvl = 'Detail'
				BEGIN
					DELETE @SummarizedGLDistributions
				
					--Add all the distributions that must be posted in detail according to the gl account
					INSERT @SummarizedGLDistributions
					SELECT GLCo, GLAccount, Journal, ActDate, [Description], Amount, NULL AS GLTrans
					FROM dbo.vSMGLDistribution
						INNER JOIN dbo.vSMGLEntry ON vSMGLDistribution.SMGLEntryID = vSMGLEntry.SMGLEntryID OR vSMGLDistribution.ReversingSMGLEntryID = vSMGLEntry.SMGLEntryID
						INNER JOIN dbo.vSMGLDetailTransaction ON vSMGLEntry.SMGLEntryID = vSMGLDetailTransaction.SMGLEntryID
					WHERE vSMGLDistribution.SMGLDistributionID = @SMGLDistributionID
				END
				
				--If we are processing records in detail we will need to update the records being pushed to GLDT
				--every time we loop. If we are posting in summary the first time we go through the loop
				--we will update all the records with a GLTrans. Every time after that we loop we will have already
				--updated the GLTrans and therefore won't need to update them.
				UpdateGLTrans:
				BEGIN
					SELECT TOP 1 @GLCo = GLCo
					FROM @SummarizedGLDistributions
					WHERE GLTrans IS NULL
					IF @@rowcount = 1
					BEGIN
						EXEC @GLTrans = dbo.bspHQTCNextTrans @tablename = 'bGLDT', @co = @GLCo, @mth = @BatchMth, @errmsg = @msg OUTPUT
 						
						IF @GLTrans = 0
						BEGIN
							GOTO RollbackErrorFound
						END

						UPDATE TOP (1) @SummarizedGLDistributions
						SET GLTrans = @GLTrans
						WHERE GLCo = @GLCo AND GLTrans IS NULL
						
						GOTO UpdateGLTrans
					END
				END

				DELETE @SMGLEntriesToDelete
				
				--Capture all the GLEntries that we need to delete after doing updates.
				INSERT @SMGLEntriesToDelete
				SELECT GLEntryIDs.GLEntryID
				FROM dbo.vSMWorkCompletedGL
					CROSS APPLY	(
						SELECT CASE @CostOrRevenue WHEN 'C' THEN CostGLDetailTransactionEntryID WHEN 'R' THEN RevenueGLDetailTransactionEntryID END AS GLDetailTransactionEntryID,
							CASE @CostOrRevenue WHEN 'C' THEN CostGLEntryID WHEN 'R' THEN RevenueGLEntryID END AS GLEntryID) CostOrRevenueGLEntryIDs
					CROSS APPLY (
						SELECT GLEntryID
						WHERE @IsAccountTransfer = 0
						UNION ALL
						SELECT GLDetailTransactionEntryID
						WHERE @IsAccountTransfer = 0 OR GLDetailTransactionEntryID <> GLEntryID
						UNION ALL
						SELECT @ReversingSMGLEntryID AS GLEntryID) GLEntryIDs
				WHERE SMWorkCompletedID = @SMWorkCompletedID
			
				IF @CostOrRevenue = 'C'
				BEGIN
					--Account transfer only update the column that points to where the cost now lives.
					IF @IsAccountTransfer = 0
					BEGIN
						UPDATE dbo.vSMWorkCompletedGL
						SET CostGLEntryID = @SMGLEntryID, CostGLDetailTransactionEntryID = @SMGLEntryID, CostGLDetailTransactionID = @SMGLDetailTransactionID
						WHERE SMWorkCompletedID = @SMWorkCompletedID
					END
					ELSE
					BEGIN
						UPDATE dbo.vSMWorkCompletedGL
						SET CostGLDetailTransactionEntryID = @SMGLEntryID, CostGLDetailTransactionID = @SMGLDetailTransactionID
						WHERE SMWorkCompletedID = @SMWorkCompletedID

						--HACK To make sure misc work completed doesn't show up as needing to be reprocessed the date is updated
						--with the work completed date. This also causes the gl for future adjustments to the work completed
						--to use the correct date(the work completed date).
						UPDATE vSMGLDetailTransaction
						SET ActDate = (SELECT [Date] FROM dbo.vSMWorkCompletedDetail WHERE SMWorkCompletedID = @SMWorkCompletedID AND IsSession = 0)
						WHERE SMGLDetailTransactionID = @SMGLDetailTransactionID
					END
				END
				
				IF @CostOrRevenue = 'R'
				BEGIN
					--Account transfer only update the column that points to where the revenue now lives.
					IF @IsAccountTransfer = 0
					BEGIN
						UPDATE dbo.vSMWorkCompletedGL
						SET RevenueGLEntryID = @SMGLEntryID, RevenueGLDetailTransactionEntryID = @SMGLEntryID, RevenueGLDetailTransactionID = @SMGLDetailTransactionID
						WHERE SMWorkCompletedID = @SMWorkCompletedID
					END
					ELSE
					BEGIN
						UPDATE dbo.vSMWorkCompletedGL
						SET RevenueGLDetailTransactionEntryID = @SMGLEntryID, RevenueGLDetailTransactionID = @SMGLDetailTransactionID
						WHERE SMWorkCompletedID = @SMWorkCompletedID
						
						--JC Revenue is using the GLEntries from the vSMWorkCompleted record so it needs to be updated.
						EXEC @GLEntryID = dbo.vspGLCreateEntry @Source = 'SM WIP', @TransactionsShouldBalance =  1, @msg = @msg OUTPUT

						IF @GLEntryID = -1 GOTO RollbackErrorFound

						INSERT dbo.vGLEntryTransaction (GLEntryID, GLTransaction, GLCo, GLAccount, Amount, ActDate, [Description])
						SELECT @GLEntryID, 1, GLCo, GLAccount, Amount, ActDate, [Description]
						FROM vSMGLDetailTransaction
						WHERE SMGLDetailTransactionID = @SMGLDetailTransactionID
						UNION ALL
						SELECT @GLEntryID, ROW_NUMBER() OVER(ORDER BY SMGLDetailTransactionID) + 1, GLCo, GLAccount, Amount, ActDate, [Description]
						FROM vSMGLDetailTransaction
						WHERE SMGLEntryID = @SMGLEntryID AND SMGLDetailTransactionID <> @SMGLDetailTransactionID

						INSERT dbo.vSMWorkCompletedGLEntry (GLEntryID, GLTransactionForSMDerivedAccount, SMWorkCompletedID)
						VALUES (@GLEntryID, 1, @SMWorkCompletedID)
						
						UPDATE dbo.vSMWorkCompleted
						SET @GLEntryIDToDelete = RevenueSMWIPGLEntryID, RevenueSMWIPGLEntryID = @GLEntryID
						WHERE SMWorkCompletedID = @SMWorkCompletedID
						
						DELETE dbo.vGLEntry
						WHERE GLEntryID = @GLEntryIDToDelete
					END
				END
				
				DELETE dbo.vSMGLDistribution
				WHERE SMGLDistributionID = @SMGLDistributionID
				
				DELETE dbo.vSMGLEntry
				WHERE SMGLEntryID IN (SELECT SMGLEntryID FROM @SMGLEntriesToDelete)
				
				--Get rid of the work completed's GL entry if the entry is no longer pointing
				--to any gl entries or gl details since it is no longer needed.
				DELETE dbo.vSMWorkCompletedGL
				WHERE SMWorkCompletedID = @SMWorkCompletedID
					AND 1 = (dbo.vfEqualsNull(CostGLEntryID) & dbo.vfEqualsNull(CostGLDetailTransactionEntryID) & dbo.vfEqualsNull(CostGLDetailTransactionID) &
						dbo.vfEqualsNull(RevenueGLEntryID) & dbo.vfEqualsNull(RevenueGLDetailTransactionEntryID) & dbo.vfEqualsNull(RevenueGLDetailTransactionID))

				IF @GLLvl = 'Detail'
				BEGIN
					INSERT dbo.bGLDT (GLCo, Mth, GLTrans, GLAcct, Jrnl, GLRef, SourceCo, Source, ActDate, DatePosted,
						[Description], BatchId, Amount, RevStatus, Adjust, InUseBatchId, Purge)
					SELECT GLCo, @BatchMth, GLTrans, GLAccount, Journal, @GLRef, @SMCo, 'SM WO', ActDate, @PostDate,
						[Description], @BatchId, Amount, 0, 'N', NULL, 'N'
					FROM @SummarizedGLDistributions
--With detail records we want to commit the transaction each time we are done processing a distribution record
--That way we can process as much of a batch as possible and then if we bomb out we pick up from where we left off.
/*TRAN COMMIT*/		COMMIT TRAN
/*TRAN BEGIN*/		BEGIN TRAN
				END

				GOTO WorkCompletedUpdate
			END
		END
		
		IF @GLLvl = 'Summary'
		BEGIN
			INSERT dbo.bGLDT (GLCo, Mth, GLTrans, GLAcct, Jrnl, GLRef, SourceCo, Source, ActDate, DatePosted,
				[Description], BatchId, Amount, RevStatus, Adjust, InUseBatchId, Purge)
			SELECT GLCo, @BatchMth, GLTrans, GLAccount, Journal, @GLRef, @SMCo, 'SM WO', ActDate, @PostDate,
				[Description], @BatchId, Amount, 0, 'N', NULL, 'N'
			FROM @SummarizedGLDistributions
		END
	
	COMMIT TRAN
	
	RETURN 0

RollbackErrorFound:
	--If an error is found then we need to properly handle the rollback
	--The assumption is if the transaction count = 1 then we are not in a nested
	--transaction and we can safely rollback. However, if the transaction count is greater than 1
	--then we are in a nested transaction and we need to make sure that the transaction count
	--when we entered the stored procedure matches the transaction count when we leave the stored procedure.
	--Then by returning 1 the rollback can be done from whatever sql executed this stored procedure.
	IF @@trancount = 1 ROLLBACK TRAN ELSE COMMIT TRAN
	RETURN 1
END
GO
PRINT N'Refreshing [dbo].[PRAUEmployees]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployees]'
GO
PRINT N'Refreshing [dbo].[PCReferences]'
GO
EXEC sp_refreshview N'[dbo].[PCReferences]'
GO
PRINT N'Refreshing [dbo].[GLAJ]'
GO
EXEC sp_refreshview N'[dbo].[GLAJ]'
GO
PRINT N'Refreshing [dbo].[JBIT]'
GO
EXEC sp_refreshview N'[dbo].[JBIT]'
GO
PRINT N'Refreshing [dbo].[APTB]'
GO
EXEC sp_refreshview N'[dbo].[APTB]'
GO
PRINT N'Refreshing [dbo].[APPH]'
GO
EXEC sp_refreshview N'[dbo].[APPH]'
GO
PRINT N'Refreshing [dbo].[APPD]'
GO
EXEC sp_refreshview N'[dbo].[APPD]'
GO
PRINT N'Refreshing [dbo].[APPB]'
GO
EXEC sp_refreshview N'[dbo].[APPB]'
GO
PRINT N'Refreshing [dbo].[vrvAPEFTRemReprint]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPEFTRemReprint]'
GO
PRINT N'Refreshing [dbo].[SLITPM]'
GO
EXEC sp_refreshview N'[dbo].[SLITPM]'
GO
PRINT N'Refreshing [dbo].[POITPM]'
GO
EXEC sp_refreshview N'[dbo].[POITPM]'
GO
PRINT N'Refreshing [dbo].[POHDPM]'
GO
EXEC sp_refreshview N'[dbo].[POHDPM]'
GO
PRINT N'Refreshing [dbo].[DDSI]'
GO
EXEC sp_refreshview N'[dbo].[DDSI]'
GO
PRINT N'Refreshing [dbo].[JBJE]'
GO
EXEC sp_refreshview N'[dbo].[JBJE]'
GO
PRINT N'Refreshing [dbo].[JBBE]'
GO
EXEC sp_refreshview N'[dbo].[JBBE]'
GO
PRINT N'Refreshing [dbo].[APUI]'
GO
EXEC sp_refreshview N'[dbo].[APUI]'
GO
PRINT N'Refreshing [dbo].[MSSurchargeOverrides]'
GO
EXEC sp_refreshview N'[dbo].[MSSurchargeOverrides]'
GO
PRINT N'Refreshing [dbo].[PMSCO_DetailLine_Total]'
GO
EXEC sp_refreshview N'[dbo].[PMSCO_DetailLine_Total]'
GO
PRINT N'Refreshing [dbo].[DDUI]'
GO
EXEC sp_refreshview N'[dbo].[DDUI]'
GO
PRINT N'Refreshing [dbo].[DDFI]'
GO
EXEC sp_refreshview N'[dbo].[DDFI]'
GO
PRINT N'Refreshing [dbo].[APWHReleaseHoldCode]'
GO
EXEC sp_refreshview N'[dbo].[APWHReleaseHoldCode]'
GO
PRINT N'Refreshing [dbo].[SLEntryTotal]'
GO
EXEC sp_refreshview N'[dbo].[SLEntryTotal]'
GO
PRINT N'Refreshing [dbo].[CMCO]'
GO
EXEC sp_refreshview N'[dbo].[CMCO]'
GO
PRINT N'Refreshing [dbo].[PRSI]'
GO
EXEC sp_refreshview N'[dbo].[PRSI]'
GO
PRINT N'Refreshing [dbo].[PRFI]'
GO
EXEC sp_refreshview N'[dbo].[PRFI]'
GO
PRINT N'Refreshing [dbo].[PREA]'
GO
EXEC sp_refreshview N'[dbo].[PREA]'
GO
PRINT N'Refreshing [dbo].[JCCDBartlett]'
GO
EXEC sp_refreshview N'[dbo].[JCCDBartlett]'
GO
PRINT N'Refreshing [dbo].[RPRP]'
GO
EXEC sp_refreshview N'[dbo].[RPRP]'
GO
PRINT N'Refreshing [dbo].[RPPLShared]'
GO
EXEC sp_refreshview N'[dbo].[RPPLShared]'
GO
PRINT N'Refreshing [dbo].[DDFLShared]'
GO
EXEC sp_refreshview N'[dbo].[DDFLShared]'
GO
PRINT N'Refreshing [dbo].[DDFL]'
GO
EXEC sp_refreshview N'[dbo].[DDFL]'
GO
PRINT N'Refreshing [dbo].[DDFIShared]'
GO
EXEC sp_refreshview N'[dbo].[DDFIShared]'
GO
PRINT N'Refreshing [dbo].[DDDT]'
GO
EXEC sp_refreshview N'[dbo].[DDDT]'
GO
PRINT N'Refreshing [dbo].[brvLookupUsage]'
GO
EXEC sp_refreshview N'[dbo].[brvLookupUsage]'
GO
PRINT N'Refreshing [dbo].[VPGridQueries]'
GO
EXEC sp_refreshview N'[dbo].[VPGridQueries]'
GO
PRINT N'Refreshing [dbo].[DDFH]'
GO
EXEC sp_refreshview N'[dbo].[DDFH]'
GO
PRINT N'Altering [dbo].[vspSMWorkCompletedLaborCreate]'
GO

ALTER PROCEDURE [dbo].[vspSMWorkCompletedLaborCreate]   
-- =============================================
-- Author:		Eric Vaterlaus
-- Create date: 01/20/2011
-- Description:	Create SMWorkCompleted record for labor from Payrol time entry.
-- Modifications: 01/27/11 Eric V  Modified to only create a single SMWorkCompleted recoord.
--			      03/12/11 Mark H  Added SMGLCo output param to vspSMWorkCompletedScopeVal
--                03/16/11 Eric V  Added Craft, Class and Shift.
--                04/14/11 Eric V  Added @IsTrackingWIP to Work Completed
--                05/04/11 Eric V  Modified for one unique WorkCompleted for all types.
--                07/18/11 Eric V  Added Craft and Class to input parameters for call to vspSMLaborRateGet.
--                07/22/11 Eric V  Set Provisional flag if validation fails.
--                07/27/11 Eric V  Change WIPAccount to CostWIPAccount and added RevenueWIPAccount.
--                08/23/11 Eric V  Added @SMCostType parameter.
--				  01/25/12 Mark H  Added @JCCostType parameter - B-07899
--				  02/09/2012 - JG - TK-12388 - Added @SMJCCostType and @SMPhaseGroup
--				  03/06/2012 - JG - TK-13074 - Added use of the CostingMethod from the Work Order.
--				5/29/12 JeremiahB - Fixed defaulting of Tax fields for Job related work completed.
--				9/4/12 JeremiahB - Defaulted Tax Type based on DefaultCountry
--				4/23/13	JVH - TFS-48034 Fixed setting the cost rate for actual cost job work orders
-- =============================================
 @SMCo bCompany, @WorkOrder int, @Scope int, @PayType varchar(10), @SMCostType smallint=null, @Date smalldatetime, @Technician varchar(15), @Hours bHrs,   
 @WorkCompleted int, @SMJCCostType dbo.bJCCType = NULL, @SMPhaseGroup dbo.bGroup = NULL,
 @SMWorkCompletedID int = NULL OUTPUT,   
 @TCPRCo bCompany=NULL, @TCPRGroup bGroup=NULL, @TCPREndDate smalldatetime=NULL, @TCPREmployee bEmployee=NULL,  
 @TCPRPaySeq tinyint=NULL, @TCPRPostSeq smallint=NULL, @TCPRPostDate smalldatetime=NULL, @Craft bCraft=NULL,  
 @Class bClass=NULL, @Shift tinyint=NULL, @msg varchar(255) = NULL OUTPUT  
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @TaxGroup bGroup, @TaxBasic bDollar, @GLCo bCompany, @CostAccount bGLAcct, @RevenueAccount bGLAcct, @RevenueWIPAccount bGLAcct,
			@CostWIPAccount bGLAcct, @CostRate numeric(16,5), @PriceRate numeric(16,5), @NextSeq int, 
			@TaxCode varchar(10), @LineType int, @TaxType int, @DefaultTaxType int, @TaxRate bRate,
			@ServiceSite varchar(20), @rcode int, @PRCo bCompany, @SMGLCo bCompany,
			@Provisional BIT, @Agreement varchar(15), @Revision int, 
			@Coverage char(1), @Job bJob, @TaxBasis bDollar
			
			
	SET @LineType = 2

	/* Get the GL Account Number */
	EXEC @rcode = vspSMCoVal @SMCo=@SMCo, @GLCo=@GLCo OUTPUT, @PRCo=@PRCo OUTPUT, @TaxGroup=@TaxGroup OUTPUT, @msg=@msg OUTPUT
	IF (@rcode = 1)
	BEGIN
		goto error			
	END
	
	/* Validate Workorder Scope and get Scope related defaults */
	EXEC @rcode = vspSMWorkCompletedScopeVal @SMCo=@SMCo, @WorkOrder=@WorkOrder, @Scope=@Scope, @WorkCompleted=@WorkCompleted,
		@LineType=@LineType, @AllowProvisional='Y', @SMCostType=@SMCostType, @DefaultCostAcct=@CostAccount OUTPUT, 
		@SMGLCo=@SMGLCo OUTPUT, @DefaultRevenueAcct=@RevenueAccount OUTPUT,
		@DefaultCostWIPAcct=@CostWIPAccount OUTPUT, @DefaultRevWIPAcct=@RevenueWIPAccount OUTPUT,
		@DefaultTaxType = @DefaultTaxType OUTPUT, @DefaultTaxCode=@TaxCode OUTPUT, 
		@ServiceSite=@ServiceSite OUTPUT, @Provisional=@Provisional OUTPUT, 
		@Agreement=@Agreement OUTPUT, @Revision=@Revision OUTPUT, @Coverage=@Coverage OUTPUT, @Job = @Job OUTPUT, 
		@msg=@msg OUTPUT
	IF (@rcode=1)
	BEGIN
		GOTO error
	END
	
	-- Clear out Tax related fields if this is related to a Job
	IF (@Job IS NOT NULL)
	BEGIN
		SELECT @TaxGroup = NULL, @TaxCode = NULL, @TaxType = NULL, @TaxRate = NULL
	END
	
	IF (@TaxCode IS NOT NULL)
	BEGIN
		-- Set Default Tax Type depending on Default Country
		SELECT @TaxType = @DefaultTaxType

		/* Get the Tax Rate */
		EXEC @rcode = vspHQTaxCodeVal @taxgroup=@TaxGroup, @taxcode=@TaxCode, @compdate=@Date, @taxtype=@TaxType, @taxrate=@TaxRate OUTPUT, @msg=@msg OUTPUT
		IF (@rcode = 1)
		BEGIN
			goto error
		END
	END
	
	/* Get CostRate and PriceRate */
	EXEC @rcode = vspSMLaborRateGet @SMCo=@SMCo, @Technician=@Technician, @PayType=@PayType, @LaborCostRate=@CostRate OUTPUT, @JCCostType = null, @msg=@msg OUTPUT
	IF (@rcode = 1)
	BEGIN
		goto error
	END

	-- Determine the Labor Price Rate
	IF EXISTS
	(
		SELECT 1
		FROM dbo.SMWorkOrder
		WHERE SMCo = @SMCo AND WorkOrder = @WorkOrder AND Job IS NOT NULL AND CostingMethod = 'Cost'
	)
	BEGIN
		SELECT @PriceRate = @CostRate
	END
	ELSE
	BEGIN
		SELECT @PriceRate = Rate FROM dbo.vfSMRateLabor(@SMCo, @WorkOrder, @Scope, @Date, @Agreement, @Revision, @Coverage, @TCPRCo, @PayType, @Craft, @Class, @Technician)
	END	
	
	-- Determine Tax Basis
	SELECT @TaxBasis = CASE WHEN @Job IS NOT NULL THEN NULL ELSE @PriceRate * @Hours END
	
	/* Insert records in SMWorkCompleted */
	BEGIN TRY

		INSERT SMWorkCompleted (Type, SMCo, WorkOrder, WorkCompleted, Scope, Date, TaxType, TaxGroup,
			TaxCode, TaxBasis, TaxAmount, GLCo, CostAccount, RevenueAccount, CostWIPAccount, RevenueWIPAccount, 
			Technician, CostQuantity, CostRate, ProjCost, PriceQuantity, PriceRate, PriceTotal, PayType, Craft, 
			Class, Shift, ServiceSite, NoCharge, CostCo, PRCo, PRGroup, PREndDate, PREmployee, PRPaySeq, PRPostSeq, 
			PRPostDate, Provisional, SMCostType, JCCostType, PhaseGroup, Agreement, Revision, Coverage)
		VALUES
			(@LineType, @SMCo, @WorkOrder, @WorkCompleted, @Scope, @Date, @TaxType, @TaxGroup, @TaxCode,
			@TaxBasis, @TaxRate*@PriceRate*@Hours, @SMGLCo, @CostAccount, @RevenueAccount, @CostWIPAccount, @RevenueWIPAccount,
			@Technician, @Hours, @CostRate, @CostRate*@Hours, @Hours, @PriceRate, @PriceRate*@Hours, @PayType, @Craft, @Class, @Shift,
			@ServiceSite, 'N', @TCPRCo, @TCPRCo, @TCPRGroup, @TCPREndDate, @TCPREmployee, @TCPRPaySeq, @TCPRPostSeq, 
			@TCPRPostDate, @Provisional, @SMCostType, @SMJCCostType, @SMPhaseGroup, @Agreement, @Revision, @Coverage)
			
		SELECT @SMWorkCompletedID=SMWorkCompletedID FROM SMWorkCompleted WHERE SMCo=@SMCo AND WorkOrder=@WorkOrder AND Scope=@Scope
			AND Type=@LineType AND WorkCompleted=@WorkCompleted
	END TRY
	
	BEGIN CATCH
		SET @msg = 'vspSMWorkCompletedLaborCreate: ' + ERROR_MESSAGE()
		GOTO error
	END CATCH

   return 0
   error:
   	select @msg = isnull(@msg,'') + ' - cannot insert SM WorkCompletedLabor!'
   	return 1
	
END
GO
PRINT N'Refreshing [dbo].[WFProcessDetailApprover]'
GO
EXEC sp_refreshview N'[dbo].[WFProcessDetailApprover]'
GO
PRINT N'Refreshing [dbo].[SLWI]'
GO
EXEC sp_refreshview N'[dbo].[SLWI]'
GO
PRINT N'Refreshing [dbo].[SLWH]'
GO
EXEC sp_refreshview N'[dbo].[SLWH]'
GO
PRINT N'Refreshing [dbo].[APHB]'
GO
EXEC sp_refreshview N'[dbo].[APHB]'
GO
PRINT N'Refreshing [dbo].[APCO]'
GO
EXEC sp_refreshview N'[dbo].[APCO]'
GO
PRINT N'Refreshing [dbo].[HRWI]'
GO
EXEC sp_refreshview N'[dbo].[HRWI]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployer]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployer]'
GO
PRINT N'Refreshing [dbo].[GLAS]'
GO
EXEC sp_refreshview N'[dbo].[GLAS]'
GO
PRINT N'Refreshing [dbo].[APTH]'
GO
EXEC sp_refreshview N'[dbo].[APTH]'
GO
PRINT N'Refreshing [dbo].[vrvAPOnCostInvoices]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPOnCostInvoices]'
GO
PRINT N'Refreshing [dbo].[DDDTSecurable]'
GO
EXEC sp_refreshview N'[dbo].[DDDTSecurable]'
GO
PRINT N'Refreshing [dbo].[PMPA]'
GO
EXEC sp_refreshview N'[dbo].[PMPA]'
GO
PRINT N'Refreshing [dbo].[PRTM]'
GO
EXEC sp_refreshview N'[dbo].[PRTM]'
GO
PRINT N'Refreshing [dbo].[DMAttachmentTypes]'
GO
EXEC sp_refreshview N'[dbo].[DMAttachmentTypes]'
GO
PRINT N'Refreshing [dbo].[DMAttachmentTypesShared]'
GO
EXEC sp_refreshview N'[dbo].[DMAttachmentTypesShared]'
GO
PRINT N'Refreshing [dbo].[DDSL]'
GO
EXEC sp_refreshview N'[dbo].[DDSL]'
GO
PRINT N'Refreshing [dbo].[HRBI]'
GO
EXEC sp_refreshview N'[dbo].[HRBI]'
GO
PRINT N'Refreshing [dbo].[SMDivision]'
GO
EXEC sp_refreshview N'[dbo].[SMDivision]'
GO
PRINT N'Refreshing [dbo].[MSSurcharges]'
GO
EXEC sp_refreshview N'[dbo].[MSSurcharges]'
GO
PRINT N'Refreshing [dbo].[PMEH]'
GO
EXEC sp_refreshview N'[dbo].[PMEH]'
GO
PRINT N'Refreshing [dbo].[PMSLItemLookup]'
GO
EXEC sp_refreshview N'[dbo].[PMSLItemLookup]'
GO
PRINT N'Refreshing [dbo].[SLHB]'
GO
EXEC sp_refreshview N'[dbo].[SLHB]'
GO
PRINT N'Refreshing [dbo].[MSTD]'
GO
EXEC sp_refreshview N'[dbo].[MSTD]'
GO
PRINT N'Refreshing [dbo].[MSID]'
GO
EXEC sp_refreshview N'[dbo].[MSID]'
GO
PRINT N'Refreshing [dbo].[brvMSInvTotal]'
GO
EXEC sp_refreshview N'[dbo].[brvMSInvTotal]'
GO
PRINT N'Refreshing [dbo].[PRW2MiscDetail]'
GO
EXEC sp_refreshview N'[dbo].[PRW2MiscDetail]'
GO
PRINT N'Refreshing [dbo].[APPC]'
GO
EXEC sp_refreshview N'[dbo].[APPC]'
GO
PRINT N'Refreshing [dbo].[SMInvoice]'
GO
EXEC sp_refreshview N'[dbo].[SMInvoice]'
GO
PRINT N'Altering [dbo].[vspSMWorkCompletedLaborUpdate]'
GO

ALTER PROCEDURE [dbo].[vspSMWorkCompletedLaborUpdate] 
-- =============================================
-- Author:		Eric Vaterlaus
-- Create date: 01/25/2011
-- Description:	Update the SMWorkCompletedLabor record with changes
-- Modification: 03/14/2011 EricV - Modified to get GLCo with GL Accounts
--               03/15/2011 EricV - Added Craft, Class and Shift
--               04/14/2011 EricV - Added @IsTrackingWIP to Work Completed
--               07/18/2011 EricV - Added Craft and Class to input parameters for call to vspSMLaborRateGet.
--               07/27/2011 EricV - Change WIPAccount to CostWIPAccount and added RevenueWIPAccount.
--               08/23/2011 EricV - Added SMCostType parameter.
--				 01/25/2012 MarkH - Added @JCCostType parameter - B-07899
--				 02/09/2012 JG - TK-12388 - Added SMJCCostType and SMPhaseGroup.
--				 03/06/2012 JG - TK-13074 - Added use of the CostingMethod from the Work Order.  
--				5/29/12 JeremiahB - Fixed defaulting of Tax fields for Job related work completed.
--				9/4/12 JeremiahB - Defaulted Tax Type based on DefaultCountry
--				4/23/13	JVH - TFS-48034 Fixed setting the cost rate for actual cost job work orders
-- =============================================
	@SMCo bCompany, @WorkOrder int, @Scope int, @PayType varchar(10), @SMCostType smallint=null, @Technician varchar(15), @UpdateFromPRTB bit=NULL,
	@Date smalldatetime, @Hours bHrs, @SMWorkCompletedID bigint, @IsBilled bit=NULL, @Craft bCraft=NULL, @Class bClass=NULL, @Shift tinyint=NULL,
	@TCPRCo bCompany = null, @TCPRGroup bGroup = null, @TCPREndDate smalldatetime = null, @TCPREmployee bEmployee = null,
	@TCPRPaySeq int = null, @TCPRPostSeq int = null, @TCPRPostDate smalldatetime = null,
	@SMJCCostType dbo.bJCCType=NULL, @SMPhaseGroup dbo.bGroup=NULL,
	@msg varchar(255) OUTPUT  
	
AS
BEGIN
	SET NOCOUNT ON;
	/* Flag to print debug statements */
	DECLARE @PrintDebug bit
	Set @PrintDebug=0
		
	DECLARE @rcode int, @TaxGroup bGroup, @TaxBasic bDollar, @GLCo bCompany, @CostAccount bGLAcct,
			@RevenueAccount bGLAcct, @CostWIPAccount bGLAcct, @RevenueWIPAccount bGLAcct, @CostRate numeric(16,5), @PriceRate numeric(16,5), 
			@TaxCode varchar(10), @LineType int, @TaxType int, @DefaultTaxType int, @TaxRate bRate, @ServiceSite varchar(20), 
			@SMGLCo bCompany, @WorkCompleted INT, @Agreement varchar(15),
			@Revision int,	@Coverage varchar(1), @Job bJob, @TaxBasis bDollar
	
	SELECT @LineType = 2
		
	/* Get the GL Account Number */
	exec @rcode = vspSMCoVal @SMCo=@SMCo, @GLCo=@GLCo OUTPUT, @TaxGroup=@TaxGroup OUTPUT, @msg = @msg OUTPUT
	IF (@rcode = 1)
		BEGIN
			goto error
		END
	
	/* Validate the Work Order Scope */
	exec @rcode = vspSMWorkOrderScopeVal @MustExist='Y',@SMCo=@SMCo, @WorkOrder=@WorkOrder, @Scope=@Scope,
		@msg = @msg OUTPUT
	IF (@rcode = 1)
		BEGIN
			goto error
		END
		
	/* Get the Billed status if it is not already set */
	IF (@IsBilled IS NULL)
	BEGIN
		IF EXISTS(SELECT 1 FROM SMWorkCompleted
				LEFT JOIN SMInvoice 
					ON SMInvoice.SMCo=SMWorkCompleted.SMCo 
					AND SMInvoice.SMInvoiceID=SMWorkCompleted.SMInvoiceID
				WHERE NOT SMInvoice.SMInvoiceID IS NULL
					AND SMWorkCompleted.SMWorkCompletedID=@SMWorkCompletedID)
			SET @IsBilled = 1
		ELSE
			SET @IsBilled = 0		
	END
	/* Get Scope related defaults */
	SELECT @WorkCompleted=WorkCompleted,
		@Agreement = @Agreement, @Revision = @Revision, @Coverage = @Coverage 
		FROM SMWorkCompleted WHERE SMWorkCompletedID=@SMWorkCompletedID
	
	exec @rcode = vspSMWorkCompletedScopeVal @SMCo=@SMCo, @WorkOrder=@WorkOrder, @Scope=@Scope,
		@WorkCompleted=@WorkCompleted, @SMCostType=@SMCostType, @AllowProvisional = 'Y',
		@LineType=@LineType, @DefaultCostAcct=@CostAccount OUTPUT, @msg = @msg OUTPUT, 
		@DefaultRevenueAcct=@RevenueAccount OUTPUT, @DefaultCostWIPAcct=@CostWIPAccount OUTPUT,
		@DefaultRevWIPAcct=@RevenueWIPAccount OUTPUT, 
		@DefaultTaxType = @DefaultTaxType OUTPUT, @DefaultTaxCode=@TaxCode OUTPUT, 
		@ServiceSite=@ServiceSite OUTPUT, @SMGLCo=@SMGLCo OUTPUT, @Job = @Job OUTPUT
	/* We don't want to prevent entry of Timesheet so ignore error */
	
	IF (@IsBilled=0)
	BEGIN
		-- Clear out Tax related fields if this is related to a Job
		IF (@Job IS NOT NULL)
		BEGIN
			SELECT @TaxGroup = NULL, @TaxCode = NULL, @TaxType = NULL, @TaxRate = NULL
		END
		
		-- Determine Tax Code if this is not related to a Job
		IF (@TaxCode IS NOT NULL)
		BEGIN
			-- Set Default Tax Type depending on Default Country
			SELECT @TaxType = @DefaultTaxType	
			
			/* Get the Tax Rate */
			exec @rcode = vspHQTaxCodeVal @taxgroup=@TaxGroup, @taxcode=@TaxCode, @compdate=@Date, @taxtype=@TaxType, @taxrate=@TaxRate OUTPUT, @msg = @msg OUTPUT
			IF (@rcode = 1)
			BEGIN
				goto error
			END
		END
	END
	
	/* Get CostRate and PriceRate */
	exec @rcode = vspSMLaborRateGet @SMCo=@SMCo, @Technician=@Technician, @PayType=@PayType, @LaborCostRate=@CostRate OUTPUT, @JCCostType = null, @msg = @msg OUTPUT
	/* We don't want to prevent entry of Timesheet so ignore error */

	-- Determine the Labor Price Rate
	IF EXISTS
	(
		SELECT 1
		FROM dbo.SMWorkOrder
		WHERE SMCo = @SMCo AND WorkOrder = @WorkOrder AND Job IS NOT NULL AND CostingMethod = 'Cost'
	)
	BEGIN
		SELECT @PriceRate = @CostRate
	END
	ELSE
	BEGIN
		SELECT @PriceRate = Rate FROM dbo.vfSMRateLabor(@SMCo, @WorkOrder, @Scope, @Date, @Agreement, @Revision, @Coverage, @TCPRCo, @PayType, @Craft, @Class, @Technician)
	END
	
	-- Determine Tax Basis
	SELECT @TaxBasis = CASE WHEN @Job IS NOT NULL THEN NULL ELSE @PriceRate * @Hours END		

	/* Update SMWorkCompleted with the new value for hours */
	--SELECT @SMWorkCompletedID=SMWorkCompletedID FROM SMWorkCompleted WHERE SMCo=@SMCo AND WorkOrder=@WorkOrder AND WorkCompleted=@WorkCompleted AND Type=2
	IF (@IsBilled=0)
	BEGIN
IF (@PrintDebug=1) PRINT 'vspSMWorkCompletedLaborUpdate 1: Update SMWorkCompleted - IsBilled=0'
		UPDATE SMWorkCompleted SET Scope=@Scope, Technician=@Technician, TaxBasis=@TaxBasis, TaxType=@TaxType, TaxGroup=@TaxGroup, 
			TaxCode=@TaxCode, TaxAmount=@TaxRate*@PriceRate*@Hours, CostQuantity=@Hours, CostRate=@CostRate, ProjCost=@CostRate*@Hours, 
			PriceQuantity=@Hours, PriceRate=@PriceRate, PriceTotal=@PriceRate*@Hours, Date=@Date, PayType=@PayType, SMCostType=@SMCostType,
			GLCo=@SMGLCo, CostAccount=@CostAccount, RevenueAccount=@RevenueAccount, CostWIPAccount=@CostWIPAccount, 
			RevenueWIPAccount=@RevenueWIPAccount, Craft=@Craft, Class=@Class, Shift=@Shift,
			CostCo=@TCPRCo, PRCo=@TCPRCo, PRGroup=@TCPRGroup, PREndDate=@TCPREndDate, PREmployee=@TCPREmployee,
			PRPaySeq=@TCPRPaySeq, PRPostSeq=@TCPRPostSeq, PRPostDate=@TCPRPostDate
			, JCCostType=@SMJCCostType, PhaseGroup=@SMPhaseGroup
		WHERE SMWorkCompletedID = @SMWorkCompletedID
	END
	ELSE
	BEGIN
		/* Since the work completed record has already been billed the PriceQuantity, PriceRate, PriceTotal, 
		 TaxBasis, TaxType, TaxGroup, TaxCode and RevenueAccount cannot be changed. 
		 The vSMWorkCompletedLabor and vSMWorkCompletedDetail are updated directly so that any changes are
		 made to both the original record and the invoice session record. */
IF (@PrintDebug=1) PRINT 'vspSMWorkCompletedLaborUpdate 2: Update SMWorkCompleted - IsBilled=1'
IF (@PrintDebug=1) PRINT '  SMWorkCompletedID='+CONVERT(varchar, @SMWorkCompletedID)
		UPDATE vSMWorkCompletedDetail
			SET Technician=@Technician, GLCo=@SMGLCo, CostAccount=@CostAccount, CostWIPAccount=@CostWIPAccount, RevenueWIPAccount=@RevenueWIPAccount, Scope=@Scope
			WHERE SMWorkCompletedID = @SMWorkCompletedID
				
		UPDATE vSMWorkCompletedLabor
			SET CostQuantity=@Hours, CostRate=@CostRate, ProjCost=@CostRate*@Hours, PayType=@PayType,
			Craft=@Craft, Class=@Class, Shift=@Shift, SMCostType=@SMCostType,
			PRGroup=@TCPRGroup, PREndDate=@TCPREndDate, PREmployee=@TCPREmployee, 
			PRPaySeq=@TCPRPaySeq, PRPostSeq=@TCPRPostSeq, PRPostDate=@TCPRPostDate, Scope=@Scope, Date=@Date
			, JCCostType=@SMJCCostType, PhaseGroup=@SMPhaseGroup
			WHERE SMWorkCompletedID = @SMWorkCompletedID
		
		UPDATE vSMWorkCompleted
			SET CostCo=@TCPRCo, PRGroup=@TCPRGroup, PREndDate=@TCPREndDate, PREmployee=@TCPREmployee,
			PRPaySeq=@TCPRPaySeq, PRPostSeq=@TCPRPostSeq, PRPostDate=@TCPRPostDate
			WHERE SMWorkCompletedID = @SMWorkCompletedID
				
	END
   return
   error:
   	select @msg = isnull(@msg,'') + ' - cannot update SMWorkCompleted!'
   	RAISERROR(@msg, 11, -1);
   	rollback transaction
END
GO
PRINT N'Refreshing [dbo].[HRHPGrid]'
GO
EXEC sp_refreshview N'[dbo].[HRHPGrid]'
GO
PRINT N'Refreshing [dbo].[HRSH]'
GO
EXEC sp_refreshview N'[dbo].[HRSH]'
GO
PRINT N'Refreshing [dbo].[HREB]'
GO
EXEC sp_refreshview N'[dbo].[HREB]'
GO
PRINT N'Refreshing [dbo].[HRBB]'
GO
EXEC sp_refreshview N'[dbo].[HRBB]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerATOItems]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerATOItems]'
GO
PRINT N'Refreshing [dbo].[PMUT]'
GO
EXEC sp_refreshview N'[dbo].[PMUT]'
GO
PRINT N'Refreshing [dbo].[GLBC]'
GO
EXEC sp_refreshview N'[dbo].[GLBC]'
GO
PRINT N'Refreshing [dbo].[vrvAPOnCostReconciliation]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPOnCostReconciliation]'
GO
PRINT N'Refreshing [dbo].[GLBD]'
GO
EXEC sp_refreshview N'[dbo].[GLBD]'
GO
PRINT N'Refreshing [dbo].[PMPAPct]'
GO
EXEC sp_refreshview N'[dbo].[PMPAPct]'
GO
PRINT N'Refreshing [dbo].[PRCS]'
GO
EXEC sp_refreshview N'[dbo].[PRCS]'
GO
PRINT N'Refreshing [dbo].[PRPS]'
GO
EXEC sp_refreshview N'[dbo].[PRPS]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedWorkCompletedBatch]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedWorkCompletedBatch]'
GO
PRINT N'Refreshing [dbo].[EMDR]'
GO
EXEC sp_refreshview N'[dbo].[EMDR]'
GO
PRINT N'Refreshing [dbo].[SMEMUsageBatch]'
GO
EXEC sp_refreshview N'[dbo].[SMEMUsageBatch]'
GO
PRINT N'Refreshing [dbo].[MSTB]'
GO
EXEC sp_refreshview N'[dbo].[MSTB]'
GO
PRINT N'Refreshing [dbo].[PMSLSubCoLookup]'
GO
EXEC sp_refreshview N'[dbo].[PMSLSubCoLookup]'
GO
PRINT N'Refreshing [dbo].[VPGridQueryParameters]'
GO
EXEC sp_refreshview N'[dbo].[VPGridQueryParameters]'
GO
PRINT N'Refreshing [dbo].[vrvPRPAYGEmployeeMiscItems]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPAYGEmployeeMiscItems]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerMaster]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerMaster]'
GO
PRINT N'Refreshing [dbo].[JCCHPM]'
GO
EXEC sp_refreshview N'[dbo].[JCCHPM]'
GO
PRINT N'Refreshing [dbo].[brvMSNumericTicket]'
GO
EXEC sp_refreshview N'[dbo].[brvMSNumericTicket]'
GO
PRINT N'Refreshing [dbo].[JCJMPM]'
GO
EXEC sp_refreshview N'[dbo].[JCJMPM]'
GO
PRINT N'Refreshing [dbo].[PMUX]'
GO
EXEC sp_refreshview N'[dbo].[PMUX]'
GO
PRINT N'Refreshing [dbo].[PRW2MiscHeader]'
GO
EXEC sp_refreshview N'[dbo].[PRW2MiscHeader]'
GO
PRINT N'Refreshing [dbo].[DDTables]'
GO
EXEC sp_refreshview N'[dbo].[DDTables]'
GO
PRINT N'Altering [dbo].[vspVACompanyCopyWizardGetParentTables]'
GO

ALTER PROCEDURE [dbo].[vspVACompanyCopyWizardGetParentTables]  
/***********************************************************  
* CREATED BY: Saurabh 04/12/2012  
* MODIFIED BY: Tom J  02/07/2013 - Had to rework the query as it was extremely slow
*              Tom J  04/30/2012 - This was still not doing what we expected. Removed the parameter so the
*                                  Inclusion of dependent tables won't be something we try to conquer in
*                                  The SQL statements. It will return all dependent tables that care about ordering
*                                  And in code we can reorganize as necessary.
* Usage:  
* Used by Company Copy Wizard to get the order of tables to copy, so FK constraints are satisfied  
*  
* Input params:  
* @tablesToCheck   comma delimited list of table names to check for FK constraints  
* @addDependents  flag to include dependent tables
* 
* Output params: none, data table  
*  
*****************************************************/  
(  
	@tablesToCheck VARCHAR(MAX)
)  
AS  
BEGIN  
	SET NOCOUNT ON;  
	DECLARE @tables TABLE  
	(  
	  TableName VARCHAR(128) NULL  
	);  
	   
	INSERT INTO @tables SELECT Names FROM dbo.vfTableFromArray(@tablesToCheck);  

	DECLARE @keys TABLE  
	(
	  KeyName sysname,
	  SourceObjectName sysname, 
	  ReferencedName sysname, 
	  SourceObjectId int,
	  ReferencedId int
	);  

	INSERT INTO @keys SELECT DISTINCT k.name AS KeyName
									, OBJECT_NAME(k.parent_object_id) AS SourceObjectName
									, OBJECT_NAME(k.referenced_object_id) AS ReferencedName
									, k.parent_object_id As SourceObjectId
									, k.referenced_object_id AS ReferencedId 
	   FROM sys.foreign_keys k
	--   JOIN sys.foreign_key_columns kc ON k.object_id = kc.constraint_object_id
	  WHERE OBJECT_NAME(k.parent_object_id) NOT LIKE 'p%' AND OBJECT_NAME(k.referenced_object_id) NOT LIKE 'p%' 
	   
	BEGIN  
	WITH ParentReferences  
	AS  
	(  
		select f.SourceObjectId
			 , f.SourceObjectName
			 , f.ReferencedId
			 , f.ReferencedName
			 , f.KeyName as ForeignKey
			 , f.KeyName as SourceKey
			 , 1 as [Level]
			 , cast('.' + f.KeyName + '.' as varchar(max)) as ReferenceKeyPath
			 , 0 as cycle
		  FROM @keys as f
	INNER JOIN @tables ON f.SourceObjectName = [@tables].TableName 
	UNION ALL  
	   --Recursive member  
		SELECT f.SourceObjectId
			 , f.SourceObjectName
			 , f.ReferencedId 
			 , f.ReferencedName
			 , f.KeyName
			 , ParentReferences.SourceKey
			 , ParentReferences.[Level] + 1 as [Level]
			 , cast(ParentReferences.ReferenceKeyPath + cast(f.KeyName + '.' as varchar(max)) as varchar(max)) as ReferenceKeyPath
			 , case when ParentReferences.ReferenceKeyPath like '%.' + cast(f.KeyName as varchar(max)) + '.%' then 1 else 0 end as cycle
		  FROM ParentReferences   
	INNER JOIN @keys f 
			ON ParentReferences.ReferencedId = f.SourceObjectId
		   AND ParentReferences.cycle = 0
	)  

		select ReferencedName, max([Level]) 
		  from ParentReferences
	INNER JOIN DDTables ON ReferencedName = DDTables.TableName AND CopyTable='Y'  
	  group by ReferencedName
	  order by max([Level]) desc
	END
END	 

GO
PRINT N'Refreshing [dbo].[HRMN]'
GO
EXEC sp_refreshview N'[dbo].[HRMN]'
GO
PRINT N'Refreshing [dbo].[WFProcessDetailForPMMF]'
GO
EXEC sp_refreshview N'[dbo].[WFProcessDetailForPMMF]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerBAS]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerBAS]'
GO
PRINT N'Refreshing [dbo].[PMWS]'
GO
EXEC sp_refreshview N'[dbo].[PMWS]'
GO
PRINT N'Refreshing [dbo].[PMWP]'
GO
EXEC sp_refreshview N'[dbo].[PMWP]'
GO
PRINT N'Refreshing [dbo].[PMWM]'
GO
EXEC sp_refreshview N'[dbo].[PMWM]'
GO
PRINT N'Refreshing [dbo].[PMWI]'
GO
EXEC sp_refreshview N'[dbo].[PMWI]'
GO
PRINT N'Refreshing [dbo].[PMWH]'
GO
EXEC sp_refreshview N'[dbo].[PMWH]'
GO
PRINT N'Refreshing [dbo].[PMWD]'
GO
EXEC sp_refreshview N'[dbo].[PMWD]'
GO
PRINT N'Refreshing [dbo].[PCStates]'
GO
EXEC sp_refreshview N'[dbo].[PCStates]'
GO
PRINT N'Refreshing [dbo].[vrvAPPBaus]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPPBaus]'
GO
PRINT N'Refreshing [dbo].[SMWorkOrderPOHD]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrderPOHD]'
GO
PRINT N'Refreshing [dbo].[SMWorkOrderPOHB]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrderPOHB]'
GO
PRINT N'Refreshing [dbo].[POIB]'
GO
EXEC sp_refreshview N'[dbo].[POIB]'
GO
PRINT N'Refreshing [dbo].[POHB]'
GO
EXEC sp_refreshview N'[dbo].[POHB]'
GO
PRINT N'Refreshing [dbo].[SMPurchaseOrderList]'
GO
EXEC sp_refreshview N'[dbo].[SMPurchaseOrderList]'
GO
PRINT N'Refreshing [dbo].[PMPC]'
GO
EXEC sp_refreshview N'[dbo].[PMPC]'
GO
PRINT N'Refreshing [dbo].[DDSLDatatypes]'
GO
EXEC sp_refreshview N'[dbo].[DDSLDatatypes]'
GO
PRINT N'Refreshing [dbo].[SMTrip]'
GO
EXEC sp_refreshview N'[dbo].[SMTrip]'
GO
PRINT N'Refreshing [dbo].[SMWorkOrderStatus]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrderStatus]'
GO
PRINT N'Refreshing [dbo].[EMCX]'
GO
EXEC sp_refreshview N'[dbo].[EMCX]'
GO
PRINT N'Refreshing [dbo].[EMCT]'
GO
EXEC sp_refreshview N'[dbo].[EMCT]'
GO
PRINT N'Refreshing [dbo].[PRLI]'
GO
EXEC sp_refreshview N'[dbo].[PRLI]'
GO
PRINT N'Refreshing [dbo].[JCDM]'
GO
EXEC sp_refreshview N'[dbo].[JCDM]'
GO
PRINT N'Refreshing [dbo].[HQST]'
GO
EXEC sp_refreshview N'[dbo].[HQST]'
GO
PRINT N'Refreshing [dbo].[HQGP]'
GO
EXEC sp_refreshview N'[dbo].[HQGP]'
GO
PRINT N'Refreshing [dbo].[EMWI]'
GO
EXEC sp_refreshview N'[dbo].[EMWI]'
GO
PRINT N'Refreshing [dbo].[EMWH]'
GO
EXEC sp_refreshview N'[dbo].[EMWH]'
GO
PRINT N'Refreshing [dbo].[EMTY]'
GO
EXEC sp_refreshview N'[dbo].[EMTY]'
GO
PRINT N'Refreshing [dbo].[EMCC]'
GO
EXEC sp_refreshview N'[dbo].[EMCC]'
GO
PRINT N'Refreshing [dbo].[EMCM]'
GO
EXEC sp_refreshview N'[dbo].[EMCM]'
GO
PRINT N'Refreshing [dbo].[EMRR]'
GO
EXEC sp_refreshview N'[dbo].[EMRR]'
GO
PRINT N'Refreshing [dbo].[EMDP]'
GO
EXEC sp_refreshview N'[dbo].[EMDP]'
GO
PRINT N'Refreshing [dbo].[MSTBGrid]'
GO
EXEC sp_refreshview N'[dbo].[MSTBGrid]'
GO
PRINT N'Refreshing [dbo].[POCB]'
GO
EXEC sp_refreshview N'[dbo].[POCB]'
GO
PRINT N'Refreshing [dbo].[POCBGrid]'
GO
EXEC sp_refreshview N'[dbo].[POCBGrid]'
GO
PRINT N'Refreshing [dbo].[CMST]'
GO
EXEC sp_refreshview N'[dbo].[CMST]'
GO
PRINT N'Refreshing [dbo].[PRED]'
GO
EXEC sp_refreshview N'[dbo].[PRED]'
GO
PRINT N'Refreshing [dbo].[JCCHSinglePhase]'
GO
EXEC sp_refreshview N'[dbo].[JCCHSinglePhase]'
GO
PRINT N'Refreshing [dbo].[MSZD]'
GO
EXEC sp_refreshview N'[dbo].[MSZD]'
GO
PRINT N'Refreshing [dbo].[MSQH]'
GO
EXEC sp_refreshview N'[dbo].[MSQH]'
GO
PRINT N'Refreshing [dbo].[MSQD]'
GO
EXEC sp_refreshview N'[dbo].[MSQD]'
GO
PRINT N'Refreshing [dbo].[MSPX]'
GO
EXEC sp_refreshview N'[dbo].[MSPX]'
GO
PRINT N'Refreshing [dbo].[MSMD]'
GO
EXEC sp_refreshview N'[dbo].[MSMD]'
GO
PRINT N'Refreshing [dbo].[MSJP]'
GO
EXEC sp_refreshview N'[dbo].[MSJP]'
GO
PRINT N'Refreshing [dbo].[MSHX]'
GO
EXEC sp_refreshview N'[dbo].[MSHX]'
GO
PRINT N'Refreshing [dbo].[MSHR]'
GO
EXEC sp_refreshview N'[dbo].[MSHR]'
GO
PRINT N'Refreshing [dbo].[MSHO]'
GO
EXEC sp_refreshview N'[dbo].[MSHO]'
GO
PRINT N'Refreshing [dbo].[MSDX]'
GO
EXEC sp_refreshview N'[dbo].[MSDX]'
GO
PRINT N'Refreshing [dbo].[INLG]'
GO
EXEC sp_refreshview N'[dbo].[INLG]'
GO
PRINT N'Refreshing [dbo].[brvMSQuoteDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvMSQuoteDetail]'
GO
PRINT N'Refreshing [dbo].[EMTH]'
GO
EXEC sp_refreshview N'[dbo].[EMTH]'
GO
PRINT N'Refreshing [dbo].[EMTE]'
GO
EXEC sp_refreshview N'[dbo].[EMTE]'
GO
PRINT N'Refreshing [dbo].[EMTC]'
GO
EXEC sp_refreshview N'[dbo].[EMTC]'
GO
PRINT N'Refreshing [dbo].[EMRH]'
GO
EXEC sp_refreshview N'[dbo].[EMRH]'
GO
PRINT N'Refreshing [dbo].[SMAgreementService]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementService]'
GO
PRINT N'Refreshing [dbo].[SMAgreementBillingSchedule]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementBillingSchedule]'
GO
PRINT N'Refreshing [dbo].[SMAgreement]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreement]'
GO
PRINT N'Refreshing [dbo].[PRWA]'
GO
EXEC sp_refreshview N'[dbo].[PRWA]'
GO
PRINT N'Refreshing [dbo].[PRArrears]'
GO
EXEC sp_refreshview N'[dbo].[PRArrears]'
GO
PRINT N'Creating [dbo].[vspPMSLGetNextSLSeq]'
GO

CREATE proc [dbo].[vspPMSLGetNextSLSeq]
/*************************************
* CREATED BY:	AW 03/13/2013 Make generating the next SL Number its own process pulled from bspPMSLInitialize
*			SL's are generated based on PMCO either (P)Project/Seq or (V)Project/Vendor based on PMSL values
*
* LAST MODIFIED:
*
* Pass: @pmco,
*	@project,
*	@vendor,
*	@allowExistingSLsYN  -- Y allows SLs to already exist, N can't exist in SLHD
*
* Output: @formattedsl - Next available SL
*		@msg - error msg if any
*
* returns:
*	0 on Success, 1 on ERROR
*
**************************************/
(@pmco bCompany=null, @project bJob=null, @vendor bVendor=null, @allowExistingSLsYN bYN='N',@formattedsl varchar(30) output,@msg varchar(255) output)
as
set nocount on

declare @rcode int,@slno varchar(1),@sigpartjob bYN, @validpartjob varchar(30),@slcharsproject tinyint,
	@apco bCompany, @slmask varchar(30),@sllength varchar(30),@slstartseq SMALLINT,
	@sigchars smallint,@slcharsvendor tinyint,@slseqlen int,@projectpart bProject, @mseq int,
	@tmpsl varchar(30),@tmpsl1 VARCHAR(30),@tmpseq varchar(30),@i int, @value varchar(1),@tmpseq1 varchar(30),
	@vendorPart varchar(30),@paddedstring varchar(60),@dummy_sl varchar(30),@retcode int

set @rcode = 0
set @msg = ''

if @pmco is null 
	begin
	select @msg = 'Missing PMCo!', @rcode = 1
	goto bspexit
	end

if @project is null 
	begin
	select @msg = 'Missing Project!', @rcode = 1
	goto bspexit
	end

if @vendor is null
	begin
	select @msg = 'Missing Vendor required!', @rcode = 1
	goto bspexit
	end

------ get HQ/PM company info
select @apco=p.APCo, @slno=p.SLNo, @sigpartjob=p.SigPartJob, @sigchars= p.SigCharsSL,
          @slcharsproject=p.SLCharsProject, @slcharsvendor=p.SLCharsVendor, @slseqlen=p.SLSeqLen,
          @slstartseq=p.SLStartSeq
from dbo.bHQCO h with (nolock) join dbo.bPMCO p with (nolock) on h.HQCo=p.APCo where p.PMCo=@pmco
------ check significant characters of job, if null or zero then not valid.
if @sigchars is null or @sigchars = 0 select @sigpartjob = 'N'

------ get input mask for bSL
select @slmask=InputMask, @sllength = convert(varchar(30), InputLength) 
from DDDTShared with (nolock) where Datatype = 'bSL'
if isnull(@slmask,'') = '' select @slmask = 'L'
if isnull(@sllength,'') = '' select @sllength = '10'
if @slmask in ('R','L')
   	begin
   	select @slmask = @sllength + @slmask + 'N'
   	end

------ set valid part job
if @sigpartjob = 'Y'
       begin
       if @sigchars > len(@project) select @sigchars = len(@project)
       select @validpartjob = substring(@project,1,@sigchars)
       end
else
       begin
       select @validpartjob = @project, @sigchars = len(@project)
       end

------ get rid of leading spaces
select @projectpart = substring(ltrim(@project),1,@slcharsproject)
select @mseq = 0

------ need to reset @slcharsproject to project part without any leading spaces
select @slcharsproject = datalength(ltrim(@projectpart))

------ if we are building the subcontract by seq, then we need to retreive the last seq
------ used to build the last subcontract number, then add one to it
select @tmpsl = null, @tmpsl1 = null
if @slno='P'
	begin
	if exists(select 1 from bPMSL WITH (NOLOCK) where SLCo=@apco and PMCo=@pmco
				and substring(Project,1,@sigchars)=@validpartjob and SL is not null) 
			or
		exists(select 1 from bSLHD with (nolock) where SLCo=@apco and JCCo=@pmco
				and substring(Job,1,@sigchars)=@validpartjob)
		begin
		------ max from PMSL
		select @tmpsl = max(SL) from bPMSL WITH (NOLOCK)
		where SLCo=@apco and PMCo=@pmco and substring(Project,1,@sigchars)=@validpartjob
		and SL is not null and substring(SL,1,len(@projectpart)) = @projectpart
		and datalength(rtrim(SL)) = len(@projectpart) + @slseqlen
		------ max from SLHD
		select @tmpsl1 = max(SL) from bSLHD WITH (NOLOCK)
		where SLCo=@apco and JCCo=@pmco and substring(Job,1,@sigchars)=@validpartjob
		and substring(SL,1,len(@projectpart)) = @projectpart
		and datalength(rtrim(SL)) = len(@projectpart) + @slseqlen
		------ now use highest to get next sequence
		if isnull(@tmpsl,'') <> '' and isnull(@tmpsl1,'') = '' select @tmpsl1 = @tmpsl
		if isnull(@tmpsl1,'') <> '' and isnull(@tmpsl,'') = '' select @tmpsl = @tmpsl1
		if @tmpsl1 > @tmpsl select @tmpsl = @tmpsl1
		------ now parse out the seq part by using company definitions
		select @tmpseq = substring(reverse(rtrim(@tmpsl)),1, @slseqlen), @i = 1, @tmpseq1 = ''
		while @i <= len(@tmpseq)
			begin
			select @value = substring(@tmpseq,@i,1)
			if @value not in ('0','1','2','3','4','5','6','7','8','9')
				select @i = len(@tmpseq)
			else
				select @tmpseq1 = @tmpseq1 + @value
					
			select @i = @i + 1
			end
		------ check if numeric
		if isnumeric(@tmpseq1) = 1 select @mseq = convert(int,reverse(@tmpseq1)+1)
		end
	else
		begin
		---- no subcontracts exist for project so use the @slstartseq if there is one
		if @slstartseq is not null select @mseq = @slstartseq
		end
	end

------ convert Vendor based on Co parameters
select @vendorPart = reverse(substring(reverse('0000000000000000000' + ltrim(str(@vendor))),1,@slcharsvendor))
------ need to pad the seq with leading zeros to the amount specified in company file @slseqlen
select @paddedstring = reverse(substring(reverse('0000000000000000000' + ltrim(str(@mseq))),1,@slseqlen))
select @formattedsl = null

if @allowExistingSLsYN = 'Y'
	begin
	if @slno = 'P'
		begin
		select @formattedsl = max(SL) from SLHD with (nolock) 
		where SLCo=@apco and JCCo=@pmco and Vendor=@vendor and substring(Job,1,@sigchars)=@validpartjob and Status in (0,3)
		if @@rowcount = 0 select @formattedsl = null
		end

	if @slno = 'V'
		begin
		select @formattedsl = max(SL) from SLHD with (nolock) 
		where SLCo=@apco and JCCo=@pmco and Vendor=@vendor and substring(Job,1,@sigchars)=@validpartjob
		if @@rowcount = 0 select @formattedsl = null
		end
	end
if @formattedsl is null
	begin
	if @slno = 'V'
   		begin
   		set @dummy_sl = ltrim(rtrim(@projectpart)) + @vendorPart
   		exec @retcode = dbo.bspHQFormatMultiPart @dummy_sl, @slmask, @formattedsl output
   		end
	else
   		begin
   		set @dummy_sl = ltrim(rtrim(@projectpart)) + @paddedstring
   		exec @retcode = dbo.bspHQFormatMultiPart @dummy_sl, @slmask, @formattedsl output
   		end
	end

if @allowExistingSLsYN = 'N' and exists(select 1 from SLHD where SLCo=@apco and JCCo=@pmco and SL=@formattedsl)
	begin
	select @msg = 'Default SL ' + rtrim(dbo.vfToString(@formattedsl)) + ' already exists.', @formattedsl = '', @rcode = 1
	goto bspexit
	end
------ check if subcontract already set up under a different job
if exists(select 1 from SLHD with (nolock) where SLCo=@apco and JCCo=@pmco and SL=@formattedsl
           and substring(Job,1,@sigchars)<>@validpartjob)
	begin
	select @msg = 'One or more subcontracts are already set up under a different project.', @formattedsl = '', @rcode = 1
	goto bspexit
	end

------ check if subcontract already setup under a different vendor
if exists(select 1 from SLHD with (nolock) where SLCo=@apco and JCCo=@pmco and SL=@formattedsl and Vendor<>@vendor)
	begin
	select @msg = 'One or more subcontracts are already set up under a different vendor.', @formattedsl = '', @rcode = 1
	goto bspexit
	end

-- exit
bspexit:

	if @rcode <> 0
		begin
		select @msg = isnull(@msg,'')
		end

   	return @rcode
GO
PRINT N'Creating [dbo].[vspPMSLGetNextSLVal]'
GO

CREATE proc [dbo].[vspPMSLGetNextSLVal]
/*************************************
* CREATED BY:	AW 03/13/2013 returns the next available SL number to the form when user requests a new one
*
* LAST MODIFIED:
*
* Pass: @pmco,
*	@project,
*	@vendor,
*   @createSLYN,  - form field for wheather we creating a new SL or not
*	@selectedsl - form field value for the sl
*
* Output: @formattedsl - Next available SL
*		@msg - error msg if any
*
* returns:
*	0 on Success, 1 on ERROR
*
**************************************/
(@pmco bCompany=null, @project bJob=null, @vendor bVendor=null, @createSLYN bYN='N',@selectedsl varchar(30)=null, @formattedsl varchar(30) output,@msg varchar(255) output)
as
set nocount on

declare @rcode int



if @pmco is null 
	begin
	select @msg = 'Missing PMCo!', @rcode = 1
	goto bspexit
	end

if @project is null 
	begin
	select @msg = 'Missing Project!', @rcode = 1
	goto bspexit
	end

-- verify if user entered a new sl if required
if @createSLYN = 'Y' and isnull(@selectedsl,'') <> '' 
 and not exists(select top 1 1 from PMSL l 
	join PMCO p on l.PMCo=p.PMCo where l.PMCo=@pmco and l.Project=@project and l.SLCo=p.APCo and SL=@selectedsl)
	begin
	select @formattedsl = @selectedsl,@rcode = 0
	goto bspexit
	end

-- attempt to calculate a new sl 
if @createSLYN = 'Y'
	begin 
	exec @rcode = dbo.vspPMSLGetNextSLSeq @pmco,@project,@vendor,'N',@formattedsl output,@msg output
	if @rcode = 1 
		begin
		select @formattedsl = '',@msg = @msg +' Please enter new SL.'
		goto bspexit
		end
	end

-- exit
bspexit:

	if @rcode <> 0
		begin
		select @msg = isnull(@msg,'')
		end

   	return @rcode
GO
PRINT N'Refreshing [dbo].[HRPC]'
GO
EXEC sp_refreshview N'[dbo].[HRPC]'
GO
PRINT N'Refreshing [dbo].[ARCM]'
GO
EXEC sp_refreshview N'[dbo].[ARCM]'
GO
PRINT N'Refreshing [dbo].[JCRT]'
GO
EXEC sp_refreshview N'[dbo].[JCRT]'
GO
PRINT N'Refreshing [dbo].[POPendingPurchaseOrderItem]'
GO
EXEC sp_refreshview N'[dbo].[POPendingPurchaseOrderItem]'
GO
PRINT N'Refreshing [dbo].[WFProcessDetailForPO]'
GO
EXEC sp_refreshview N'[dbo].[WFProcessDetailForPO]'
GO
PRINT N'Refreshing [dbo].[DDMO]'
GO
EXEC sp_refreshview N'[dbo].[DDMO]'
GO
PRINT N'Refreshing [dbo].[HQFC]'
GO
EXEC sp_refreshview N'[dbo].[HQFC]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerBASAmounts]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerBASAmounts]'
GO
PRINT N'Refreshing [dbo].[GLBDWithFYEMO]'
GO
EXEC sp_refreshview N'[dbo].[GLBDWithFYEMO]'
GO
PRINT N'Refreshing [dbo].[JBIS]'
GO
EXEC sp_refreshview N'[dbo].[JBIS]'
GO
PRINT N'Refreshing [dbo].[JBIN]'
GO
EXEC sp_refreshview N'[dbo].[JBIN]'
GO
PRINT N'Refreshing [dbo].[JBITProgGrid]'
GO
EXEC sp_refreshview N'[dbo].[JBITProgGrid]'
GO
PRINT N'Refreshing [dbo].[HQAT]'
GO
EXEC sp_refreshview N'[dbo].[HQAT]'
GO
PRINT N'Refreshing [dbo].[vrvAPPmtHistoryDDAttachments]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPPmtHistoryDDAttachments]'
GO
PRINT N'Altering [dbo].[vPMSubmittalPackage]'
GO
ALTER TABLE [dbo].[vPMSubmittalPackage] ALTER COLUMN [SpecSection] [varchar] (20) COLLATE Latin1_General_BIN NULL
GO
PRINT N'Refreshing [dbo].[DDSLSecure]'
GO
EXEC sp_refreshview N'[dbo].[DDSLSecure]'
GO
PRINT N'Refreshing [dbo].[PRTI]'
GO
EXEC sp_refreshview N'[dbo].[PRTI]'
GO
PRINT N'Refreshing [dbo].[PRTF]'
GO
EXEC sp_refreshview N'[dbo].[PRTF]'
GO
PRINT N'Refreshing [dbo].[PRTD]'
GO
EXEC sp_refreshview N'[dbo].[PRTD]'
GO
PRINT N'Refreshing [dbo].[PRTC]'
GO
EXEC sp_refreshview N'[dbo].[PRTC]'
GO
PRINT N'Refreshing [dbo].[PRCI]'
GO
EXEC sp_refreshview N'[dbo].[PRCI]'
GO
PRINT N'Refreshing [dbo].[PRCF]'
GO
EXEC sp_refreshview N'[dbo].[PRCF]'
GO
PRINT N'Refreshing [dbo].[PRCD]'
GO
EXEC sp_refreshview N'[dbo].[PRCD]'
GO
PRINT N'Refreshing [dbo].[PRTR]'
GO
EXEC sp_refreshview N'[dbo].[PRTR]'
GO
PRINT N'Refreshing [dbo].[EMRD]'
GO
EXEC sp_refreshview N'[dbo].[EMRD]'
GO
PRINT N'Refreshing [dbo].[POIBPost]'
GO
EXEC sp_refreshview N'[dbo].[POIBPost]'
GO
PRINT N'Refreshing [dbo].[SMInvoiceSession]'
GO
EXEC sp_refreshview N'[dbo].[SMInvoiceSession]'
GO
PRINT N'Refreshing [dbo].[SMDeliveryGroupInvoice]'
GO
EXEC sp_refreshview N'[dbo].[SMDeliveryGroupInvoice]'
GO
PRINT N'Refreshing [dbo].[SMAgreementBillingScheduleExt]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementBillingScheduleExt]'
GO
PRINT N'Refreshing [dbo].[PCBidPackageScopes]'
GO
EXEC sp_refreshview N'[dbo].[PCBidPackageScopes]'
GO
PRINT N'Refreshing [dbo].[brvMSQuoteForm]'
GO
EXEC sp_refreshview N'[dbo].[brvMSQuoteForm]'
GO
PRINT N'Refreshing [dbo].[PRWC]'
GO
EXEC sp_refreshview N'[dbo].[PRWC]'
GO
PRINT N'Creating [dbo].[vPRAULimitsAndRates]'
GO
CREATE TABLE [dbo].[vPRAULimitsAndRates]
(
[KeyID] [bigint] NOT NULL IDENTITY(1, 1),
[EffectiveDate] [dbo].[bDate] NOT NULL,
[ETPCap] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_ETPCap] DEFAULT ((0)),
[WholeIncomeCap] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_WholeIncomeCap] DEFAULT ((0)),
[RedundancyTaxFreeBasis] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_RedundancyTaxFreeBasis] DEFAULT ((0)),
[RedundancyTaxFreeYears] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_RedundancyTaxFreeYears] DEFAULT ((0)),
[UnderPreservationAgePct] [dbo].[bPct] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_UnderPreservationAgePct] DEFAULT ((0)),
[OverPreservationAgePct] [dbo].[bPct] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_OverPreservationAgePct] DEFAULT ((0)),
[ExcessCapPct] [dbo].[bPct] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_ExcessCapPct] DEFAULT ((0)),
[AnnualLeaveLoadingPct] [dbo].[bPct] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_AnnualLeaveLoadingPct] DEFAULT ((0)),
[LeaveFlatRateLimit] [dbo].[bDollar] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_LeaveFlatRateLimit] DEFAULT ((0)),
[LeaveFlatRatePct] [dbo].[bPct] NOT NULL CONSTRAINT [DF_vPRAULimitsAndRates_LeaveFlatRatePct] DEFAULT ((0)),
[Notes] [dbo].[bNotes] NULL,
[UniqueAttchID] [uniqueidentifier] NULL
) ON [PRIMARY]
GO
PRINT N'Creating index [biPRAULimitsAndRates] on [dbo].[vPRAULimitsAndRates]'
GO
CREATE UNIQUE CLUSTERED INDEX [biPRAULimitsAndRates] ON [dbo].[vPRAULimitsAndRates] ([EffectiveDate]) WITH (FILLFACTOR=90) ON [PRIMARY]
GO
PRINT N'Creating primary key [PK_vPRAULimitsAndRates] on [dbo].[vPRAULimitsAndRates]'
GO
ALTER TABLE [dbo].[vPRAULimitsAndRates] ADD CONSTRAINT [PK_vPRAULimitsAndRates] PRIMARY KEY NONCLUSTERED  ([KeyID]) ON [PRIMARY]
GO
PRINT N'Creating trigger [dbo].[vtPRAULimitsAndRatesd] on [dbo].[vPRAULimitsAndRates]'
GO
CREATE TRIGGER [dbo].[vtPRAULimitsAndRatesd] ON [dbo].[vPRAULimitsAndRates] FOR DELETE AS
/*-----------------------------------------------------------------
* Created:	DAN SO 02/22/2013 - TFS-40968
* Modified:	DAN SO 03/13/2013 - TFS-40968 - removed TaxYear - replaced with EffectiveDate
*
*	Delete trigger for PR Australian Limits And Rates table
*
*	Adds HQ Master Audit entry.
*/----------------------------------------------------------------

SET NOCOUNT ON
 
	/* add HQ Master Audit entry */
	INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
			FieldName, OldValue, NewValue, DateTime, UserName)
	SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(d.EffectiveDate), NULL, 'D', 
			NULL, NULL, NULL, GETDATE(), SUSER_SNAME() 
	  FROM deleted d 
	  
RETURN
GO
PRINT N'Refreshing [dbo].[HRPCRptTo]'
GO
EXEC sp_refreshview N'[dbo].[HRPCRptTo]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerBASGSTTaxCodes]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerBASGSTTaxCodes]'
GO
PRINT N'Refreshing [dbo].[PORB]'
GO
EXEC sp_refreshview N'[dbo].[PORB]'
GO
PRINT N'Refreshing [dbo].[GLBL]'
GO
EXEC sp_refreshview N'[dbo].[GLBL]'
GO
PRINT N'Refreshing [dbo].[vrvAPTLTaxRates]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPTLTaxRates]'
GO
PRINT N'Refreshing [dbo].[GLYB]'
GO
EXEC sp_refreshview N'[dbo].[GLYB]'
GO
PRINT N'Refreshing [dbo].[GLJB]'
GO
EXEC sp_refreshview N'[dbo].[GLJB]'
GO
PRINT N'Refreshing [dbo].[PRCW]'
GO
EXEC sp_refreshview N'[dbo].[PRCW]'
GO
PRINT N'Refreshing [dbo].[PMRQ]'
GO
EXEC sp_refreshview N'[dbo].[PMRQ]'
GO
PRINT N'Refreshing [dbo].[RPFDShared]'
GO
EXEC sp_refreshview N'[dbo].[RPFDShared]'
GO
PRINT N'Refreshing [dbo].[JBTS]'
GO
EXEC sp_refreshview N'[dbo].[JBTS]'
GO
PRINT N'Refreshing [dbo].[MSTDHaulGrid]'
GO
EXEC sp_refreshview N'[dbo].[MSTDHaulGrid]'
GO
PRINT N'Refreshing [dbo].[PRAB]'
GO
EXEC sp_refreshview N'[dbo].[PRAB]'
GO
PRINT N'Refreshing [dbo].[PRABGrid]'
GO
EXEC sp_refreshview N'[dbo].[PRABGrid]'
GO
PRINT N'Refreshing [dbo].[ARBH]'
GO
EXEC sp_refreshview N'[dbo].[ARBH]'
GO
PRINT N'Refreshing [dbo].[SLIB]'
GO
EXEC sp_refreshview N'[dbo].[SLIB]'
GO
PRINT N'Refreshing [dbo].[JCCIGrid]'
GO
EXEC sp_refreshview N'[dbo].[JCCIGrid]'
GO
PRINT N'Refreshing [dbo].[brvMSQuotes]'
GO
EXEC sp_refreshview N'[dbo].[brvMSQuotes]'
GO
PRINT N'Refreshing [dbo].[PRWE]'
GO
EXEC sp_refreshview N'[dbo].[PRWE]'
GO
PRINT N'Creating trigger [dbo].[vtPRAULimitsAndRatesi] on [dbo].[vPRAULimitsAndRates]'
GO
CREATE TRIGGER [dbo].[vtPRAULimitsAndRatesi] ON [dbo].[vPRAULimitsAndRates] FOR INSERT AS
/*-----------------------------------------------------------------
* Created:	DAN SO 02/22/2013 - TFS-40968
* Modified:	DAN SO 03/13/2013 - TFS-40968 - removed TaxYear 
*
*	Insert trigger for PR Australian Limits And Rates table
*
*   Verify TaxYear is in the correct format.
*	Adds HQ Master Audit entry.
*/----------------------------------------------------------------

SET NOCOUNT ON
 
	DECLARE @errmsg VARCHAR(255)
	   	
	--------------------
	-- ADD HQMA ENTRY --
	--------------------
	INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
			FieldName, OldValue, NewValue, DateTime, UserName)
	SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'A', 
			NULL, NULL, NULL, GETDATE(), SUSER_SNAME() 
	  FROM INSERTED i


	RETURN
	
	--------------------
	-- ERROR HANDLING --
	--------------------
	Error:
		SET @errmsg = isnull(@errmsg,'') + ' - cannot insert into vPRAULimitsAndRates.'
		RAISERROR(@errmsg, 11, -1);
		ROLLBACK TRANSACTION

  
RETURN

GO
PRINT N'Refreshing [dbo].[HRPQ]'
GO
EXEC sp_refreshview N'[dbo].[HRPQ]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerETP]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerETP]'
GO
PRINT N'Refreshing [dbo].[PMOA]'
GO
EXEC sp_refreshview N'[dbo].[PMOA]'
GO
PRINT N'Refreshing [dbo].[GLBLWithFYEMO]'
GO
EXEC sp_refreshview N'[dbo].[GLBLWithFYEMO]'
GO
PRINT N'Refreshing [dbo].[vrvAPTLTaxRatesGST]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPTLTaxRatesGST]'
GO
PRINT N'Refreshing [dbo].[PMPCPct]'
GO
EXEC sp_refreshview N'[dbo].[PMPCPct]'
GO
PRINT N'Refreshing [dbo].[PMPF]'
GO
EXEC sp_refreshview N'[dbo].[PMPF]'
GO
PRINT N'Refreshing [dbo].[RPFRShared]'
GO
EXEC sp_refreshview N'[dbo].[RPFRShared]'
GO
PRINT N'Refreshing [dbo].[JBTM]'
GO
EXEC sp_refreshview N'[dbo].[JBTM]'
GO
PRINT N'Refreshing [dbo].[MSTH]'
GO
EXEC sp_refreshview N'[dbo].[MSTH]'
GO
PRINT N'Refreshing [dbo].[PRCAItems]'
GO
EXEC sp_refreshview N'[dbo].[PRCAItems]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployerItems]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployerItems]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployerItemLookup]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployerItemLookup]'
GO
PRINT N'Refreshing [dbo].[SLIBGrid]'
GO
EXEC sp_refreshview N'[dbo].[SLIBGrid]'
GO
PRINT N'Refreshing [dbo].[CMDB]'
GO
EXEC sp_refreshview N'[dbo].[CMDB]'
GO
PRINT N'Refreshing [dbo].[SMAgreementExtended]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementExtended]'
GO
PRINT N'Refreshing [dbo].[JCCINotes]'
GO
EXEC sp_refreshview N'[dbo].[JCCINotes]'
GO
PRINT N'Refreshing [dbo].[brvPMACODetEstProfit]'
GO
EXEC sp_refreshview N'[dbo].[brvPMACODetEstProfit]'
GO
PRINT N'Refreshing [dbo].[PRWH]'
GO
EXEC sp_refreshview N'[dbo].[PRWH]'
GO
PRINT N'Creating trigger [dbo].[vtPRAULimitsAndRatesu] on [dbo].[vPRAULimitsAndRates]'
GO
CREATE TRIGGER [dbo].[vtPRAULimitsAndRatesu] ON [dbo].[vPRAULimitsAndRates] FOR UPDATE AS
/*-----------------------------------------------------------------
* Created:	DAN SO 02/22/2013 - TFS-40968
* Modified:	DAN SO 03/13/2013 - TFS-40968 - removed TaxYear - replaced with EffectiveDate
*			EN 3/26/2013 - Story 39859 / Task 42411 - adjusted HQMA code for column name change and a new column
*
*	Update trigger for PR Australian Limits And Rates table
*
*	Adds HQ Master Audit entry.
*/----------------------------------------------------------------

	SET NOCOUNT ON
 
	DECLARE @errmsg VARCHAR(255)

	---------------------
	-- CHECK KEY FIELD --
	---------------------
	IF UPDATE (EffectiveDate)
	BEGIN
		SET @errmsg = 'Effective Date is a Key field and cannot be updated - cannot update record!'
		RAISERROR(@errmsg, 11, -1);
		ROLLBACK TRANSACTION
	END

	----------
	-- HQMA --
	----------
	-- ETPCap --
	IF UPDATE (ETPCap)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'ETPCap', 
					CONVERT(varchar(128), d.ETPCap),
					CONVERT(varchar(128), i.ETPCap),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.ETPCap <> d.ETPCap
		END
	
	-- WholeIncomeCap --
	IF UPDATE (WholeIncomeCap)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'WholeIncomeCap', 
					CONVERT(varchar(128), d.WholeIncomeCap),
					CONVERT(varchar(128), i.WholeIncomeCap),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.WholeIncomeCap <> d.WholeIncomeCap
		END	
	
	-- RedundancyTaxFreeBasis --
	IF UPDATE (RedundancyTaxFreeBasis)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'RedundancyTaxFreeBasis', 
					CONVERT(varchar(128), d.RedundancyTaxFreeBasis),
					CONVERT(varchar(128), i.RedundancyTaxFreeBasis),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.RedundancyTaxFreeBasis <> d.RedundancyTaxFreeBasis
		END	
	
	-- RedundancyTaxFreeYears --
	IF UPDATE (RedundancyTaxFreeYears)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'RedundancyTaxFreeYears', 
					CONVERT(varchar(128), d.RedundancyTaxFreeYears),
					CONVERT(varchar(128), i.RedundancyTaxFreeYears),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.RedundancyTaxFreeYears <> d.RedundancyTaxFreeYears
		END	

	-- UnderPreservationAgePct --
	IF UPDATE (UnderPreservationAgePct)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'UnderPreservationAgePct', 
					CONVERT(varchar(128), d.UnderPreservationAgePct),
					CONVERT(varchar(128), i.UnderPreservationAgePct),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.UnderPreservationAgePct <> d.UnderPreservationAgePct
		END	
		
	-- OverPreservationAgePct --
	IF UPDATE (OverPreservationAgePct)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'OverPreservationAgePct', 
					CONVERT(varchar(128), d.OverPreservationAgePct),
					CONVERT(varchar(128), i.OverPreservationAgePct),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.OverPreservationAgePct <> d.OverPreservationAgePct
		END	

	-- ExcessCapPct --
	IF UPDATE (ExcessCapPct)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'ExcessCapPct', 
					CONVERT(varchar(128), d.ExcessCapPct),
					CONVERT(varchar(128), i.ExcessCapPct),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.ExcessCapPct <> d.ExcessCapPct
		END	

	-- LeaveFlatRateLimit --
	IF UPDATE (LeaveFlatRateLimit)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'LeaveFlatRateLimit', 
					CONVERT(varchar(128), d.LeaveFlatRateLimit),
					CONVERT(varchar(128), i.LeaveFlatRateLimit),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.LeaveFlatRateLimit <> d.LeaveFlatRateLimit
		END	

	-- LeaveFlatRatePct --
	IF UPDATE (LeaveFlatRatePct)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'LeaveFlatRatePct', 
					CONVERT(varchar(128), d.LeaveFlatRatePct),
					CONVERT(varchar(128), i.LeaveFlatRatePct),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.LeaveFlatRatePct <> d.LeaveFlatRatePct
		END	
		
	-- AnnualLeaveLoadingPct --
	IF UPDATE (AnnualLeaveLoadingPct)
		BEGIN
		
			INSERT  dbo.bHQMA(TableName, KeyString, Co, RecType, 
					FieldName, 
					OldValue, 
					NewValue, 
					DateTime, UserName)
			SELECT  'vPRAULimitsAndRates', 'Effective Date: ' + dbo.vfToString(i.EffectiveDate), NULL, 'C', 
					'AnnualLeaveLoadingPct', 
					CONVERT(varchar(128), d.AnnualLeaveLoadingPct),
					CONVERT(varchar(128), i.AnnualLeaveLoadingPct),
					GETDATE(), SUSER_SNAME() 
			  FROM	inserted i
			  JOIN	deleted d ON i.EffectiveDate = d.EffectiveDate 
			 WHERE	i.AnnualLeaveLoadingPct <> d.AnnualLeaveLoadingPct
		END	

RETURN
 

GO
PRINT N'Refreshing [dbo].[HRBC]'
GO
EXEC sp_refreshview N'[dbo].[HRBC]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerFBT]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerFBT]'
GO
PRINT N'Refreshing [dbo].[POCD]'
GO
EXEC sp_refreshview N'[dbo].[POCD]'
GO
PRINT N'Refreshing [dbo].[GLBR]'
GO
EXEC sp_refreshview N'[dbo].[GLBR]'
GO
PRINT N'Refreshing [dbo].[vrvAPVM_MasterVendor]'
GO
EXEC sp_refreshview N'[dbo].[vrvAPVM_MasterVendor]'
GO
PRINT N'Refreshing [dbo].[PRRQ]'
GO
EXEC sp_refreshview N'[dbo].[PRRQ]'
GO
PRINT N'Refreshing [dbo].[PRRE]'
GO
EXEC sp_refreshview N'[dbo].[PRRE]'
GO
PRINT N'Refreshing [dbo].[MSTP]'
GO
EXEC sp_refreshview N'[dbo].[MSTP]'
GO
PRINT N'Refreshing [dbo].[PRLV]'
GO
EXEC sp_refreshview N'[dbo].[PRLV]'
GO
PRINT N'Refreshing [dbo].[PREL]'
GO
EXEC sp_refreshview N'[dbo].[PREL]'
GO
PRINT N'Refreshing [dbo].[PRELStats]'
GO
EXEC sp_refreshview N'[dbo].[PRELStats]'
GO
PRINT N'Refreshing [dbo].[SLInExclusions]'
GO
EXEC sp_refreshview N'[dbo].[SLInExclusions]'
GO
PRINT N'Refreshing [dbo].[SMWorkCompletedARTL]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkCompletedARTL]'
GO
PRINT N'Refreshing [dbo].[SMTechnicianInfo]'
GO
EXEC sp_refreshview N'[dbo].[SMTechnicianInfo]'
GO
PRINT N'Refreshing [dbo].[SMInvoiceList]'
GO
EXEC sp_refreshview N'[dbo].[SMInvoiceList]'
GO
PRINT N'Refreshing [dbo].[brvPMAddonPCOItem]'
GO
EXEC sp_refreshview N'[dbo].[brvPMAddonPCOItem]'
GO
PRINT N'Altering [dbo].[vPRCraftClassAllowance]'
GO
ALTER TABLE [dbo].[vPRCraftClassAllowance] ADD
[ShiftRateOverride] [tinyint] NULL
GO
PRINT N'Refreshing [dbo].[HRPT]'
GO
EXEC sp_refreshview N'[dbo].[HRPT]'
GO
PRINT N'Refreshing [dbo].[POVM]'
GO
EXEC sp_refreshview N'[dbo].[POVM]'
GO
PRINT N'Refreshing [dbo].[vrvAP_MVAllInvoices]'
GO
EXEC sp_refreshview N'[dbo].[vrvAP_MVAllInvoices]'
GO
PRINT N'Refreshing [dbo].[RPRMShared]'
GO
EXEC sp_refreshview N'[dbo].[RPRMShared]'
GO
PRINT N'Refreshing [dbo].[SMServiceSiteContact]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceSiteContact]'
GO
PRINT N'Refreshing [dbo].[HQContact]'
GO
EXEC sp_refreshview N'[dbo].[HQContact]'
GO
PRINT N'Refreshing [dbo].[SMContact]'
GO
EXEC sp_refreshview N'[dbo].[SMContact]'
GO
PRINT N'Refreshing [dbo].[SMWorkOrderScopeTask]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrderScopeTask]'
GO
PRINT N'Refreshing [dbo].[SMAgreementServiceTask]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementServiceTask]'
GO
PRINT N'Refreshing [dbo].[SMAgreementServiceDate]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementServiceDate]'
GO
PRINT N'Refreshing [dbo].[MSTT]'
GO
EXEC sp_refreshview N'[dbo].[MSTT]'
GO
PRINT N'Refreshing [dbo].[HQRD]'
GO
EXEC sp_refreshview N'[dbo].[HQRD]'
GO
PRINT N'Refreshing [dbo].[PRMyTimesheetDetailForApproval]'
GO
EXEC sp_refreshview N'[dbo].[PRMyTimesheetDetailForApproval]'
GO
PRINT N'Refreshing [dbo].[PRMyTimesheetApproval]'
GO
EXEC sp_refreshview N'[dbo].[PRMyTimesheetApproval]'
GO
PRINT N'Refreshing [dbo].[RPRPc]'
GO
EXEC sp_refreshview N'[dbo].[RPRPc]'
GO
PRINT N'Refreshing [dbo].[RPRMc]'
GO
EXEC sp_refreshview N'[dbo].[RPRMc]'
GO
PRINT N'Refreshing [dbo].[RPRM]'
GO
EXEC sp_refreshview N'[dbo].[RPRM]'
GO
PRINT N'Refreshing [dbo].[RPFRc]'
GO
EXEC sp_refreshview N'[dbo].[RPFRc]'
GO
PRINT N'Refreshing [dbo].[RPFR]'
GO
EXEC sp_refreshview N'[dbo].[RPFR]'
GO
PRINT N'Refreshing [dbo].[RPFDc]'
GO
EXEC sp_refreshview N'[dbo].[RPFDc]'
GO
PRINT N'Refreshing [dbo].[RPFD]'
GO
EXEC sp_refreshview N'[dbo].[RPFD]'
GO
PRINT N'Refreshing [dbo].[JCCMARBillAddress]'
GO
EXEC sp_refreshview N'[dbo].[JCCMARBillAddress]'
GO
PRINT N'Refreshing [dbo].[PMSI]'
GO
EXEC sp_refreshview N'[dbo].[PMSI]'
GO
PRINT N'Refreshing [dbo].[PMQD]'
GO
EXEC sp_refreshview N'[dbo].[PMQD]'
GO
PRINT N'Refreshing [dbo].[brvPMBallInCourt]'
GO
EXEC sp_refreshview N'[dbo].[brvPMBallInCourt]'
GO
PRINT N'Refreshing [dbo].[VPGridQueryAssociation]'
GO
EXEC sp_refreshview N'[dbo].[VPGridQueryAssociation]'
GO
PRINT N'Refreshing [dbo].[PRWL]'
GO
EXEC sp_refreshview N'[dbo].[PRWL]'
GO
PRINT N'Altering [dbo].[vPRCraftClassTemplateAllowance]'
GO
ALTER TABLE [dbo].[vPRCraftClassTemplateAllowance] ADD
[ShiftRateOverride] [tinyint] NULL
GO
PRINT N'Refreshing [dbo].[HRRC]'
GO
EXEC sp_refreshview N'[dbo].[HRRC]'
GO
PRINT N'Refreshing [dbo].[WFProcessStep]'
GO
EXEC sp_refreshview N'[dbo].[WFProcessStep]'
GO
PRINT N'Refreshing [dbo].[SLAD]'
GO
EXEC sp_refreshview N'[dbo].[SLAD]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerFBTCodes]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerFBTCodes]'
GO
PRINT N'Refreshing [dbo].[ARRT]'
GO
EXEC sp_refreshview N'[dbo].[ARRT]'
GO
PRINT N'Refreshing [dbo].[vrvARInvoiceDetails]'
GO
EXEC sp_refreshview N'[dbo].[vrvARInvoiceDetails]'
GO
PRINT N'Refreshing [dbo].[DDFTShared]'
GO
EXEC sp_refreshview N'[dbo].[DDFTShared]'
GO
PRINT N'Refreshing [dbo].[PMPI]'
GO
EXEC sp_refreshview N'[dbo].[PMPI]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideBaseRate]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideBaseRate]'
GO
PRINT N'Refreshing [dbo].[SMGenericEntity]'
GO
EXEC sp_refreshview N'[dbo].[SMGenericEntity]'
GO
PRINT N'Refreshing [dbo].[MSTTTruck]'
GO
EXEC sp_refreshview N'[dbo].[MSTTTruck]'
GO
PRINT N'Refreshing [dbo].[SLInExclusionsPM]'
GO
EXEC sp_refreshview N'[dbo].[SLInExclusionsPM]'
GO
PRINT N'Refreshing [dbo].[SMServiceableItemWOList]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceableItemWOList]'
GO
PRINT N'Refreshing [dbo].[SMServiceItems]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceItems]'
GO
PRINT N'Refreshing [dbo].[JCCMContractAmtForMaxRetg]'
GO
EXEC sp_refreshview N'[dbo].[JCCMContractAmtForMaxRetg]'
GO
PRINT N'Refreshing [dbo].[brvPMBuyOutACO]'
GO
EXEC sp_refreshview N'[dbo].[brvPMBuyOutACO]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideStandardItem]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideStandardItem]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideMatlBP]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideMatlBP]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideMaterial]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideMaterial]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideLabor]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideLabor]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideEquipment]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideEquipment]'
GO
PRINT N'Refreshing [dbo].[EMSD]'
GO
EXEC sp_refreshview N'[dbo].[EMSD]'
GO
PRINT N'Refreshing [dbo].[EMML]'
GO
EXEC sp_refreshview N'[dbo].[EMML]'
GO
PRINT N'Refreshing [dbo].[EMMH]'
GO
EXEC sp_refreshview N'[dbo].[EMMH]'
GO
PRINT N'Refreshing [dbo].[PRWS]'
GO
EXEC sp_refreshview N'[dbo].[PRWS]'
GO
PRINT N'Refreshing [dbo].[PRAE]'
GO
EXEC sp_refreshview N'[dbo].[PRAE]'
GO
PRINT N'Altering [dbo].[vPRCraftMasterAllowance]'
GO
ALTER TABLE [dbo].[vPRCraftMasterAllowance] ADD
[ShiftRateOverride] [tinyint] NULL
GO
PRINT N'Refreshing [dbo].[HRRD]'
GO
EXEC sp_refreshview N'[dbo].[HRRD]'
GO
PRINT N'Refreshing [dbo].[JCSI]'
GO
EXEC sp_refreshview N'[dbo].[JCSI]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerFBTItems]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerFBTItems]'
GO
PRINT N'Refreshing [dbo].[POXB]'
GO
EXEC sp_refreshview N'[dbo].[POXB]'
GO
PRINT N'Refreshing [dbo].[PRRC]'
GO
EXEC sp_refreshview N'[dbo].[PRRC]'
GO
PRINT N'Refreshing [dbo].[GLDB]'
GO
EXEC sp_refreshview N'[dbo].[GLDB]'
GO
PRINT N'Refreshing [dbo].[vrvARInvoices]'
GO
EXEC sp_refreshview N'[dbo].[vrvARInvoices]'
GO
PRINT N'Refreshing [dbo].[RQReviewerDistinct]'
GO
EXEC sp_refreshview N'[dbo].[RQReviewerDistinct]'
GO
PRINT N'Refreshing [dbo].[INMI]'
GO
EXEC sp_refreshview N'[dbo].[INMI]'
GO
PRINT N'Refreshing [dbo].[DDLH]'
GO
EXEC sp_refreshview N'[dbo].[DDLH]'
GO
PRINT N'Refreshing [dbo].[JCCMContracts]'
GO
EXEC sp_refreshview N'[dbo].[JCCMContracts]'
GO
PRINT N'Refreshing [dbo].[brvPMBuyOutReport]'
GO
EXEC sp_refreshview N'[dbo].[brvPMBuyOutReport]'
GO
PRINT N'Refreshing [dbo].[PRWT]'
GO
EXEC sp_refreshview N'[dbo].[PRWT]'
GO
PRINT N'Altering [dbo].[vPRCraftTemplateAllowance]'
GO
ALTER TABLE [dbo].[vPRCraftTemplateAllowance] ADD
[ShiftRateOverride] [tinyint] NULL
GO
PRINT N'Refreshing [dbo].[MSCO]'
GO
EXEC sp_refreshview N'[dbo].[MSCO]'
GO
PRINT N'Refreshing [dbo].[PRDB]'
GO
EXEC sp_refreshview N'[dbo].[PRDB]'
GO
PRINT N'Refreshing [dbo].[GLDT]'
GO
EXEC sp_refreshview N'[dbo].[GLDT]'
GO
PRINT N'Refreshing [dbo].[vrvARTaxRates]'
GO
EXEC sp_refreshview N'[dbo].[vrvARTaxRates]'
GO
PRINT N'Refreshing [dbo].[PMPL1]'
GO
EXEC sp_refreshview N'[dbo].[PMPL1]'
GO
PRINT N'Refreshing [dbo].[RPTYShared]'
GO
EXEC sp_refreshview N'[dbo].[RPTYShared]'
GO
PRINT N'Refreshing [dbo].[PMMM]'
GO
EXEC sp_refreshview N'[dbo].[PMMM]'
GO
PRINT N'Refreshing [dbo].[PMMD]'
GO
EXEC sp_refreshview N'[dbo].[PMMD]'
GO
PRINT N'Refreshing [dbo].[MSVT]'
GO
EXEC sp_refreshview N'[dbo].[MSVT]'
GO
PRINT N'Refreshing [dbo].[SLCBGrid]'
GO
EXEC sp_refreshview N'[dbo].[SLCBGrid]'
GO
PRINT N'Refreshing [dbo].[HQCompanyProcess]'
GO
EXEC sp_refreshview N'[dbo].[HQCompanyProcess]'
GO
PRINT N'Refreshing [dbo].[SLITMaxRetgAmt]'
GO
EXEC sp_refreshview N'[dbo].[SLITMaxRetgAmt]'
GO
PRINT N'Refreshing [dbo].[CMDT]'
GO
EXEC sp_refreshview N'[dbo].[CMDT]'
GO
PRINT N'Refreshing [dbo].[brvPMChangeOrderCostDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvPMChangeOrderCostDetail]'
GO
PRINT N'Refreshing [dbo].[ptvJCCH]'
GO
EXEC sp_refreshview N'[dbo].[ptvJCCH]'
GO
PRINT N'Creating [dbo].[vPREmplPeriodsWithoutPay]'
GO
CREATE TABLE [dbo].[vPREmplPeriodsWithoutPay]
(
[PRCo] [dbo].[bCompany] NOT NULL,
[Employee] [dbo].[bEmployee] NOT NULL,
[Seq] [smallint] NOT NULL,
[FirstDate] [dbo].[bDate] NOT NULL CONSTRAINT [DF_vPREmplPeriodsWithoutPay_FirstDate] DEFAULT (getdate()),
[LastDate] [dbo].[bDate] NOT NULL CONSTRAINT [DF_vPREmplPeriodsWithoutPay_LastDate] DEFAULT (getdate()),
[Memo] [varchar] (max) COLLATE Latin1_General_BIN NULL,
[KeyID] [bigint] NOT NULL IDENTITY(1, 1),
[UniqueAttchID] [uniqueidentifier] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
PRINT N'Creating primary key [PK_vPREmplPeriodsWithoutPay_PRCo_Employee_Seq] on [dbo].[vPREmplPeriodsWithoutPay]'
GO
ALTER TABLE [dbo].[vPREmplPeriodsWithoutPay] ADD CONSTRAINT [PK_vPREmplPeriodsWithoutPay_PRCo_Employee_Seq] PRIMARY KEY CLUSTERED  ([PRCo], [Employee], [Seq]) ON [PRIMARY]
GO
PRINT N'Creating trigger [dbo].[vtPREmplPeriodsWithoutPayd] on [dbo].[vPREmplPeriodsWithoutPay]'
GO
CREATE TRIGGER [dbo].[vtPREmplPeriodsWithoutPayd] ON [dbo].[vPREmplPeriodsWithoutPay] FOR DELETE AS

/*-----------------------------------------------------------------
* Created:		EN 4/5/2013 Story 44310 / Task 45407
* Modified:		
*
*	This trigger validates deletions to vPREmplPeriodsWithoutPay.
*	Adds HQ Master Audit entry.
*
*/-----------------------------------------------------------------

IF @@ROWCOUNT = 0 RETURN

/************** Record deletion in HQMA *******************/
SET NOCOUNT ON
-- Do not audit records coming from processing: End Date, PR Group and Pay Seq are NULL 
INSERT INTO dbo.bHQMA  (TableName,	KeyString,	Co,				
						RecType,	FieldName,	OldValue, 
						NewValue,	DateTime,	UserName)
SELECT  'vPREmplPeriodsWithoutPay',	
		'Employee:' + CONVERT(varchar(10),d.Employee) 
		+ 'Seq:' + CONVERT(varchar(10),d.Seq),
		d.PRCo,			
		'D', 
		NULL,			
		NULL, 
		NULL,			
		GETDATE(), 
		SUSER_SNAME()
FROM  deleted d

RETURN

 



GO
PRINT N'Refreshing [dbo].[WFChecklistTasks]'
GO
EXEC sp_refreshview N'[dbo].[WFChecklistTasks]'
GO
PRINT N'Refreshing [dbo].[WFChecklistSteps]'
GO
EXEC sp_refreshview N'[dbo].[WFChecklistSteps]'
GO
PRINT N'Refreshing [dbo].[WFTasklist]'
GO
EXEC sp_refreshview N'[dbo].[WFTasklist]'
GO
PRINT N'Refreshing [dbo].[PRAUEmployerMiscItems]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerMiscItems]'
GO
PRINT N'Refreshing [dbo].[vrvCompanySettings]'
GO
EXEC sp_refreshview N'[dbo].[vrvCompanySettings]'
GO
PRINT N'Refreshing [dbo].[DDMF]'
GO
EXEC sp_refreshview N'[dbo].[DDMF]'
GO
PRINT N'Refreshing [dbo].[vDDFHSecurable]'
GO
EXEC sp_refreshview N'[dbo].[vDDFHSecurable]'
GO
PRINT N'Refreshing [dbo].[MSWD]'
GO
EXEC sp_refreshview N'[dbo].[MSWD]'
GO
PRINT N'Refreshing [dbo].[SLWHInvoiceTotals]'
GO
EXEC sp_refreshview N'[dbo].[SLWHInvoiceTotals]'
GO
PRINT N'Refreshing [dbo].[ARCN]'
GO
EXEC sp_refreshview N'[dbo].[ARCN]'
GO
PRINT N'Refreshing [dbo].[GLJR]'
GO
EXEC sp_refreshview N'[dbo].[GLJR]'
GO
PRINT N'Refreshing [dbo].[JCCOCompany]'
GO
EXEC sp_refreshview N'[dbo].[JCCOCompany]'
GO
PRINT N'Refreshing [dbo].[PMDR]'
GO
EXEC sp_refreshview N'[dbo].[PMDR]'
GO
PRINT N'Refreshing [dbo].[PMDG]'
GO
EXEC sp_refreshview N'[dbo].[PMDG]'
GO
PRINT N'Refreshing [dbo].[JBPG]'
GO
EXEC sp_refreshview N'[dbo].[JBPG]'
GO
PRINT N'Refreshing [dbo].[brvPMChangeOrders]'
GO
EXEC sp_refreshview N'[dbo].[brvPMChangeOrders]'
GO
PRINT N'Refreshing [dbo].[VPGridColumns]'
GO
EXEC sp_refreshview N'[dbo].[VPGridColumns]'
GO
PRINT N'Refreshing [dbo].[ptvJCCHPhaseUnits]'
GO
EXEC sp_refreshview N'[dbo].[ptvJCCHPhaseUnits]'
GO
PRINT N'Creating trigger [dbo].[vtPREmplPeriodsWithoutPayi] on [dbo].[vPREmplPeriodsWithoutPay]'
GO
CREATE TRIGGER [dbo].[vtPREmplPeriodsWithoutPayi] ON [dbo].[vPREmplPeriodsWithoutPay] FOR INSERT AS

/*-----------------------------------------------------------------
* Created:  EN 4/5/2013 Story 44310 / Task 45407
* Modified: 
*
*	This trigger validates insertion in vPREmplPeriodsWithoutPay.
*	Validate that LastDate is the same or later than FirstDate.
*	Adds HQ Master Audit entry.
*
*/-----------------------------------------------------------------

DECLARE @errmsg varchar(255), 
		@numrows int, 
		@validcnt int
SELECT @numrows = @@ROWCOUNT
IF @numrows = 0 RETURN
SET NOCOUNT ON

--Validate employee
SELECT @validcnt = COUNT(*) 
FROM bPREH h 
JOIN inserted i ON i.PRCo = h.PRCo AND i.Employee = h.Employee
IF @validcnt <> @numrows
BEGIN
	SELECT @errmsg = 'Invalid Employee'
	GOTO ERROR
END

--Compare order of FirstDate and LastDate
SELECT @validcnt = COUNT(*)
FROM inserted i
WHERE i.FirstDate <= i.LastDate
IF @validcnt <> @numrows
BEGIN
	SELECT @errmsg = 'Last Date cannot be earlier than First Date '
	GOTO ERROR
END

--Verify that date ranges do not intersect or conflict
SET @validcnt = 0

SELECT @validcnt = COUNT(*) 
FROM inserted i
JOIN dbo.vPREmplPeriodsWithoutPay pwp1 ON pwp1.PRCo = i.PRCo AND pwp1.Employee = i.Employee AND pwp1.Seq <> i.Seq
JOIN dbo.vPREmplPeriodsWithoutPay pwp2 ON pwp2.PRCo = i.PRCo AND pwp2.Employee = i.Employee AND pwp2.Seq <> i.Seq
WHERE (
	   i.FirstDate BETWEEN pwp1.FirstDate AND pwp1.LastDate OR
	   i.LastDate BETWEEN pwp1.FirstDate AND pwp1.LastDate
	  )
	  OR
	  (i.FirstDate <= pwp2.FirstDate AND i.LastDate >= pwp2.LastDate)

IF @validcnt <> 0
BEGIN
	SELECT @errmsg = 'Date range conflicts with an existing date range '
	GOTO ERROR
END

/************* Insert HQ Master Audit Entry ***********************************/      
	INSERT INTO dbo.bHQMA  (TableName,	KeyString,	Co,
							RecType,	FieldName,	OldValue,	
							NewValue,	DateTime,	UserName)
	SELECT  'vPREmplPeriodsWithoutPay',	
			'Employee:' + CONVERT(varchar(10),i.Employee) 
			+ 'Seq:' + CONVERT(varchar(10),i.Seq),
			i.PRCo,			
			'A', 
			NULL,			
			NULL, 
			NULL,			
			GETDATE(), 
			SUSER_SNAME()
	FROM inserted i
	JOIN dbo.bPRCO a ON i.PRCo = a.PRCo
	WHERE a.AuditEmployees = 'Y'

RETURN
ERROR:
	SELECT @errmsg = ISNULL(@errmsg,'') + ' - cannot insert PR Employee Period(s) Without Pay!'
   	RAISERROR(@errmsg, 11, -1);
   	ROLLBACK TRANSACTION
   
   
   
   
   
   
   
  
 




GO
PRINT N'Refreshing [dbo].[PRAUEmployerSuperItems]'
GO
EXEC sp_refreshview N'[dbo].[PRAUEmployerSuperItems]'
GO
PRINT N'Refreshing [dbo].[RPRT]'
GO
EXEC sp_refreshview N'[dbo].[RPRT]'
GO
PRINT N'Refreshing [dbo].[vrvDDTemplateDetail]'
GO
EXEC sp_refreshview N'[dbo].[vrvDDTemplateDetail]'
GO
PRINT N'Refreshing [dbo].[viDim_APInvoice]'
GO
EXEC sp_refreshview N'[dbo].[viDim_APInvoice]'
GO
PRINT N'Refreshing [dbo].[PRRH]'
GO
EXEC sp_refreshview N'[dbo].[PRRH]'
GO
PRINT N'Refreshing [dbo].[EMUD]'
GO
EXEC sp_refreshview N'[dbo].[EMUD]'
GO
PRINT N'Refreshing [dbo].[SMAgreementBillingSched]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementBillingSched]'
GO
PRINT N'Refreshing [dbo].[brvPMEstCo]'
GO
EXEC sp_refreshview N'[dbo].[brvPMEstCo]'
GO
PRINT N'Refreshing [dbo].[ptvJCCO]'
GO
EXEC sp_refreshview N'[dbo].[ptvJCCO]'
GO
PRINT N'Creating trigger [dbo].[vtPREmplPeriodsWithoutPayu] on [dbo].[vPREmplPeriodsWithoutPay]'
GO
CREATE TRIGGER [dbo].[vtPREmplPeriodsWithoutPayu] ON [dbo].[vPREmplPeriodsWithoutPay] FOR UPDATE AS

/*-----------------------------------------------------------------
* Created:  EN  EN 4/5/2013 Story 44310 / Task 45407
* Modified:	DAN SO 04/23/2013 - Task 45407 - Wrapped FirstDate and LastDate in "dbo.vfToString("
*
*	This trigger validates update to vPREmplPeriodsWithoutPay.
*	Validate that LastDate is the same or later than FirstDate.
*	Adds HQ Master Audit entries.
*	
*/-----------------------------------------------------------------
    
DECLARE @errmsg varchar(255), 
		@numrows int, 
		@validcnt int
SELECT @numrows = @@rowcount
IF @numrows = 0 RETURN
SET NOCOUNT ON    
    
/************* Validate fields before updating ************/    

--Company and DL Code and Employee are Key fields and cannot update
IF UPDATE(PRCo)
BEGIN
	SELECT @errmsg = 'PR Company cannot be updated, it is a key value '
	GOTO ERROR
END

IF UPDATE(Employee)
BEGIN
	SELECT @errmsg = 'Employee cannot be updated, it is a key value '
	GOTO ERROR
END 

--Compare order of FirstDate and LastDate
SELECT @validcnt = COUNT(*)
FROM inserted i
WHERE i.FirstDate <= i.LastDate
IF @validcnt <> @numrows
BEGIN
	SELECT @errmsg = 'Last Date cannot be earlier than First Date '
	GOTO ERROR
END

--Verify that date ranges do not intersect or conflict
SET @validcnt = 0

SELECT @validcnt = COUNT(*) 
FROM inserted i
JOIN dbo.vPREmplPeriodsWithoutPay pwp1 ON pwp1.PRCo = i.PRCo AND pwp1.Employee = i.Employee AND pwp1.Seq <> i.Seq
JOIN dbo.vPREmplPeriodsWithoutPay pwp2 ON pwp2.PRCo = i.PRCo AND pwp2.Employee = i.Employee AND pwp2.Seq <> i.Seq
WHERE (
	   i.FirstDate BETWEEN pwp1.FirstDate AND pwp1.LastDate OR
	   i.LastDate BETWEEN pwp1.FirstDate AND pwp1.LastDate
	  )
	  OR
	  (i.FirstDate <= pwp2.FirstDate AND i.LastDate >= pwp2.LastDate)

IF @validcnt <> 0
BEGIN
	SELECT @errmsg = 'Date range conflicts with an existing date range '
	GOTO ERROR
END


/************* Update HQ Master Audit entry **********************************/
IF EXISTS (SELECT * FROM inserted i JOIN dbo.bPRCO a WITH(NOLOCK) ON a.PRCo = i.PRCo WHERE a.AuditEmployees = 'Y')
BEGIN
	IF UPDATE (FirstDate)
	BEGIN
		INSERT INTO dbo.bHQMA (TableName,	KeyString,	Co,
							   RecType,		FieldName,	OldValue, 
							   NewValue,	DateTime,	UserName)
					   SELECT 'vPREmplPeriodsWithoutPay',
							  'Employee:' + CONVERT(varchar(10),i.Employee) 
							  + 'Seq:' + CONVERT(varchar(10),i.Seq),
							  i.PRCo,			
							  'C', 
							  'FirstDate',			
							  dbo.vfToString(d.FirstDate),
							  dbo.vfToString(i.FirstDate),		
							  GETDATE(), 
							  SUSER_SNAME()
						 FROM inserted i
						 JOIN deleted d 
						 ON	  i.PRCo = d.PRCo 
						      AND i.Employee = d.Employee 
						      AND i.Seq = d.Seq
						WHERE i.FirstDate <> d.FirstDate
	END
	
	IF UPDATE (LastDate)
	BEGIN
		INSERT INTO dbo.bHQMA (TableName,	KeyString,	Co,
							   RecType,		FieldName,	OldValue, 
							   NewValue,	DateTime,	UserName)
					   SELECT 'vPREmplPeriodsWithoutPay',
							  'Employee:' + CONVERT(varchar(10),i.Employee) 
							  + 'Seq:' + CONVERT(varchar(10),i.Seq),
							  i.PRCo,			
							  'C', 
							  'LastDate',			
							  dbo.vfToString(d.LastDate),
							  dbo.vfToString(i.LastDate),
							  GETDATE(), 
							  SUSER_SNAME()
						 FROM inserted i
						 JOIN deleted d 
						 ON	  i.PRCo = d.PRCo 
						      AND i.Employee = d.Employee 
						      AND i.Seq = d.Seq
						WHERE i.LastDate <> d.LastDate
	END

END
     
RETURN 
ERROR:
SELECT @errmsg = ISNULL(@errmsg,'') + ' - cannot update PR Employee Period(s) Without Pay!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
     
     
     
    
    
    
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
 



GO
PRINT N'Refreshing [dbo].[PRAUItems]'
GO
EXEC sp_refreshview N'[dbo].[PRAUItems]'
GO
PRINT N'Refreshing [dbo].[GLIA]'
GO
EXEC sp_refreshview N'[dbo].[GLIA]'
GO
PRINT N'Refreshing [dbo].[DMAttachmentAuditLog]'
GO
EXEC sp_refreshview N'[dbo].[DMAttachmentAuditLog]'
GO
PRINT N'Refreshing [dbo].[PMPMReq]'
GO
EXEC sp_refreshview N'[dbo].[PMPMReq]'
GO
PRINT N'Refreshing [dbo].[PMSubmittalPackage]'
GO
EXEC sp_refreshview N'[dbo].[PMSubmittalPackage]'
GO
PRINT N'Refreshing [dbo].[PMSubmittal]'
GO
EXEC sp_refreshview N'[dbo].[PMSubmittal]'
GO
PRINT N'Refreshing [dbo].[viDim_APVendor]'
GO
EXEC sp_refreshview N'[dbo].[viDim_APVendor]'
GO
PRINT N'Refreshing [dbo].[MSWH]'
GO
EXEC sp_refreshview N'[dbo].[MSWH]'
GO
PRINT N'Refreshing [dbo].[SMAgreementServiceDatesGenerated]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementServiceDatesGenerated]'
GO
PRINT N'Refreshing [dbo].[SMAgreementWorkOrderList]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementWorkOrderList]'
GO
PRINT N'Refreshing [dbo].[ARMC]'
GO
EXEC sp_refreshview N'[dbo].[ARMC]'
GO
PRINT N'Refreshing [dbo].[SLWHHist]'
GO
EXEC sp_refreshview N'[dbo].[SLWHHist]'
GO
PRINT N'Refreshing [dbo].[brvPMMatlSubDtl]'
GO
EXEC sp_refreshview N'[dbo].[brvPMMatlSubDtl]'
GO
PRINT N'Refreshing [dbo].[ptvJCJM]'
GO
EXEC sp_refreshview N'[dbo].[ptvJCJM]'
GO
PRINT N'Refreshing [dbo].[PRLH]'
GO
EXEC sp_refreshview N'[dbo].[PRLH]'
GO
PRINT N'Refreshing [dbo].[HRRMGroupRes]'
GO
EXEC sp_refreshview N'[dbo].[HRRMGroupRes]'
GO
PRINT N'Refreshing [dbo].[DDCIShared]'
GO
EXEC sp_refreshview N'[dbo].[DDCIShared]'
GO
PRINT N'Refreshing [dbo].[HRCC]'
GO
EXEC sp_refreshview N'[dbo].[HRCC]'
GO
PRINT N'Refreshing [dbo].[PRAUItemsATOCategories]'
GO
EXEC sp_refreshview N'[dbo].[PRAUItemsATOCategories]'
GO
PRINT N'Refreshing [dbo].[vrvHQCO_User]'
GO
EXEC sp_refreshview N'[dbo].[vrvHQCO_User]'
GO
PRINT N'Refreshing [dbo].[PMPMResp]'
GO
EXEC sp_refreshview N'[dbo].[PMPMResp]'
GO
PRINT N'Refreshing [dbo].[viDim_ARCustomer]'
GO
EXEC sp_refreshview N'[dbo].[viDim_ARCustomer]'
GO
PRINT N'Refreshing [dbo].[SMBatches]'
GO
EXEC sp_refreshview N'[dbo].[SMBatches]'
GO
PRINT N'Refreshing [dbo].[INMB]'
GO
EXEC sp_refreshview N'[dbo].[INMB]'
GO
PRINT N'Refreshing [dbo].[INIB]'
GO
EXEC sp_refreshview N'[dbo].[INIB]'
GO
PRINT N'Refreshing [dbo].[SLWHView]'
GO
EXEC sp_refreshview N'[dbo].[SLWHView]'
GO
PRINT N'Refreshing [dbo].[JCJobApprovalProcess]'
GO
EXEC sp_refreshview N'[dbo].[JCJobApprovalProcess]'
GO
PRINT N'Refreshing [dbo].[INLocationApprovalProcess]'
GO
EXEC sp_refreshview N'[dbo].[INLocationApprovalProcess]'
GO
PRINT N'Refreshing [dbo].[EMDepartmentApprovalProcess]'
GO
EXEC sp_refreshview N'[dbo].[EMDepartmentApprovalProcess]'
GO
PRINT N'Refreshing [dbo].[HQRoleMember]'
GO
EXEC sp_refreshview N'[dbo].[HQRoleMember]'
GO
PRINT N'Refreshing [dbo].[JCCTByPhase]'
GO
EXEC sp_refreshview N'[dbo].[JCCTByPhase]'
GO
PRINT N'Refreshing [dbo].[PMContractChangeOrderACO]'
GO
EXEC sp_refreshview N'[dbo].[PMContractChangeOrderACO]'
GO
PRINT N'Refreshing [dbo].[brvPMMSQuoteDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvPMMSQuoteDetail]'
GO
PRINT N'Refreshing [dbo].[ptvJCJP]'
GO
EXEC sp_refreshview N'[dbo].[ptvJCJP]'
GO
PRINT N'Refreshing [dbo].[HRRMName]'
GO
EXEC sp_refreshview N'[dbo].[HRRMName]'
GO
PRINT N'Refreshing [dbo].[JBTA]'
GO
EXEC sp_refreshview N'[dbo].[JBTA]'
GO
PRINT N'Refreshing [dbo].[vrvHRFMLA]'
GO
EXEC sp_refreshview N'[dbo].[vrvHRFMLA]'
GO
PRINT N'Refreshing [dbo].[SMTechnicianPreferences]'
GO
EXEC sp_refreshview N'[dbo].[SMTechnicianPreferences]'
GO
PRINT N'Refreshing [dbo].[PMPMSend]'
GO
EXEC sp_refreshview N'[dbo].[PMPMSend]'
GO
PRINT N'Refreshing [dbo].[viDim_ARInvoice]'
GO
EXEC sp_refreshview N'[dbo].[viDim_ARInvoice]'
GO
PRINT N'Refreshing [dbo].[SMDetailTransaction]'
GO
EXEC sp_refreshview N'[dbo].[SMDetailTransaction]'
GO
PRINT N'Refreshing [dbo].[SMDetailTransactionExtended]'
GO
EXEC sp_refreshview N'[dbo].[SMDetailTransactionExtended]'
GO
PRINT N'Refreshing [dbo].[INCB]'
GO
EXEC sp_refreshview N'[dbo].[INCB]'
GO
PRINT N'Refreshing [dbo].[RPRTc]'
GO
EXEC sp_refreshview N'[dbo].[RPRTc]'
GO
PRINT N'Refreshing [dbo].[brvPMMtlSub]'
GO
EXEC sp_refreshview N'[dbo].[brvPMMtlSub]'
GO
PRINT N'Refreshing [dbo].[JCProductionCalcs]'
GO
EXEC sp_refreshview N'[dbo].[JCProductionCalcs]'
GO
PRINT N'Refreshing [dbo].[ptvJCProductionCalc]'
GO
EXEC sp_refreshview N'[dbo].[ptvJCProductionCalc]'
GO
PRINT N'Refreshing [dbo].[JCDO]'
GO
EXEC sp_refreshview N'[dbo].[JCDO]'
GO
PRINT N'Refreshing [dbo].[JCDC]'
GO
EXEC sp_refreshview N'[dbo].[JCDC]'
GO
PRINT N'Refreshing [dbo].[HRCM]'
GO
EXEC sp_refreshview N'[dbo].[HRCM]'
GO
PRINT N'Refreshing [dbo].[vrvHRLeaveApprovers]'
GO
EXEC sp_refreshview N'[dbo].[vrvHRLeaveApprovers]'
GO
PRINT N'Refreshing [dbo].[PMPMSub]'
GO
EXEC sp_refreshview N'[dbo].[PMPMSub]'
GO
PRINT N'Refreshing [dbo].[udxrefPRDedLiab]'
GO
EXEC sp_refreshview N'[dbo].[udxrefPRDedLiab]'
GO
PRINT N'Refreshing [dbo].[DDTHUnionUDTH]'
GO
EXEC sp_refreshview N'[dbo].[DDTHUnionUDTH]'
GO
PRINT N'Refreshing [dbo].[viDim_CubeDataSecurity]'
GO
EXEC sp_refreshview N'[dbo].[viDim_CubeDataSecurity]'
GO
PRINT N'Refreshing [dbo].[EMSX]'
GO
EXEC sp_refreshview N'[dbo].[EMSX]'
GO
PRINT N'Refreshing [dbo].[HQCountry]'
GO
EXEC sp_refreshview N'[dbo].[HQCountry]'
GO
PRINT N'Refreshing [dbo].[SLWIGrid]'
GO
EXEC sp_refreshview N'[dbo].[SLWIGrid]'
GO
PRINT N'Refreshing [dbo].[CMCE]'
GO
EXEC sp_refreshview N'[dbo].[CMCE]'
GO
PRINT N'Refreshing [dbo].[APTT]'
GO
EXEC sp_refreshview N'[dbo].[APTT]'
GO
PRINT N'Refreshing [dbo].[brvPMProjectCostandCOs]'
GO
EXEC sp_refreshview N'[dbo].[brvPMProjectCostandCOs]'
GO
PRINT N'Refreshing [dbo].[EMBG]'
GO
EXEC sp_refreshview N'[dbo].[EMBG]'
GO
PRINT N'Refreshing [dbo].[EMBE]'
GO
EXEC sp_refreshview N'[dbo].[EMBE]'
GO
PRINT N'Refreshing [dbo].[ptvJobData]'
GO
EXEC sp_refreshview N'[dbo].[ptvJobData]'
GO
PRINT N'Refreshing [dbo].[HRRS]'
GO
EXEC sp_refreshview N'[dbo].[HRRS]'
GO
PRINT N'Refreshing [dbo].[PRCACodes]'
GO
EXEC sp_refreshview N'[dbo].[PRCACodes]'
GO
PRINT N'Refreshing [dbo].[GLPD]'
GO
EXEC sp_refreshview N'[dbo].[GLPD]'
GO
PRINT N'Refreshing [dbo].[vrvHRPositions]'
GO
EXEC sp_refreshview N'[dbo].[vrvHRPositions]'
GO
PRINT N'Refreshing [dbo].[PMPMTest]'
GO
EXEC sp_refreshview N'[dbo].[PMPMTest]'
GO
PRINT N'Refreshing [dbo].[PMPU]'
GO
EXEC sp_refreshview N'[dbo].[PMPU]'
GO
PRINT N'Refreshing [dbo].[SLWIHist]'
GO
EXEC sp_refreshview N'[dbo].[SLWIHist]'
GO
PRINT N'Refreshing [dbo].[JCDE]'
GO
EXEC sp_refreshview N'[dbo].[JCDE]'
GO
PRINT N'Refreshing [dbo].[brvPMReminderLtr]'
GO
EXEC sp_refreshview N'[dbo].[brvPMReminderLtr]'
GO
PRINT N'Refreshing [dbo].[ptvPMPunchList]'
GO
EXEC sp_refreshview N'[dbo].[ptvPMPunchList]'
GO
PRINT N'Refreshing [dbo].[JCPR]'
GO
EXEC sp_refreshview N'[dbo].[JCPR]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployeeCodes]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployeeCodes]'
GO
PRINT N'Refreshing [dbo].[GLPI]'
GO
EXEC sp_refreshview N'[dbo].[GLPI]'
GO
PRINT N'Refreshing [dbo].[JBLX]'
GO
EXEC sp_refreshview N'[dbo].[JBLX]'
GO
PRINT N'Refreshing [dbo].[JBIJ]'
GO
EXEC sp_refreshview N'[dbo].[JBIJ]'
GO
PRINT N'Refreshing [dbo].[vrvJBLaborRates]'
GO
EXEC sp_refreshview N'[dbo].[vrvJBLaborRates]'
GO
PRINT N'Refreshing [dbo].[DDFHSharedSingleForm]'
GO
EXEC sp_refreshview N'[dbo].[DDFHSharedSingleForm]'
GO
PRINT N'Refreshing [dbo].[DDFT]'
GO
EXEC sp_refreshview N'[dbo].[DDFT]'
GO
PRINT N'Refreshing [dbo].[PMPN]'
GO
EXEC sp_refreshview N'[dbo].[PMPN]'
GO
PRINT N'Refreshing [dbo].[PMMI]'
GO
EXEC sp_refreshview N'[dbo].[PMMI]'
GO
PRINT N'Refreshing [dbo].[viDim_EMCategory]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMCategory]'
GO
PRINT N'Refreshing [dbo].[EMWS]'
GO
EXEC sp_refreshview N'[dbo].[EMWS]'
GO
PRINT N'Refreshing [dbo].[EMSI]'
GO
EXEC sp_refreshview N'[dbo].[EMSI]'
GO
PRINT N'Refreshing [dbo].[PCBidPackageBidListBidResponse]'
GO
EXEC sp_refreshview N'[dbo].[PCBidPackageBidListBidResponse]'
GO
PRINT N'Refreshing [dbo].[SLWIInvoices]'
GO
EXEC sp_refreshview N'[dbo].[SLWIInvoices]'
GO
PRINT N'Refreshing [dbo].[JCDL]'
GO
EXEC sp_refreshview N'[dbo].[JCDL]'
GO
PRINT N'Refreshing [dbo].[PMCA]'
GO
EXEC sp_refreshview N'[dbo].[PMCA]'
GO
PRINT N'Refreshing [dbo].[brvPMSLCOACOSubCoSort]'
GO
EXEC sp_refreshview N'[dbo].[brvPMSLCOACOSubCoSort]'
GO
PRINT N'Refreshing [dbo].[EMRT]'
GO
EXEC sp_refreshview N'[dbo].[EMRT]'
GO
PRINT N'Refreshing [dbo].[EMRevBdownCategEquip]'
GO
EXEC sp_refreshview N'[dbo].[EMRevBdownCategEquip]'
GO
PRINT N'Refreshing [dbo].[ptvPMPunchListItemDetail]'
GO
EXEC sp_refreshview N'[dbo].[ptvPMPunchListItemDetail]'
GO
PRINT N'Refreshing [dbo].[HRSH_Sorted]'
GO
EXEC sp_refreshview N'[dbo].[HRSH_Sorted]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployeeItems]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployeeItems]'
GO
PRINT N'Refreshing [dbo].[vrvJBProgressBills]'
GO
EXEC sp_refreshview N'[dbo].[vrvJBProgressBills]'
GO
PRINT N'Refreshing [dbo].[DDTS]'
GO
EXEC sp_refreshview N'[dbo].[DDTS]'
GO
PRINT N'Refreshing [dbo].[viDim_EMCompany]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMCompany]'
GO
PRINT N'Refreshing [dbo].[vrvARAgingTotalsByCompany]'
GO
EXEC sp_refreshview N'[dbo].[vrvARAgingTotalsByCompany]'
GO
PRINT N'Refreshing [dbo].[WDJBTableLayout]'
GO
EXEC sp_refreshview N'[dbo].[WDJBTableLayout]'
GO
PRINT N'Refreshing [dbo].[SLWIView]'
GO
EXEC sp_refreshview N'[dbo].[SLWIView]'
GO
PRINT N'Refreshing [dbo].[brvPMSubmittals]'
GO
EXEC sp_refreshview N'[dbo].[brvPMSubmittals]'
GO
PRINT N'Refreshing [dbo].[ptvPMPunchListItems]'
GO
EXEC sp_refreshview N'[dbo].[ptvPMPunchListItems]'
GO
PRINT N'Refreshing [dbo].[HRSP]'
GO
EXEC sp_refreshview N'[dbo].[HRSP]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployeeProvince]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployeeProvince]'
GO
PRINT N'Refreshing [dbo].[GLRB]'
GO
EXEC sp_refreshview N'[dbo].[GLRB]'
GO
PRINT N'Refreshing [dbo].[vrvJBProgressBills_Received]'
GO
EXEC sp_refreshview N'[dbo].[vrvJBProgressBills_Received]'
GO
PRINT N'Refreshing [dbo].[DDFU]'
GO
EXEC sp_refreshview N'[dbo].[DDFU]'
GO
PRINT N'Refreshing [dbo].[PMPOCOTotal]'
GO
EXEC sp_refreshview N'[dbo].[PMPOCOTotal]'
GO
PRINT N'Refreshing [dbo].[DDUC]'
GO
EXEC sp_refreshview N'[dbo].[DDUC]'
GO
PRINT N'Refreshing [dbo].[PRAU]'
GO
EXEC sp_refreshview N'[dbo].[PRAU]'
GO
PRINT N'Refreshing [dbo].[viDim_EMComponent]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMComponent]'
GO
PRINT N'Refreshing [dbo].[HQRoleMemberOverride]'
GO
EXEC sp_refreshview N'[dbo].[HQRoleMemberOverride]'
GO
PRINT N'Refreshing [dbo].[HQRoleLimit]'
GO
EXEC sp_refreshview N'[dbo].[HQRoleLimit]'
GO
PRINT N'Refreshing [dbo].[HQRoles]'
GO
EXEC sp_refreshview N'[dbo].[HQRoles]'
GO
PRINT N'Refreshing [dbo].[vrvHQRolesListByMember]'
GO
EXEC sp_refreshview N'[dbo].[vrvHQRolesListByMember]'
GO
PRINT N'Refreshing [dbo].[APHD]'
GO
EXEC sp_refreshview N'[dbo].[APHD]'
GO
PRINT N'Refreshing [dbo].[PMOMTotals]'
GO
EXEC sp_refreshview N'[dbo].[PMOMTotals]'
GO
PRINT N'Refreshing [dbo].[PMOIPCOTotals]'
GO
EXEC sp_refreshview N'[dbo].[PMOIPCOTotals]'
GO
PRINT N'Refreshing [dbo].[PMOPTotals]'
GO
EXEC sp_refreshview N'[dbo].[PMOPTotals]'
GO
PRINT N'Refreshing [dbo].[brvPMSubSco]'
GO
EXEC sp_refreshview N'[dbo].[brvPMSubSco]'
GO
PRINT N'Refreshing [dbo].[DDLDShared]'
GO
EXEC sp_refreshview N'[dbo].[DDLDShared]'
GO
PRINT N'Refreshing [dbo].[ptvPOCO]'
GO
EXEC sp_refreshview N'[dbo].[ptvPOCO]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployees]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployees]'
GO
PRINT N'Refreshing [dbo].[GLRF]'
GO
EXEC sp_refreshview N'[dbo].[GLRF]'
GO
PRINT N'Refreshing [dbo].[PCPotentialWork]'
GO
EXEC sp_refreshview N'[dbo].[PCPotentialWork]'
GO
PRINT N'Refreshing [dbo].[PCForecastMonth]'
GO
EXEC sp_refreshview N'[dbo].[PCForecastMonth]'
GO
PRINT N'Refreshing [dbo].[JCForecastMonth]'
GO
EXEC sp_refreshview N'[dbo].[JCForecastMonth]'
GO
PRINT N'Refreshing [dbo].[vrvJCBacklogForecast]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCBacklogForecast]'
GO
PRINT N'Refreshing [dbo].[JCOD]'
GO
EXEC sp_refreshview N'[dbo].[JCOD]'
GO
PRINT N'Refreshing [dbo].[PMPOCO_DetailLine_Total]'
GO
EXEC sp_refreshview N'[dbo].[PMPOCO_DetailLine_Total]'
GO
PRINT N'Refreshing [dbo].[viDim_EMCostCode]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMCostCode]'
GO
PRINT N'Refreshing [dbo].[vrvJCIPProjRev]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCIPProjRev]'
GO
PRINT N'Refreshing [dbo].[HQDS]'
GO
EXEC sp_refreshview N'[dbo].[HQDS]'
GO
PRINT N'Refreshing [dbo].[SLXB]'
GO
EXEC sp_refreshview N'[dbo].[SLXB]'
GO
PRINT N'Refreshing [dbo].[PMChangeOrderRequest]'
GO
EXEC sp_refreshview N'[dbo].[PMChangeOrderRequest]'
GO
PRINT N'Refreshing [dbo].[brvPOAudit]'
GO
EXEC sp_refreshview N'[dbo].[brvPOAudit]'
GO
PRINT N'Refreshing [dbo].[ptvPOHD]'
GO
EXEC sp_refreshview N'[dbo].[ptvPOHD]'
GO
PRINT N'Refreshing [dbo].[HRTA]'
GO
EXEC sp_refreshview N'[dbo].[HRTA]'
GO
PRINT N'Refreshing [dbo].[SMCustomerInfo]'
GO
EXEC sp_refreshview N'[dbo].[SMCustomerInfo]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployer]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployer]'
GO
PRINT N'Refreshing [dbo].[vrvJCBacklogNoForecast]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCBacklogNoForecast]'
GO
PRINT N'Refreshing [dbo].[PMPOItemForReview]'
GO
EXEC sp_refreshview N'[dbo].[PMPOItemForReview]'
GO
PRINT N'Refreshing [dbo].[JCPC]'
GO
EXEC sp_refreshview N'[dbo].[JCPC]'
GO
PRINT N'Refreshing [dbo].[WDSettings]'
GO
EXEC sp_refreshview N'[dbo].[WDSettings]'
GO
PRINT N'Refreshing [dbo].[PMML]'
GO
EXEC sp_refreshview N'[dbo].[PMML]'
GO
PRINT N'Refreshing [dbo].[viDim_EMCostType]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMCostType]'
GO
PRINT N'Refreshing [dbo].[INDT]'
GO
EXEC sp_refreshview N'[dbo].[INDT]'
GO
PRINT N'Refreshing [dbo].[vrvJCNetCashFlow]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCNetCashFlow]'
GO
PRINT N'Refreshing [dbo].[SMAdvancedLaborRate]'
GO
EXEC sp_refreshview N'[dbo].[SMAdvancedLaborRate]'
GO
PRINT N'Refreshing [dbo].[JCForecastTotalsCost]'
GO
EXEC sp_refreshview N'[dbo].[JCForecastTotalsCost]'
GO
PRINT N'Refreshing [dbo].[PMChangeOrderRequestPCO]'
GO
EXEC sp_refreshview N'[dbo].[PMChangeOrderRequestPCO]'
GO
PRINT N'Refreshing [dbo].[brvPOCD_DistinctPO]'
GO
EXEC sp_refreshview N'[dbo].[brvPOCD_DistinctPO]'
GO
PRINT N'Refreshing [dbo].[DDMFShared]'
GO
EXEC sp_refreshview N'[dbo].[DDMFShared]'
GO
PRINT N'Refreshing [dbo].[ptvPOIT]'
GO
EXEC sp_refreshview N'[dbo].[ptvPOIT]'
GO
PRINT N'Refreshing [dbo].[HRTC]'
GO
EXEC sp_refreshview N'[dbo].[HRTC]'
GO
PRINT N'Refreshing [dbo].[HRCA]'
GO
EXEC sp_refreshview N'[dbo].[HRCA]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployerCodes]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployerCodes]'
GO
PRINT N'Refreshing [dbo].[GLYBClosed]'
GO
EXEC sp_refreshview N'[dbo].[GLYBClosed]'
GO
PRINT N'Refreshing [dbo].[vrvJCCmtdCostDDAttachments]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCCmtdCostDDAttachments]'
GO
PRINT N'Refreshing [dbo].[PMPOTotal]'
GO
EXEC sp_refreshview N'[dbo].[PMPOTotal]'
GO
PRINT N'Refreshing [dbo].[viDim_EMDepartment]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMDepartment]'
GO
PRINT N'Refreshing [dbo].[brvSLLedgerDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvSLLedgerDetail]'
GO
PRINT N'Refreshing [dbo].[vrvPCSubcontractRisk]'
GO
EXEC sp_refreshview N'[dbo].[vrvPCSubcontractRisk]'
GO
PRINT N'Refreshing [dbo].[HQDR]'
GO
EXEC sp_refreshview N'[dbo].[HQDR]'
GO
PRINT N'Refreshing [dbo].[JCForecastTotalsRev]'
GO
EXEC sp_refreshview N'[dbo].[JCForecastTotalsRev]'
GO
PRINT N'Refreshing [dbo].[brvPOChgOrderSummary]'
GO
EXEC sp_refreshview N'[dbo].[brvPOChgOrderSummary]'
GO
PRINT N'Refreshing [dbo].[WFProcessDetailApproverForPO]'
GO
EXEC sp_refreshview N'[dbo].[WFProcessDetailApproverForPO]'
GO
PRINT N'Refreshing [dbo].[WFProcessDetailApproverForPMMF]'
GO
EXEC sp_refreshview N'[dbo].[WFProcessDetailApproverForPMMF]'
GO
PRINT N'Refreshing [dbo].[ptvPRCC]'
GO
EXEC sp_refreshview N'[dbo].[ptvPRCC]'
GO
PRINT N'Refreshing [dbo].[HRTCGrid]'
GO
EXEC sp_refreshview N'[dbo].[HRTCGrid]'
GO
PRINT N'Refreshing [dbo].[GLYBClosedNoHeaders]'
GO
EXEC sp_refreshview N'[dbo].[GLYBClosedNoHeaders]'
GO
PRINT N'Refreshing [dbo].[PORD]'
GO
EXEC sp_refreshview N'[dbo].[PORD]'
GO
PRINT N'Refreshing [dbo].[vrvJCCommittedCost]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCCommittedCost]'
GO
PRINT N'Refreshing [dbo].[SMWorkScope]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkScope]'
GO
PRINT N'Refreshing [dbo].[viDim_EMEquipment]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMEquipment]'
GO
PRINT N'Refreshing [dbo].[PRRO]'
GO
EXEC sp_refreshview N'[dbo].[PRRO]'
GO
PRINT N'Refreshing [dbo].[PRRN]'
GO
EXEC sp_refreshview N'[dbo].[PRRN]'
GO
PRINT N'Refreshing [dbo].[POSL]'
GO
EXEC sp_refreshview N'[dbo].[POSL]'
GO
PRINT N'Refreshing [dbo].[brvJCContrMinJob]'
GO
EXEC sp_refreshview N'[dbo].[brvJCContrMinJob]'
GO
PRINT N'Refreshing [dbo].[vrvPMContractAnalysisDD]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMContractAnalysisDD]'
GO
PRINT N'Refreshing [dbo].[APDB]'
GO
EXEC sp_refreshview N'[dbo].[APDB]'
GO
PRINT N'Refreshing [dbo].[brvAPPayCurrent]'
GO
EXEC sp_refreshview N'[dbo].[brvAPPayCurrent]'
GO
PRINT N'Refreshing [dbo].[JCFuturePMCO]'
GO
EXEC sp_refreshview N'[dbo].[JCFuturePMCO]'
GO
PRINT N'Refreshing [dbo].[brvPOCT_DistinctPO]'
GO
EXEC sp_refreshview N'[dbo].[brvPOCT_DistinctPO]'
GO
PRINT N'Refreshing [dbo].[ptvPRCO]'
GO
EXEC sp_refreshview N'[dbo].[ptvPRCO]'
GO
PRINT N'Refreshing [dbo].[HRTCHead]'
GO
EXEC sp_refreshview N'[dbo].[HRTCHead]'
GO
PRINT N'Refreshing [dbo].[PRCAEmployerProvince]'
GO
EXEC sp_refreshview N'[dbo].[PRCAEmployerProvince]'
GO
PRINT N'Refreshing [dbo].[vrvJCContItemCostEstimate]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCContItemCostEstimate]'
GO
PRINT N'Refreshing [dbo].[PMProjectApprovalProcess]'
GO
EXEC sp_refreshview N'[dbo].[PMProjectApprovalProcess]'
GO
PRINT N'Refreshing [dbo].[viDim_EMMechanic]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMMechanic]'
GO
PRINT N'Refreshing [dbo].[vrvPMContractStatusDD]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMContractStatusDD]'
GO
PRINT N'Refreshing [dbo].[brvAPTaxGST]'
GO
EXEC sp_refreshview N'[dbo].[brvAPTaxGST]'
GO
PRINT N'Refreshing [dbo].[HQIC]'
GO
EXEC sp_refreshview N'[dbo].[HQIC]'
GO
PRINT N'Refreshing [dbo].[brvPOCurCost]'
GO
EXEC sp_refreshview N'[dbo].[brvPOCurCost]'
GO
PRINT N'Refreshing [dbo].[ptvPREC]'
GO
EXEC sp_refreshview N'[dbo].[ptvPREC]'
GO
PRINT N'Refreshing [dbo].[brvPRW2Box14StateEntries]'
GO
EXEC sp_refreshview N'[dbo].[brvPRW2Box14StateEntries]'
GO
PRINT N'Refreshing [dbo].[brvPRW2Box14FederalEntriesBase]'
GO
EXEC sp_refreshview N'[dbo].[brvPRW2Box14FederalEntriesBase]'
GO
PRINT N'Refreshing [dbo].[brvPRW2Box14FederalEntries]'
GO
EXEC sp_refreshview N'[dbo].[brvPRW2Box14FederalEntries]'
GO
PRINT N'Refreshing [dbo].[brvPRW2Box12]'
GO
EXEC sp_refreshview N'[dbo].[brvPRW2Box12]'
GO
PRINT N'Refreshing [dbo].[vwMckNewProject]'
GO
EXEC sp_refreshview N'[dbo].[vwMckNewProject]'
GO
PRINT N'Refreshing [dbo].[vrvJCContractMaster]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCContractMaster]'
GO
PRINT N'Refreshing [dbo].[viDim_EMRevenueCode]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMRevenueCode]'
GO
PRINT N'Refreshing [dbo].[EMSH]'
GO
EXEC sp_refreshview N'[dbo].[EMSH]'
GO
PRINT N'Refreshing [dbo].[vrvPMSCOTotal]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMSCOTotal]'
GO
PRINT N'Refreshing [dbo].[vrvPMPOCOTotal]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMPOCOTotal]'
GO
PRINT N'Refreshing [dbo].[brvSLCT_DistinctSL]'
GO
EXEC sp_refreshview N'[dbo].[brvSLCT_DistinctSL]'
GO
PRINT N'Refreshing [dbo].[vrvPMVendorRegister]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMVendorRegister]'
GO
PRINT N'Refreshing [dbo].[WDQF]'
GO
EXEC sp_refreshview N'[dbo].[WDQF]'
GO
PRINT N'Refreshing [dbo].[brvAPTL_DistinctPO]'
GO
EXEC sp_refreshview N'[dbo].[brvAPTL_DistinctPO]'
GO
PRINT N'Refreshing [dbo].[brvPOCurCostByVendor]'
GO
EXEC sp_refreshview N'[dbo].[brvPOCurCostByVendor]'
GO
PRINT N'Refreshing [dbo].[ptvPREH]'
GO
EXEC sp_refreshview N'[dbo].[ptvPREH]'
GO
PRINT N'Refreshing [dbo].[PRCB]'
GO
EXEC sp_refreshview N'[dbo].[PRCB]'
GO
PRINT N'Refreshing [dbo].[JCAD]'
GO
EXEC sp_refreshview N'[dbo].[JCAD]'
GO
PRINT N'Refreshing [dbo].[vrvJCCostRevenueExcept]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCCostRevenueExcept]'
GO
PRINT N'Refreshing [dbo].[PRCH]'
GO
EXEC sp_refreshview N'[dbo].[PRCH]'
GO
PRINT N'Refreshing [dbo].[pvPMMyPOChangeOrder]'
GO
EXEC sp_refreshview N'[dbo].[pvPMMyPOChangeOrder]'
GO
PRINT N'Refreshing [dbo].[viDim_EMScheduledMaintenance]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMScheduledMaintenance]'
GO
PRINT N'Refreshing [dbo].[SMInvoiceDetailChanges]'
GO
EXEC sp_refreshview N'[dbo].[SMInvoiceDetailChanges]'
GO
PRINT N'Refreshing [dbo].[PMUD]'
GO
EXEC sp_refreshview N'[dbo].[PMUD]'
GO
PRINT N'Refreshing [dbo].[vrvSMServiceItemWithAgreement]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMServiceItemWithAgreement]'
GO
PRINT N'Refreshing [dbo].[vrvSMAgreementQuoteServiceDetails]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMAgreementQuoteServiceDetails]'
GO
PRINT N'Refreshing [dbo].[brvAPTL_DistinctSL]'
GO
EXEC sp_refreshview N'[dbo].[brvAPTL_DistinctSL]'
GO
PRINT N'Refreshing [dbo].[APCT]'
GO
EXEC sp_refreshview N'[dbo].[APCT]'
GO
PRINT N'Refreshing [dbo].[brvPOMaxMatUC]'
GO
EXEC sp_refreshview N'[dbo].[brvPOMaxMatUC]'
GO
PRINT N'Refreshing [dbo].[PMRFIResponse]'
GO
EXEC sp_refreshview N'[dbo].[PMRFIResponse]'
GO
PRINT N'Refreshing [dbo].[ptvPREHViewCombined]'
GO
EXEC sp_refreshview N'[dbo].[ptvPREHViewCombined]'
GO
PRINT N'Refreshing [dbo].[vrvJCCP]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCCP]'
GO
PRINT N'Refreshing [dbo].[PMPS]'
GO
EXEC sp_refreshview N'[dbo].[PMPS]'
GO
PRINT N'Refreshing [dbo].[DDUPExtended]'
GO
EXEC sp_refreshview N'[dbo].[DDUPExtended]'
GO
PRINT N'Refreshing [dbo].[viDim_EMStdMaintGroup]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMStdMaintGroup]'
GO
PRINT N'Refreshing [dbo].[PMWX]'
GO
EXEC sp_refreshview N'[dbo].[PMWX]'
GO
PRINT N'Refreshing [dbo].[PMUR]'
GO
EXEC sp_refreshview N'[dbo].[PMUR]'
GO
PRINT N'Refreshing [dbo].[vrvSMTechnicianList]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMTechnicianList]'
GO
PRINT N'Refreshing [dbo].[vrvSMServiceSiteCustomer]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMServiceSiteCustomer]'
GO
PRINT N'Refreshing [dbo].[vrvSMInvoiceList]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMInvoiceList]'
GO
PRINT N'Refreshing [dbo].[brvAPTotalAPTDAmt]'
GO
EXEC sp_refreshview N'[dbo].[brvAPTotalAPTDAmt]'
GO
PRINT N'Refreshing [dbo].[SMAgreementServiceBillingSched]'
GO
EXEC sp_refreshview N'[dbo].[SMAgreementServiceBillingSched]'
GO
PRINT N'Refreshing [dbo].[JCIB]'
GO
EXEC sp_refreshview N'[dbo].[JCIB]'
GO
PRINT N'Refreshing [dbo].[brvPOMaxMatVendorUC]'
GO
EXEC sp_refreshview N'[dbo].[brvPOMaxMatVendorUC]'
GO
PRINT N'Refreshing [dbo].[ptvPRMechWO]'
GO
EXEC sp_refreshview N'[dbo].[ptvPRMechWO]'
GO
PRINT N'Refreshing [dbo].[vrvJCDashboardSubcontract]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCDashboardSubcontract]'
GO
PRINT N'Refreshing [dbo].[viDim_EMWarranty]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMWarranty]'
GO
PRINT N'Refreshing [dbo].[vrvWFProcessApprovalOutstandingDocs]'
GO
EXEC sp_refreshview N'[dbo].[vrvWFProcessApprovalOutstandingDocs]'
GO
PRINT N'Refreshing [dbo].[brvARBH_CMDist]'
GO
EXEC sp_refreshview N'[dbo].[brvARBH_CMDist]'
GO
PRINT N'Refreshing [dbo].[JCIBGrid]'
GO
EXEC sp_refreshview N'[dbo].[JCIBGrid]'
GO
PRINT N'Refreshing [dbo].[brvPOPurchStats]'
GO
EXEC sp_refreshview N'[dbo].[brvPOPurchStats]'
GO
PRINT N'Refreshing [dbo].[ptvPRMechWOItem]'
GO
EXEC sp_refreshview N'[dbo].[ptvPRMechWOItem]'
GO
PRINT N'Refreshing [dbo].[HQApprovalModule]'
GO
EXEC sp_refreshview N'[dbo].[HQApprovalModule]'
GO
PRINT N'Refreshing [dbo].[vrvJCDetProjections]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCDetProjections]'
GO
PRINT N'Refreshing [dbo].[DDFS]'
GO
EXEC sp_refreshview N'[dbo].[DDFS]'
GO
PRINT N'Refreshing [dbo].[viDim_EMWorkOrder]'
GO
EXEC sp_refreshview N'[dbo].[viDim_EMWorkOrder]'
GO
PRINT N'Refreshing [dbo].[RQQH]'
GO
EXEC sp_refreshview N'[dbo].[RQQH]'
GO
PRINT N'Refreshing [dbo].[brvPORecptExpGlRec]'
GO
EXEC sp_refreshview N'[dbo].[brvPORecptExpGlRec]'
GO
PRINT N'Refreshing [dbo].[JCAJ]'
GO
EXEC sp_refreshview N'[dbo].[JCAJ]'
GO
PRINT N'Refreshing [dbo].[vrvJCEstCostComplete_Except]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCEstCostComplete_Except]'
GO
PRINT N'Refreshing [dbo].[viDim_GLFiscalMth]'
GO
EXEC sp_refreshview N'[dbo].[viDim_GLFiscalMth]'
GO
PRINT N'Refreshing [dbo].[brvARInvCreditNotes]'
GO
EXEC sp_refreshview N'[dbo].[brvARInvCreditNotes]'
GO
PRINT N'Refreshing [dbo].[brvPR9412005FormEmpCount]'
GO
EXEC sp_refreshview N'[dbo].[brvPR9412005FormEmpCount]'
GO
PRINT N'Refreshing [dbo].[EMSL]'
GO
EXEC sp_refreshview N'[dbo].[EMSL]'
GO
PRINT N'Refreshing [dbo].[vrvJCJobEstDrill]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCJobEstDrill]'
GO
PRINT N'Refreshing [dbo].[viDim_HQMaterial]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HQMaterial]'
GO
PRINT N'Refreshing [dbo].[POSM]'
GO
EXEC sp_refreshview N'[dbo].[POSM]'
GO
PRINT N'Refreshing [dbo].[brvAROpenTrans]'
GO
EXEC sp_refreshview N'[dbo].[brvAROpenTrans]'
GO
PRINT N'Refreshing [dbo].[brvPR941Form]'
GO
EXEC sp_refreshview N'[dbo].[brvPR941Form]'
GO
PRINT N'Refreshing [dbo].[vrvJCJobMaster]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCJobMaster]'
GO
PRINT N'Refreshing [dbo].[UDTH]'
GO
EXEC sp_refreshview N'[dbo].[UDTH]'
GO
PRINT N'Refreshing [dbo].[viDim_HRAccidents]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HRAccidents]'
GO
PRINT N'Refreshing [dbo].[brvARReceivedTax]'
GO
EXEC sp_refreshview N'[dbo].[brvARReceivedTax]'
GO
PRINT N'Refreshing [dbo].[brvPRAttachments]'
GO
EXEC sp_refreshview N'[dbo].[brvPRAttachments]'
GO
PRINT N'Refreshing [dbo].[JBLO]'
GO
EXEC sp_refreshview N'[dbo].[JBLO]'
GO
PRINT N'Refreshing [dbo].[APPT]'
GO
EXEC sp_refreshview N'[dbo].[APPT]'
GO
PRINT N'Refreshing [dbo].[vrvJCLastMonthOfActivityByContract]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCLastMonthOfActivityByContract]'
GO
PRINT N'Refreshing [dbo].[PMRFIResponseDoc]'
GO
EXEC sp_refreshview N'[dbo].[PMRFIResponseDoc]'
GO
PRINT N'Refreshing [dbo].[viDim_HRBenefitCodes]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HRBenefitCodes]'
GO
PRINT N'Refreshing [dbo].[brvEMMR]'
GO
EXEC sp_refreshview N'[dbo].[brvEMMR]'
GO
PRINT N'Refreshing [dbo].[brvEMMeterVsRevenue]'
GO
EXEC sp_refreshview N'[dbo].[brvEMMeterVsRevenue]'
GO
PRINT N'Refreshing [dbo].[brvARRTRecap]'
GO
EXEC sp_refreshview N'[dbo].[brvARRTRecap]'
GO
PRINT N'Refreshing [dbo].[JCIRTotals]'
GO
EXEC sp_refreshview N'[dbo].[JCIRTotals]'
GO
PRINT N'Refreshing [dbo].[brvPRDedNotTaken]'
GO
EXEC sp_refreshview N'[dbo].[brvPRDedNotTaken]'
GO
PRINT N'Refreshing [dbo].[PRGS]'
GO
EXEC sp_refreshview N'[dbo].[PRGS]'
GO
PRINT N'Refreshing [dbo].[DDNotificationPrefs]'
GO
EXEC sp_refreshview N'[dbo].[DDNotificationPrefs]'
GO
PRINT N'Refreshing [dbo].[MSHB]'
GO
EXEC sp_refreshview N'[dbo].[MSHB]'
GO
PRINT N'Refreshing [dbo].[vrvJCProjectionByContractMonth]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCProjectionByContractMonth]'
GO
PRINT N'Refreshing [dbo].[viDim_HRCodeMaster]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HRCodeMaster]'
GO
PRINT N'Refreshing [dbo].[brvGLFSPart3]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSPart3]'
GO
PRINT N'Refreshing [dbo].[brvGLFSPart2]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSPart2]'
GO
PRINT N'Refreshing [dbo].[brvGLBudget]'
GO
EXEC sp_refreshview N'[dbo].[brvGLBudget]'
GO
PRINT N'Refreshing [dbo].[SMClass]'
GO
EXEC sp_refreshview N'[dbo].[SMClass]'
GO
PRINT N'Refreshing [dbo].[brvPRDeptCostExpMonth]'
GO
EXEC sp_refreshview N'[dbo].[brvPRDeptCostExpMonth]'
GO
PRINT N'Refreshing [dbo].[vrvJCRatesUnbilledAnalysis]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCRatesUnbilledAnalysis]'
GO
PRINT N'Refreshing [dbo].[PMRIGrid]'
GO
EXEC sp_refreshview N'[dbo].[PMRIGrid]'
GO
PRINT N'Refreshing [dbo].[viDim_HRCompany]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HRCompany]'
GO
PRINT N'Refreshing [dbo].[brvHQAuditDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvHQAuditDetail]'
GO
PRINT N'Refreshing [dbo].[brvDatatypeSecurity]'
GO
EXEC sp_refreshview N'[dbo].[brvDatatypeSecurity]'
GO
PRINT N'Refreshing [dbo].[JCJMJobs]'
GO
EXEC sp_refreshview N'[dbo].[JCJMJobs]'
GO
PRINT N'Refreshing [dbo].[brvPRDeptCostLiab]'
GO
EXEC sp_refreshview N'[dbo].[brvPRDeptCostLiab]'
GO
PRINT N'Refreshing [dbo].[vrvJCRevCostComplete]'
GO
EXEC sp_refreshview N'[dbo].[vrvJCRevCostComplete]'
GO
PRINT N'Refreshing [dbo].[viDim_HRPositionCode]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HRPositionCode]'
GO
PRINT N'Refreshing [dbo].[brvPRInsVarRate]'
GO
EXEC sp_refreshview N'[dbo].[brvPRInsVarRate]'
GO
PRINT N'Refreshing [dbo].[brvPRInsJob]'
GO
EXEC sp_refreshview N'[dbo].[brvPRInsJob]'
GO
PRINT N'Refreshing [dbo].[brvPRDL_APCO]'
GO
EXEC sp_refreshview N'[dbo].[brvPRDL_APCO]'
GO
PRINT N'Refreshing [dbo].[PMDL]'
GO
EXEC sp_refreshview N'[dbo].[PMDL]'
GO
PRINT N'Refreshing [dbo].[PRCraftClassAllowance]'
GO
EXEC sp_refreshview N'[dbo].[PRCraftClassAllowance]'
GO
PRINT N'Refreshing [dbo].[vrvJC_PM_ChgOrderCostCompare]'
GO
EXEC sp_refreshview N'[dbo].[vrvJC_PM_ChgOrderCostCompare]'
GO
PRINT N'Refreshing [dbo].[PMRQGrid]'
GO
EXEC sp_refreshview N'[dbo].[PMRQGrid]'
GO
PRINT N'Refreshing [dbo].[viDim_HRResource]'
GO
EXEC sp_refreshview N'[dbo].[viDim_HRResource]'
GO
PRINT N'Refreshing [dbo].[EMWF]'
GO
EXEC sp_refreshview N'[dbo].[EMWF]'
GO
PRINT N'Refreshing [dbo].[EMPS]'
GO
EXEC sp_refreshview N'[dbo].[EMPS]'
GO
PRINT N'Refreshing [dbo].[EMDO]'
GO
EXEC sp_refreshview N'[dbo].[EMDO]'
GO
PRINT N'Refreshing [dbo].[EMDG]'
GO
EXEC sp_refreshview N'[dbo].[EMDG]'
GO
PRINT N'Refreshing [dbo].[vrvPREA_YearEndMonths]'
GO
EXEC sp_refreshview N'[dbo].[vrvPREA_YearEndMonths]'
GO
PRINT N'Refreshing [dbo].[PRPH]'
GO
EXEC sp_refreshview N'[dbo].[PRPH]'
GO
PRINT N'Refreshing [dbo].[brvPRDrillDown]'
GO
EXEC sp_refreshview N'[dbo].[brvPRDrillDown]'
GO
PRINT N'Refreshing [dbo].[MSIB]'
GO
EXEC sp_refreshview N'[dbo].[MSIB]'
GO
PRINT N'Refreshing [dbo].[APLBforWO]'
GO
EXEC sp_refreshview N'[dbo].[APLBforWO]'
GO
PRINT N'Refreshing [dbo].[ReportUsers]'
GO
EXEC sp_refreshview N'[dbo].[ReportUsers]'
GO
PRINT N'Refreshing [dbo].[PRCraftClassTemplateAllowance]'
GO
EXEC sp_refreshview N'[dbo].[PRCraftClassTemplateAllowance]'
GO
PRINT N'Refreshing [dbo].[MSIH]'
GO
EXEC sp_refreshview N'[dbo].[MSIH]'
GO
PRINT N'Refreshing [dbo].[vrvMSInvoice]'
GO
EXEC sp_refreshview N'[dbo].[vrvMSInvoice]'
GO
PRINT N'Refreshing [dbo].[WDJB]'
GO
EXEC sp_refreshview N'[dbo].[WDJB]'
GO
PRINT N'Refreshing [dbo].[WDJob]'
GO
EXEC sp_refreshview N'[dbo].[WDJob]'
GO
PRINT N'Refreshing [dbo].[WDJBTableColumns]'
GO
EXEC sp_refreshview N'[dbo].[WDJBTableColumns]'
GO
PRINT N'Refreshing [dbo].[viDim_INLocation]'
GO
EXEC sp_refreshview N'[dbo].[viDim_INLocation]'
GO
PRINT N'Refreshing [dbo].[EMChangeEquipCol]'
GO
EXEC sp_refreshview N'[dbo].[EMChangeEquipCol]'
GO
PRINT N'Refreshing [dbo].[EMChangeBatchCol]'
GO
EXEC sp_refreshview N'[dbo].[EMChangeBatchCol]'
GO
PRINT N'Refreshing [dbo].[JCJobRoles]'
GO
EXEC sp_refreshview N'[dbo].[JCJobRoles]'
GO
PRINT N'Refreshing [dbo].[brvPRDrlDwnPREndDate]'
GO
EXEC sp_refreshview N'[dbo].[brvPRDrlDwnPREndDate]'
GO
PRINT N'Refreshing [dbo].[HRAT]'
GO
EXEC sp_refreshview N'[dbo].[HRAT]'
GO
PRINT N'Refreshing [dbo].[JCRD]'
GO
EXEC sp_refreshview N'[dbo].[JCRD]'
GO
PRINT N'Refreshing [dbo].[APLBOnCostStatus]'
GO
EXEC sp_refreshview N'[dbo].[APLBOnCostStatus]'
GO
PRINT N'Refreshing [dbo].[PRCraftMasterAllowance]'
GO
EXEC sp_refreshview N'[dbo].[PRCraftMasterAllowance]'
GO
PRINT N'Refreshing [dbo].[APAA]'
GO
EXEC sp_refreshview N'[dbo].[APAA]'
GO
PRINT N'Creating [dbo].[PRAULimitsAndRates]'
GO
CREATE view [dbo].[PRAULimitsAndRates] as select a.* From vPRAULimitsAndRates a
GO
PRINT N'Refreshing [dbo].[vrvMSQuoteStatusDetail]'
GO
EXEC sp_refreshview N'[dbo].[vrvMSQuoteStatusDetail]'
GO
PRINT N'Refreshing [dbo].[viDim_JCCompany]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCCompany]'
GO
PRINT N'Refreshing [dbo].[EMChangeBatchEquipEMCoCol]'
GO
EXEC sp_refreshview N'[dbo].[EMChangeBatchEquipEMCoCol]'
GO
PRINT N'Refreshing [dbo].[brvMSHaul_APTH_DistinctAPRef]'
GO
EXEC sp_refreshview N'[dbo].[brvMSHaul_APTH_DistinctAPRef]'
GO
PRINT N'Refreshing [dbo].[SMCustomerContact]'
GO
EXEC sp_refreshview N'[dbo].[SMCustomerContact]'
GO
PRINT N'Refreshing [dbo].[JCJobRolesPM]'
GO
EXEC sp_refreshview N'[dbo].[JCJobRolesPM]'
GO
PRINT N'Refreshing [dbo].[brvPREarnByDept]'
GO
EXEC sp_refreshview N'[dbo].[brvPREarnByDept]'
GO
PRINT N'Refreshing [dbo].[APOnCostAPTrans]'
GO
EXEC sp_refreshview N'[dbo].[APOnCostAPTrans]'
GO
PRINT N'Refreshing [dbo].[DDQueryableViews]'
GO
EXEC sp_refreshview N'[dbo].[DDQueryableViews]'
GO
PRINT N'Refreshing [dbo].[DDQueryableViewsShared]'
GO
EXEC sp_refreshview N'[dbo].[DDQueryableViewsShared]'
GO
PRINT N'Refreshing [dbo].[DDQueryableColumns]'
GO
EXEC sp_refreshview N'[dbo].[DDQueryableColumns]'
GO
PRINT N'Refreshing [dbo].[DDQueryableColumnsShared]'
GO
EXEC sp_refreshview N'[dbo].[DDQueryableColumnsShared]'
GO
PRINT N'Refreshing [dbo].[PRCraftTemplateAllowance]'
GO
EXEC sp_refreshview N'[dbo].[PRCraftTemplateAllowance]'
GO
PRINT N'Refreshing [dbo].[HQHC]'
GO
EXEC sp_refreshview N'[dbo].[HQHC]'
GO
PRINT N'Refreshing [dbo].[APVH]'
GO
EXEC sp_refreshview N'[dbo].[APVH]'
GO
PRINT N'Refreshing [dbo].[vrvMSTicketQuoteSalesDetail]'
GO
EXEC sp_refreshview N'[dbo].[vrvMSTicketQuoteSalesDetail]'
GO
PRINT N'Refreshing [dbo].[EMAD]'
GO
EXEC sp_refreshview N'[dbo].[EMAD]'
GO
PRINT N'Refreshing [dbo].[viDim_JCContract]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCContract]'
GO
PRINT N'Refreshing [dbo].[EMChangeBatchList]'
GO
EXEC sp_refreshview N'[dbo].[EMChangeBatchList]'
GO
PRINT N'Refreshing [dbo].[brvPMBallInCourtNotifier]'
GO
EXEC sp_refreshview N'[dbo].[brvPMBallInCourtNotifier]'
GO
PRINT N'Refreshing [dbo].[brvPREarnings]'
GO
EXEC sp_refreshview N'[dbo].[brvPREarnings]'
GO
PRINT N'Refreshing [dbo].[pvPMEMCoSelector]'
GO
EXEC sp_refreshview N'[dbo].[pvPMEMCoSelector]'
GO
PRINT N'Refreshing [dbo].[APOnCostExpMth]'
GO
EXEC sp_refreshview N'[dbo].[APOnCostExpMth]'
GO
PRINT N'Refreshing [dbo].[vrvPCCurrentProjectGoals]'
GO
EXEC sp_refreshview N'[dbo].[vrvPCCurrentProjectGoals]'
GO
PRINT N'Refreshing [dbo].[PMSLTotal]'
GO
EXEC sp_refreshview N'[dbo].[PMSLTotal]'
GO
PRINT N'Refreshing [dbo].[EMAE]'
GO
EXEC sp_refreshview N'[dbo].[EMAE]'
GO
PRINT N'Refreshing [dbo].[viDim_JCContractItem]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCContractItem]'
GO
PRINT N'Refreshing [dbo].[PCBidCoverageOverview]'
GO
EXEC sp_refreshview N'[dbo].[PCBidCoverageOverview]'
GO
PRINT N'Refreshing [dbo].[PCBidCoverage]'
GO
EXEC sp_refreshview N'[dbo].[PCBidCoverage]'
GO
PRINT N'Refreshing [dbo].[INTB]'
GO
EXEC sp_refreshview N'[dbo].[INTB]'
GO
PRINT N'Refreshing [dbo].[INPD]'
GO
EXEC sp_refreshview N'[dbo].[INPD]'
GO
PRINT N'Refreshing [dbo].[INPB]'
GO
EXEC sp_refreshview N'[dbo].[INPB]'
GO
PRINT N'Refreshing [dbo].[INBL]'
GO
EXEC sp_refreshview N'[dbo].[INBL]'
GO
PRINT N'Refreshing [dbo].[INBH]'
GO
EXEC sp_refreshview N'[dbo].[INBH]'
GO
PRINT N'Refreshing [dbo].[INAB]'
GO
EXEC sp_refreshview N'[dbo].[INAB]'
GO
PRINT N'Refreshing [dbo].[APTransTotals]'
GO
EXEC sp_refreshview N'[dbo].[APTransTotals]'
GO
PRINT N'Refreshing [dbo].[JCJPPM]'
GO
EXEC sp_refreshview N'[dbo].[JCJPPM]'
GO
PRINT N'Refreshing [dbo].[brvPRECConvert]'
GO
EXEC sp_refreshview N'[dbo].[brvPRECConvert]'
GO
PRINT N'Refreshing [dbo].[APOnCostVendorTypesYN]'
GO
EXEC sp_refreshview N'[dbo].[APOnCostVendorTypesYN]'
GO
PRINT N'Refreshing [dbo].[PORS]'
GO
EXEC sp_refreshview N'[dbo].[PORS]'
GO
PRINT N'Refreshing [dbo].[vrvPCPotentialWorkForecast]'
GO
EXEC sp_refreshview N'[dbo].[vrvPCPotentialWorkForecast]'
GO
PRINT N'Refreshing [dbo].[EMAG]'
GO
EXEC sp_refreshview N'[dbo].[EMAG]'
GO
PRINT N'Refreshing [dbo].[viDim_JCCostType]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCCostType]'
GO
PRINT N'Refreshing [dbo].[PMBC]'
GO
EXEC sp_refreshview N'[dbo].[PMBC]'
GO
PRINT N'Refreshing [dbo].[PCBidPackageBidListBidStatus]'
GO
EXEC sp_refreshview N'[dbo].[PCBidPackageBidListBidStatus]'
GO
PRINT N'Refreshing [dbo].[brvSLAPAmounts]'
GO
EXEC sp_refreshview N'[dbo].[brvSLAPAmounts]'
GO
PRINT N'Refreshing [dbo].[JCJPProjMinPct]'
GO
EXEC sp_refreshview N'[dbo].[JCJPProjMinPct]'
GO
PRINT N'Refreshing [dbo].[brvPREC_PhsGrp]'
GO
EXEC sp_refreshview N'[dbo].[brvPREC_PhsGrp]'
GO
PRINT N'Refreshing [dbo].[IMWHImportId]'
GO
EXEC sp_refreshview N'[dbo].[IMWHImportId]'
GO
PRINT N'Refreshing [dbo].[APRefUnionforSL]'
GO
EXEC sp_refreshview N'[dbo].[APRefUnionforSL]'
GO
PRINT N'Refreshing [dbo].[vrvPCSWMBESubcontracts]'
GO
EXEC sp_refreshview N'[dbo].[vrvPCSWMBESubcontracts]'
GO
PRINT N'Refreshing [dbo].[PMSS]'
GO
EXEC sp_refreshview N'[dbo].[PMSS]'
GO
PRINT N'Refreshing [dbo].[EMAH]'
GO
EXEC sp_refreshview N'[dbo].[EMAH]'
GO
PRINT N'Refreshing [dbo].[viDim_JCDept]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCDept]'
GO
PRINT N'Refreshing [dbo].[PMOIACOTotals]'
GO
EXEC sp_refreshview N'[dbo].[PMOIACOTotals]'
GO
PRINT N'Refreshing [dbo].[JCJPRoles]'
GO
EXEC sp_refreshview N'[dbo].[JCJPRoles]'
GO
PRINT N'Refreshing [dbo].[brvPREH]'
GO
EXEC sp_refreshview N'[dbo].[brvPREH]'
GO
PRINT N'Refreshing [dbo].[APRL]'
GO
EXEC sp_refreshview N'[dbo].[APRL]'
GO
PRINT N'Refreshing [dbo].[APRLforWO]'
GO
EXEC sp_refreshview N'[dbo].[APRLforWO]'
GO
PRINT N'Creating [dbo].[PREmplPeriodsWithoutPay]'
GO
CREATE view [dbo].[PREmplPeriodsWithoutPay] as select a.* From vPREmplPeriodsWithoutPay a
GO
PRINT N'Refreshing [dbo].[MSLB]'
GO
EXEC sp_refreshview N'[dbo].[MSLB]'
GO
PRINT N'Refreshing [dbo].[vrvPMBuyOutReportDD]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMBuyOutReportDD]'
GO
PRINT N'Refreshing [dbo].[EMAR]'
GO
EXEC sp_refreshview N'[dbo].[EMAR]'
GO
PRINT N'Refreshing [dbo].[viDim_JCDeptContract_Hierarchy]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCDeptContract_Hierarchy]'
GO
PRINT N'Refreshing [dbo].[PMOICalc]'
GO
EXEC sp_refreshview N'[dbo].[PMOICalc]'
GO
PRINT N'Refreshing [dbo].[JCJPRolesPM]'
GO
EXEC sp_refreshview N'[dbo].[JCJPRolesPM]'
GO
PRINT N'Refreshing [dbo].[brvPRFlash_PRRE]'
GO
EXEC sp_refreshview N'[dbo].[brvPRFlash_PRRE]'
GO
PRINT N'Refreshing [dbo].[APULforWO]'
GO
EXEC sp_refreshview N'[dbo].[APULforWO]'
GO
PRINT N'Refreshing [dbo].[WDJP]'
GO
EXEC sp_refreshview N'[dbo].[WDJP]'
GO
PRINT N'Refreshing [dbo].[MSHH]'
GO
EXEC sp_refreshview N'[dbo].[MSHH]'
GO
PRINT N'Refreshing [dbo].[vrvPMChangeOrderCostDetail]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMChangeOrderCostDetail]'
GO
PRINT N'Refreshing [dbo].[PMContractChangeOrder]'
GO
EXEC sp_refreshview N'[dbo].[PMContractChangeOrder]'
GO
PRINT N'Refreshing [dbo].[EMAT]'
GO
EXEC sp_refreshview N'[dbo].[EMAT]'
GO
PRINT N'Refreshing [dbo].[viDim_JCJob]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCJob]'
GO
PRINT N'Refreshing [dbo].[PMCAPct]'
GO
EXEC sp_refreshview N'[dbo].[PMCAPct]'
GO
PRINT N'Refreshing [dbo].[brvPRFlash_PRRO]'
GO
EXEC sp_refreshview N'[dbo].[brvPRFlash_PRRO]'
GO
PRINT N'Refreshing [dbo].[pvPMMeetingType]'
GO
EXEC sp_refreshview N'[dbo].[pvPMMeetingType]'
GO
PRINT N'Refreshing [dbo].[APUnappInvStatusLineInfo]'
GO
EXEC sp_refreshview N'[dbo].[APUnappInvStatusLineInfo]'
GO
PRINT N'Refreshing [dbo].[PRDD]'
GO
EXEC sp_refreshview N'[dbo].[PRDD]'
GO
PRINT N'Refreshing [dbo].[JCContractLastMthActivity]'
GO
EXEC sp_refreshview N'[dbo].[JCContractLastMthActivity]'
GO
PRINT N'Refreshing [dbo].[vrvPMChgOrderAddOn]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMChgOrderAddOn]'
GO
PRINT N'Refreshing [dbo].[EMAV]'
GO
EXEC sp_refreshview N'[dbo].[EMAV]'
GO
PRINT N'Refreshing [dbo].[viDim_JCJobPhases]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCJobPhases]'
GO
PRINT N'Refreshing [dbo].[brvPRFlash_RRRE]'
GO
EXEC sp_refreshview N'[dbo].[brvPRFlash_RRRE]'
GO
PRINT N'Refreshing [dbo].[MSDH]'
GO
EXEC sp_refreshview N'[dbo].[MSDH]'
GO
PRINT N'Refreshing [dbo].[MSDD]'
GO
EXEC sp_refreshview N'[dbo].[MSDD]'
GO
PRINT N'Refreshing [dbo].[APVMforProjectSLandPO]'
GO
EXEC sp_refreshview N'[dbo].[APVMforProjectSLandPO]'
GO
PRINT N'Refreshing [dbo].[DDCBc]'
GO
EXEC sp_refreshview N'[dbo].[DDCBc]'
GO
PRINT N'Refreshing [dbo].[vrvPMChgOrderAddOnCost]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMChgOrderAddOnCost]'
GO
PRINT N'Refreshing [dbo].[JCOR]'
GO
EXEC sp_refreshview N'[dbo].[JCOR]'
GO
PRINT N'Refreshing [dbo].[viDim_JCPhaseMaster]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCPhaseMaster]'
GO
PRINT N'Refreshing [dbo].[INXB]'
GO
EXEC sp_refreshview N'[dbo].[INXB]'
GO
PRINT N'Refreshing [dbo].[HQPO]'
GO
EXEC sp_refreshview N'[dbo].[HQPO]'
GO
PRINT N'Refreshing [dbo].[ARReleaseLineValues]'
GO
EXEC sp_refreshview N'[dbo].[ARReleaseLineValues]'
GO
PRINT N'Refreshing [dbo].[PRDeductionGroup]'
GO
EXEC sp_refreshview N'[dbo].[PRDeductionGroup]'
GO
PRINT N'Refreshing [dbo].[vrvPMCommitmentCO]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMCommitmentCO]'
GO
PRINT N'Refreshing [dbo].[PMTD]'
GO
EXEC sp_refreshview N'[dbo].[PMTD]'
GO
PRINT N'Refreshing [dbo].[viDim_JCProjectMgr]'
GO
EXEC sp_refreshview N'[dbo].[viDim_JCProjectMgr]'
GO
PRINT N'Refreshing [dbo].[SMEMUsageBatchReport]'
GO
EXEC sp_refreshview N'[dbo].[SMEMUsageBatchReport]'
GO
PRINT N'Refreshing [dbo].[CMDBGrid]'
GO
EXEC sp_refreshview N'[dbo].[CMDBGrid]'
GO
PRINT N'Refreshing [dbo].[PRLB]'
GO
EXEC sp_refreshview N'[dbo].[PRLB]'
GO
PRINT N'Refreshing [dbo].[brvPRLeave]'
GO
EXEC sp_refreshview N'[dbo].[brvPRLeave]'
GO
PRINT N'Refreshing [dbo].[BITargetDDFILookup]'
GO
EXEC sp_refreshview N'[dbo].[BITargetDDFILookup]'
GO
PRINT N'Refreshing [dbo].[vrvPMCommitmentCompliance]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMCommitmentCompliance]'
GO
PRINT N'Refreshing [dbo].[PMTH]'
GO
EXEC sp_refreshview N'[dbo].[PMTH]'
GO
PRINT N'Refreshing [dbo].[viDim_MSCompany]'
GO
EXEC sp_refreshview N'[dbo].[viDim_MSCompany]'
GO
PRINT N'Refreshing [dbo].[SMPartType]'
GO
EXEC sp_refreshview N'[dbo].[SMPartType]'
GO
PRINT N'Refreshing [dbo].[SMMiscellaneousBatchReport]'
GO
EXEC sp_refreshview N'[dbo].[SMMiscellaneousBatchReport]'
GO
PRINT N'Refreshing [dbo].[SMEMUsageBreakdownDistribution]'
GO
EXEC sp_refreshview N'[dbo].[SMEMUsageBreakdownDistribution]'
GO
PRINT N'Refreshing [dbo].[JCTL]'
GO
EXEC sp_refreshview N'[dbo].[JCTL]'
GO
PRINT N'Refreshing [dbo].[JCTE]'
GO
EXEC sp_refreshview N'[dbo].[JCTE]'
GO
PRINT N'Refreshing [dbo].[EMPB]'
GO
EXEC sp_refreshview N'[dbo].[EMPB]'
GO
PRINT N'Refreshing [dbo].[brvPRLiabilities]'
GO
EXEC sp_refreshview N'[dbo].[brvPRLiabilities]'
GO
PRINT N'Refreshing [dbo].[EMSP]'
GO
EXEC sp_refreshview N'[dbo].[EMSP]'
GO
PRINT N'Refreshing [dbo].[brvAPAllInvoices]'
GO
EXEC sp_refreshview N'[dbo].[brvAPAllInvoices]'
GO
PRINT N'Refreshing [dbo].[APCD]'
GO
EXEC sp_refreshview N'[dbo].[APCD]'
GO
PRINT N'Refreshing [dbo].[vrvPMContractAnalysisDDAttachments]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMContractAnalysisDDAttachments]'
GO
PRINT N'Refreshing [dbo].[viDim_MSCustomerJob]'
GO
EXEC sp_refreshview N'[dbo].[viDim_MSCustomerJob]'
GO
PRINT N'Refreshing [dbo].[PMCompanyTemplates]'
GO
EXEC sp_refreshview N'[dbo].[PMCompanyTemplates]'
GO
PRINT N'Refreshing [dbo].[CMDTGrid]'
GO
EXEC sp_refreshview N'[dbo].[CMDTGrid]'
GO
PRINT N'Refreshing [dbo].[brvPRMissingTimecards]'
GO
EXEC sp_refreshview N'[dbo].[brvPRMissingTimecards]'
GO
PRINT N'Refreshing [dbo].[pvPMRFIType]'
GO
EXEC sp_refreshview N'[dbo].[pvPMRFIType]'
GO
PRINT N'Altering [dbo].[vfPRRateDefault]'
GO
ALTER FUNCTION [dbo].[vfPRRateDefault]
/***********************************************************
* Based on stored proc BY: (kb 3/1/99)
*			
* MODIFIED BY : KK 12/02/12 - TK-19690 Made this stored procedure bspPRRateDefault into a function for AU Allowances epic
*				KK 01/17/13 - TK-20786 Refactored when there was a concern with base rate calculations
*				KK 04/09/13 - 45623	 Modified to disregard Variable Rate calculations all together.
*									 Including Shift in the rate but took out EarnCode and therefore Factor throughout.
*
* USAGE: Used by PR Process when processing allowances to get the rate
*
* INPUT PARAMETERS
*	@prco		PR Company
*	@employee	PR Employee being evaluated
*	@postdate	PR Timecard Entry posting date 
*	@craft		PR Craft for this timecard line
*	@class		PR Class for this timecard line 
*	@template	PR Template that comes from the job on this timecard line
*	@shift		Shift on this timecard line
*
* OUTPUT PARAMETERS
*	Rate	  as bUnitCost = base allowance rate to use for this timecard line
*
* RETURN VALUE
*   0         success
*   1         Failure
*****************************************************/
(
	@prco bCompany, 
	@employee bEmployee, 
	@postdate bDate, 
	@craft bCraft,
	@class bClass, 
	@template smallint, 
	@shift tinyint
)
RETURNS dbo.bUnitCost
AS
BEGIN
	DECLARE @rate bUnitCost,
			@effectivedate bDate,
			@classrate bUnitCost

	-- Get the employee's hourly pay rate from PR Employees and multiply it by the factor from the earn code
	SELECT @rate = HrlyRate FROM PREH WHERE PRCo = @prco AND Employee = @employee
	
	-- Get the effective date from Craft Master
	SELECT @effectivedate = EffectiveDate FROM PRCM WHERE PRCo = @prco AND Craft = @craft
	
	-- Initialize pay rate(@classrate) set at the Craft/Class or Craft/Class Temp level
	SELECT @classrate = 0.00

	-- CRAFT/CLASS TEMPLATE: If there is a template, we will check here for a pay rate overrides
	IF @template IS NOT NULL
  	BEGIN
		-- If there is an effective date override at Craft Template, use this, else use Craft Master effective date 
  		SELECT @effectivedate = CASE OverEffectDate WHEN 'Y' 
  													THEN ISNULL(EffectiveDate,@effectivedate) 
													ELSE @effectivedate END
  		FROM PRCT WHERE PRCo = @prco 
  					AND Craft = @craft 
  					AND Template = @template
  		
		-- C/C Temp Pay Rate: If the posting date is on or after the effective date use new rate, else use old rate
  		SELECT @classrate = CASE WHEN @postdate >= @effectivedate 
  								 THEN NewRate 
  								 ELSE OldRate END
  		FROM PRTP
		WHERE PRCo = @prco 
		  AND Craft = @craft 
		  AND Class = @class 
		  AND Template = @template 
		  AND Shift = @shift

		-- If we found a pay rate at the Craft/Class Temp, compare it to the PR Employee rate
		IF @classrate IS NOT NULL AND @classrate <> 0
		BEGIN
			-- Return the greater between the C/C Temp pay rate and the PR Employee rate
			IF @classrate > @rate SELECT @rate = @classrate
			RETURN @rate
		END

		-- No pay rates were found at the Craft/Class Template, reinitialize variable
		SELECT @classrate = 0.00
  	END

	-- CRAFT/CLASS: Rates will be based on Employee or Craft/Class tables

	-- C/C Pay Rate: If the posting date is on or after the effective date use new rate, else use old rate
	SELECT @classrate = CASE WHEN @postdate >= @effectivedate 
							 THEN NewRate 
							 ELSE OldRate END
	FROM PRCP 
	WHERE PRCo = @prco 
	  AND Craft = @craft 
	  AND Class = @class 
	  AND Shift = @shift
		
	-- If we found a pay rate at Craft/Class, compare it to the PR Employee rate
	IF @classrate IS NOT NULL AND @classrate <> 0
	BEGIN
		-- Return the greater between the factored C/C pay rate and the factored PR Employee rate
		IF @classrate > @rate SELECT @rate = @classrate
		RETURN @rate
	END

	-- No rate overrides were found that were greater than PR Employee rate, so return PR Employee rate
	RETURN @rate
END
GO
PRINT N'Altering [dbo].[vspPRLoadAllowances]'
GO
SET QUOTED_IDENTIFIER OFF
GO
ALTER proc [dbo].[vspPRLoadAllowances] (@PRCo bCompany, @PRGroup bGroup, @PREndDate DATETIME, @Employee bEmployee, @PaySeq TINYINT)
AS
/**************************************************************************************
* CREATED BY: 	AR 12/2012
* COMMITTED BY: JR 12/2012
* MODIFIED BY:  KK 01/16/13 - D-12044/TK-20786 Changed the earn code used from timecard ec to allowance ec when getting base rate
*				KK 01/24/13 - D-12044/TK-20786 Added join on prco for vPRAllowanceRuleSet
*				KK 04/12/13 - 45623 Modified call to RateDefault function. No need to pass EarnCode/Factor in modified function.
*
* USAGE: Called from PRProcessAllowances to get total breadth of information. This gets all possible allowances eligible for 
*		 each line on a given timecard for an employee. This information is in it's most raw unflitered state. Each record
*		 in this temp table will have it's own individual timecard line information, rate and allowance rule/ruleset, 
*		 EarnCode and threshold to be aggregated, filtered, applied and distributed. This table gets wittled down as we continue 
*		 to eliminate ineligible allowances through processing.
*
* INPUT PARAMETERS
*		PRCo, PRGroup, PREndDate, Employee, PaySeq 
*  
* OUTPUT: Fills and returns temp table #TCAllowEmp for processing allowances 
*
***************************************************************************************/
-- Make sure that the temp tables need for this procedure exist at this instance.
IF OBJECT_ID('tempdb..#TCAllowEmp') IS NULL
BEGIN 
	RAISERROR('ERROR: This stored procedure is meant to be called from vspPRProcessAllowances where the temp table is defined.',-11,1);
END

-- Get the allowances for our time card batch to filter down our set: Find all rules related to time cards distinctly
INSERT INTO #TCAllowEmp (Employee, PRCo, PREndDate, PRGroup, PaySeq, PostSeq, AllowanceTypeName, Craft, AllowanceRulesetName, AllowanceRuleName, ThresholdPeriod, IsHoliday, Threshold, PayRate, Hours, PostDate, KeyID, AllowanceEarnCode)
SELECT DISTINCT 
		-- Key on timecard: Employee, Company, End Date, Group, PaySeq and PostSeq (employee might have mulitple time cards)
		tc.Employee,
		tc.PRCo, 
		tc.PREndDate,
		tc.PRGroup,
		tc.PaySeq,
		tc.PostSeq,
		-- allowLocInfo:
		allowLocInfo.AllowanceTypeName,
		-- Timecard: Craft
		tc.Craft, 
		-- Rule: RuleSet Name, Rule Name
		vpar.AllowanceRulesetName,
		vpar.AllowanceRuleName,
		-- RuleSet: ThresholdPeriod
		vpars.ThresholdPeriod, 
		-- Rule: Holiday Y/N, Threshold
		vpar.Holiday AS IsHoliday,
		vpar.Threshold,
		-- Get base pay rate from function: Using the "Shift" declared at the allowance location
		dbo.vfPRRateDefault( tc.PRCo, --45623 Modified PRRateDefault, no need for EarnCode or Factor
							 tc.Employee, 
							 tc.PostDate, 
							 tc.Craft,
							 tc.Class, 
							 job.CraftTemplate, 
							 -- 46570 Use shift set at the allowance location if one exists, otherwise use timecard line Shift
							 CASE WHEN allowLocInfo.ShiftRateOverride IS NOT NULL
								  THEN allowLocInfo.ShiftRateOverride
								  ELSE tc.Shift END
			) AS PayRate, 					
		-- Get additional timecard information
		tc.[Hours], 
		tc.PostDate,
		tc.KeyID,
		allowLocInfo.EarnCode AS AllowanceEarnCode

FROM dbo.bPRTH tc -- Employee timecards
	-- Get Job information to determine Template
	LEFT JOIN bJCJM job ON job.Job = tc.Job AND job.JCCo = tc.JCCo
	-- Location subquery: Get allowances and rulesets from CraftMast, CraftTemp, CraftClass, or CraftClassTemp 
	--					  given an employee's Craft/Class/Job-Template
	CROSS APPLY -- Calling out table names as static in we want to JOIN to PRAllowanceTypes in the future
		(	
			-- Craft/Class allowances
			SELECT 'vPRCraftClassAllowances' AS TableName,
					vpcca.AllowanceTypeName,
					vpcca.AllowanceRulesetName,
					vpcca.EarnCode,
					vpcca.ShiftRateOverride 
			FROM dbo.vPRCraftClassAllowance AS vpcca
			WHERE vpcca.Class = tc.Class
				AND vpcca.Craft = tc.Craft
				AND vpcca.PRCo = tc.PRCo
											
			UNION ALL
			-- Craft Master allowances
			SELECT 'vPRCraftMasterAllowances' AS TableName,
					vpcma.AllowanceTypeName,
					vpcma.AllowanceRulesetName,
					vpcma.EarnCode,
					vpcma.ShiftRateOverride 
			FROM dbo.vPRCraftMasterAllowance AS vpcma
			WHERE vpcma.Craft = tc.Craft
				AND vpcma.PRCo = tc.PRCo
			
			UNION ALL
			-- Craft/Class Template allowances
			SELECT 'vPRCraftClassTemplateAllowances' AS TableName,
					vpccta.AllowanceTypeName,
					vpccta.AllowanceRulesetName,
					vpccta.EarnCode,
					vpccta.ShiftRateOverride 
			FROM dbo.vPRCraftClassTemplateAllowance AS vpccta
			WHERE vpccta.Class = tc.Class
				AND vpccta.Craft = tc.Craft
				AND vpccta.PRCo = tc.PRCo
				AND vpccta.Template = job.CraftTemplate
			
			UNION ALL
			-- Craft Template allowances
			SELECT 'vPRCraftTemplateAllowances' AS TableName,
					vpcta.AllowanceTypeName,
					vpcta.AllowanceRulesetName,
					vpcta.EarnCode,
					vpcta.ShiftRateOverride 
			FROM dbo.vPRCraftTemplateAllowance AS vpcta
			WHERE vpcta.Craft = tc.Craft
				AND vpcta.PRCo = tc.PRCo
				AND vpcta.Template = job.CraftTemplate
		) allowLocInfo
		
-- Join in rules from RuleSet header and detail (Rules)
JOIN dbo.vPRAllowanceRuleSet AS vpars 
		ON vpars.PRCo = tc.PRCo -- KK added join on PRCo
		AND allowLocInfo.AllowanceRulesetName = vpars.AllowanceRulesetName
JOIN dbo.vPRAllowanceRules AS vpar 
		ON vpar.PRCo = tc.PRCo
		AND allowLocInfo.AllowanceRulesetName = vpar.AllowanceRulesetName
-- Join in earn codes and subject earncodes
JOIN dbo.bPREC AS ec 
		ON ec.PRCo = tc.PRCo 
		AND allowLocInfo.EarnCode = ec.EarnCode
JOIN dbo.bPRES AS es 
		ON ec.PRCo = es.PRCo 
		AND ec.EarnCode = es.EarnCode
		AND es.SubjEarnCode = tc.EarnCode
						
WHERE tc.Employee = @Employee
	AND tc.PRCo = @PRCo
	AND tc.PREndDate = @PREndDate
	AND tc.PRGroup = @PRGroup
	AND tc.PaySeq = @PaySeq;
	
GO
PRINT N'Altering [dbo].[vspPRLoadAllowanceHoursAggregated]'
GO
ALTER proc [dbo].[vspPRLoadAllowanceHoursAggregated] 
AS
/**************************************************************************************
* CREATED BY: 	AR 12/2012
* COMMITTED BY: JR 12/2012
* MODIFIED BY:  KK 12/2012  - TK-20693  Craft will never be null when checking for PRHD is holiday checked
*				KK 01/30/13 - TFS-8166  Added comments to code
*				KK 04/28/13 - TFS-46570 Modified such that the max pay rate is taken when multiple timecard lines are used to evaluate a threshold
*				KK 05/08/13 - TFS-46570 Changed the period of the partition to get the max rate value for Weekly
*
* USAGE: Called from PRProcessAllowances to filter the allowance
*		 Based on threshold 1. Hourly - not in use, 2. Daily - with a holiday type, 3. Not in use  4. Weekly
*
* OUTPUT: Fills and returns temp table #tmpEmpHoursAggregated for processing allowances 
*
***************************************************************************************/
IF OBJECT_ID('tempdb..#tmpEmpHoursAggregated') IS NULL
OR OBJECT_ID('tempdb..#TCAllowEmp') IS NULL 
BEGIN 
	RAISERROR('ERROR: This stored procedure is meant to be called from vspPRProcessAllowances.  vspPRProcessAllowances has the temp table definition',-11,1);
END

/*************************************************************
Sum up the Time Cards by rule and elminate non-threshold rules
**************************************************************/

/************ Daily (2) - Holiday as an attribute **************/
INSERT INTO #tmpEmpHoursAggregated
			 (TCGroupId,
			  Employee,
			  PRCo,
			  ThresholdPeriod,
			  Threshold,
			  PeriodDate,
			  PeriodHours,
			  AllowanceRuleName,
			  AllowanceRulesetName,
			  AllowanceTypeName,
			  PREndDate,
			  PayPerWeek,
			  PayRate,
			  IsHoliday,
			  KeyID,
			  AllowanceEarnCode)
-- Unpivot time cards detail and verify hours per day against threshold
-- The following query = total hours per day for any days that are part of a rule
SELECT 
	-- Build a group Id to identify consoldiated time cards
		MAX(tae.Id)
		OVER(PARTITION BY 
			 tae.PRCo
			,tae.Threshold
			,tae.ThresholdPeriod
			,tae.AllowanceRuleName
			,tae.AllowanceRulesetName
			,tae.AllowanceTypeName
			,tae.PostDate
			,tae.Employee
			,tae.PREndDate
	)AS TimecardGroupID,
	tae.Employee,
	tae.PRCo,
	tae.ThresholdPeriod,
	tae.Threshold,
	tae.PostDate,
	-- Sum up timecards already broken out by rule
		SUM(tae.Hours) 
		OVER(PARTITION BY 
			 tae.PRCo
			,tae.Threshold
			,tae.ThresholdPeriod
			,tae.AllowanceRuleName
			,tae.AllowanceRulesetName
			,tae.AllowanceTypeName
			,tae.PostDate
			,tae.Employee
			,tae.PREndDate
	)AS PeriodHours,
	tae.AllowanceRuleName,
	tae.AllowanceRulesetName,
	tae.AllowanceTypeName,
	tae.PREndDate,
	-- Get the Pay Period Week
	FLOOR(DATEDIFF(day,PayPer.BeginDate, tae.PostDate)/7),
	-- Get the max payrate for each group of timecards being evaluated together against a threshold
		(MAX (tae.PayRate)
		 OVER(PARTITION BY 
			  tae.PRCo
			 ,tae.Threshold
			 ,tae.ThresholdPeriod
			 ,tae.AllowanceRuleName
			 ,tae.AllowanceRulesetName
			 ,tae.AllowanceTypeName
			 ,tae.PostDate
			 ,tae.Employee
			 ,tae.PREndDate)
	)AS MaxPayRate,
	-- Set the holiday flag for evaluation when the rule is applied
	CASE WHEN HolidayCheck.Holiday IS NOT NULL AND tae.IsHoliday = 'Y' THEN 'Y' ELSE 'N' END, -- Is Holiday
	tae.KeyID,
	tae.AllowanceEarnCode
FROM #TCAllowEmp tae
	-- Join in pay period to get an offset for figuring out the week
	JOIN dbo.bPRPC AS PayPer ON PayPer.PRCo = tae.PRCo
							AND PayPer.PREndDate = tae.PREndDate
							AND PayPer.PRGroup = tae.PRGroup
	-- Sub query (OUTER APPLY): One to pivot the dates, the other joins PRTH temp table to them...
	OUTER APPLY 
	(	SELECT 
			dw.AllowanceRuleName,
			dw.DayOfWeekValue,
			dw.Threshold,
			dw.DayOfWeek
		FROM dbo.vPRAllowanceRules AS vpar
			-- Unflatten the days
			UNPIVOT (DayOfWeekValue FOR DayOfWeek IN (DayOfWeekMonday
													 ,DayOfWeekTuesday
													 ,DayOfWeekWednesday
													 ,DayOfWeekThursday
													 ,DayOfWeekFriday
													 ,DayOfWeekSaturday
													 ,DayOfWeekSunday)) AS dw
		WHERE dw.DayOfWeekValue = 'Y' -- Only care where the rule is active for that day
			AND dw.AllowanceRuleName = tae.AllowanceRuleName
			AND dw.AllowanceRulesetName = tae.AllowanceRulesetName
			AND dw.PRCo = tae.PRCo
	) AS a 
	-- Is this day a holiday?
	OUTER APPLY 
	(   -- Holiday from Pay Period Control ONLY where "Apply to craft" is checked
		SELECT CONVERT(INT,1) AS Holiday
		FROM dbo.bPRHD AS CntHol 
		WHERE tae.PRCo = CntHol.PRCo
				AND tae.PREndDate = CntHol.PREndDate
				AND tae.PRGroup = CntHol.PRGroup
				AND tae.PostDate = CntHol.Holiday
				AND CntHol.ApplyToCraft = 'Y' 
		UNION
		-- Holiday from Craft Master (ALL emps that qualify for allowances will have a Craft Master entry)
		SELECT CONVERT(INT,1)
		FROM dbo.bPRCH AS CntHol 
		WHERE CntHol.PRCo = tae.PRCo
				AND CntHol.Craft = tae.Craft
				AND CntHol.Holiday = tae.PostDate

	) AS HolidayCheck
WHERE	tae.ThresholdPeriod = 2 -- Threshold period is "Daily"
		AND
		(	-- Line up days that were unpivoted above and/or check for holiday
			RIGHT(a.DayOfWeek, LEN(a.DayOfWeek)-9) = dbo.vfDayOfWeekAsString(tae.PostDate)
			OR (HolidayCheck.Holiday IS NOT NULL AND tae.IsHoliday = 'Y')
		)
			
/************ Weekly (4) **************/
INSERT INTO #tmpEmpHoursAggregated
			 (TCGroupId, 
			  Employee,
			  PRCo,
			  ThresholdPeriod,
			  Threshold,
			  PeriodDate,
			  PeriodHours,
			  AllowanceRuleName,
			  AllowanceRulesetName,
			  AllowanceTypeName,
			  PREndDate,
			  PayPerWeek,
			  PayRate,
			  IsHoliday,
			  KeyID,
			  AllowanceEarnCode)
SELECT	
	-- Build a group Id to identify consoldiated time cards
		MAX(tae.Id)
		OVER(PARTITION BY 
			 tae.PRCo
			,tae.Threshold
			,tae.ThresholdPeriod
			,tae.AllowanceRuleName
			,tae.AllowanceRulesetName
			,tae.AllowanceTypeName
			,FLOOR(DATEDIFF(day,PayPer.BeginDate, tae.PostDate)/7)
			,tae.Employee
			,tae.PREndDate
	)AS TimecardGroupID,
	tae.Employee,
	tae.PRCo,
	tae.ThresholdPeriod,
	tae.Threshold,
	-- Group by pay week: Difference in weeks + begin date
	-- Then convert to date and put it in Period Date
	DATEADD(week,FLOOR(DATEDIFF(day,PayPer.BeginDate, tae.PostDate)/7),PayPer.BeginDate) AS WeekInPayPer,
	-- Sum up timecards already broken out by rule
		SUM(tae.Hours) 
		OVER(PARTITION BY 
			 tae.PRCo
			,tae.Threshold
			,tae.ThresholdPeriod
			,tae.AllowanceRuleName
			,tae.AllowanceRulesetName
			,tae.AllowanceTypeName
			,FLOOR(DATEDIFF(day,PayPer.BeginDate, tae.PostDate)/7)
			,tae.Employee
			,tae.PREndDate
	)AS PeriodHours,
	tae.AllowanceRuleName,
	tae.AllowanceRulesetName,
	tae.AllowanceTypeName,
	tae.PREndDate,
	FLOOR(DATEDIFF(day,PayPer.BeginDate, tae.PostDate)/7),
	-- Get the max payrate for each group of timecards being evaluated together against a threshold
		(MAX (tae.PayRate)
		 OVER(PARTITION BY 
			  tae.PRCo
			 ,tae.Threshold
			 ,tae.ThresholdPeriod
			 ,tae.AllowanceRuleName
			 ,tae.AllowanceRulesetName
			 ,tae.AllowanceTypeName
			 ,FLOOR(DATEDIFF(day,PayPer.BeginDate, tae.PostDate)/7)
			 ,tae.Employee
			 ,tae.PREndDate)
	)AS MaxPayRate,
	'N', -- NOTE: Weekly has no holidays
	tae.KeyID,
	tae.AllowanceEarnCode
FROM #TCAllowEmp tae
	-- Join in the pay period to get an offset when figuring out weeks
	JOIN dbo.bPRPC AS PayPer ON PayPer.PRCo = tae.PRCo
								AND PayPer.PREndDate = tae.PREndDate
								AND PayPer.PRGroup = tae.PRGroup
WHERE tae.ThresholdPeriod = 4; -- Threshold period 4 is "Weekly"
GO
PRINT N'Refreshing [dbo].[vrvPMContractAnalysisDDBilledAmts]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMContractAnalysisDDBilledAmts]'
GO
PRINT N'Refreshing [dbo].[viDim_MSCustomerPO]'
GO
EXEC sp_refreshview N'[dbo].[viDim_MSCustomerPO]'
GO
PRINT N'Refreshing [dbo].[CMRefByMthIncludeARBatch]'
GO
EXEC sp_refreshview N'[dbo].[CMRefByMthIncludeARBatch]'
GO
PRINT N'Refreshing [dbo].[brvPRRecon]'
GO
EXEC sp_refreshview N'[dbo].[brvPRRecon]'
GO
PRINT N'Refreshing [dbo].[brvAPCashReq]'
GO
EXEC sp_refreshview N'[dbo].[brvAPCashReq]'
GO
PRINT N'Refreshing [dbo].[vrvPMDistDrawingLogs]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMDistDrawingLogs]'
GO
PRINT N'Refreshing [dbo].[PMTP]'
GO
EXEC sp_refreshview N'[dbo].[PMTP]'
GO
PRINT N'Refreshing [dbo].[viDim_MSTruckTypes]'
GO
EXEC sp_refreshview N'[dbo].[viDim_MSTruckTypes]'
GO
PRINT N'Refreshing [dbo].[vrvARInvoiceAttach]'
GO
EXEC sp_refreshview N'[dbo].[vrvARInvoiceAttach]'
GO
PRINT N'Refreshing [dbo].[JBCX]'
GO
EXEC sp_refreshview N'[dbo].[JBCX]'
GO
PRINT N'Refreshing [dbo].[SMGLDistributionReport]'
GO
EXEC sp_refreshview N'[dbo].[SMGLDistributionReport]'
GO
PRINT N'Refreshing [dbo].[JCOITotals]'
GO
EXEC sp_refreshview N'[dbo].[JCOITotals]'
GO
PRINT N'Refreshing [dbo].[brvPRSQforTaxLiab]'
GO
EXEC sp_refreshview N'[dbo].[brvPRSQforTaxLiab]'
GO
PRINT N'Refreshing [dbo].[brvAPOpenInvoicesByJob]'
GO
EXEC sp_refreshview N'[dbo].[brvAPOpenInvoicesByJob]'
GO
PRINT N'Refreshing [dbo].[vrvPMDistInspectionLogs]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMDistInspectionLogs]'
GO
PRINT N'Refreshing [dbo].[EMCH]'
GO
EXEC sp_refreshview N'[dbo].[EMCH]'
GO
PRINT N'Refreshing [dbo].[viDim_MSUnitMeasures]'
GO
EXEC sp_refreshview N'[dbo].[viDim_MSUnitMeasures]'
GO
PRINT N'Refreshing [dbo].[vrvPCBidAnalysis]'
GO
EXEC sp_refreshview N'[dbo].[vrvPCBidAnalysis]'
GO
PRINT N'Refreshing [dbo].[JCOP]'
GO
EXEC sp_refreshview N'[dbo].[JCOP]'
GO
PRINT N'Refreshing [dbo].[brvPRTimeJob]'
GO
EXEC sp_refreshview N'[dbo].[brvPRTimeJob]'
GO
PRINT N'Refreshing [dbo].[brvAPTax]'
GO
EXEC sp_refreshview N'[dbo].[brvAPTax]'
GO
PRINT N'Refreshing [dbo].[vrvPMDistTestLogs]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMDistTestLogs]'
GO
PRINT N'Refreshing [dbo].[PMUC]'
GO
EXEC sp_refreshview N'[dbo].[PMUC]'
GO
PRINT N'Refreshing [dbo].[viDim_PMCompany]'
GO
EXEC sp_refreshview N'[dbo].[viDim_PMCompany]'
GO
PRINT N'Refreshing [dbo].[PMContractManagers]'
GO
EXEC sp_refreshview N'[dbo].[PMContractManagers]'
GO
PRINT N'Refreshing [dbo].[vrvPCBidCoverage]'
GO
EXEC sp_refreshview N'[dbo].[vrvPCBidCoverage]'
GO
PRINT N'Refreshing [dbo].[CMTB]'
GO
EXEC sp_refreshview N'[dbo].[CMTB]'
GO
PRINT N'Refreshing [dbo].[MSMT]'
GO
EXEC sp_refreshview N'[dbo].[MSMT]'
GO
PRINT N'Refreshing [dbo].[MSMH]'
GO
EXEC sp_refreshview N'[dbo].[MSMH]'
GO
PRINT N'Refreshing [dbo].[brvAPUnapprovedCheck]'
GO
EXEC sp_refreshview N'[dbo].[brvAPUnapprovedCheck]'
GO
PRINT N'Refreshing [dbo].[vrvPMDocDistAudit]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMDocDistAudit]'
GO
PRINT N'Refreshing [dbo].[vrvSMInvoiceByWO]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMInvoiceByWO]'
GO
PRINT N'Refreshing [dbo].[CMTBGrid]'
GO
EXEC sp_refreshview N'[dbo].[CMTBGrid]'
GO
PRINT N'Refreshing [dbo].[JCOverrides]'
GO
EXEC sp_refreshview N'[dbo].[JCOverrides]'
GO
PRINT N'Refreshing [dbo].[brvPRW2Box14FederalDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvPRW2Box14FederalDetail]'
GO
PRINT N'Refreshing [dbo].[MSPR]'
GO
EXEC sp_refreshview N'[dbo].[MSPR]'
GO
PRINT N'Refreshing [dbo].[brvAttachments]'
GO
EXEC sp_refreshview N'[dbo].[brvAttachments]'
GO
PRINT N'Refreshing [dbo].[PREAEmplMonths]'
GO
EXEC sp_refreshview N'[dbo].[PREAEmplMonths]'
GO
PRINT N'Refreshing [dbo].[vrvPMDocDistAuditLookup]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMDocDistAuditLookup]'
GO
PRINT N'Refreshing [dbo].[viDim_PMFirms]'
GO
EXEC sp_refreshview N'[dbo].[viDim_PMFirms]'
GO
PRINT N'Refreshing [dbo].[vrvSMWorkOrder]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMWorkOrder]'
GO
PRINT N'Refreshing [dbo].[CMTT]'
GO
EXEC sp_refreshview N'[dbo].[CMTT]'
GO
PRINT N'Refreshing [dbo].[JCOverridesCost]'
GO
EXEC sp_refreshview N'[dbo].[JCOverridesCost]'
GO
PRINT N'Refreshing [dbo].[pvPRAnnualCheckHistory]'
GO
EXEC sp_refreshview N'[dbo].[pvPRAnnualCheckHistory]'
GO
PRINT N'Refreshing [dbo].[brvCMAC]'
GO
EXEC sp_refreshview N'[dbo].[brvCMAC]'
GO
PRINT N'Creating [dbo].[vspPRDaysWithoutPayGet]'
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[vspPRDaysWithoutPayGet]
/***********************************************************
* CREATED:	EN  EN 4/5/2013 Story 44310 / Task 45407
* MODIFIED BY: 
*
* USAGE:
* For a specified date range, determines an employee's total number of 
* days without pay based on the employee's periods without pay 
* (vPREmplPeriodsWithoutPay) used to store absences such as maternity/
* paternity leave and hiatus. 
*
* INPUT PARAMETERS
*   @PRCo			PR Company
*   @Employee		Employee number
*	@FromDate		beginning date of range for determination
*	@ThruDate		ending date of range for determination
*
* OUTPUT PARAMETERS
*	@DaysWithoutPay	# of days within the given date range that coincided with periods without pay for the employee
*   @ErrorMsg		Error message if error occurs	
*
* RETURN VALUE
*   0			Success
*   1			Failure
*
******************************************************************/
(@PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @FromDate bDate = NULL,
 @ThruDate bDate = NULL,
 @DaysWithoutPay int OUTPUT,
 @ErrorMsg varchar(255) OUTPUT)

AS
SET NOCOUNT ON


BEGIN TRY

	DECLARE @Return_Value tinyint
			
	------------------
	-- PRIME VALUES --
	------------------
    SET @Return_Value = 0
    SET @ErrorMsg = ''
    
	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @FromDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing From Date of date range!'
			GOTO vspExit
		END
		
	IF @ThruDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Through Date of date range!'
			GOTO vspExit
		END


	-------------------------------------------------------------------------------------------------------
	-- DETERMINE NUMBER OF DAYS IN THE EMPLOYEE'S PERIODS WITHOUT PAY                       			 --
	--																									 --
	-- Find date ranges of any periods without pay that fall within or intersect the @FromDate to        --
	-- @ThruDate range, adjusting the beginning and/or ending dates of the periods without pay depending --
	-- on the given date range.																			 --
	-------------------------------------------------------------------------------------------------------
	;WITH DateRangesWithoutPay (FirstDate, LastDate)
	AS
	(
		-- find periods without pay that straddle the beginning or end of the given date range
		-- and adjust FirstDate or LastDate accordingly
		SELECT  CASE WHEN DATEDIFF(DAY, @FromDate, FirstDate) < 0 
					 THEN @FromDate 
					 ELSE FirstDate END,
				 
				CASE WHEN DATEDIFF(DAY, LastDate, @ThruDate) < 0
					 THEN @ThruDate	
					 ELSE LastDate END
			 
		FROM	dbo.vPREmplPeriodsWithoutPay
	
		WHERE	PRCo = @PRCo AND
				Employee = @Employee AND
				(@FromDate BETWEEN FirstDate AND LastDate OR
				 @ThruDate BETWEEN FirstDate AND LastDate)
		UNION
		-- find periods without pay that exist fully within the given date range
		SELECT	FirstDate, LastDate
		FROM	dbo.vPREmplPeriodsWithoutPay
	
		WHERE	PRCo = @PRCo AND
				Employee = @Employee AND
				(@FromDate <= FirstDate AND @ThruDate >= LastDate)
	)

	SELECT	@DaysWithoutPay = ISNULL(SUM(DATEDIFF(DAY, FirstDate, LastDate) + 1) ,0)
	FROM	DateRangesWithoutPay


END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[PMIssueHistory]'
GO
EXEC sp_refreshview N'[dbo].[PMIssueHistory]'
GO
PRINT N'Refreshing [dbo].[vrvPMIHIssueHistory]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMIHIssueHistory]'
GO
PRINT N'Refreshing [dbo].[PMNR]'
GO
EXEC sp_refreshview N'[dbo].[PMNR]'
GO
PRINT N'Refreshing [dbo].[viDim_PMProjectMgrJobs]'
GO
EXEC sp_refreshview N'[dbo].[viDim_PMProjectMgrJobs]'
GO
PRINT N'Refreshing [dbo].[PMDC]'
GO
EXEC sp_refreshview N'[dbo].[PMDC]'
GO
PRINT N'Refreshing [dbo].[vrvSMWorkOrderProfitReports]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMWorkOrderProfitReports]'
GO
PRINT N'Refreshing [dbo].[Companies]'
GO
EXEC sp_refreshview N'[dbo].[Companies]'
GO
PRINT N'Refreshing [dbo].[JCPB]'
GO
EXEC sp_refreshview N'[dbo].[JCPB]'
GO
PRINT N'Refreshing [dbo].[brvCMChkInqDD]'
GO
EXEC sp_refreshview N'[dbo].[brvCMChkInqDD]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_LimitsAndRatesGet]'
GO

CREATE  PROC [dbo].[vspPR_AU_ETP_LimitsAndRatesGet]
/***********************************************************/
-- CREATED BY: EN 3/14/2013  TFS-39858
-- MODIFIED BY: 
--
-- USAGE:
-- Reads ATO-provided information stored in table vPRAULimitsAndRates
-- that is used in Australian ETP reporting and taxation.
--
-- This stored procedure is called from vspPRAUPAYGEmplItemAmountsGet and
-- vspPR_AU_ETP_TaxComputations.
-- 
--
-- INPUT PARAMETERS
--	 @ThruDate			Used to assure that the values under the correct effective date are accessed and returned
--
-- OUTPUT PARAMETERS
--   @ETPCap
--   @WholeIncomeCap 
--   @RedundancyTaxFreeBasis
--   @RedundancyTaxFreeYears
--   @UnderPreservationAgePct
--   @OverPreservationAgePct
--   @ExcessCapPct
--	 @AnnualLeaveLoadingPct
--   @LeaveFlatRatePct
--	 @LeaveFlatRateLimit
--   @errmsg					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @ThruDate bDate = NULL,
 @ETPCap bDollar OUTPUT, 
 @WholeIncomeCap bDollar OUTPUT, 
 @RedundancyTaxFreeBasis bDollar OUTPUT,
 @RedundancyTaxFreeYears bDollar OUTPUT, 
 @UnderPreservationAgePct bPct OUTPUT,
 @OverPreservationAgePct bPct OUTPUT, 
 @ExcessCapPct bPct OUTPUT, 
 @AnnualLeaveLoadingPct bPct OUTPUT,
 @LeaveFlatRatePct bPct OUTPUT,
 @LeaveFlatRateLimit bDollar OUTPUT,
 @errmsg varchar(1000) OUTPUT
)
AS
SET NOCOUNT ON

DECLARE @ReturnCode int
SET		@ReturnCode = 0

BEGIN TRY
	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @ThruDate IS NULL
		BEGIN
			SET @ReturnCode = 1
			SET @errmsg = 'Missing Through Date!'
			GOTO vspExit
		END

	-------------------------------------------------------------
	-- READ MOST RECENT ETP REPORTING AND TAXATION INFORMATION --
	-------------------------------------------------------------
	DECLARE @MaxEffectiveDate bDate

	SELECT	@MaxEffectiveDate = MAX(EffectiveDate)

	FROM	dbo.vPRAULimitsAndRates
	WHERE	EffectiveDate <= @ThruDate 


	SELECT	@ETPCap = ETPCap, 
			@WholeIncomeCap = WholeIncomeCap, 
			@RedundancyTaxFreeBasis = RedundancyTaxFreeBasis,
			@RedundancyTaxFreeYears = RedundancyTaxFreeYears,
			@UnderPreservationAgePct = UnderPreservationAgePct,
			@OverPreservationAgePct = OverPreservationAgePct,
			@ExcessCapPct = ExcessCapPct, 
			@AnnualLeaveLoadingPct = AnnualLeaveLoadingPct,
			@LeaveFlatRatePct = LeaveFlatRatePct,
			@LeaveFlatRateLimit = LeaveFlatRateLimit

	FROM	dbo.vPRAULimitsAndRates
	WHERE	EffectiveDate = @MaxEffectiveDate

	-----------------------------------------------------------------------
	-- THROW ERROR IF A VALID SET OF LIMITS AND RATES CAN NOT BE LOCATED --
	-----------------------------------------------------------------------
	IF @@ROWCOUNT = 0 
	BEGIN
		SET @ReturnCode = 1
		SET @errmsg = 'Limits and Rates that are effective through: ' + dbo.vfToString(@ThruDate) + ' can not be found.'
		GOTO vspExit
	END

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @ReturnCode = 1
	SET @errmsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @ReturnCode
GO
PRINT N'Refreshing [dbo].[vrvPMIL]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMIL]'
GO
PRINT N'Refreshing [dbo].[EMDB]'
GO
EXEC sp_refreshview N'[dbo].[EMDB]'
GO
PRINT N'Refreshing [dbo].[viDim_PRCompany]'
GO
EXEC sp_refreshview N'[dbo].[viDim_PRCompany]'
GO
PRINT N'Refreshing [dbo].[PMDD]'
GO
EXEC sp_refreshview N'[dbo].[PMDD]'
GO
PRINT N'Refreshing [dbo].[vrvSMWorkOrderScopeList]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMWorkOrderScopeList]'
GO
PRINT N'Refreshing [dbo].[CompanyImages]'
GO
EXEC sp_refreshview N'[dbo].[CompanyImages]'
GO
PRINT N'Refreshing [dbo].[JCPBCurrEstPlusIncl]'
GO
EXEC sp_refreshview N'[dbo].[JCPBCurrEstPlusIncl]'
GO
PRINT N'Refreshing [dbo].[brvPRW2LocalState]'
GO
EXEC sp_refreshview N'[dbo].[brvPRW2LocalState]'
GO
PRINT N'Refreshing [dbo].[brvCMOutEntryAudit]'
GO
EXEC sp_refreshview N'[dbo].[brvCMOutEntryAudit]'
GO
PRINT N'Refreshing [dbo].[PREDMaint]'
GO
EXEC sp_refreshview N'[dbo].[PREDMaint]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_RedundancyTaxFreeGet]'
GO

CREATE  PROC [dbo].[vspPR_AU_ETP_RedundancyTaxFreeGet]
/***********************************************************/
-- CREATED BY: EN 2/22/2013  TFS-39858
-- MODIFIED BY: EN 4/5/2013 Story 44310 / Task 45407  Added solution for ignoring days without pay
--
-- USAGE:
-- Determines what portion of Redundancy and Early Retirement (ATO Category ETPR) earnings
-- is Tax-Free and what is ETP Taxable.  
--
-- The Tax-Free portion will be reported on the PAYG statement as Lump Sum D.
-- The remaining, ETP Taxable portion will be included in the Gross Payments of the PAYG statement.
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @UseSubjectAmountYN		If = Y then computation will be based on SubjectAmount passed in, 
--								otherwise SubjectAmount will be the totals ETPR earnings for the employee
--   @SubjectAmount				SubjectAmount on which to base the computation
--   @HireDate					Employee's date of hire
--   @SeparationDate			Employee's termination date
--   @RedundancyTaxFreeBasis	Base amount (basic tax free portion)
--   @RedundancyTaxFreeYears	Per Year tax free amount
--
-- OUTPUT PARAMETERS
--	 @RedundancyTaxFreePortion	Portion of the employee's ETP Redundancy earnings that are Tax-Free
--	 @RedundancyTaxablePortion	Portion of the employee's ETP Redundancy earnings that are Taxable
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @UseSubjectAmountYN bYN = 'N',
 @SubjectAmount bDollar = 0,
 @HireDate bDate = NULL,
 @SeparationDate bDate = NULL,
 @RedundancyTaxFreeBasis bDollar = 0,
 @RedundancyTaxFreeYears bDollar = 0,
 @RedundancyTaxFreePortion bDollar OUTPUT,
 @RedundancyTaxablePortion bDollar OUTPUT,
 @ErrorMsg varchar(100) OUTPUT
)

AS
SET NOCOUNT ON

BEGIN TRY

	DECLARE @Return_Value tinyint
			
	------------------
	-- PRIME VALUES --
	------------------
    SET @Return_Value = 0
    SET @ErrorMsg = ''
    
	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @HireDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Hire Date!'
			GOTO vspExit
		END
		
	IF @SeparationDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Separation Date!'
			GOTO vspExit
		END


	-------------------------------------------------------------------------------------------------
	-- IF NOT USING THE SUBJECT AMOUNT PASSED IN, SUBJECT AMOUNT WILL BE THE OVERALL ETPR EARNINGS --
	-------------------------------------------------------------------------------------------------
	IF @UseSubjectAmountYN = 'N'
	BEGIN
		SELECT @SubjectAmount = SUM(PREA.Amount)
		FROM dbo.bPREA PREA (NOLOCK)
		JOIN dbo.bPREC PREC ON PREC.PRCo = PREA.PRCo AND PREC.EarnCode = PREA.EDLCode
		WHERE PREA.PRCo = @PRCo AND
				PREA.Employee = @Employee AND
				PREA.EDLType = 'E' AND
				PREC.ATOCategory = 'ETPR'
		GROUP BY PREA.PRCo, PREA.Employee
	END


	-------------------------------------------------------------------------------------------------------------
	-- DETERMINE # OF YEARS WORKED (FRACTIONAL PART IS IGNORED) AND USE TO COMPUTE REDUNDANCY TAX FREE PORTION --
	-------------------------------------------------------------------------------------------------------------
	DECLARE @YearsWorked tinyint
		
	SET @YearsWorked = FLOOR((DATEDIFF(DAY, @HireDate, @SeparationDate)) / 365.25)

	SET @RedundancyTaxFreePortion = @RedundancyTaxFreeBasis + (@YearsWorked * @RedundancyTaxFreeYears)


	--------------------------------------------------------------------------------------------------------------
	-- COMPUTE ETP TAX FREE AND TAXABLE PORTIONS ALLOWING FOR THE CHANCE THAT ALL ETPR EARNINGS MAY BE TAX FREE --
	--------------------------------------------------------------------------------------------------------------
	IF @RedundancyTaxFreePortion > @SubjectAmount SET @RedundancyTaxFreePortion = @SubjectAmount

	SET @RedundancyTaxablePortion = @SubjectAmount - @RedundancyTaxFreePortion


END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value



GO
PRINT N'Refreshing [dbo].[vrvPMMeetMin]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMMeetMin]'
GO
PRINT N'Refreshing [dbo].[EMDE]'
GO
EXEC sp_refreshview N'[dbo].[EMDE]'
GO
PRINT N'Refreshing [dbo].[viDim_PRCrews]'
GO
EXEC sp_refreshview N'[dbo].[viDim_PRCrews]'
GO
PRINT N'Refreshing [dbo].[vrvSMWorkOrderStatusByTechnician]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMWorkOrderStatusByTechnician]'
GO
PRINT N'Refreshing [dbo].[brvReportInfo]'
GO
EXEC sp_refreshview N'[dbo].[brvReportInfo]'
GO
PRINT N'Refreshing [dbo].[INCWGRID]'
GO
EXEC sp_refreshview N'[dbo].[INCWGRID]'
GO
PRINT N'Refreshing [dbo].[brvCMST]'
GO
EXEC sp_refreshview N'[dbo].[brvCMST]'
GO
PRINT N'Altering [dbo].[vspPRAUPAYGEmplItemAmountsGet]'
GO

/****** Object:  Stored Procedure dbo.vspPRAUPAYGEmplItemAmountsGet    Script Date: 8/28/99 9:33:18 AM ******/
ALTER  PROC [dbo].[vspPRAUPAYGEmplItemAmountsGet]
/***********************************************************/
-- CREATED BY: EN 6/21/2011
-- MODIFIED BY: EN 02/27/2013  TFS-39858
--				EN 5/14/2013 User Story 39860 / Task 42416 - mods to vspPR_AU_ETP_LimitsAndRatesGet output params
--				EN 5/15/2013 User Story 39860 / Task 42416 - mods to vspPR_AU_ETP_RedundancyTaxFreeGet params
--				EN 5/20/2013 User Story 49517 / Task 50627 - Do NOT include ETP in Gross Payments which includes not backing out Lump Sum D from Gross Payments
--				EN 5/20/2013 User Story 50989 / Task 50990 - **CLEANUP** No need to dis-include ETP earnings in Gross Payments since they are no longer included in the vPRAUEmployerATOItems list
-- USAGE:
-- Gets the PAYG ATO/Super Amounts for a specific employee.  
--
-- INPUT PARAMETERS
--   @PRCo					PR Company
--   @TaxYear				Tax Year
--	 @Employee				Employee
--	 @FirstMonthIsPartialYN
--	 @FromDate
--	 @PartialMonthThruDate
--	 @PRAUBeginMonth
--	 @PRAUEndMonth
--	 @FBTBeginMonth
--	 @FBTEndMonth
--	 @EndDate				Ending Date of pay date range to update
--	 @LastDateOfEndMonth
--	 @FBTLastDateOfEndMonth
--
-- OUTPUT PARAMETERS
--   @errmsg	Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @TaxYear char(4) = NULL,
 @Employee bEmployee = NULL,
 @FirstMonthIsPartialYN bYN = 'N',
 @FromDate bDate = NULL,
 @PartialMonthThruDate bDate = NULL,
 @PRAUBeginMonth bDate = NULL,
 @PRAUEndMonth bDate = NULL,
 @FBTBeginMonth bDate = NULL, 
 @FBTEndMonth bDate = NULL,
 @ThruDate bDate = NULL,
 @LastDateOfEndMonth bDate = NULL,
 @FBTLastDateOfEndMonth bDate = NULL,
 @errmsg varchar(4000) OUTPUT
)
AS
SET NOCOUNT ON

DECLARE @rcode int
SET @rcode = 0

-- Search for amounts
DECLARE @EmployerItems TABLE (ItemCode char(4) NOT NULL,
							  EDLType char(1) NOT NULL,
							  EDLCode bEDLCode NOT NULL)

INSERT @EmployerItems
		SELECT	ItemCode, EDLType, EDLCode 
		FROM dbo.vPRAUEmployerATOItems 
		WHERE	PRCo = @PRCo AND TaxYear = @TaxYear
		UNION
		SELECT	ItemCode, DLType AS [EDLType], DLCode AS [EDLCode] 
		FROM dbo.vPRAUEmployerSuperItems 
		WHERE	PRCo = @PRCo AND TaxYear = @TaxYear

DECLARE @AmountData TABLE (ItemCode char(4) NOT NULL, 
						   EDLType char(1) NOT NULL, 
						   Amount bDollar NOT NULL, 
						   LSAType char(1) NULL)
 
-- Search for amounts
INSERT @AmountData
	-- Using Detail (PRDT) when first month of summary is a partial month
	-- This would never be the first summary for the employee/tax year 
	-- Items besides GR, FBT, and LSA
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END), 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
			AND @FirstMonthIsPartialYN = 'Y' 
			AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode NOT IN ('GR  ', 'FBT ', 'LSA ')
	GROUP BY Items.ItemCode, Items.EDLType
	
	UNION

	-- GR Deductions subject amount (+)
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PRDT.SubjectAmt), 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
			AND @FirstMonthIsPartialYN = 'Y' 
			AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'D'
	GROUP BY Items.ItemCode, Items.EDLType

	UNION
		
	-- GR Earnings amount (-)  Taxable Allowances as well as Lump Sum A, B, and E reduce the reported Gross Payments amount
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) * -1, 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	JOIN dbo.PREC PREC ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
			AND @FirstMonthIsPartialYN = 'Y' 
			AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'E'
			--AND PREC.ATOCategory NOT IN ('ETP', 'ETPR', 'ETPV', 'ETPU', 'ETPD')
	GROUP BY Items.ItemCode, Items.EDLType

	--UNION
		
	---- GR Earnings amount (+)  Include ETP, ETPR (Lump Sum D exclusion in code to follow), ETPV, ETPU, and ETPD in reported Gross Payments amount
	--SELECT	Items.ItemCode, 
	--		Items.EDLType, 
	--		SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END), 
	--		NULL 
	--FROM dbo.bPRDT PRDT (nolock)
	--JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	--JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
	--								AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
	--								AND PRSQ.Employee = PRDT.Employee
	--JOIN dbo.PREC PREC ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode
	--WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
	--		AND @FirstMonthIsPartialYN = 'Y' 
	--		AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
	--		AND PRSQ.CMRef IS NOT NULL
	--		AND PRDT.OldMth IS NOT NULL
	--		AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'E'
	--		AND PREC.ATOCategory IN ('ETP', 'ETPR', 'ETPV', 'ETPU', 'ETPD')
	--GROUP BY Items.ItemCode, Items.EDLType

	UNION
		
	-- FBT Earnings and Liabilities (+)
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END), 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
			AND @FirstMonthIsPartialYN = 'Y' 
			AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND (Items.ItemCode = 'FBT ' AND Items.EDLType IN ('E', 'L'))
	GROUP BY Items.ItemCode, Items.EDLType
	
	UNION
	
	-- FBT Deductions (-)
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) * -1, 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
			AND @FirstMonthIsPartialYN = 'Y' 
			AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND (Items.ItemCode = 'FBT ' AND Items.EDLType = 'D')
	GROUP BY Items.ItemCode, Items.EDLType

	UNION
	
	-- LSA items
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END), 
			(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	JOIN dbo.bPREC PREC (nolock) ON PREC.PRCo = PRDT.PRCo AND PRDT.EDLType = 'E' AND PREC.EarnCode = PRDT.EDLCode
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee
			AND @FirstMonthIsPartialYN = 'Y' 
			AND PRSQ.PaidDate BETWEEN @FromDate AND @PartialMonthThruDate
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode = 'LSA '
	GROUP BY Items.ItemCode, Items.EDLType, PREC.ATOCategory

	UNION
	
	-- Adding ACCUMS (PRAU)
	-- Items besides GR, FBT, and LSA
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PREA.Amount), 
			NULL 
	FROM @EmployerItems Items
	JOIN dbo.bPREA PREA (nolock) ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
			AND PREA.Mth BETWEEN @PRAUBeginMonth AND @PRAUEndMonth 
			AND Items.ItemCode NOT IN ('GR  ', 'FBT ', 'LSA ')
	GROUP BY Items.ItemCode, Items.EDLType
	
	UNION

	-- GR Deductions subject amount (+)
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PREA.SubjectAmt), 
			NULL 
	FROM @EmployerItems Items
	JOIN dbo.bPREA PREA (nolock)ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
			AND PREA.Mth BETWEEN @PRAUBeginMonth AND @PRAUEndMonth 
			AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'D'
	GROUP BY Items.ItemCode, Items.EDLType

	UNION
		
	-- GR Earnings amount (-)  Taxable Allowances as well as Lump Sum A, B, and E reduce the reported Gross Payments amount
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PREA.Amount) * -1, 
			NULL 
	FROM @EmployerItems Items
	JOIN dbo.bPREA PREA (nolock) ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	JOIN dbo.PREC PREC ON PREC.PRCo = PREA.PRCo AND PREC.EarnCode = PREA.EDLCode
	WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
			AND PREA.Mth BETWEEN @PRAUBeginMonth AND @PRAUEndMonth 
			AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'E'
			--AND PREC.ATOCategory NOT IN ('ETP', 'ETPR', 'ETPV', 'ETPU', 'ETPD')
	GROUP BY Items.ItemCode, Items.EDLType

	--UNION
		
	---- GR Earnings amount (+)  Include ETP, ETPR (Lump Sum D exclusion in code to follow), ETPV, ETPU, and ETPD in reported Gross Payments amount
	--SELECT	Items.ItemCode, 
	--		Items.EDLType, 
	--		SUM(PREA.Amount), 
	--		NULL 
	--FROM @EmployerItems Items
	--JOIN dbo.bPREA PREA (nolock) ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	--JOIN dbo.PREC PREC ON PREC.PRCo = PREA.PRCo AND PREC.EarnCode = PREA.EDLCode
	--WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
	--		AND PREA.Mth BETWEEN @PRAUBeginMonth AND @PRAUEndMonth 
	--		AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'E'
	--		AND PREC.ATOCategory IN ('ETP', 'ETPR', 'ETPV', 'ETPU', 'ETPD')
	--GROUP BY Items.ItemCode, Items.EDLType

	UNION
			
	-- FBT Earnings and Liabilities (+)
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PREA.Amount), 
			NULL 
	FROM @EmployerItems Items
	JOIN dbo.bPREA PREA (nolock) ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
			AND PREA.Mth BETWEEN @FBTBeginMonth AND @FBTEndMonth 
			AND (Items.ItemCode = 'FBT ' AND Items.EDLType IN ('E', 'L'))
	GROUP BY Items.ItemCode, Items.EDLType
	
	UNION
	
	-- FBT Deductions (-)
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PREA.Amount) * -1, 
			NULL 
	FROM @EmployerItems Items
	JOIN dbo.bPREA PREA (nolock) ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
			AND PREA.Mth BETWEEN @FBTBeginMonth AND @FBTEndMonth 
			AND (Items.ItemCode = 'FBT ' AND Items.EDLType = 'D')
	GROUP BY Items.ItemCode, Items.EDLType

	UNION
	
	-- LSA items
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PREA.Amount), 
			(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) 
	FROM @EmployerItems Items
	JOIN dbo.bPREA PREA (nolock) ON PREA.EDLType = Items.EDLType AND PREA.EDLCode = Items.EDLCode
	JOIN dbo.bPREC PREC (nolock) ON PREC.PRCo = PREA.PRCo AND PREA.EDLType = 'E' AND PREC.EarnCode = PREA.EDLCode
	WHERE	PREA.PRCo = @PRCo AND PREA.Employee = @Employee
			AND PREA.Mth BETWEEN @PRAUBeginMonth AND @PRAUEndMonth 
			AND Items.ItemCode = 'LSA '
	GROUP BY Items.ItemCode, Items.EDLType, PREC.ATOCategory

	UNION
	
	-- Subtracting Detail (PRDT) from last month accums when getting amounts for partial last month
	-- Subtract Items besides GR, FBT, and LSA
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) * -1, 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee 
			AND PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @LastDateOfEndMonth
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode NOT IN ('GR  ', 'FBT ', 'LSA ')
	GROUP BY Items.ItemCode, Items.EDLType
	
	UNION

	-- Subtract GR Deductions subject amount
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(PRDT.SubjectAmt) * -1, 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee 
			AND PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @LastDateOfEndMonth
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'D'
	GROUP BY Items.ItemCode, Items.EDLType

	UNION
		
	-- Add back GR Earnings amounts for Taxable Allowances as well as Lump Sum A, B, and E
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END), 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	JOIN dbo.PREC PREC ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee 
			AND PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @LastDateOfEndMonth
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'E'
			--AND PREC.ATOCategory NOT IN ('ETP', 'ETPR', 'ETPV', 'ETPU', 'ETPD')
	GROUP BY Items.ItemCode, Items.EDLType

	--UNION
		
	---- Subtract GR Earnings amount for ATO Categories ETP, ETPR (Lump Sum D exclusion in code to follow), ETPV, ETPU, and ETPD
	--SELECT	Items.ItemCode, 
	--		Items.EDLType, 
	--		SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) * -1, 
	--		NULL 
	--FROM dbo.bPRDT PRDT (nolock)
	--JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	--JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
	--								AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
	--								AND PRSQ.Employee = PRDT.Employee
	--JOIN dbo.PREC PREC ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode
	--WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee 
	--		AND PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @LastDateOfEndMonth
	--		AND PRSQ.CMRef IS NOT NULL
	--		AND PRDT.OldMth IS NOT NULL
	--		AND Items.ItemCode = 'GR  ' AND Items.EDLType = 'E'
	--		AND PREC.ATOCategory IN ('ETP', 'ETPR', 'ETPV', 'ETPU', 'ETPD')
	--GROUP BY Items.ItemCode, Items.EDLType

	UNION
		
	-- Subtract FBT Earnings and Liabilities
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) * -1, 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee 
			AND PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @FBTLastDateOfEndMonth
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND (Items.ItemCode = 'FBT ' AND Items.EDLType IN ('E', 'L'))
	GROUP BY Items.ItemCode, Items.EDLType
	
	UNION
	
	-- Add back FBT Deductions
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END), 
			NULL 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee 
			AND PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @FBTLastDateOfEndMonth
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND (Items.ItemCode = 'FBT ' AND Items.EDLType = 'D')
	GROUP BY Items.ItemCode, Items.EDLType

	UNION
	
	-- Subtract LSA items
	SELECT	Items.ItemCode, 
			Items.EDLType, 
			SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) * -1, 
			(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) 
	FROM dbo.bPRDT PRDT (nolock)
	JOIN @EmployerItems Items ON Items.EDLType = PRDT.EDLType AND Items.EDLCode = PRDT.EDLCode
	JOIN dbo.bPRSQ PRSQ (nolock) ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
									AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
									AND PRSQ.Employee = PRDT.Employee
	JOIN dbo.bPREC PREC (nolock) ON PREC.PRCo = PRDT.PRCo AND PRDT.EDLType = 'E' AND PREC.EarnCode = PRDT.EDLCode
	WHERE	PRDT.PRCo = @PRCo AND PRDT.Employee = @Employee AND 
			PRSQ.PaidDate BETWEEN DATEADD(Day, 1, @ThruDate) AND @LastDateOfEndMonth
			AND PRSQ.CMRef IS NOT NULL
			AND PRDT.OldMth IS NOT NULL
			AND Items.ItemCode = 'LSA '
	GROUP BY Items.ItemCode, Items.EDLType, PREC.ATOCategory

-- If employee was terminated for reason of genuine redundancy or approved early retirement,
-- exclude Lump Sum D (Tax-Free) portion of ETPR payments from Gross Payments.
DECLARE	@SeparationRedundancyRetirement bYN,
		@HireDate bDate,
		@SeparationDate bDate,
		@TaxFreePortion bDollar,
		@ETPRTaxablePortion bDollar

SELECT @SeparationRedundancyRetirement = SeparationRedundancyRetirement,
	   @HireDate = (CASE WHEN RecentRehireDate IS NULL THEN HireDate ELSE RecentRehireDate END),
	   @SeparationDate = RecentSeparationDate

FROM dbo.bPREH
WHERE PRCo = @PRCo AND Employee = @Employee

IF @SeparationRedundancyRetirement = 'Y'
BEGIN
	DECLARE	@Return_Value int

	-- Retrieve ATO-provided information stored in table vPRAULimitsAndRates	
	DECLARE	@ETPCap bDollar,
			@WholeIncomeCap bDollar,
			@RedundancyTaxFreeBasis bDollar,
			@RedundancyTaxFreeYears bDollar,
			@UnderPreservationAgePct bPct,
			@OverPreservationAgePct bPct,
			@ExcessCapPct bPct,
			@AnnualLeaveLoadingPct bPct,
			@LeaveFlatRatePct bPct,
			@LeaveFlatRateLimit bDollar

	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_LimitsAndRatesGet]
			@ThruDate,
			@ETPCap OUTPUT,
			@WholeIncomeCap OUTPUT,
			@RedundancyTaxFreeBasis OUTPUT,
			@RedundancyTaxFreeYears OUTPUT,
			@UnderPreservationAgePct OUTPUT,
			@OverPreservationAgePct OUTPUT,
			@ExcessCapPct OUTPUT,
			@AnnualLeaveLoadingPct OUTPUT,
			@LeaveFlatRatePct OUTPUT,
			@LeaveFlatRateLimit OUTPUT,
			@errmsg OUTPUT
	
	IF @Return_Value = 1 
	BEGIN
		SET @rcode = 1
		GOTO vspExit
	END

	-- get the Tax-Free component of the Genuine Redundancy or Approved Early Retirement ETP
	DECLARE @UseSubjectAmtYN bYN,
			@SubjectAmt bDollar,
			@RedundancyTaxFreePortion bDollar,
			@RedundancyTaxablePortion bDollar

	SET @UseSubjectAmtYN = 'N'
	SET @SubjectAmt = 0

	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_RedundancyTaxFreeGet]
			@PRCo,
			@Employee,
			@UseSubjectAmtYN,
			@SubjectAmt, 
			@HireDate, 
			@SeparationDate,
			@RedundancyTaxFreeBasis, 
			@RedundancyTaxFreeYears,
			@RedundancyTaxFreePortion OUTPUT,
			@RedundancyTaxablePortion OUTPUT,
			@ErrorMsg = @errmsg OUTPUT

	IF @Return_Value = 1 
	BEGIN
		SET @rcode = 1
		GOTO vspExit
	END

	---- subtract the Tax-Free component from any ETPR amounts included above in the AmountData
	--INSERT @AmountData 
	--SELECT 'GR  ' AS ItemCode, 
	--	   'E' AS EDLType, 
	--	   @RedundancyTaxFreePortion * -1 AS Amount, 
	--	   NULL AS LSAType

	-- add an AmountData entry to assign the Tax-Free component as Lump Sum D
	INSERT @AmountData 
	SELECT 'LSD ' AS ItemCode, 
		   'E' AS EDLType, 
		   @RedundancyTaxFreePortion AS Amount, 
		   NULL AS LSAType
END


-- RETURN RESULTSET
SELECT * FROM @AmountData 	


vspExit:
	RETURN @rcode
GO
PRINT N'Refreshing [dbo].[vrvPMOH]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMOH]'
GO
PRINT N'Refreshing [dbo].[viDim_PRGroups]'
GO
EXEC sp_refreshview N'[dbo].[viDim_PRGroups]'
GO
PRINT N'Refreshing [dbo].[vrvSMWorkOrderTotalsByLineType]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMWorkOrderTotalsByLineType]'
GO
PRINT N'Refreshing [dbo].[brvRPReportType]'
GO
EXEC sp_refreshview N'[dbo].[brvRPReportType]'
GO
PRINT N'Refreshing [dbo].[brvDistinctEMCD]'
GO
EXEC sp_refreshview N'[dbo].[brvDistinctEMCD]'
GO
PRINT N'Creating [dbo].[vspPR_AU_UnderPreservationAgeYN]'
GO

CREATE  PROC [dbo].[vspPR_AU_UnderPreservationAgeYN]
/***********************************************************/
-- CREATED BY: EN 3/07/2013  TFS-39860
-- MODIFIED BY: 
--
-- USAGE:
-- Determines if an employee is under the preservation (retirement) age for
-- ETP withholding tax computation.  Employee's birth date is compared to 
-- a preservation age change phase-in period that is for workers born from
-- 1 July 1960 through 30 June 1964.
--
-- 
-- INPUT PARAMETERS
--   @BirthDate	Employee's birth date
--
-- OUTPUT PARAMETERS
--	 @UnderPreservationAgeYN	'Y' if employee is under the preservation age
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @BirthDate bDate = NULL,
 @UnderPreservationAgeYN bYN OUTPUT,
 @errmsg varchar(1000) OUTPUT
)
AS
SET NOCOUNT ON

-- validate BirthDate
IF @BirthDate IS NULL
BEGIN
	SELECT @errmsg = 'Missing Birth Date'
	RETURN 1
END

-- determine the Employee's age
DECLARE @EmployeeAge int

SELECT @EmployeeAge = FLOOR(DATEDIFF(DAY, @BirthDate, GETDATE()) / 365.25)

-- determine the Employee's preservation age
DECLARE @PreservationAge tinyint

SELECT @PreservationAge = CASE
							WHEN @BirthDate < '7/1/1960'					   THEN 55
							WHEN @BirthDate BETWEEN '7/1/1960' AND '6/30/1961' THEN 56
							WHEN @BirthDate BETWEEN '7/1/1961' AND '6/30/1962' THEN 57
							WHEN @BirthDate BETWEEN '7/1/1962' AND '6/30/1963' THEN 58
							WHEN @BirthDate BETWEEN '7/1/1963' AND '6/30/1964' THEN 59
							ELSE													60
						  END

-- determine employee's preservation age status							
IF @EmployeeAge < @PreservationAge 
BEGIN
	SELECT @UnderPreservationAgeYN = 'Y'
END
ELSE
BEGIN
	SELECT @UnderPreservationAgeYN = 'N'
END


RETURN 0
GO
PRINT N'Refreshing [dbo].[vrvPMOP]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMOP]'
GO
PRINT N'Refreshing [dbo].[EMDepartmentRole]'
GO
EXEC sp_refreshview N'[dbo].[EMDepartmentRole]'
GO
PRINT N'Refreshing [dbo].[viFact_APJobCost]'
GO
EXEC sp_refreshview N'[dbo].[viFact_APJobCost]'
GO
PRINT N'Refreshing [dbo].[SMRateTemplateEffectiveDate]'
GO
EXEC sp_refreshview N'[dbo].[SMRateTemplateEffectiveDate]'
GO
PRINT N'Refreshing [dbo].[JCPDTotals]'
GO
EXEC sp_refreshview N'[dbo].[JCPDTotals]'
GO
PRINT N'Refreshing [dbo].[brvRQReviewers]'
GO
EXEC sp_refreshview N'[dbo].[brvRQReviewers]'
GO
PRINT N'Refreshing [dbo].[EMRX]'
GO
EXEC sp_refreshview N'[dbo].[EMRX]'
GO
PRINT N'Refreshing [dbo].[brvDistinctEMCD_Time]'
GO
EXEC sp_refreshview N'[dbo].[brvDistinctEMCD_Time]'
GO
PRINT N'Creating [dbo].[vspPR_AU_TaxYearWagesGet]'
GO

CREATE  PROC [dbo].[vspPR_AU_TaxYearWagesGet]
/***********************************************************/
-- CREATED BY: EN 3/26/2013
-- MODIFIED BY: 
--
-- USAGE:
-- Returns the amount of taxable wages earned by an employee for the current Australian tax year
-- based on the PR Ending Date. 
--
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @PREndDate					Last Payroll End Date of the tax year
--
-- OUTPUT PARAMETERS
--	 @TaxableAmount				Employee's taxable (PAYG) subject amount for the current tax year
--   @ErrorMsg					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PREndDate bDate = NULL,
 @TaxableWages bDollar OUTPUT,
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing PR Company!'
		GOTO vspExit
	END
		
	IF @Employee IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Employee!'
		GOTO vspExit
	END

	IF @PREndDate IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Pay Period Ending Date!'
		GOTO vspExit
	END

	
	-----------------------------------
	-- DETERMINE 1ST DAY OF TAX YEAR --
	-----------------------------------
	DECLARE @TaxYear int,
			@TaxYearBeginDate bDate

	SELECT	@TaxYear = DATEPART(YEAR,@PREndDate)
	
	IF DATEPART(MONTH,@PREndDate) IN (1,2,3,4,5,6) SELECT @TaxYear = @TaxYear - 1
	
	SELECT	@TaxYearBeginDate = '07/01/' + CAST(@TaxYear AS varchar)


	------------------------------------------------------
	-- GET DEDUCTION CODE USED FOR THE FEDERAL PAYG TAX --
	------------------------------------------------------
	DECLARE @PAYGDednCode bEDLCode

	SELECT @PAYGDednCode = TaxDedn
	FROM PRFI
	WHERE PRCo = @PRCo


	-------------------------------------------------------------------
	-- DETERMINE THE TOTAL TAXABLE EARNINGS FOR THE CURRENT TAX YEAR --
	-------------------------------------------------------------------
	;WITH TaxYearWages (SubjectAmount)
	AS
	(
		SELECT  SUM(PRDT.SubjectAmt)
		FROM	dbo.bPRDT PRDT
		JOIN	dbo.bPRSQ PRSQ ON PRSQ.PRCo = PRDT.PRCo 
								  AND PRSQ.PRGroup = PRDT.PRGroup  
								  AND PRSQ.PREndDate = PRDT.PREndDate  
								  AND PRSQ.Employee = PRDT.Employee  
								  AND PRSQ.PaySeq = PRDT.PaySeq
		WHERE	PRDT.PRCo = @PRCo AND
				PRDT.Employee = @Employee AND
				PRDT.EDLType = 'D' AND
				PRDT.EDLCode = @PAYGDednCode AND
				PRSQ.PaidDate >= @TaxYearBeginDate AND PRSQ.PaidDate < @PREndDate
				
		UNION
		
		SELECT  PRDT.SubjectAmt
		FROM	dbo.bPRDT PRDT
		WHERE	PRDT.PRCo = @PRCo AND
				PRDT.Employee = @Employee AND
				PRDT.EDLType = 'D' AND
				PRDT.EDLCode = @PAYGDednCode AND
				PRDT.PREndDate = @PREndDate
	)

	SELECT	@TaxableWages = SUM(SubjectAmount)
	FROM TaxYearWages

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[HQPD]'
GO
EXEC sp_refreshview N'[dbo].[HQPD]'
GO
PRINT N'Refreshing [dbo].[viFact_EMCost]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMCost]'
GO
PRINT N'Refreshing [dbo].[JCPhaseNoGroup]'
GO
EXEC sp_refreshview N'[dbo].[JCPhaseNoGroup]'
GO
PRINT N'Refreshing [dbo].[brvSLCD_DistinctSL]'
GO
EXEC sp_refreshview N'[dbo].[brvSLCD_DistinctSL]'
GO
PRINT N'Refreshing [dbo].[brvDistinctEMWP]'
GO
EXEC sp_refreshview N'[dbo].[brvDistinctEMWP]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_TaxRatesGet]'
GO
CREATE procedure [dbo].[vspPR_AU_ETP_TaxRatesGet]
/************************************************************************
* CREATED:	DAN SO 03/07/2013 - TFS: User Story 39860:PR ETP Redundancy Tax Calculations - 1
*							  - Co-developed with Ellen BN
* MODIFIED:
*
* Purpose of Stored Procedure
*
*    Get AU ETP Tax Rates 
*    
* 
* INPUT
*	@ATOETPType			- ATO ETP Type (ETPR, ETPV, ETP, ETPD, ETPU)
*	@UnderPresAgePct	- Under Preservation Age Percent
*	@OverPresAgePct		- Over Preservation Age Percent
*	@ExcessCapPct		- Above Cap Percent
*	@DelayPayPct		- Delayed Payment Percent
*	@NoTFNPct			- No Employee TFN Percent
*	@UnderPresAgeYN		- Employee Under the Preservation Age YN
*	@TFNProvidedYN		- Was a TFN provided by the Employee YN
*	@ForeignResYN		- Is the Employee a prescribed Foreign Resident YN
*   @PREndDate		    - Employee Last Payroll Date 
*
* OUTPUT
*	@UpToCapPct			- Rate up to Cap amount
*	@AboveCapPct		- Rate above Cap amount
*	@rcode				- Return Code - (0)Successful, (1)Failure
*	@ErrorMsg			- Error Message
*************************************************************************/
(@ATOETPType CHAR(4) = NULL,
 @UnderPresAgePct bPct = NULL, @OverPresAgePct bPct = NULL, 
 @ExcessCapPct bPct = NULL, @NoTFNPct bPct = NULL, 
 @ForeignResPct bPct = NULL, @DelayPayPct bPct = NULL,
 @UnderPresAgeYN bYN = NULL,  @TFNProvidedYN bYN = NULL, 
 @ForeignResYN bYN = NULL,  @PREndDate bDate = NULL,
 @UpToCapPct bPct OUTPUT, @AboveCapPct bPct OUTPUT, 
 @ErrorMsg VARCHAR(255) OUTPUT)

AS

BEGIN TRY

	SET NOCOUNT ON

    DECLARE 
			@rcode INT


	------------------
	-- PRIME VALUES --
	------------------
    SET @rcode = 0
    SET @ErrorMsg = ''


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @ATOETPType IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing ATO ETP Type!'
			GOTO vspExit
		END
		
	IF @UnderPresAgePct IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Under Preservation Age Percent!'
			GOTO vspExit
		END
		
	IF @OverPresAgePct IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Over Preservation Age Percent!'
			GOTO vspExit
		END
			
	IF @ExcessCapPct IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Excessive Cap Percent!'
			GOTO vspExit
		END
		
	IF @NoTFNPct IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing No TFN Percent!'
			GOTO vspExit
		END
		
	IF @ForeignResPct IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Foreign Resident Percent!'
			GOTO vspExit
		END
		
	IF @DelayPayPct IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Delayed Payment Percent!'
			GOTO vspExit
		END
			
	IF @UnderPresAgeYN IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Under Preservation Age YN!'
			GOTO vspExit
		END

	IF @TFNProvidedYN IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing TFN Supplied YN!'
			GOTO vspExit
		END
		
	IF @ForeignResYN IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Foreign Resident YN!'
			GOTO vspExit
		END	

	IF @PREndDate IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Last Payroll Ending Date!'
			GOTO vspExit
		END

		
	------------------
	-- SET PERCENTS --
	------------------
	
	-- JUST SETTING THESE PERCENTS - WANTED TO KEEP ALL PERCENT LOGIC IN THIS SP --
	SET @AboveCapPct = @ExcessCapPct
	
	-- PRESERVATION AGE RATE SET --
	SET @UpToCapPct = @OverPresAgePct
	IF UPPER(@UnderPresAgeYN) = 'Y'  SET @UpToCapPct = @UnderPresAgePct
	
	-- DEATH PAY --    
	IF @ATOETPType = 'ETPD'  SET @UpToCapPct = 0.0
		
	-- DETERMINE "Delayed Termimnation Payment -- A PAYMENT MADE OUTSIDE 12 MONTHS -- USED DAYS BECAUSE DATEDIFF IS KIND OF LAME --
	-- OVERRIDE ALL RATES --
	IF DATEDIFF(DAY, @PREndDate, GETDATE()) >= 365 
		BEGIN
			-- BASIC RATE --
			SET @UpToCapPct = @DelayPayPct
			SET @OverPresAgePct = @DelayPayPct
	
			-- TFN/FOREIGN RESIDENT RATE SET --
			IF @TFNProvidedYN = 'N'
				BEGIN
					SET @UpToCapPct = @NoTFNPct
					SET @OverPresAgePct = @NoTFNPct
				
					IF @ForeignResYN = 'Y'
						BEGIN
							SET @UpToCapPct = @ForeignResPct
							SET @OverPresAgePct = @ForeignResPct
						END
				END
		END

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @rcode = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @rcode


GO
PRINT N'Refreshing [dbo].[EMDL]'
GO
EXEC sp_refreshview N'[dbo].[EMDL]'
GO
PRINT N'Refreshing [dbo].[viFact_EMEquipment]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMEquipment]'
GO
PRINT N'Refreshing [dbo].[SMRateOverride]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverride]'
GO
PRINT N'Refreshing [dbo].[APFT]'
GO
EXEC sp_refreshview N'[dbo].[APFT]'
GO
PRINT N'Refreshing [dbo].[brvSLChangeOrders]'
GO
EXEC sp_refreshview N'[dbo].[brvSLChangeOrders]'
GO
PRINT N'Refreshing [dbo].[brvEMAttachments]'
GO
EXEC sp_refreshview N'[dbo].[brvEMAttachments]'
GO
PRINT N'Refreshing [dbo].[EMUR]'
GO
EXEC sp_refreshview N'[dbo].[EMUR]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_InvalidityTaxFreeGet]'
GO
CREATE PROCEDURE [dbo].[vspPR_AU_ETP_InvalidityTaxFreeGet]
/***********************************************************
* CREATED:	DAN SO 03/07/2013 - TFS: User Story 39860:PR ETP Redundancy Tax Calculations - 1
*							  - Co-developed with Ellen BN
* MODIFIED BY:	EN 4/5/2013 Story 44310 / Task 45407  Added solution for ignoring days without pay
*				DAN SO 04/26/2013 - Task 48575 - If Retirement Date < Invalidity Date - ALL Invalidity earnings are taxable
*				DAN SO 04/30/2013 - Task 48575 - Changed @RetirementAge datatype from INT to bUnits
*
* USAGE:
* Determines what portion of Invalidity (ATO Type: ETPV) earnings
* that is Tax-Free and what is Taxable.  
*
* INPUT PARAMETERS
*	@PRCo					- PR Company
*   @Employee				- Employee number
*	@ETPAmt					- ETP Amount
*	@BirthDate				- Employee birth date
*   @HireDate				- Employee hire date
*   @SeparationDate			- Employee separation date
*
* OUTPUT PARAMETERS
*	@InvalidityTaxFreePortion	- Portion of the employee's Invalidity ETP that is Tax-Free
*	@InvalidityTaxablePortion	- Portion of the employee's Invalidity ETP that is Taxable
*   @ErrorMsg					- Error message if error occurs	
*
* RETURN VALUE
*   0			Success
*   1			Failure
*
******************************************************************/
(@PRCo bCompany = NULL, 
 @Employee bEmployee = NULL, 
 @ETPAmt bDollar = NULL,
 @BirthDate bDate = NULL, @HireDate bDate = NULL, @SeparationDate bDate = NULL,
 @EmployeeGender CHAR(1) = NULL,
 @InvalidityTaxFreePortion bDollar OUTPUT, @InvalidityTaxablePortion bDollar OUTPUT,
 @ErrorMsg VARCHAR(255) OUTPUT)

AS
SET NOCOUNT ON

BEGIN TRY

	DECLARE @RetirementAge bUnits,
			@Return_Value INT
			
	------------------
	-- PRIME VALUES --
	------------------
	SET @RetirementAge = 0
    SET @Return_Value = 0
    SET @ErrorMsg = ''
    
	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @ETPAmt IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing ETP Amount!'
			GOTO vspExit
		END
		
	IF @BirthDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Birth Date!'
			GOTO vspExit
		END

	IF @HireDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Hire Date!'
			GOTO vspExit
		END
		
	IF @SeparationDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Separation Date!'
			GOTO vspExit
		END

	IF @EmployeeGender IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee Gender!'
			GOTO vspExit
		END
		
	
	----------------------------------
	-- INITIALIZE RETURN PARAMETERS --
	----------------------------------
	SET @InvalidityTaxFreePortion = 0
	SET @InvalidityTaxablePortion = @ETPAmt		-- TASK 48575 --
		
	------------------------------
	-- DETERMINE Retirement Age --
	------------------------------
	-- Male Retirement Age --
	SET @RetirementAge = 65 
	
	-- Female Retirement Age --
	IF UPPER(@EmployeeGender) = 'F'
		BEGIN
		
			---------------------
			-- Date YYYY-MM-DD --
			---------------------
			SELECT @RetirementAge =
			  CASE 
				 WHEN @BirthDate < '1935-07-01' THEN 60.5
				 WHEN @BirthDate BETWEEN '1935-07-01' AND '1936-12-31' THEN 60.5
				 WHEN @BirthDate BETWEEN '1937-01-01' AND '1938-06-30' THEN 61
				 WHEN @BirthDate BETWEEN '1938-07-01' AND '1939-12-31' THEN 61.5
				 WHEN @BirthDate BETWEEN '1940-01-01' AND '1941-06-30' THEN 62
				 WHEN @BirthDate BETWEEN '1941-07-01' AND '1942-12-31' THEN 62.5
				 WHEN @BirthDate BETWEEN '1943-01-01' AND '1944-06-30' THEN 63	
				 WHEN @BirthDate BETWEEN '1944-07-01' AND '1945-12-31' THEN 63.5
				 WHEN @BirthDate BETWEEN '1946-01-01' AND '1947-06-30' THEN 64	
				 WHEN @BirthDate BETWEEN '1947-07-01' AND '1948-12-31' THEN 64.5
				 WHEN @BirthDate > '1949-01-01' THEN 65
				 ELSE 0
			  END		
		END
		
	-------------------------------------------------------------------------------------
	-- DETERMINE Whole Days FROM SeparationDate TO WHAT WOULD HAVE BEEN RetirementDate --
	------------------------------------------------------------------------------------- 
	DECLARE @DaysSepToRet INT, 
			@DaysWorked INT, 
			@DaysWithoutPay INT,
			@RetirementDate bDate
	
	SET @RetirementDate = DATEADD(MONTH, (@RetirementAge * 12), @BirthDate)
	SET @DaysSepToRet = DATEDIFF(DAY, @SeparationDate, @RetirementDate) + 1

	EXEC	@Return_Value = [dbo].[vspPRDaysWithoutPayGet]
			@PRCo = @PRCo,
			@Employee = @Employee,
			@FromDate = @HireDate,
			@ThruDate = @SeparationDate,
			@DaysWithoutPay = @DaysWithoutPay OUTPUT,
			@ErrorMsg = @ErrorMsg OUTPUT

	IF @Return_Value <> 0 GOTO vspExit

	SET @DaysWorked = DATEDIFF(DAY, @HireDate - 1, @SeparationDate)	- @DaysWithoutPay

	-----------------------
	-- CALCULATE AMOUNTS --
	-----------------------
	-- TASK 48575 --
	IF @DaysSepToRet > 0
		BEGIN
			SET @InvalidityTaxFreePortion = (@ETPAmt * @DaysSepToRet) / (@DaysWorked + @DaysSepToRet)
			SET @InvalidityTaxablePortion = @ETPAmt - @InvalidityTaxFreePortion
		END

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[vrvPMSubmittalBallInCourt]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMSubmittalBallInCourt]'
GO
PRINT N'Refreshing [dbo].[PMWDPhase]'
GO
EXEC sp_refreshview N'[dbo].[PMWDPhase]'
GO
PRINT N'Refreshing [dbo].[viFact_EMLocation]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMLocation]'
GO
PRINT N'Refreshing [dbo].[SMTripOpen]'
GO
EXEC sp_refreshview N'[dbo].[SMTripOpen]'
GO
PRINT N'Refreshing [dbo].[DDCB]'
GO
EXEC sp_refreshview N'[dbo].[DDCB]'
GO
PRINT N'Refreshing [dbo].[JCPP]'
GO
EXEC sp_refreshview N'[dbo].[JCPP]'
GO
PRINT N'Refreshing [dbo].[SLClaimItem]'
GO
EXEC sp_refreshview N'[dbo].[SLClaimItem]'
GO
PRINT N'Refreshing [dbo].[brvSLClaimTaxInvoice]'
GO
EXEC sp_refreshview N'[dbo].[brvSLClaimTaxInvoice]'
GO
PRINT N'Refreshing [dbo].[brvEMCDDetlDesc]'
GO
EXEC sp_refreshview N'[dbo].[brvEMCDDetlDesc]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_Pre83TaxFreeGet]'
GO

CREATE  PROC [dbo].[vspPR_AU_ETP_Pre83TaxFreeGet]
/***********************************************************/
-- CREATED BY: EN 3/04/2013  TFS-39858
-- MODIFIED BY: EN 4/5/2013 Story 44310 / Task 45407  Added solution for ignoring days without pay
--				DAN SO 04/27/2013 TASK 48576 - Prime @Pre83TaxablePortion = @SubjectAmount and not 0
--				DAN SO 04/30/2013 TASK 48576 - Change from HireDate to 7/01/1983 (6/30/1983)
--				DAN SO 04/30/2013 TASK 48576 - Added @TotalDaysOfEmployment = Pre and Post 83 days worked 
--
-- USAGE:
-- Determines what portion of an ETP/ETPR payment (earnings) is attributed to 
-- days of employment prior to 1 July 1983 and is thereby Tax-Free.
--
-- This computation requires determining the # of days of employment before
-- 1 July 1983 and also the total days of employment.  If the employee was actually
-- hired prior to that date, a factor is computed by dividing # of days before
-- 1 July 1983 by # day of employment and this factor is multiplied by the amount
-- of ETP/ETPR earnings to get the Tax-Free component of the earnings. 
-- 
--
-- INPUT PARAMETERS
--	 @PRCo					PR Company
--	 @Employee				Employee number
--	 @SubjectAmount			SubjectAmount on which to base the computation
--   @HireDate				Employee's date of hire
--   @SeparationDate		Employee's termination date
--
-- OUTPUT PARAMETERS
--	 @Pre83TaxFreePortion	portion of the employee's basis earnings to this dedn code that are Tax-Free
--	 @Pre83TaxablePortion   portion of the employee's basis earnings to this dedn code that are Taxable
--   @Message				Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL, 
 @Employee bEmployee = NULL, 
 @SubjectAmount bDollar = NULL,
 @HireDate bDate = NULL,
 @SeparationDate bDate = NULL,
 @Pre83TaxFreePortion bDollar OUTPUT,
 @Pre83TaxablePortion bDollar OUTPUT,
 @ErrorMsg varchar(1000) OUTPUT
)
AS
SET NOCOUNT ON

BEGIN TRY

	DECLARE @Return_Value tinyint
			
	------------------
	-- PRIME VALUES --
	------------------
    SET @Return_Value = 0
    SET @ErrorMsg = ''
    
	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @HireDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Hire Date!'
			GOTO vspExit
		END
		
	IF @SeparationDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Separation Date!'
			GOTO vspExit
		END


	----------------------------------
	-- INITIALIZE RETURN PARAMETERS --
	----------------------------------
	SET @Pre83TaxFreePortion = 0
	SET @Pre83TaxablePortion = @SubjectAmount		-- TASK 48576 --

	---------------------------------------------------------------------------------------------------
	-- COMPUTE THE PRE 83 TAX FREE AND TAXABLE PORTION ONLY IF EMPLOYEE WAS HIRED BEFORE 1 JULY 1983 --
	---------------------------------------------------------------------------------------------------
	IF @HireDate < '7/1/1983'
	BEGIN

		DECLARE @DaysWorked int,
				@DaysWithoutPay int

		----------------------------------------------------------
		-- DETERMINE # OF DAYS OF EMPLOYMENT BEFORE 1 JULY 1983 --
		----------------------------------------------------------
		DECLARE @Pre83DaysOfEmployment decimal

		EXEC	@Return_Value = [dbo].[vspPRDaysWithoutPayGet]
				@PRCo = @PRCo,
				@Employee = @Employee,
				@FromDate = @HireDate,
				@ThruDate = '6/30/1983',
				@DaysWithoutPay = @DaysWithoutPay OUTPUT,
				@ErrorMsg = @ErrorMsg OUTPUT

		IF @Return_Value <> 0 GOTO vspExit

		SET @DaysWorked = DATEDIFF(DAY, @HireDate - 1, '6/30/1983')
		SET @Pre83DaysOfEmployment = CAST(@DaysWorked AS decimal) - CAST(@DaysWithoutPay AS decimal)

		---------------------------------------------------------------------------------------------
		-- DETERMINE TOTAL DAYS OF EMPLOYMENT FROM THE MOST RECENT HIRE DATE TO DATE OF SEPARATION --
		---------------------------------------------------------------------------------------------
		DECLARE @Post83DaysOfEmployment decimal

		EXEC	@Return_Value = [dbo].[vspPRDaysWithoutPayGet]
				@PRCo = @PRCo,
				@Employee = @Employee,
				@FromDate = '7/01/1983',	-- TASK 48576 --
				@ThruDate = @SeparationDate,
				@DaysWithoutPay = @DaysWithoutPay OUTPUT,
				@ErrorMsg = @ErrorMsg OUTPUT

		IF @Return_Value <> 0 GOTO vspExit

		SET @DaysWorked = DATEDIFF(DAY, '6/30/1983', @SeparationDate) -- TASK 48576 --
		SET @Post83DaysOfEmployment = CAST(@DaysWorked AS decimal) - CAST(@DaysWithoutPay AS decimal)

		---------------------------
		-- COMPUTE RETURN VALUES --
		---------------------------
		-- TASK 48576 --
		DECLARE @TotalDaysOfEmployment decimal
		SET @TotalDaysOfEmployment = @Pre83DaysOfEmployment + @Post83DaysOfEmployment

		IF @TotalDaysOfEmployment > 0	
		BEGIN
			SELECT @Pre83TaxFreePortion = ROUND((@Pre83DaysOfEmployment / @TotalDaysOfEmployment) * @SubjectAmount, 2)
			SELECT @Pre83TaxablePortion = ROUND(@SubjectAmount - @Pre83TaxFreePortion, 2)
		END

	END

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value
GO
PRINT N'Refreshing [dbo].[vrvPMSubmittalRegister]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMSubmittalRegister]'
GO
PRINT N'Refreshing [dbo].[viFact_EMMaintenance]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMMaintenance]'
GO
PRINT N'Refreshing [dbo].[SMRateOverrideCatMatlBP]'
GO
EXEC sp_refreshview N'[dbo].[SMRateOverrideCatMatlBP]'
GO
PRINT N'Refreshing [dbo].[brvEMDeprExpAcct]'
GO
EXEC sp_refreshview N'[dbo].[brvEMDeprExpAcct]'
GO
PRINT N'Refreshing [dbo].[PRES]'
GO
EXEC sp_refreshview N'[dbo].[PRES]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_CapAmtsGet]'
GO
CREATE procedure [dbo].[vspPR_AU_ETP_CapAmtsGet]
/************************************************************************
* CREATED:	DAN SO 03/07/2013 - TFS: User Story 39860:PR ETP Redundancy Tax Calculations - 1
*							  - Co-developed with Ellen BN   
* MODIFIED:
*
* Purpose of Stored Procedure
*
*    Get AU ETP Cap Amts
*    
* 
* INPUT
*	@ATOETPType			- ATO Type 
*   @SubjectAmt			- Subject Amount
*	@ETPAmt				- ETP Standard portion of the ETP
*	@ETPCapAmt			- ETP Cap Amount
*	@WholeIncomeCapAmt	- Whole Income Cap Amount
*	
*
* OUTPUT
*	@UpToCapAmt			- Up To Cap Amount (ETP or Whole of Income Cap)
*	@AboveCapAmt		- Above Cap Amount (ETP or Whole of Income Cap)
*	@CapAmt				- ETP or Whole of Income Cap Amount (the amount used in calculations)
*	@rcode				- Return Code - (0)Successful, (1)Failure
*	@ErrorMsg			- Error Message
*************************************************************************/
(@ATOETPType VARCHAR(4) = NULL, 
 @SubjectAmt bDollar = NULL, @ETPAmt bDollar = NULL, 
 @ETPCapAmt bDollar = NULL, @WholeIncomeCapAmt bDollar = NULL,
 @UpToCapAmt bDollar OUTPUT, @AboveCapAmt bDollar OUTPUT, @CapAmt bDollar OUTPUT,	
 @ErrorMsg VARCHAR(255) OUT)

AS

BEGIN TRY

	SET NOCOUNT ON

    DECLARE @cWIC bDollar,	-- calculated Whole Income Cap
			@RetVal INT,
			@rcode INT


	------------------
	-- PRIME VALUES --
	------------------
	SET @UpToCapAmt = 0.00
	SET @AboveCapAmt = 0.00
	SET @CapAmt = 0.00
    SET @rcode = 0
    SET @ErrorMsg = ''


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @ATOETPType IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing ATO ETP Type!'
			GOTO vspExit
		END

	IF @SubjectAmt IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Subject Amount!'
			GOTO vspExit
		END

	IF @ETPAmt IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing ETP Amount!'
			GOTO vspExit
		END
				
	IF @ETPCapAmt IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing ETP Cap!'
			GOTO vspExit
		END
				
	IF @WholeIncomeCapAmt IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Whole Income Cap!'
			GOTO vspExit
		END	
	
		
	--------------------------
	-- DETERMINE CAP TO USE --
	--------------------------
	SET @CapAmt = @ETPCapAmt

	-- FOR ETP Category - USE THE SMALLER OF THE TWO CAPS --
	IF (@ATOETPType = 'ETP') -- ONLY FOR STANDARD ETPs
		BEGIN

			SET @cWIC = (@WholeIncomeCapAmt - @SubjectAmt) 
		
			-------------------------
			-- USE CALCULATED CAP? --   
			-------------------------
			IF (@cWIC < @ETPCapAmt)
				BEGIN
					
					-- IF CALCULATE AMT IS NEGATIVE - SET TO ZERO --
					IF @cWIC < 0 SET @CapAmt = 0
					ELSE		 SET @CapAmt = @cWIC  

				END
		END

	--------------------------------------
	-- DETERMINE OVER/UNDER CAP AMOUNTS --
	--------------------------------------
	IF @CapAmt > @ETPAmt
		BEGIN
			SET @UpToCapAmt = @ETPAmt
		END
	ELSE
		BEGIN
			SET @UpToCapAmt = @CapAmt
			SET @AboveCapAmt = (@ETPAmt - @CapAmt)
		END

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @rcode = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @rcode

GO
PRINT N'Refreshing [dbo].[vrvPMSubScoItem]'
GO
EXEC sp_refreshview N'[dbo].[vrvPMSubScoItem]'
GO
PRINT N'Refreshing [dbo].[viFact_EMMeterReadings]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMMeterReadings]'
GO
PRINT N'Altering [dbo].[vspPMInterfacePOCONum]'
GO


/*************************************/
ALTER proc [dbo].[vspPMInterfacePOCONum]
/*************************************
* CREATED BY:   TRL 05/03/2011 TK-04412
* MODIFIED By:	GF 05/26/2011 TK-05347 TK-05531 TK-05548 TK-06406
*				GP 7/28/2011 - TK-07143 changed bPO to varchar(30)
*				MV 10/25/2011 - TK-09243 - added NULL param to bspHQTaxRateGetAll
*				GF 10/31/2011 TK-09503
*				DAN SO 11/21/2011 D-03631 - POCONum error message not being recorded properly
*				GF 01/08/2011 TK-11760 #145512 PCO detail not validating
*				GF 04/05/2012 TK-13836 #145969 update ChgToTax in POCB
*				GF 04/30/2012 TK-14595 #146332 change to check HQBC for stuck PM interface batches
*				DAN SO 06/18/2012 - TK-15746 - validate Unit of Measure
*				GF 09/17/2012 - TK-17969 use vspHQTaxRateGet for gst rate (single level)
*				GF 10/09/2012 TK-18382 147184 display pending POCO for interface if approved
*				GF 10/10/2012 TK-18416 write out JCCo to POIB table
*				AW 01/08/2013 TK-20643 return error if GLAcct is invalid
*				AW 04/19/2013 TFS-45060 Update OrigUnitCost on a new item from PM PO Change Order Reverses fix change on TK-06406				
*
*
*
* USAGE:
* used by PMInterface to interface a PO change order
* from PM to PO as specified
*
* Pass in :
* PMCo, Project, Mth, GLCo, PO, POCONum
*
* Returns
*	POHB Batchid, Error message and return code
*
*******************************/
(@pmco bCompany = NULL, @project bJob = NULL, @mth bMonth = NULL,
 @glco bCompany = NULL, @po varchar(30) = NULL, @POCONum SMALLINT = NULL, 
 @pobatchid int = NULL OUTPUT, @pocbbatchid int = NULL OUTPUT,
 @postatus tinyint = NULL OUTPUT, @pocbstatus tinyint = NULL output,
 @errmsg varchar(600) output)
AS
SET NOCOUNT ON
   
declare @rcode int, @pohbseq int, @opencursor tinyint, @poco bCompany, @vendorgroup bGroup, @vendor bVendor,
		@reqdate bDate, @materialgroup bGroup, @materialcode bMatl, @vendmtlid varchar(30), @um bUM,
		@recvyn bYN, @location bLoc, @phasegroup bGroup, @phase bPhase, @costtype bJCCType,
		@taxgroup bGroup, @taxcode bTaxCode, @taxtype tinyint, @units bUnits, @unitcost bUnitCost,
		@ecm bECM, @amount bDollar, @taxrate bRate, @taxamount bDollar, @glacct bGLAcct,
		@errtext varchar(255), @pmmfpo varchar(30), @poitem bItem, @errorcount int, @mtldesc bItemDesc,
		@porowcount int,
		@batchtranstype char(1), @contract bContract, @contractitem bContractItem, @requisitionnum varchar(20),
		@department bDept, @approved bYN, @status tinyint, @pocbseq tinyint,
		@pocurunits bUnits, @pocurunitcost bUnitCost, @pocurcost bDollar, @poecm bECM, @pocbunits bUnits,
		@pocbunitcost bUnitCost, @pocbcost bDollar, @factor int, @pmmfseq int, @slseq int, @activeyn bYN,
		@pophase bPhase, @pomaterial bMatl, @poum bUM, @mtldescription bItemDesc, @poitemerr varchar(30),
		@ApprovedDate bDate, @pocbchgtotcost bDollar, @taxphase bPhase,
		@taxct bJCCType, @taxjcum bUM, @chgtotax bDollar, @valueadd varchar(1)

declare @gstrate bRate, @pstrate bRate, @HQTXcrdGLAcct bGLAcct, @HQTXcrdGLAcctPST bGLAcct,  
		@HQTXdebtGLAcct bGLAcct, @oldreqdate bDate, @dflt_matl_group bGroup,
		@oldtaxrate bRate, @oldgstrate bRate, @oldpstrate bRate, @oldHQTXdebtGLAcct bGLAcct,  
		@jccmtdtax bDollar, @supplier bVendor, @ACO bACO, @PMMF_KeyID BIGINT,
		@inusebatchid bBatchID, @source bSource, @inusemth bMonth
		
select @rcode = 0, @errorcount = 0, @porowcount = 0, @opencursor = 0

-- get PO Company from PM Company
select @poco=APCo 
from dbo.PMCO    
where PMCo=@pmco

-- get Default Material Group from HQ Company #137088
select @dflt_matl_group=MatlGroup
from dbo.HQCO   
where HQCo=@poco
if @@rowcount = 0
begin
	select @dflt_matl_group=MatlGroup
	from dbo.HQCO   
	where HQCo=@pmco
end

SET @errorcount = 0

---------------------
-- D-03631 (start) --
---------------------
-- check for data then create batch
if exists (select 1 from dbo.PMMF a where a.PMCo=@pmco AND a.Project=@project AND a.POCo=@poco
				AND a.PO = @po AND a.POCONum = @POCONum AND a.SendFlag = 'Y'
				AND a.MaterialOption = 'P' AND a.InterfaceDate IS NULL
				----TK-11760
				----and (a.RecordType='O' OR (a.RecordType = 'C' AND a.ACO IS NOT NULL))
				AND EXISTS(select 1 from dbo.POHD b where b.POCo=a.POCo and b.PO=a.PO
							AND ISNULL(b.Approved,'Y') = 'Y'))		
	begin
		--Reset Batch Status to Open to allow posting of new records
		If @pobatchid <> 0 and @postatus =3 --and @interfacestatus=0 
		begin
			Update dbo.HQBC
			set [Status] = 0
			Where Co=@poco and Mth=@mth and BatchId=@pobatchid
		end
		
		If @pobatchid = 0 or @pobatchid is null
		begin
			exec @pobatchid = dbo.bspHQBCInsert @poco, @mth, 'PM Intface', 'POHB', 'N', 'N', null, null, @errmsg output
			if @pobatchid = 0
			begin
				select @errmsg = @errmsg + ' - Cannot create PO batch', @rcode = 1
				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
				select @errorcount = @errorcount + 1
				goto vspexit
			end
		end
		
		-- insert batchid into PMBC
		select @slseq=isnull(max(SLSeq),0)+1 from dbo.PMBC 

		insert into dbo.PMBC (Co, Project, Mth, BatchTable, BatchId, BatchCo, SLSeq, SL, SLItem, PO, POItem)
		select @pmco, @project, @mth, 'POHB', @pobatchid, @poco, @slseq, null, null, null, null
	end
else
	begin
		goto vspexit
	end
	
---------------------
-- D-03631 (end) --
---------------------
   
-- declare cursor on PMMF Material Detail for interface to POCB
declare bcPMMF cursor LOCAL FAST_FORWARD
FOR SELECT Seq,PO,POItem,VendorGroup,Vendor,MaterialGroup,MaterialCode,VendMatId,
		MtlDescription, UM,RecvYN,Location,PhaseGroup,Phase,CostType,ReqDate,
		TaxGroup,TaxCode,TaxType, isnull(Units,0),isnull(UnitCost,0),ECM,
		isnull(Amount,0),MtlDescription, RequisitionNum, Supplier, POCONum,
		ACO, KeyID
FROM dbo.bPMMF
WHERE PMCo=@pmco AND Project=@project
	AND POCo = @poco
	AND PO = @po
	AND POCONum = @POCONum
	AND SendFlag='Y'
	AND MaterialOption='P' 
	AND InterfaceDate IS NULL
GROUP BY PO, POItem, Seq, VendorGroup, Vendor, MaterialGroup, MaterialCode, VendMatId,
		MtlDescription, UM, RecvYN, Location, PhaseGroup, Phase, CostType, ReqDate,
		TaxGroup, TaxCode, TaxType, Units, UnitCost, ECM, Amount, MtlDescription,
		RequisitionNum, Supplier, POCONum, ACO, KeyID
   
---- open cursor
OPEN bcPMMF
   
---- set open cursor flag to true
SET @opencursor = 1
   
PMMF_loop:
fetch next from bcPMMF into @pmmfseq, @pmmfpo, @poitem, @vendorgroup, @vendor, @materialgroup,
		@materialcode, @vendmtlid, @mtldesc, @um, @recvyn, @location, @phasegroup, @phase,
		@costtype, @reqdate, @taxgroup, @taxcode, @taxtype, @units, @unitcost, @ecm, @amount,
		@mtldescription, @requisitionnum, @supplier, @POCONum, @ACO, @PMMF_KeyID
   
IF @@fetch_status <> 0 GOTO PMMF_end
IF @@FETCH_STATUS = -1 GOTO PMMF_end


-- get needed PO information
select @approved=Approved, @status=[Status],
		@inusebatchid=InUseBatchId, @inusemth=InUseMth
from dbo.bPOHD   
where POCo=@poco AND PO=@po

---- check header approved when status pending
IF @status = 3 AND ISNULL(@approved,'Y') = 'N' GOTO PMMF_loop


---- valudate POCONum must be ready for accounting and get approved date
SELECT @ApprovedDate = DateApproved
FROM dbo.PMPOCO
WHERE POCo=@poco 
	AND PO=@po
	AND POCONum=@POCONum 
	AND ReadyForAcctg = 'Y'
---- if POCO then ready for accounting flag must be checked
IF @@ROWCOUNT = 0 GOTO PMMF_loop

---- Validate PO record prior to inserting into batch table
if @inusebatchid is not null
	BEGIN
	select @source=[Source] from dbo.HQBC    
	where Co=@poco and BatchId=@inusebatchid and Mth=@inusemth
	if @@rowcount <> 0
		BEGIN
		SELECT @errtext = 'PO: ' + isnull(@pmmfpo,'') + ' already in use by ' +
				convert(varchar(2),DATEPART(month, @inusemth)) + '/' + substring(convert(varchar(4),DATEPART(year, @inusemth)),3,4) +
				' batch # ' + convert(varchar(6),@inusebatchid) + ' - ' + 'Batch Source: ' + @source, @rcode = 1
		END
	ELSE
		BEGIN
		SELECT @errtext='PO already in use by another batch!', @rcode=1
		END

	exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
	select @errorcount = @errorcount + 1
	goto PMMF_loop
	END


---- if no approved date use system date
IF @ApprovedDate IS NULL SET @ApprovedDate = dbo.vfDateOnly()

---- check first for an existing batch to add to. if found
---- we need to set the status back to 0 - open othrewise will
---- not be able to add to. TK-05531
IF @pobatchid <> 0 ----AND @pocbbatchid <> 0
	BEGIN
	---- update the status for batch to 0 - open for additional entries
	UPDATE dbo.bHQBC SET Status = 0
	where Co = @poco and Mth = @mth and BatchId = @pobatchid
	if @@rowcount = 0
		BEGIN
		SELECT @errmsg = 'Unable to update Batch Control information!', @rcode = 1
		select @errorcount = @errorcount + 1
		goto PMMF_loop
		END
	END
	
IF @pocbbatchid <> 0
	BEGIN
	---- try to use existing PO Change order batch id
	UPDATE dbo.bHQBC SET Status = 0
	where Co = @poco and Mth = @mth and BatchId = @pocbbatchid
	if @@rowcount = 0
		BEGIN
		SELECT @errmsg = 'Unable to update Batch Control information!', @rcode = 1
		select @errorcount = @errorcount + 1
		goto PMMF_loop
		END
	END
	
---- no batch existing, so create a POHB batch
if @pobatchid = 0
	BEGIN
	exec @pobatchid = dbo.bspHQBCInsert @poco, @mth,'PM Intface','POHB','N','N',null,null,@errmsg output
	if @pobatchid = 0
		BEGIN
		select @errmsg = @errmsg + ' - Cannot create POHB batch'
		select @errorcount = @errorcount + 1
		goto PMMF_loop
		END

	-- insert batchid into PMBC
	select @slseq=isnull(max(SLSeq),0)+1 
	from dbo.PMBC    
	----TK-05548
	insert into dbo.PMBC (Co, Project, Mth, BatchTable, BatchId, BatchCo, SLSeq, SL, SLItem, PO, POItem, ChangeOrderHeaderBatch)
	select @pmco, @project, @mth, 'POHB', @pobatchid, @poco, @slseq, null, null, NULL, NULL, 'Y'
	END


if @pocbbatchid = 0
	BEGIN
	exec @pocbbatchid = dbo.bspHQBCInsert @poco,@mth,'PM Intface','POCB','N','N',null,null,@errmsg output
	if @pocbbatchid = 0
		BEGIN
		select @errmsg = @errmsg + ' - Cannot create POCB batch'
		select @errorcount = @errorcount + 1
		goto PMMF_loop
		END
		
	-- insert batchid into PMBC
	select @slseq=isnull(max(SLSeq),0)+1
	from dbo.PMBC    

	insert into dbo.PMBC (Co, Project, Mth, BatchTable, BatchId, BatchCo, SLSeq, SL, SLItem, PO, POItem)
	select @pmco, @project, @mth, 'POCB', @pocbbatchid, @poco, @slseq, null, null, NULL, NULL
	END




-- get next available sequence # for this batch
select @pohbseq = isnull(max(BatchSeq),0)+1
from dbo.POHB    
where Co = @poco and Mth = @mth and BatchId = @pobatchid
	
INSERT INTO dbo.POHB (Co, Mth, BatchId, BatchSeq, BatchTransType, PO, VendorGroup, Vendor, [Description],
		OrderDate, OrderedBy, ExpDate, [Status], JCCo, Job, INCo, Loc, ShipLoc, [Address], City, [State],
		Zip, ShipIns, HoldCode, PayTerms, CompGroup, OldVendorGroup, OldVendor, OldDesc, OldOrderDate,
		OldOrderedBy, OldExpDate, OldStatus, OldJCCo, OldJob, OldINCo, OldLoc, OldShipLoc, OldAddress,
		OldCity, OldState, OldZip, OldShipIns, OldHoldCode, OldPayTerms, OldCompGroup, Attention, OldAttention,
		Notes, PayAddressSeq, OldPayAddressSeq, POAddressSeq, OldPOAddressSeq, Address2, OldAddress2,
		UniqueAttchID, Country, OldCountry)
SELECT @poco, @mth, @pobatchid, @pohbseq, 'C', @pmmfpo, @vendorgroup, @vendor, [Description],
		OrderDate, OrderedBy, ExpDate, 0, JCCo, Job, INCo, Loc, ShipLoc, [Address], City, [State],
		Zip, ShipIns, HoldCode, PayTerms, CompGroup, @vendorgroup, @vendor, [Description], OrderDate,
		OrderedBy, ExpDate, 3, JCCo, Job, INCo, Loc, ShipLoc, [Address], City, [State], Zip,
		ShipIns, HoldCode, PayTerms, CompGroup, Attention, Attention, Notes, PayAddressSeq, PayAddressSeq,
		POAddressSeq, POAddressSeq, Address2, Address2, UniqueAttchID, Country, Country
from dbo.POHD    
where POCo=@poco and PO=@pmmfpo
SET @porowcount = @@ROWCOUNT

if @porowcount <> 1
	begin
	   select @errtext = 'Could not insert PO: ' + isnull(@pmmfpo,'') + ' into batch'
	   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
	   select @errorcount = @errorcount + 1
	   goto PMMF_loop
	end
else
	begin
		-- update user memos
		exec @rcode = dbo.bspBatchUserMemoInsertExisting @poco, @mth, @pobatchid, @pohbseq, 'PO Entry', 0, @errmsg output
		if @rcode <> 0
		begin
 			select @errmsg = 'Unable to update user memo to PO: ' + isnull(@pmmfpo,'') + ' Batch'
 			select @errorcount = @errorcount + 1
            goto PMMF_loop
 		end
 	end
   
select @poitemerr = ' PO: ' + isnull(@pmmfpo,'') + ' Item: ' + convert(varchar(6),isnull(@poitem,''))

-- Validate Phase and Costtype
exec @rcode = dbo.bspJCADDPHASE @pmco,@project,@phasegroup,@phase,'Y',null,@errmsg output
if @rcode <> 0
begin
   select @errtext = @errmsg + 'Could not add/validate phase.' + @poitemerr
   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
   select @errorcount = @errorcount + 1
   goto PMMF_loop
end

-- validate cost type
exec @rcode = dbo.bspJCADDCOSTTYPE @jcco=@pmco, @job=@project, @phasegroup=@phasegroup, @phase=@phase, @costtype=@costtype, @um=@um, @override= 'P', @msg=@errmsg output
if @rcode <> 0
begin
	select @errtext = @errmsg + 'Could not add/validate cost type.' + @poitemerr
	exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
	select @errorcount = @errorcount + 1
	goto PMMF_loop
end

-- update active flag if needed
select @activeyn=ActiveYN
from dbo.JCCH   
where JCCo=@pmco and Job=@project and Phase=@phase and CostType=@costtype
if @activeyn <> 'Y'
begin
	update dbo.JCCH 
	set ActiveYN='Y'
	where JCCo=@pmco and Job=@project and Phase=@phase and CostType=@costtype
end

	-- Get GLAcct
	select @contract=[Contract], @contractitem=Item
	from dbo.JCJP   
	where JCCo=@pmco and Job=@project and PhaseGroup=@phasegroup and Phase=@phase
	
	select @department=Department
	from dbo.JCCI   
	where JCCo=@pmco and [Contract]=@contract and Item=@contractitem

	-- Get GLAcct
	select @glacct = null
	exec @rcode = dbo.bspJCCAGlacctDflt @pmco, @project, @phasegroup, @phase, @costtype, 'N', @glacct output, @errmsg output
	if @glacct is null
	begin
		select @errtext = 'GL Acct for Cost Type: ' + convert(varchar(3),isnull(@costtype,'')) + 'may not be null' + @poitemerr
		exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		select @errorcount = @errorcount + 1
		goto PMMF_loop
	end

	--verify GLAcct is valid
	exec @rcode = dbo.bspGLACfPostable @glco, @glacct, 'J', @errmsg output
	if @rcode <> 0
	begin
		select @errtext = '- GLAcct:' + isnull(@glacct,'') + ':  ' + isnull(@errmsg,'')
		exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg OUTPUT
		SELECT @errorcount = @errorcount + 1
		GOTO PMMF_loop
	end

	if @taxtype is null and @taxcode is not null
	begin
		select @errtext = 'Tax Code assigned, but missing Tax Type for material.' + @poitemerr
		exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		select @errorcount = @errorcount + 1
		goto PMMF_loop
	end

	-- if tax code assigned, validate tax phase and cost type then calculate tax
	-- ANY CHANGES MADE TO THIS ROUTINE NEED TO ALSO BE DONE IN bspPMSLACOInterface,
	-- bspPMPOInterface, bspPMSLInterface, and vspPMSLCreateSLItem. The logic should
	-- be similar between the procedures working with tax codes.
	if @taxcode is null
		begin
			select @taxamount=0, @jccmtdtax = 0
		end
	else
   		begin
   			select @taxphase = null, @taxct = null
   			-- validate Tax Code
   			exec @rcode = dbo.bspPOTaxCodeVal @taxgroup, @taxcode, @taxtype, @taxphase output, @taxct output, @errmsg output
   			if @rcode <> 0
   			begin
   				select @errtext = isnull(@errmsg,'') + ' ' + @poitemerr
   				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
   				select @errorcount = @errorcount + 1
   				goto PMMF_loop
   			end
   			-- validate Tax Phase if Job Type
   			if @taxphase is null select @taxphase = @phase
   			if @taxct is null select @taxct = @costtype
   			-- validate tax phase - if does not exist try to add it
   			exec @rcode = dbo.bspJCADDPHASE @pmco, @project, @phasegroup, @taxphase, 'Y', null, @errmsg output
   			-- if phase/cost type does not exist in JCCH try to add it
   			if not exists(select top 1 1 from dbo.JCCH where JCCo=@pmco and Job=@project and PhaseGroup=@phasegroup
   								and Phase=@taxphase and CostType=@taxct)
   			begin
   				-- insert cost header record
   				insert into dbo.JCCH (JCCo,Job,PhaseGroup,Phase,CostType,UM,BillFlag,ItemUnitFlag,PhaseUnitFlag,BuyOutYN,Plugged,ActiveYN,SourceStatus)
   				select @pmco, @project, @phasegroup, @taxphase, @taxct, 'LS', 'C', 'N', 'N', 'N', 'N', 'Y', 'I'
   			end
   			-- validate Tax phase and Tax Cost Type
   			exec @rcode = dbo.bspJobTypeVal @pmco, @phasegroup, @project, @taxphase, @taxct, @taxjcum output, @errmsg output
   			if @rcode <> 0
   			begin
   				select @errtext = 'Tax: ' + isnull(@errmsg,'') + ' ' + @poitemerr
   				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
   				select @errorcount = @errorcount + 1
   				goto PMMF_loop
   			end
   
			-- calculate tax
			--exec @rcode = bspHQTaxRateGetAll @taxgroup, @taxcode, @reqdate, @valueadd output, @taxrate output, @gstrate output, @pstrate output, 
			--		@HQTXcrdGLAcct output, null, @HQTXdebtGLAcct output, null, @HQTXcrdGLAcctPST output, null, NULL, NULL, @errmsg OUTPUT
			----TK-17969		
			exec @rcode = dbo.vspHQTaxRateGet @taxgroup, @taxcode, @reqdate, @valueadd output, @taxrate output, NULL, NULL, 
						@gstrate output, @pstrate output, null, null, @HQTXdebtGLAcct output, null, null, null, @errmsg output
			if @rcode <> 0
			begin
   				select @errtext = @errmsg + 'Could not get tax rate.' + @poitemerr
				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
				select @errorcount = @errorcount + 1
				goto PMMF_loop
			end

			-- calculate tax amount
			select @taxamount = @amount * @taxrate
			select @jccmtdtax = 0
			
			-- if tax code is value added then calculate tht JC tax that will only be the PST portion
			if isnull(@valueadd,'N') = 'Y' and @pstrate <> 0
				begin
					select @jccmtdtax = @amount * @pstrate
				end			
			else
				begin
					select @jccmtdtax = @taxamount
				end	
   		end

-- VALIDATE UM -- TK-15746 --
EXEC @rcode = dbo.bspHQUMVal @um, @errmsg output
IF @rcode <> 0
	BEGIN
		SET @errtext = ISNULL(@errmsg,'') + '('+ ISNULL(@um,'') + ') ' + @poitemerr
		EXEC @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		SET @errorcount = @errorcount + 1
		GOTO PMMF_loop
	END

-- check units to UM
if @um = 'LS' and @units <> 0
begin
   select @errtext = 'Units must be zero when UM is (LS).' + @poitemerr
   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
   select @errorcount = @errorcount + 1
   goto PMMF_loop
end

-- check unit cost to UM
if @um = 'LS' and @unitcost <> 0
begin
   select @errtext = 'Unit cost must be zero when UM is (LS).' + @poitemerr
   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
   select @errorcount = @errorcount + 1
   goto PMMF_loop
end

-- validate units when UM <> 'LS' and Amount <> 0
if @um <> 'LS' and @amount <> 0 and @units = 0
begin
	select @errtext = 'Must have units when UM is not (LS) and there is an amount.' + @poitemerr
	exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
	select @errorcount = @errorcount + 1
	goto PMMF_loop
end

if @um <> 'LS'
	BEGIN
	IF @ecm IS NULL
		BEGIN
		select @errtext = 'Missing ECM, must be (E,C,M) when UM is not lump sum (LS).' + @poitemerr
		exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		select @errorcount = @errorcount + 1
		goto PMMF_loop
		END
	if @ecm not in ('E', 'C', 'M')
		BEGIN
		select @errtext = 'Missing ECM, must be (E,C,M) when UM is not lump sum (LS).' + @poitemerr
		exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		select @errorcount = @errorcount + 1
		goto PMMF_loop
		END
	END




select @pocurunits=isnull(CurUnits,0), @pocurunitcost=isnull(CurUnitCost,0),
		@pocurcost=isnull(CurCost,0), @poecm=isnull(CurECM,'E'), 
		@pophase=Phase, @pomaterial=Material, @poum=UM
from dbo.POIT   
where POCo=@poco and PO=@pmmfpo and POItem=@poitem
if @@rowcount <> 0
	begin
		if @pophase<>@phase
		begin
		   --#141349
		   select @errtext = 'PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + '  has different phase'
		   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid,@errtext,@errmsg output
		   select @errorcount=@errorcount+1
		   goto PMMF_loop
		end
	       
	   if isnull(@pomaterial,'')<>isnull(@materialcode,'')
	   begin
		   --#141349
		   select @errtext = 'PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + '  has different material code'
		   exec @rcode = dbo.bspHQBEInsert @poco,@mth,@pobatchid,@errtext,@errmsg output
		   select @errorcount=@errorcount+1
		   goto PMMF_loop
		end
	       
	   if isnull(@poum,'')<>isnull(@um,'')
	   begin
		   --#141349
		   select @errtext = 'PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + '  has different unit of measure'
		   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		   select @errorcount = @errorcount + 1
		   goto PMMF_loop
		 end

	   if isnull(@pocurunitcost,0) <> isnull(@unitcost,0)
	   begin
		   --#141349
		   select @errtext = 'PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + '  has different unit cost'
		   exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
		   select @errorcount = @errorcount + 1
		   goto PMMF_loop
	   end

	   -- need to find the difference to enter the change into the batch
	   select @factor=1
	   if @poecm <> @ecm
	   begin
		   if @ecm='C'
		   begin
			   select @factor=100
		   end
		   if @ecm='M'
		   begin
			   select @factor=1000
		   end
	   end

		-- Insert record into POCB
		-- get next available sequence # for this batch
		select @pocbseq = isnull(max(BatchSeq),0)+1
		from dbo.POCB
		where Co = @poco and Mth = @mth and BatchId = @pocbbatchid

   		---- if the POIT record may have zeros for units, unitcost, and amount treat like inserting
		---- a PO change order to a new PO Item and keep the unit cost
		if @pocurunits <> 0 or @pocurunitcost <> 0 or @pocurcost <> 0
			begin
				select @pocbunitcost = 0
			end
		else
			begin
				select @pocbunitcost = @unitcost
			end

		select @pocbchgtotcost = 0, @pocbcost=@amount
		-- need to calculate ChgTotCost if not 'LS'
   		if @um <> 'LS'
   			begin
   			exec @rcode = dbo.bspPOCBChgTotCost @poco, @mth, @pocbbatchid, @pocbseq, @pmmfpo, @poitem,
				@units, @pocbunitcost, @um, /*DC #120634*/@pocbchgtotcost output,@chgtotax output,/*DC #120634*/@errmsg output
   			end
   		else
   			begin
   				select @pocbchgtotcost = @amount
   			end

		-- add PO change order transaction to batch
		INSERT dbo.bPOCB (Co, Mth, BatchId, BatchSeq, BatchTransType, POTrans, PO, POItem,
				ChangeOrder, ActDate, [Description], UM, ChangeCurUnits, CurUnitCost, ECM, 
				ChangeCurCost, ChangeBOUnits, ChangeBOCost, ChgTotCost,
				----TK-13836
				ChgToTax, POCONum, Notes)
		SELECT @poco, @mth, @pocbbatchid, @pocbseq, 'A', null, @pmmfpo, @poitem,
			@ACO, @ApprovedDate, @mtldesc, @um,
			isnull(@units,0), isnull(@pocbunitcost,0),
			ECM = case when @um='LS' then null else @ecm end, 
   			ChangeCurCost = case when @um='LS' then isnull(@pocbcost,0) else 0 end,
   			isnull(@units,0),
   			ChangeBOCost = case when @um='LS' then isnull(@pocbcost,0)else 0 end,
   			isnull(@pocbchgtotcost,0),
   			----TK-13856
   			ISNULL(@chgtotax,0), POCONum, Notes
		FROM dbo.PMMF
		WHERE KeyID = @PMMF_KeyID
		if @@rowcount = 0
			begin
			 --#141349
			 select @errmsg = 'Could not insert PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + 'into POCB'
			 exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
			 select @errorcount = @errorcount + 1
			END
			
		-- update IntFlag in PMMF to 'I', needed to update interface date in bspPOHBPost
		--UPDATE dbo.PMMF SET IntFlag='I'
		--WHERE KeyID = @PMMF_KeyID
	END
else
    begin
		-- This is kind of turned around because Carol keeps changing her mind about how this should work.
		-- Sometimes they think a change order item that is not in POIT should automatically be entered into
		-- POIT with 0 orig amounts and sometimes they think an error should be thrown and the user
		-- should enter and interface an original item first.
		-- I'm going to leave this the way it is so this part can easily be removed.
		-- 1/10/99 - now, if the item does not exist and the po is pending (not open), then add
		-- the po item as an original, not a change with $0 original amounts
		-- check PMMF for non interfaced record
		IF EXISTS(SELECT 1 FROM dbo.PMMF WHERE PMCo=@pmco AND Project=@project AND POCo=@poco
					AND PO=@pmmfpo AND POItem=@poitem AND RecordType='O'
					AND InterfaceDate IS NULL AND Seq <> @pmmfseq)
			begin
			---- must interface the original first
			select @errtext = 'The original PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + ' exists in PMMF but must be interfaced first.'
			exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
			select @errorcount = @errorcount + 1
			goto PMMF_loop
			end

		if @status = 3 -- insert as original
			begin
			INSERT INTO dbo.POIB(Co, Mth, BatchId, BatchSeq, POItem, BatchTransType, ItemType,
					MatlGroup, Material, VendMatId, [Description], UM, RecvYN, PostToCo, Loc, 
					Job, PhaseGroup, Phase, JCCType, GLCo, GLAcct, ReqDate, TaxGroup, TaxCode, 
					TaxType, OrigUnits, OrigUnitCost, OrigECM, OrigCost, OrigTax, RequisitionNum,
					JCCmtdTax, Notes, Supplier, SupplierGroup, TaxRate, GSTRate
					----TK-18416
					,JCCo)
			SELECT @poco, @mth, @pobatchid, @pohbseq, @poitem, 'A', 1, isnull(@materialgroup,@dflt_matl_group),
					@materialcode, @vendmtlid, @mtldescription, @um, @recvyn, @pmco, @location, 
					@project, @phasegroup, @phase, @costtype, @glco, @glacct, @reqdate, @taxgroup, 
					@taxcode, @taxtype, @units, @unitcost, 
					OrigECM = case when @um='LS' then null else @ecm end, 
					@amount, @taxamount, @requisitionnum, @jccmtdtax, Notes, 
					@supplier, @vendorgroup, isnull(@taxrate,0), isnull(@gstrate,0)
					----TK-18416
					,@pmco
			FROM dbo.PMMF 
			WHERE KeyID = @PMMF_KeyID   
			if @@rowcount <> 1
			begin
				--#141349
				select @errorcount = @errorcount + 1
				select @errtext = 'Could not insert PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + ' into POIT'
				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
				select @errorcount = @errorcount + 1
				goto PMMF_loop
			end

			-- update IntFlag in PMMF to 'I', needed to update interface date in bspPOHBPost
			UPDATE dbo.PMMF SET IntFlag='I'
			WHERE KeyID = @PMMF_KeyID
		end

		if @status = 0
			begin
			---- insert a record into POIT with zero values
			INSERT INTO dbo.bPOIT(POCo, PO, POItem, ItemType, MatlGroup, Material, VendMatId, 
					[Description], UM, RecvYN, PostToCo, Loc, JCCo, Job, PhaseGroup, Phase, 
					JCCType, GLCo, GLAcct, ReqDate, TaxGroup, TaxCode, TaxType, OrigUnits, 
					OrigUnitCost, OrigECM, OrigCost, OrigTax, CurUnits, CurUnitCost, CurECM, CurCost,
					CurTax, RecvdUnits, RecvdCost, BOUnits, BOCost, TotalUnits, TotalCost, TotalTax,
					InvUnits, InvCost, InvTax, RemUnits, RemCost, RemTax, PostedDate, RequisitionNum,
					Notes, Supplier, SupplierGroup, AddedMth, AddedBatchID, TaxRate, GSTRate)
			SELECT @poco, @pmmfpo, @poitem, 1, isnull(@materialgroup,@dflt_matl_group), @materialcode,
					@vendmtlid, @mtldescription, @um, @recvyn, @pmco, @location, @pmco, @project, 
					@phasegroup, @phase, @costtype, @glco, @glacct, @reqdate, @taxgroup, @taxcode,
					@taxtype, 0, 
					--OrigUnitCost = 0, ----case when @um='LS' then 0 else @unitcost end, ----TK-06406
					-- TFS-45060 reversing our dicision to 0 out OrigUnitCost on a change order leaving it 0 causes PO Reciepts
					-- to not correctly update JCCD  (Aaron Jost,Andrew Karr,Gil Fox discustion)
					OrigUnitCost = case when @um='LS' then 0 else @unitcost end,
					OrigECM      = case when @um='LS' then null else @ecm end, 0, 0, 0,
					CurrUnitCost = 0, ----case when @um='LS' then 0 else @unitcost end, ----TK-06406
					CurECM       = case when @um='LS' then null else @ecm end, 
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, @ApprovedDate, @requisitionnum,
					Notes, @supplier, @vendorgroup, @mth, @pocbbatchid,
					isnull(@taxrate,0), isnull(@gstrate,0)
			FROM dbo.bPMMF 
			WHERE KeyID = @PMMF_KeyID 
			if @@rowcount <> 1
				begin
				--#141349
				select @errorcount = @errorcount + 1
				select @errtext = 'Could not insert PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + ' into POIT'
				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pobatchid, @errtext, @errmsg output
				select @errorcount = @errorcount + 1
				goto PMMF_loop
				END
			ELSE
				BEGIN
				insert into dbo.bPMBC (Co, Project, Mth, BatchTable, BatchId, BatchCo, SLSeq, PO, POItem)
				select @pmco, @project, @mth, 'POCB', @pocbbatchid, @poco, @pmmfseq, @pmmfpo, @poitem
				END

			-- get next available sequence # for this batch
			select @pocbseq = isnull(max(BatchSeq),0)+1
			from dbo.bPOCB   
			where Co = @poco and Mth = @mth and BatchId = @pocbbatchid
			
			-- need to calculate ChgTotCost if not 'LS'
			select @pocbchgtotcost = 0
			if @um <> 'LS'
				begin
					exec @rcode = dbo.bspPOCBChgTotCost @poco, @mth, @pocbbatchid, @pocbseq, @pmmfpo, @poitem,
					@units, @unitcost,@um,@pocbchgtotcost output,@chgtotax output,@errmsg output
				end
			else
				begin
					select @pocbchgtotcost = @amount
				end

			-- add PO change order transaction to batch
			INSERT dbo.bPOCB (Co, Mth, BatchId, BatchSeq, BatchTransType, POTrans, PO, POItem,
					ChangeOrder, ActDate, [Description], UM, ChangeCurUnits, CurUnitCost, ECM, 
					ChangeCurCost, ChangeBOUnits, ChangeBOCost, ChgTotCost,
					----TK-13836
					ChgToTax, POCONum, Notes)
			SELECT @poco, @mth, @pocbbatchid, @pocbseq, 'A', null, @pmmfpo, @poitem,
					@ACO, @ApprovedDate, @mtldesc, @um,
					isnull(@units,0), isnull(@unitcost,0),
					ECM = case when @um='LS' then null else @ecm end,
					ChangeCurCost = case when @um='LS' then isnull(@amount,0) else 0 end,
					isnull(@units,0),
					ChangeBOCost = case when @um='LS' then isnull(@amount,0)else 0 end,
					isnull(@pocbchgtotcost,0),
					----TK-13856
					ISNULL(@chgtotax,0), POCONum, Notes
			FROM dbo.bPMMF  
			WHERE KeyID = @PMMF_KeyID
			if @@rowcount <> 1
				begin
				--#141349
				select @errorcount = @errorcount + 1
				select @errtext = 'Could not insert PO: ' + ISNULL(@pmmfpo,'') + ' PO Item: ' + convert(varchar(10),isnull(@poitem,'')) + ' into POCB'
				exec @rcode = dbo.bspHQBEInsert @poco, @mth, @pocbbatchid, @errtext, @errmsg output
				select @errorcount = @errorcount + 1
				goto PMMF_loop
			END
			
			-- update IntFlag in PMMF to 'I', needed to update interface date in bspPOHBPost
			UPDATE dbo.PMMF SET IntFlag='I'
			WHERE KeyID = @PMMF_KeyID
		end
	end

goto PMMF_loop
 
PMMF_end:
	if @opencursor <> 0
	begin
		close bcPMMF
		deallocate bcPMMF
		select @opencursor = 0
	end


if @errorcount > 0
begin
	-- undo everything
	delete dbo.bPOIB where Co=@poco and Mth=@mth and BatchId=@pobatchid
	delete dbo.bPOHB where Co=@poco and Mth=@mth and BatchId=@pobatchid
	delete dbo.bPOCB where Co=@poco and Mth=@mth and BatchId=@pocbbatchid
	
	---- TK-09503 update purge flag so we can delete line 1
	UPDATE dbo.vPOItemLine SET PurgeYN = 'Y'
	FROM dbo.vPOItemLine l
	INNER JOIN dbo.bPOIT i ON i.KeyID = l.POITKeyID
	INNER JOIN dbo.bPMBC c ON c.BatchCo = i.POCo AND c.PO = i.PO AND c.POItem = i.POItem
	where c.Co=@pmco and c.Project=@project 
		AND c.Mth=@mth 
		AND c.BatchId=@pocbbatchid 
		AND c.BatchTable='POCB'
		AND c.PO IS NOT NULL
		AND c.POItem IS NOT NULL
		AND l.POItemLine = 1
		
	---- TK-09503 remove POItemLines added via this process zero value items and lines
	DELETE dbo.vPOItemLine
	FROM dbo.vPOItemLine l
	INNER JOIN dbo.bPOIT i ON i.KeyID = l.POITKeyID
	INNER JOIN dbo.bPMBC c ON c.BatchCo = i.POCo AND c.PO = i.PO AND c.POItem = i.POItem
	where c.Co=@pmco and c.Project=@project 
		AND c.Mth=@mth 
		AND c.BatchId=@pocbbatchid 
		AND c.BatchTable='POCB'
		AND c.PO IS NOT NULL
		AND c.POItem IS NOT NULL
		AND l.POItemLine = 1
		
	---- remove POIT rows added via this process zero value items
	DELETE dbo.bPOIT
	FROM dbo.bPOIT i
	INNER JOIN dbo.bPMBC c ON c.BatchCo = i.POCo AND c.PO = i.PO AND c.POItem = i.POItem
	where c.Co=@pmco and c.Project=@project 
		AND c.Mth=@mth 
		AND c.BatchId=@pocbbatchid 
		AND c.BatchTable='POCB'
		AND c.PO IS NOT NULL
		AND c.POItem IS NOT NULL
		
		
	if @pobatchid<>0
		begin
		exec @rcode = dbo.bspHQBCExitCheck @poco, @mth, @pobatchid, 'PM Intface', 'POHB', @errmsg output
		if @rcode <> 0
		begin
			select @errmsg = @errmsg + ' - Cannot cancel batch '
		end
		END
	
	if @pocbbatchid <> 0
		begin
		exec @rcode = dbo.bspHQBCExitCheck @poco, @mth, @pocbbatchid, 'PM Intface', 'POCB', @errmsg output
		if @rcode <> 0
		begin
			select @errmsg = @errmsg + ' - Cannot cancel batch '
		end
	end

	----TK-14595
	delete dbo.bPMBC 
	where Co=@pmco and Project=@project 
		AND Mth=@mth 
		AND BatchId=@pocbbatchid 
		AND BatchTable='POCB' 
		AND BatchCo=@poco
		AND PO IS NOT NULL
		AND POItem IS NOT NULL

	update dbo.bPMMF set IntFlag=Null
	where PMCo=@pmco and Project=@project 
		AND PO IS NOT NULL
		AND InterfaceDate is null 
		AND IntFlag='I'

	select @rcode = 1
end

vspexit:
	if @opencursor <> 0
	begin
		close bcPMMF
		deallocate bcPMMF
		select @opencursor = 0
	end

	select @postatus=[Status] 
	from dbo.bHQBC    
	where Co=@poco and Mth=@mth and BatchId=@pobatchid and TableName='POHB'
	
	select @pocbstatus=[Status] 
	from dbo.bHQBC    
	where Co=@poco and Mth=@mth and BatchId=@pocbbatchid and TableName='POCB'
	
	select @errmsg = isNull(@errmsg,'') + ' ' + isnull(@errtext,'')	
	return @rcode
	
	








GO
PRINT N'Refreshing [dbo].[DDCBShared]'
GO
EXEC sp_refreshview N'[dbo].[DDCBShared]'
GO
PRINT N'Refreshing [dbo].[pvUserDetails]'
GO
EXEC sp_refreshview N'[dbo].[pvUserDetails]'
GO
PRINT N'Refreshing [dbo].[brvEMEqCatforEMTE]'
GO
EXEC sp_refreshview N'[dbo].[brvEMEqCatforEMTE]'
GO
PRINT N'Refreshing [dbo].[PRFD]'
GO
EXEC sp_refreshview N'[dbo].[PRFD]'
GO
PRINT N'Creating [dbo].[vspPR_AU_ETP_TaxComputations]'
GO
CREATE PROCEDURE [dbo].[vspPR_AU_ETP_TaxComputations]
/************************************************************************
* CREATED:	DAN SO 03/07/2013 - TFS: User Story 39860:PR ETP Redundancy Tax Calculations - 1
*							  - Co-developed with Ellen BN
* MODIFIED:	EN 4/5/2013 Story 44310 / Task 45407  Added solution for ignoring days without pay
*			DAN SO 05/21/2013 - Story 50738 - return Eligible amount
*
*
* Purpose of Stored Procedure
*
*    This is the head/main procedure to calculate AU ETP Taxes
*    
* 
* INPUT
*	@PRCo				- PR Company
*	@Employee			- Employee number
*	@PREndDate			- Employee Last Payroll Date
*	@ATOETPType			- ATO ETP Type (ETPR, ETPV, ETP, ETPD, ETPU)
*	@SubjectAmt			- Amount on which to base the tax computation
*
* OUTPUT
*	@TotalAmtWithheld	- Total Amount Withheld
*	@ETPTaxableAmt		- Amount to be taxed
*	@rcode				- Return Code - (0)Successful, (1)Failure
*	@ErrorMsg			- Error Message
*************************************************************************/
(@PRCo bCompany = NULL, @Employee bEmployee = NULL, @PREndDate bDate = NULL,
 @ATOETPType VARCHAR(4) = NULL, @SubjectAmt bDollar = 0, 
 @TotalAmtWithheld bDollar OUTPUT,	@ETPTaxableAmt bDollar OUTPUT,
 @ErrorMsg VARCHAR(255) OUTPUT)

AS

BEGIN TRY

	SET NOCOUNT ON

    DECLARE @NoTFNPct bPct,
			@ForeignResPct bPct,
			@DelayPayPct bPct,
			@UseSubjectAmtYN bYN,	
			@RetVal INT,
			@rcode INT


	------------------
	-- PRIME VALUES --
	------------------
	SET @NoTFNPct = .465
	SET @ForeignResPct = .450
	SET @DelayPayPct = .315
	SET @UseSubjectAmtYN = 'Y'	
	SET @ETPTaxableAmt = 0.00
    SET @rcode = 0
    SET @ErrorMsg = ''


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @PREndDate IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Payroll Date!'
			GOTO vspExit
		END

	IF @ATOETPType IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing ATO ETP Type!'
			GOTO vspExit
		END		

	IF @SubjectAmt IS NULL
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Missing Subject Amount!'
			GOTO vspExit
		END		


	-------------------
	-- GET DB VALUES --
	-------------------
	---------------------------------------------------------------------------
	-- Retrieve ATO-provided information stored in table vPRAULimitsAndRates --
	---------------------------------------------------------------------------
	DECLARE	@Return_Value int
	
	DECLARE	@ThruDate bDate,
			@ETPCap bDollar,
			@WholeIncomeCap bDollar,
			@RedundancyTaxFreeBasis bDollar,
			@RedundancyTaxFreeYears bDollar,
			@UnderPreservationAgePct bPct,
			@OverPreservationAgePct bPct,
			@ExcessCapPct bPct,
			@AnnualLeaveLoadingPct bPct,
			@LeaveFlatRatePct bPct,
			@LeaveFlatRateLimit bDollar

	SET @ThruDate = @PREndDate

	-- GET DATA FROM PRAULimitsAndRates TABLE --
	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_LimitsAndRatesGet]
			@ThruDate,
			@ETPCap OUTPUT,
			@WholeIncomeCap OUTPUT,
			@RedundancyTaxFreeBasis OUTPUT,
			@RedundancyTaxFreeYears OUTPUT,
			@UnderPreservationAgePct OUTPUT,
			@OverPreservationAgePct OUTPUT,
			@ExcessCapPct OUTPUT,
			@AnnualLeaveLoadingPct OUTPUT,
			@LeaveFlatRatePct OUTPUT,
			@LeaveFlatRateLimit OUTPUT,
			@ErrorMsg OUTPUT
	
	IF @Return_Value = 1 
	BEGIN
		SET @rcode = 1
		GOTO vspExit
	END


	----------
	-- PREH --
	----------
	DECLARE	@BirthDate bDate, @HireDate bDate, @SeparationDate bDate,
			@TFNSuppliedYN bYN, @ForeignResidentYN bYN, @EmployeeGender CHAR(1)
			
	SELECT	@BirthDate = BirthDate, 
			@SeparationDate = RecentSeparationDate, 
			@HireDate = (CASE WHEN RecentRehireDate IS NULL THEN HireDate ELSE RecentRehireDate END),
			@TFNSuppliedYN = CASE WHEN SSN IS NULL THEN 'N' ELSE 'Y' END,
			@ForeignResidentYN = NonResAlienYN,
			@EmployeeGender = Sex
	  FROM	dbo.bPREH WITH (NOLOCK)
	 WHERE	PRCo = @PRCo
	   AND	Employee = @Employee

	-- MAKE SURE WE HAVE EMPLOYEE DATA --
	IF @@ROWCOUNT = 0 
		BEGIN
			SET @rcode = 1
			SET @ErrorMsg = 'Unable to retrieve data for Employee: ' + dbo.vfToString(@Employee)
			GOTO vspExit
		END
	

	------------------------------------
	-- GET Redundancy TAX FREE AMOUNT --  ONLY FOR ETPR
	------------------------------------
	DECLARE @RedundancyTaxFreePortion bDollar, @RedundancyTaxablePortion bDollar
	SET @RedundancyTaxFreePortion = 0.00
	SET @RedundancyTaxablePortion = 0.00

	-- USED ONLY FOR Early Retirement & Genuine Redundancy --
	IF @ATOETPType = 'ETPR'
		BEGIN
			EXEC @rcode = [dbo].[vspPR_AU_ETP_RedundancyTaxFreeGet]
						@PRCo, @Employee, @UseSubjectAmtYN,
						@SubjectAmt, @HireDate, @SeparationDate,
						@RedundancyTaxFreeBasis, @RedundancyTaxFreeYears,
						@RedundancyTaxFreePortion OUTPUT,
						@RedundancyTaxablePortion OUTPUT,
						@ErrorMsg OUTPUT
				
			-- VERIFY SP SUCCESSFUL EXECUTION --
			IF @rcode <> 0 GOTO vspExit
		END 


	------------------------------------
	-- GET Invalidity TAX FREE AMOUNT --  ONLY FOR ETPV
	------------------------------------
	DECLARE @InvalidityTaxFreePortion bDollar, @InvalidityTaxablePortion bDollar
	SET @InvalidityTaxFreePortion = 0.00
	SET @InvalidityTaxablePortion = 0.00

	-- USED ONLY FOR Permanent Disability/Invalidity --   
	IF @ATOETPType = 'ETPV'
		BEGIN
			EXEC @rcode = [dbo].[vspPR_AU_ETP_InvalidityTaxFreeGet]
							@PRCo = @PRCo, 
							@Employee = @Employee,
							@ETPAmt = @SubjectAmt, 
							@BirthDate = @BirthDate, 
							@HireDate = @HireDate, 
							@SeparationDate = @SeparationDate,
							@EmployeeGender = @EmployeeGender,
							@InvalidityTaxFreePortion = @InvalidityTaxFreePortion OUTPUT, 
							@InvalidityTaxablePortion = @InvalidityTaxablePortion OUTPUT,
							@ErrorMsg = @ErrorMsg OUTPUT

			-- VERIFY SP SUCCESSFUL EXECUTION --
			IF @rcode <> 0 GOTO vspExit
		END


	--------------------------------
	-- GET PRE 83 TAX FREE AMOUNT -- FOR ALL ETPs
	--------------------------------
	DECLARE @Pre83TaxFreePortion bDollar,  @Pre83TaxablePortion bDollar
	SET @Pre83TaxFreePortion = 0.00
	SET @Pre83TaxablePortion = 0.00

	-- Based on the taxable portion of the ETP --
	SELECT @SubjectAmt = 
				CASE @ATOETPType
					WHEN 'ETPR' THEN @RedundancyTaxablePortion
					WHEN 'ETPV' THEN @InvalidityTaxablePortion
					ELSE @SubjectAmt
					END

	EXEC @rcode = [dbo].[vspPR_AU_ETP_Pre83TaxFreeGet]
					@PRCo, @Employee,
					@SubjectAmt, @HireDate, @SeparationDate,
					@Pre83TaxFreePortion OUTPUT,
					@Pre83TaxablePortion OUTPUT,   --- this becomes new subjedctamt or etptaxable amt
					@ErrorMsg OUTPUT
				
	-- VERIFY SP SUCCESSFUL EXECUTION --
	IF @rcode <> 0 GOTO vspExit


	-----------------------------------------------------------------------------------
	-- @Pre83TaxablePortion IS NOW THE ETP PORTION THAT IS SUBJECT TO Caps AND Rates --
	-----------------------------------------------------------------------------------
	SET @ETPTaxableAmt = @Pre83TaxablePortion 
	IF @ETPTaxableAmt < 0  SET @ETPTaxableAmt = 0	-- 50738 --


	-------------------------------------------
	-- IS Employee Under Preservation Age YN -- FOR ALL ETPs
	-------------------------------------------
	DECLARE @UnderPreservationAgeYN bYN

	EXEC @rcode = [dbo].[vspPR_AU_UnderPreservationAgeYN]
					@BirthDate,
					@UnderPreservationAgeYN OUTPUT,
					@ErrorMsg OUTPUT
				
	-- VERIFY SP SUCCESSFUL EXECUTION --
	IF @rcode <> 0 GOTO vspExit


	-----------------------
	-- SET ETP TAX RATES --  FOR ALL ETPs
	-----------------------
	DECLARE @UpToCapPct bPct,
			@AboveCapPct bPct

	EXEC @rcode = [dbo].[vspPR_AU_ETP_TaxRatesGet] 
					@ATOETPType, @UnderPreservationAgePct, @OverPreservationAgePct, 
					@ExcessCapPct, @NoTFNPct, @ForeignResPct, @DelayPayPct, 
					@UnderPreservationAgeYN, @TFNSuppliedYN,
					@ForeignResidentYN, @PREndDate,
					@UpToCapPct OUTPUT, @AboveCapPct OUTPUT,
					@ErrorMsg OUTPUT
				
	-- VERIFY SP SUCCESSFUL EXECUTION --
	IF @rcode <> 0 GOTO vspExit


	-------------------------------------
	-- GET TOTAL EARNINGS FOR THE YEAR -- 
	-------------------------------------
	DECLARE @YearEarnings bDollar
	SET @YearEarnings = 0.00

	-- CURRENT YEARS EARNINGS NEEDED TO CALCULATE WHOLE INCOME CAP --
	EXEC @rcode = [dbo].[vspPR_AU_TaxYearWagesGet] 
					@PRCo = @PRCo, 
					@Employee = @Employee, 
					@PREndDate = @PREndDate,
					@TaxableWages = @YearEarnings OUTPUT,
					@ErrorMsg = @ErrorMsg OUTPUT
				
	-- VERIFY SP SUCCESSFUL EXECUTION --
	IF @rcode <> 0 GOTO vspExit


	-------------------------
	-- SET ETP CAP AMOUNTS -- FOR ALL ETPS
	-------------------------
	DECLARE @UpToCapAmt bDollar,
			@AboveCapAmt bDollar,
			@CapAmt bDollar

	EXEC @rcode = [dbo].[vspPR_AU_ETP_CapAmtsGet]
					@ATOETPType = @ATOETPType, 
					@SubjectAmt = @YearEarnings, 
					@ETPAmt = @ETPTaxableAmt,
					@ETPCapAmt = @ETPCap, 
					@WholeIncomeCapAmt = @WholeIncomeCap,
					@UpToCapAmt = @UpToCapAmt OUTPUT,  
					@AboveCapAmt = @AboveCapAmt OUTPUT,
					@CapAmt = @CapAmt OUTPUT,
					@ErrorMsg = @ErrorMsg OUTPUT

	-- VERIFY SP SUCCESSFUL EXECUTION --
	IF @rcode <> 0 GOTO vspExit


	-------------------------------------------
	-- CALCULATIONS TOTAL AMOUNT TO WITHHOLD --
	-------------------------------------------
	SET @TotalAmtWithheld = (@UpToCapPct * @UpToCapAmt) + (@AboveCapPct * @AboveCapAmt)


END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @rcode = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @rcode

GO
PRINT N'Refreshing [dbo].[vrvPOCurCostByVendorSMWO]'
GO
EXEC sp_refreshview N'[dbo].[vrvPOCurCostByVendorSMWO]'
GO
PRINT N'Refreshing [dbo].[viFact_EMRevenue]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMRevenue]'
GO
PRINT N'Refreshing [dbo].[PMOHTotals]'
GO
EXEC sp_refreshview N'[dbo].[PMOHTotals]'
GO
PRINT N'Refreshing [dbo].[brvSLLedgerRpt]'
GO
EXEC sp_refreshview N'[dbo].[brvSLLedgerRpt]'
GO
PRINT N'Refreshing [dbo].[brvEMEquipCategory]'
GO
EXEC sp_refreshview N'[dbo].[brvEMEquipCategory]'
GO
PRINT N'Refreshing [dbo].[vrvPOTaxRates]'
GO
EXEC sp_refreshview N'[dbo].[vrvPOTaxRates]'
GO
PRINT N'Refreshing [dbo].[JCTN]'
GO
EXEC sp_refreshview N'[dbo].[JCTN]'
GO
PRINT N'Refreshing [dbo].[viFact_EMScheduledMaintenance]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMScheduledMaintenance]'
GO
PRINT N'Refreshing [dbo].[SMServiceCenterCallType]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceCenterCallType]'
GO
PRINT N'Refreshing [dbo].[JCPPJCCD]'
GO
EXEC sp_refreshview N'[dbo].[JCPPJCCD]'
GO
PRINT N'Refreshing [dbo].[brvSLSubContrByJob]'
GO
EXEC sp_refreshview N'[dbo].[brvSLSubContrByJob]'
GO
PRINT N'Refreshing [dbo].[INLocationRole]'
GO
EXEC sp_refreshview N'[dbo].[INLocationRole]'
GO
PRINT N'Refreshing [dbo].[brvEMEquipCompoCosts]'
GO
EXEC sp_refreshview N'[dbo].[brvEMEquipCompoCosts]'
GO
PRINT N'Refreshing [dbo].[vrvPOTaxRatesUnbatched]'
GO
EXEC sp_refreshview N'[dbo].[vrvPOTaxRatesUnbatched]'
GO
PRINT N'Refreshing [dbo].[EMED]'
GO
EXEC sp_refreshview N'[dbo].[EMED]'
GO
PRINT N'Refreshing [dbo].[viFact_EMWarranty]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMWarranty]'
GO
PRINT N'Refreshing [dbo].[vrvSMInvoiceListOnlyInvoiced]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMInvoiceListOnlyInvoiced]'
GO
PRINT N'Refreshing [dbo].[JBID]'
GO
EXEC sp_refreshview N'[dbo].[JBID]'
GO
PRINT N'Refreshing [dbo].[brvVBJCCDDetlDesc]'
GO
EXEC sp_refreshview N'[dbo].[brvVBJCCDDetlDesc]'
GO
PRINT N'Refreshing [dbo].[brvEMGLFiscalPeriods]'
GO
EXEC sp_refreshview N'[dbo].[brvEMGLFiscalPeriods]'
GO
PRINT N'Refreshing [dbo].[PRGG]'
GO
EXEC sp_refreshview N'[dbo].[PRGG]'
GO
PRINT N'Refreshing [dbo].[vrvPRAttach]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRAttach]'
GO
PRINT N'Refreshing [dbo].[viFact_EMWorkOrder]'
GO
EXEC sp_refreshview N'[dbo].[viFact_EMWorkOrder]'
GO
PRINT N'Refreshing [dbo].[vrvSMInvoicesByInvoiceNumber]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMInvoicesByInvoiceNumber]'
GO
PRINT N'Refreshing [dbo].[brvViewLookup]'
GO
EXEC sp_refreshview N'[dbo].[brvViewLookup]'
GO
PRINT N'Refreshing [dbo].[brvEMLocHistByJob]'
GO
EXEC sp_refreshview N'[dbo].[brvEMLocHistByJob]'
GO
PRINT N'Refreshing [dbo].[vrvPRAUBASGSTRec]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRAUBASGSTRec]'
GO
PRINT N'Refreshing [dbo].[viFact_HRAccident]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRAccident]'
GO
PRINT N'Refreshing [dbo].[vrvSMWorkOrderCountByTechnician]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMWorkOrderCountByTechnician]'
GO
PRINT N'Refreshing [dbo].[CMDTforCMClear]'
GO
EXEC sp_refreshview N'[dbo].[CMDTforCMClear]'
GO
PRINT N'Refreshing [dbo].[vrvPRAUBASGSTRecAR]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRAUBASGSTRecAR]'
GO
PRINT N'Refreshing [dbo].[EMEMAttachToEquip]'
GO
EXEC sp_refreshview N'[dbo].[EMEMAttachToEquip]'
GO
PRINT N'Refreshing [dbo].[viFact_HRApplicantByJobOpenings]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRApplicantByJobOpenings]'
GO
PRINT N'Refreshing [dbo].[JCPRTotal]'
GO
EXEC sp_refreshview N'[dbo].[JCPRTotal]'
GO
PRINT N'Refreshing [dbo].[EMMC]'
GO
EXEC sp_refreshview N'[dbo].[EMMC]'
GO
PRINT N'Refreshing [dbo].[brvEMMthCostRev]'
GO
EXEC sp_refreshview N'[dbo].[brvEMMthCostRev]'
GO
PRINT N'Refreshing [dbo].[vrvPRAUBASReport]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRAUBASReport]'
GO
PRINT N'Refreshing [dbo].[EMSM]'
GO
EXEC sp_refreshview N'[dbo].[EMSM]'
GO
PRINT N'Refreshing [dbo].[EMEMHasAttachmentsYN]'
GO
EXEC sp_refreshview N'[dbo].[EMEMHasAttachmentsYN]'
GO
PRINT N'Refreshing [dbo].[viFact_HRBenefitsExpiring]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRBenefitsExpiring]'
GO
PRINT N'Refreshing [dbo].[INMIPM]'
GO
EXEC sp_refreshview N'[dbo].[INMIPM]'
GO
PRINT N'Refreshing [dbo].[brvEMMthDeprCostRev]'
GO
EXEC sp_refreshview N'[dbo].[brvEMMthDeprCostRev]'
GO
PRINT N'Refreshing [dbo].[vrvPRAUETPReport]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRAUETPReport]'
GO
PRINT N'Refreshing [dbo].[viFact_HRCobra]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRCobra]'
GO
PRINT N'Refreshing [dbo].[DDFHUserMemoForms]'
GO
EXEC sp_refreshview N'[dbo].[DDFHUserMemoForms]'
GO
PRINT N'Refreshing [dbo].[DDFHUserMemoExist]'
GO
EXEC sp_refreshview N'[dbo].[DDFHUserMemoExist]'
GO
PRINT N'Refreshing [dbo].[brvEmpAcc]'
GO
EXEC sp_refreshview N'[dbo].[brvEmpAcc]'
GO
PRINT N'Refreshing [dbo].[EMTD]'
GO
EXEC sp_refreshview N'[dbo].[EMTD]'
GO
PRINT N'Refreshing [dbo].[vrvPRAUFBTReport]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRAUFBTReport]'
GO
PRINT N'Refreshing [dbo].[viFact_HRHistoryByPosition]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRHistoryByPosition]'
GO
PRINT N'Refreshing [dbo].[DDFSForm]'
GO
EXEC sp_refreshview N'[dbo].[DDFSForm]'
GO
PRINT N'Refreshing [dbo].[INMOPM]'
GO
EXEC sp_refreshview N'[dbo].[INMOPM]'
GO
PRINT N'Refreshing [dbo].[brvEMRevandCost]'
GO
EXEC sp_refreshview N'[dbo].[brvEMRevandCost]'
GO
PRINT N'Refreshing [dbo].[vrvPRCanT4Ver]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCanT4Ver]'
GO
PRINT N'Refreshing [dbo].[EMRB]'
GO
EXEC sp_refreshview N'[dbo].[EMRB]'
GO
PRINT N'Refreshing [dbo].[EMHC]'
GO
EXEC sp_refreshview N'[dbo].[EMHC]'
GO
PRINT N'Refreshing [dbo].[viFact_HROpenPositions]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HROpenPositions]'
GO
PRINT N'Refreshing [dbo].[PMDistributionLists]'
GO
EXEC sp_refreshview N'[dbo].[PMDistributionLists]'
GO
PRINT N'Refreshing [dbo].[SMServiceItemPart]'
GO
EXEC sp_refreshview N'[dbo].[SMServiceItemPart]'
GO
PRINT N'Refreshing [dbo].[DDFSGroup]'
GO
EXEC sp_refreshview N'[dbo].[DDFSGroup]'
GO
PRINT N'Refreshing [dbo].[brvEMRevAttachments]'
GO
EXEC sp_refreshview N'[dbo].[brvEMRevAttachments]'
GO
PRINT N'Refreshing [dbo].[vrvPRCertExport]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCertExport]'
GO
PRINT N'Refreshing [dbo].[POCTGrid]'
GO
EXEC sp_refreshview N'[dbo].[POCTGrid]'
GO
PRINT N'Refreshing [dbo].[viFact_HRPhysicalsReviewsExpiring]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRPhysicalsReviewsExpiring]'
GO
PRINT N'Refreshing [dbo].[INMTUnitCost]'
GO
EXEC sp_refreshview N'[dbo].[INMTUnitCost]'
GO
PRINT N'Refreshing [dbo].[brvEMRevBdownCost]'
GO
EXEC sp_refreshview N'[dbo].[brvEMRevBdownCost]'
GO
PRINT N'Refreshing [dbo].[PRID]'
GO
EXEC sp_refreshview N'[dbo].[PRID]'
GO
PRINT N'Creating [dbo].[vAPAUPayeeTaxPaymentATO]'
GO
CREATE TABLE [dbo].[vAPAUPayeeTaxPaymentATO]
(
[KeyID] [bigint] NOT NULL IDENTITY(1, 1),
[APCo] [dbo].[bCompany] NOT NULL,
[TaxYear] [char] (4) COLLATE Latin1_General_BIN NOT NULL,
[VendorGroup] [dbo].[bGroup] NOT NULL,
[Vendor] [dbo].[bVendor] NOT NULL,
[PayeeName] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[AusBusNbr] [varchar] (20) COLLATE Latin1_General_BIN NULL,
[Address] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[Address2] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[City] [varchar] (30) COLLATE Latin1_General_BIN NULL,
[State] [varchar] (4) COLLATE Latin1_General_BIN NULL,
[PostalCode] [dbo].[bZip] NULL,
[Country] [varchar] (2) COLLATE Latin1_General_BIN NULL,
[Phone] [varchar] (15) COLLATE Latin1_General_BIN NULL,
[TotalNoABNTax] [dbo].[bDollar] NULL CONSTRAINT [DF_vAPAUPayeeTaxPaymentATO_TotalNoABNTax] DEFAULT ((0)),
[TotalGST] [dbo].[bDollar] NULL CONSTRAINT [DF_vAPAUPayeeTaxPaymentATO_TotalGST] DEFAULT ((0)),
[TotalPaid] [dbo].[bDollar] NULL CONSTRAINT [DF_vAPAUPayeeTaxPaymentATO_TotalPaid] DEFAULT ((0)),
[AmendedDate] [dbo].[bDate] NULL,
[UniqueAttchID] [uniqueidentifier] NULL
) ON [PRIMARY]
GO
PRINT N'Creating primary key [PK_vAPAUPayeeTaxPaymentATO] on [dbo].[vAPAUPayeeTaxPaymentATO]'
GO
ALTER TABLE [dbo].[vAPAUPayeeTaxPaymentATO] ADD CONSTRAINT [PK_vAPAUPayeeTaxPaymentATO] PRIMARY KEY CLUSTERED  ([APCo], [TaxYear], [VendorGroup], [Vendor]) ON [PRIMARY]
GO
PRINT N'Creating [dbo].[APAUPayeeTaxPaymentATO]'
GO
SET QUOTED_IDENTIFIER OFF
GO


	CREATE VIEW [dbo].[APAUPayeeTaxPaymentATO] 
	AS 
	SELECT a.* FROM vAPAUPayeeTaxPaymentATO a
	
GO
PRINT N'Refreshing [dbo].[vrvPRCraftClassHierarchy]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCraftClassHierarchy]'
GO
PRINT N'Refreshing [dbo].[viFact_HRTraining]'
GO
EXEC sp_refreshview N'[dbo].[viFact_HRTraining]'
GO
PRINT N'Refreshing [dbo].[JBGC]'
GO
EXEC sp_refreshview N'[dbo].[JBGC]'
GO
PRINT N'Refreshing [dbo].[PMDocEmail]'
GO
EXEC sp_refreshview N'[dbo].[PMDocEmail]'
GO
PRINT N'Refreshing [dbo].[JBTC]'
GO
EXEC sp_refreshview N'[dbo].[JBTC]'
GO
PRINT N'Refreshing [dbo].[JCTH]'
GO
EXEC sp_refreshview N'[dbo].[JCTH]'
GO
PRINT N'Refreshing [dbo].[EMBFFuelInit]'
GO
EXEC sp_refreshview N'[dbo].[EMBFFuelInit]'
GO
PRINT N'Refreshing [dbo].[APExport]'
GO
EXEC sp_refreshview N'[dbo].[APExport]'
GO
PRINT N'Refreshing [dbo].[brvEMRevCost]'
GO
EXEC sp_refreshview N'[dbo].[brvEMRevCost]'
GO
PRINT N'Creating [dbo].[vAPAUPayerTaxPaymentATO]'
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[vAPAUPayerTaxPaymentATO]
(
[KeyID] [bigint] NOT NULL IDENTITY(1, 1),
[APCo] [dbo].[bCompany] NOT NULL,
[TaxYear] [char] (4) COLLATE Latin1_General_BIN NOT NULL,
[ContactName] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[ContactPhone] [varchar] (15) COLLATE Latin1_General_BIN NULL,
[SignatureOfAuthPerson] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[ReportDate] [dbo].[bDate] NULL,
[TaxYearClosed] [dbo].[bYN] NOT NULL CONSTRAINT [DF_vAPAUPayerTaxPaymentATO_TaxYearClosed] DEFAULT ('N'),
[UniqueAttchID] [uniqueidentifier] NULL,
[ABN] [varchar] (11) COLLATE Latin1_General_BIN NULL,
[BranchNo] [varchar] (3) COLLATE Latin1_General_BIN NULL,
[CompanyName] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[Address] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[Address2] [varchar] (60) COLLATE Latin1_General_BIN NULL,
[City] [varchar] (30) COLLATE Latin1_General_BIN NULL,
[State] [varchar] (4) COLLATE Latin1_General_BIN NULL,
[PostalCode] [dbo].[bZip] NULL,
[Country] [varchar] (2) COLLATE Latin1_General_BIN NULL,
[Notes] [varchar] (max) COLLATE Latin1_General_BIN NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
PRINT N'Creating primary key [PK_vAPAUPayerTaxPaymentATO] on [dbo].[vAPAUPayerTaxPaymentATO]'
GO
ALTER TABLE [dbo].[vAPAUPayerTaxPaymentATO] ADD CONSTRAINT [PK_vAPAUPayerTaxPaymentATO] PRIMARY KEY CLUSTERED  ([APCo], [TaxYear]) ON [PRIMARY]
GO
PRINT N'Creating [dbo].[APAUPayerTaxPaymentATO]'
GO
SET QUOTED_IDENTIFIER OFF
GO


	CREATE VIEW [dbo].[APAUPayerTaxPaymentATO] 
	AS 
	SELECT a.* FROM vAPAUPayerTaxPaymentATO a
	
GO
PRINT N'Refreshing [dbo].[vrvPRCraftClassTemplate]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCraftClassTemplate]'
GO
PRINT N'Refreshing [dbo].[viFact_INCurrentInventory]'
GO
EXEC sp_refreshview N'[dbo].[viFact_INCurrentInventory]'
GO
PRINT N'Refreshing [dbo].[EMBZGrid]'
GO
EXEC sp_refreshview N'[dbo].[EMBZGrid]'
GO
PRINT N'Refreshing [dbo].[brvEMRevCostMthlDetail]'
GO
EXEC sp_refreshview N'[dbo].[brvEMRevCostMthlDetail]'
GO
PRINT N'Altering [dbo].[bspAPLBVal]'
GO
SET QUOTED_IDENTIFIER ON
GO

ALTER procedure [dbo].[bspAPLBVal]
/***********************************************************
* CREATED: GG 07/07/99
* MODIFIED: GG 08/10/99 - Fixed GL distribution for old entries - subtract old retainage from old gross
*			GR 08/16/99 - Added comptype and component to bcAPLB cursor
*                         passed oldmatlgrp and oldmatl to bspAPLBValEquip
*			GG 11/13/99 - added output params to bspAPLBValNew, bspAPLBValPO, and bspAPLBValSL - used to
*                        fix RecvdNInvcd and RemCmtd calculations
*           GG 12/06/99 - fixed calls to bspAPLBValPO and bspAPLBValSL
*           GG 03/03/00 - reverse sign on updates to remaining units and costs to JC
*           GG 03/06/00 - include tax in RNI Cost updates to JC if PO Item Recv = 'Y'
*           GR 04/13/00 - Added the validation for supplier if exists
*           GG 05/08/00 - Fixed RemCmtdCost and RNI Cost updates to bAPJC - use calculated tax
*           GG 06/06/00 - Added validtaion for Expense Journal
*           GG 06/16/00 - Modified for changes to bAPIN
*           GG 06/20/00 - Tax info updated to bAPJC and bAPEM
*           kb 8/20/00  - issue #10146 - valdating disc date, can't be null if discount <> 0
*           GH 08/22/00 - Added isnull to @remcmtdcost when checking to insert APJC record
*           GR 09/06/00 - issue# 10343 - fixed call to bspAPLBValJCInsert
*           GR 11/21/00 - changed datatype from bAPRef to bAPReference
*           GR 11/29/00 - Fixed issue# 11403
*           GG 12/11/00 - Fixed issue #11475, old tax backed out of wrong phase
*			TV 03/13/01 - Validate @CompType
*           DANF 05/14/01 - Added Update for expensed PO Receipts.
*           GG 05/23/01 - fixed GL distributions for old IN lines when using burdened unit cost
*           bc 07/25/01 - sent fuelcapum error into HQBE instead of throwing a msgbox during validation.
*           GG 07/27/01 - fixed 'old' IN GL distributions (#14131), moved EM CompType validation to bspAPLBValEquip
*		 	GG 08/27/01 - #14461 - pull tax accrual account using AP Co# tax group
*		 	GH 08/31/01 - Added isnull to @fueltype when validating fuel info, issue #14512
*		 	GH 09/18/01 - issue #14647 added @oldcomptype to bspAPLBValEquip call
*			GG 09/21/01 - #14461 changed use tax validation and updates, also removed EM fuel capacity
*					validation now performed in EM triggers (#14132)
*           kb 12/10/1 - issue #11857
*           allenn 01/21/02 - issue 14529 - added validation error when taxcode is null and taxamount<>0
*           kb 1/29/2 - issue #15980
*			MV 2/4/02 - issue 14681 removed @uptaxgroup, use @taxgroup or @oldtaxgroup from APLB. Removed 
*				@apcotaxgroup param for bspAPLBValNew.
*           danf 03/19/02 Fix PO Receipt Exp By adding Delete along with change  to correct removal of entry
*			MV 03/26/02 - #14164 validate changes to paid lines.
*			MV 04/19/02 - #16892 GL distributions of tax and misc costs for non burdened, non standard IN transactions
*				also made modifications to bspPORBExpVal for IN distributions.
*			MV 04/29/02 - #17041 GL distributions for freight/misc costs when costs are burdened but Inc=N (MiscYN=N)
*			kb 5/16/2 - issue #17041 - in delete section of this issue need to not multiply by -1
				cause we are backing out
*			DANF 09/05/02 - 17738 Added PhaseGroup to bspAPLBValJob & bspJCCAGlacctDflt
*			MV 10/15/02 - #18720 - validate the vendor against PO or SL vendor for PO or SL lines.
*			MV 10/22/02 - #19063 - Old JC Distributions - default to oldphase, oldjcctype, oldglacct if no tax  
*						    but remaining committed costs to back out.
*           kb 10/28/2 - issue #18878 - fix double quotes
*			MV 01/08/03 - #18720 - validate vendor against PO and SL lines in bAPTL
*			MV 03/04/03 - #19926 - remaining committed cost/units, total committed cost/units for Standing PO
*			MV 09/02/03 - #21978 - added 2 output params to bspAPLBValPO, performance enhancements 
*			MV 11/11/03 - #22947 - added @invdate to bspAPLBValPO params for HQTX taxrate
*			MV 12/01/03 - #22664 - don't include Misc Amt in Total Cmtd Cost for standing POs not flagged for receiving
*			MV 12/08/03 - #23224 - trap for null @potaxrate, @oldpotaxrate
*			MV 02/09/04 - #18769 - Pay Category / #23061 isnull wrap 
*			ES 03/11/04 - #23061 - isnull wraps
*			MV 04/26/04 - #18769 - oldpaycategory retpaytype validation
*			MV 05/26/05 - #28714 - calc RemCmtdCost for tax on POs for update to JCCD the same as PO calculates it
*			MV 08/16/05 - #29558 - Use AvgECM to calculate StdUnitCost for Inventory update to bAPIN
*			MV 09/15/05 - #29610 - update APJC with taxbasis even if taxamt=0
*			MV 11/11/05 - #30340 - isnull wrap @oldavgecm 
*			MV 01/25/06 - #120033 - 6X fix for 5X issue #119950
*			MV 06/15/06 - #120234 - 6X fix for 5X issue #120125
*			MV 02/13/07 - #		  - removed 'bspAPLBVal' from error msg
*			MV 06/06/08 - #128288 - VAT/GST tax in GL distributions
*			MV 09/11/08 - #129788 - don't updated APJC for tax if taxbasis <> 0 BUT taxcode is null
*			MV 12/01/08 - #131275 - fixed APGL distribution for Job with VAT that isn't PST or GST 
*			MV 12/09/08 - #131380 - related to #128288 - more VAT bug fixes
*			MV 12/10/08 - #131385 - related to #128288 - VAT bug fixes for PO and S
*			MV 12/11/08 - #131407 - related to #128288 - Use tax update to GL Distributions
*			MV 12/18/08 - #131503 - GST tax was doubling in GL Dist if no Debit GL Acct for taxcode
*			MV 05/05/09 - #30264 - if tax is redirected don't include tax amount in JC unit cost calc
*			MV 07/29/09 - #133959 - corrected backing out old retainage GLAcct and old DiscOffered GL Acct
*			MV 08/20/09 - #135211 - don't evaluate tax type on paid line unless there is a taxcode.
*			DC 12/15/09 - #122288 - Store Tax Rate in POIT
*			MV 12/16/09 - #136903 - Don't validate old retainage paytype if no retainage
*			DC 12/29/09 - #130175 - SLIT needs to match POIT
*			MV 02/09/10 - #136500 - GST taxbasis net retainage, break out retg GST payable
*			MV 03/29/10 - #134876 - use closed Job GL Acct if job status = 3 - hard closed when posting changed or deleted lines.
*			MV 05/18/10	- #134876 - post tax to closed Job GL Acct
*			MV 05/19/10 - #136500 - fixed calc to open payables
*			TJL 05/27/10 - Issue #139910, GST not removed from EMCD.TaxAmount when AP Transaction gets Changed or Deleted
*			GP 6/28/10 - #135813 change bSL to varchar(30)
*			MV 07/15/10 - #133107 - Check Reversal on Holdback GST Payables 
*			CHS	08/05/10	- #140813 error invoicing to a hard closed job.
*			MV 11/30/10 - #141846 - 1) Validate Tax Code Retg GST payables against APCO TaxBasisNetRetg flag,
*						 2) use Retg GST Payables GL Acct only flag is checked.
*			MH 12/09/10 - #131640 - Changes to support SM.  Need to recognize PO Line Type 6 - SM Work Order.
*			EN 5/5/2011 TK-04672/#143321 To resolve Missing GST credit when deleting transaction changed @pstrate to @oldpstrate
*			GF 08/04/2011 - TK-07144 EXPAND PO
*			MV 08/10/11 - TK-07621 AP project to use POItemLine
*			CHS	08/29/2011	- TK-07986 added parameters in call to bspPORBExpVal
*			MV 09/01/11 - TK-08150 Retg GST GL Acct edge case
*			JVH 9/6/11 - TK-08137 Capture cost for PO Lines for transfering cost
*			MV 10/25/11 - TK-09243 - return @oldcrdRetgPSTGLAcct from bspHQTaxRateGetAll
*			MV 10/27/11 - TK-09245 - break out retainage PST tax into it's own payables GL Acct
*			JG 01/23/2012  - TK-11971 - Added JCCostType and PhaseGroup
*			MV 01/31/2012 - TK-11875 - On-Cost validation (SubjToOnCostYN, OnCostStatus)
*			TL	  03/08/2012  - TK- 12858 added code to update variables @oldsmservicesite and @oldsmtaxgroup
*			TL 03/19/2012 - TK - 13408 fixed code for SM/JC TaxCode Phase/Cost Redirect
*			TL 04/16/2012 0 TK13994 Added code to update APSM.Phase from APBL.SMPhase/OLdPhase
*			TL 04/24/2012 - TK-14135 removed @smtaxgroup
*			MV 04/26/12 - TK-14041 - commented out On-Cost validation
*			MV 05/08/12 - TK-14683 - validate GST/PST taxcode GL accounts only if there is a taxcode on the line.
*			MV 05/15/12 - TK-14964 - validate GST/PST credit retg GL Acct only if there is retainage on the line.
*			LG 08/09/12 - TK-16873 - validates deleted AP Translation Entry for SM line type
*			MV 08/16/12 - TK-17202 - fix GST/PST distributions when the calculated Tax Amount is overidden. 
*			JB 12/10/12 - Fix to support SM PO receiving
			MV 04/24/13 - TFS-48245 Changed/Deleted Job - fix calc for OldPST/OldGst where taxbasis is net of retg.
*
* ** Note Any changes made in this bsp may also need to be changed in bspPORBExpVal --- DANF *
*
* USAGE:
* Called from bspAPHBVal to validate the lines of a Batch Sequence and
* create distributions in bAPJC, bAPEM, bAPIN, and/or bAPGL.
*
* Errors in batch added to bHQBE
*
* INPUT PARAMETERS:
*  @apco               AP Company
*  @mth                Batch month
*  @batchid            Batch ID#
*  @batchseq           Batch sequence - a transaction
*  @headertranstype    Header transaction type ('A','C','D')
*  @aptrans            AP Transaction # for type 'C' and 'D', null if 'A'
*  @vendorgroup        Vendor Group - current
*  @vendor             Vendor # - current
*  @sortname           Vendor Sort Name - current
*  @oldvendorgroup     Vendor Group - old
*  @oldvendor          Vendor # - old
*  @oldsortname        Vendor Sort Name = old
*  @apref              AP Reference - current
*  @oldapref           AP Reference - old
*  @transdesc          Transaction description - current
*  @oldtransdesc       Transaction description - old
*  @invdate            Invoice Date - current
*  @oldinvdate         Invoice Date - old
*
* OUTPUT PARAMETERS
*    @errmsg           error message
*
* RETURN VALUE
*    0                 success
*    1                 failure
*****************************************************/
	@apco bCompany, @mth bMonth, @batchid bBatchID, @batchseq int, @headertranstype char(1),
	@aptrans bTrans, @vendorgroup bGroup, @vendor bVendor, @sortname varchar(15), @oldvendorgroup bGroup,
	@oldvendor bVendor, @oldsortname varchar(15), @apref bAPReference, @oldapref bAPReference,
	@transdesc bDesc, @oldtransdesc bDesc, @invdate bDate, @oldinvdate bDate, @errmsg varchar(255) output

  as
  
  set nocount on
  
	declare @rcode int, @openAPLB tinyint, @errorstart varchar(50), @errortext varchar(255), @recyn bYN,
	@jcum bUM, @jcunits bUnits, @emum bUM, @emunits bUnits, @stdum bUM, @stdunits bUnits, @costopt tinyint,
	@fixedunitcost bUnitCost, @fixedecm bECM, @burdenyn bYN, @loctaxglacct bGLAcct, @locmiscglacct bGLAcct,
	@locvarianceglacct bGLAcct, @accounttype char(1), @intercoarglacct bGLAcct, @intercoapglacct bGLAcct,
	@active bYN, @apglacct bGLAcct, @taxaccrualacct bGLAcct, @taxphase bPhase, @taxct bJCCType, @taxglacct bGLAcct,
	@retglacct bGLAcct, @oldrecyn bYN, @oldjcum bUM, @oldjcunits bUnits, @oldemum bUM, @oldemunits bUnits, @oldstdum bUM,
	@oldstdunits bUnits, @oldcostopt tinyint, @oldfixedunitcost bUnitCost, @oldfixedecm bECM, @oldburdenyn bYN,
	@oldloctaxglacct bGLAcct, @oldlocmiscglacct bGLAcct, @oldlocvarianceglacct bGLAcct, @oldintercoarglacct bGLAcct,
	@oldintercoapglacct bGLAcct, @oldapglacct bGLAcct,@oldtaxphase bPhase, @oldtaxct bJCCType, @oldtaxaccrualacct bGLAcct,
	@oldtaxglacct bGLAcct, @change char(1), @totalcost bDollar, @rniunits bUnits, @rnicost bDollar, @remcmtdcost bDollar,
	@jcunitcost bUnitCost, @slitemtype tinyint, @oldslitemtype tinyint, @u1 bUnitCost, @u2 bUnitCost, @c1 bDollar,
	@stdunitcost bUnitCost, @i smallint, @stdecm bECM, @variance bDollar, @upglacct bGLAcct, @glamt bDollar,
	@upphase bPhase, @upunits bUnits, @upjcctype bJCCType, @upum bUM, @upjcum bUM, @upjcunits bUnits, @upjcecm bECM,
	@uptaxbasis bDollar, @uptaxamt bDollar, @factor smallint, @oldcurunitcost bUnitCost, @oldcurecm bECM,
	@curunitcost bUnitCost, @curecm bECM, @taxrate bRate, @oldtaxrate bRate, @stdtotalcost bDollar, @unitcost bUnitCost,
	@c2 bDollar, @t1 bDollar, @t2 bDollar, @receiptupdate bYN, @pounits bUnits, @pogrossamt bDollar,
	@oldpounits bUnits, @oldpogrossamt bDollar, @apcotaxgroup bGroup, @usetaxamt bDollar, @remcmtdunits bUnits,
	@curcost bDollar, @curunits bUnits, @totalcmtdunits bUnits, @totalcmtdcost bDollar, @retpaytype tinyint,
	@discoffglacct bGLAcct, @posltaxbasis bDollar, @avgecm bECM, @oldavgecm bECM,@origunits bUnits, @origcost bDollar,
	@oldretpaytype tinyint, @oldretglacct bGLAcct, @olddiscoffglacct bGLAcct, @APHBCheckRevYN bYN 

	-- GST/PST declares
	declare @valueadd char(1), @gstrate bRate, @pstrate bRate, @dbtGLAcct bGLAcct, @dbtRetgGLAcct bGLAcct, @gstTaxAmt bDollar,
	@retgGstTaxAmt bDollar, @VATpstTaxAmt bDollar, @payTaxAmt bDollar, @retgTaxAmt bDollar, @retgPstTaxAmt bDollar, 
	@pstTaxAmt bDollar, @VATgstTaxAmt bDollar, @poGSTrate bRate, @oldvalueadd char(1), @oldgstrate bRate, @oldpstrate bRate, @olddbtGLAcct bGLAcct,
	@olddbtRetgGLAcct bGLAcct, @oldgstTaxAmt bDollar, @oldretgGstTaxAmt bDollar, @oldVATpstTaxAmt bDollar, @oldpayTaxAmt bDollar,
	@oldretgTaxAmt bDollar, @oldretgPstTaxAmt bDollar, @oldpstTaxAmt bDollar, @oldVATgstTaxAmt bDollar,@oldpoGSTrate bRate, @poslTaxAmt bDollar,
	@poslGSTtaxAmt bDollar, @oldposlTaxAmt bDollar,@oldposlGSTtaxAmt bDollar,@sltaxrate bRate,@slGSTrate bRate, @oldsltaxrate bRate,
	@oldslGSTrate bRate, @crdRetgGSTGLAcct bGLAcct, @oldcrdRetgGSTGLAcct bGLAcct, @crdRetgPSTGLAcct bGLAcct, @oldcrdRetgPSTGLAcct bGLAcct
			
  
	-- APCO declares
	declare @apglco bCompany, @expjrnl bJrnl, @pototyn bYN, @sltotyn bYN, @netamtopt bYN, @APretpaytype tinyint,
	@APdiscoffglacct bGLAcct, @retholdcode bHoldCode, @APCOTaxBasisNetRetg bYN

	-- APLB declares
	declare @apline smallint, @linetranstype char(1), @LineType tinyint, @po VARCHAR(30), @poitem bItem, @POItemLine INT,@itemtype tinyint,
	@sl varchar(30), @slitem bItem, @jcco bCompany, @job bJob, @phasegroup bGroup, @phase bPhase, @jcctype bJCCType,
	@emco bCompany, @wo bWO, @woitem bItem, @equip bEquip, @emgroup bGroup, @costcode bCostCode, @emctype bEMCType,
	@comptype varchar(10), @component bEquip, @inco bCompany, @loc bLoc, @matlgroup bGroup, @matl bMatl,
	@glco bCompany, @glacct bGLAcct, @linedesc bDesc, @um bUM, @apunits bUnits, @apunitcost bUnitCost, @ecm bECM,
	@suppliergroup bGroup, @supplier bVendor, @paytype tinyint, @grossamt bDollar, @miscamt bDollar, @miscyn bYN,
	@taxgroup bGroup, @taxcode bTaxCode, @taxtype tinyint, @taxbasis bDollar, @taxamt bDollar, @retainage bDollar,
	@discount bDollar, @burunitcost bUnitCost, @becm bECM, @oldlinetype tinyint, @oldpo VARCHAR(30), @oldpoitem bItem, @OldPOItemLine INT,
	@olditemtype tinyint, @oldsl varchar(30), @oldslitem bItem, @oldjcco bCompany, @oldjob bJob, @oldphasegroup bGroup,
	@oldphase bPhase, @oldjcctype bJCCType, @oldemco bCompany, @oldwo bWO, @oldwoitem bItem, @oldequip bEquip,
	@oldemgroup bGroup, @oldcostcode bCostCode, @oldemctype bEMCType, @oldcomptype varchar(10), @oldcomponent bEquip,
	@oldinco bCompany, @oldloc bLoc, @oldmatlgroup bGroup, @oldmatl bMatl, @oldglco bCompany, @oldglacct bGLAcct,
	@oldlinedesc bDesc, @oldum bUM, @oldunits bUnits, @oldunitcost bUnitCost, @oldecm bECM, @oldpaytype tinyint,
	@oldgrossamt bDollar, @oldmiscamt bDollar, @oldmiscyn bYN, @oldtaxgroup bGroup, @oldtaxcode bTaxCode,
	@oldtaxtype tinyint, @oldtaxbasis bDollar, @oldtaxamt bDollar, @oldretainage bDollar, @olddiscount bDollar,
	@oldburunitcost bUnitCost, @oldbecm bECM, @oldpotaxrate bRate, @potaxrate bRate, @linepaidyn bYN, @oldsupplier bVendor,
	@oldpotaxcode bTaxCode, @oldpotaxgroup bGroup, @paycategory int, @oldpaycategory int, @smco bCompany, @smworkorder int, 
	@scope int, @smcosttype smallint, @oldsmco bCompany, @oldsmworkorder int, @oldscope int, @oldsmcosttype smallint,
	@smjccosttype dbo.bJCCType, @oldsmjccosttype dbo.bJCCType, @smphasegroup dbo.bGroup, @oldsmphasegroup dbo.bGroup,
	@smphase dbo.bPhase, @oldsmphase dbo.bPhase,
	@SubjToOnCostYN bYN, @OldSubjToOnCostYN bYN, @smtaxcode bTaxCode, @smtaxgroup bGroup, @smtaxtype tinyint, 
	@smtaxrate bRate, @smtaxamt bDollar

	--APJC declares  --DC #122288
	declare @totalcmtdtax bDollar, @remcmtdtax bDollar

	--APSM declares
	DECLARE @oldsmlinedesc varchar(60), @oldsmservicesite varchar(20), @oldsmtype tinyint
	DECLARE @smlinedesc varchar(60),  @smservicesite varchar(20), @smtype tinyint,
	@aptlkeyid bigint, @smoldnew tinyint, @HQBatchDistributionID bigint, @HQBatchLineID bigint

	--Closed Job declares -- #134876
	declare @status tinyint, @contract bContract, @dept bDept,@closedGLAcct bGLAcct

	--PO Receipt Transfer declares
	DECLARE @GLEntryID bigint, @GLJobDetailDesc varchar(60), @GLInvDetailDesc varchar(60), @GLEquipDetailDesc varchar(60), @GLExpDetailDesc varchar(60), @GLExpTransDesc varchar(60), @TransactionDescription bTransDesc

	select @rcode = 0, @totalcmtdtax = 0, @remcmtdtax = 0 /*DC #122288*/, @errorstart = ''  --#23061	
  
	-- get AP Company info
	select @apglco = GLCo, @expjrnl = ExpJrnl, @pototyn = POTotYN, @sltotyn = SLTotYN, @netamtopt = NetAmtOpt,
	@APretpaytype = RetPayType, @APdiscoffglacct = DiscOffGLAcct, @retholdcode = RetHoldCode, @APCOTaxBasisNetRetg = TaxBasisNetRetgYN,
	@GLJobDetailDesc = GLJobDetailDesc, @GLInvDetailDesc = GLInvDetailDesc, @GLEquipDetailDesc = GLEquipDetailDesc, @GLExpDetailDesc = GLExpDetailDesc, @GLExpTransDesc = GLExpTransDesc
	from bAPCO WITH (NOLOCK) where APCo = @apco
	if @@rowcount = 0
	begin
		select @errmsg = 'Invalid AP Co#!', @rcode = 1
		goto bspexit
	end

	-- APHB info
	SELECT @APHBCheckRevYN = ChkRev	FROM dbo.APHB WHERE Co = @apco AND Mth = @mth AND BatchId = @batchid AND BatchSeq = @batchseq
	
  -- create a cursor to validate each line within this transaction
	declare bcAPLB cursor LOCAL FAST_FORWARD for
	select APLine, BatchTransType, LineType, PO, POItem, POItemLine,ItemType, SL, SLItem, JCCo, Job, PhaseGroup, Phase, JCCType,
	EMCo, WO, WOItem, Equip, EMGroup, CostCode, EMCType, CompType, Component,
	INCo, Loc, MatlGroup, Material, GLCo, GLAcct, Description, UM, Units, UnitCost, ECM,
	VendorGroup, Supplier, PayType, GrossAmt, MiscAmt, MiscYN, TaxGroup, TaxCode, TaxType, TaxBasis, TaxAmt,
	Retainage, Discount, BurUnitCost, BECM,PayCategory,
	OldLineType, OldPO, OldPOItem, OldPOItemLine,OldItemType, OldSL, OldSLItem, OldJCCo, OldJob, OldPhaseGroup, OldPhase, OldJCCType,
	OldEMCo, OldWO, OldWOItem, OldEquip, OldEMGroup, OldCostCode, OldEMCType, OldCompType, OldComponent,
	OldINCo, OldLoc, OldMatlGroup, OldMaterial, OldGLCo, OldGLAcct, OldDesc, OldUM, OldUnits, OldUnitCost, OldECM,
	OldPayType, OldGrossAmt, OldMiscAmt, OldMiscYN, OldTaxGroup, OldTaxCode, OldTaxType, OldTaxBasis, OldTaxAmt,
	OldRetainage, OldDiscount, OldBurUnitCost, OldBECM, PaidYN, OldSupplier, OldPayCategory, SMCo, SMWorkOrder, Scope,
	SMCostType, OldSMCo, OldSMWorkOrder, OldScope, OldSMCostType, APTLKeyID, 
	SMJCCostType, OldSMJCCostType, SMPhaseGroup, OldSMPhaseGroup,SMPhase,OldSMPhase,OldSubjToOnCostYN, SubjToOnCostYN
	from bAPLB WITH (NOLOCK)
	where Co = @apco and Mth = @mth and BatchId = @batchid and BatchSeq = @batchseq
  
	open bcAPLB
	select @openAPLB = 1
  
APLB_loop:      -- loop through each line

	fetch next from bcAPLB into @apline, @linetranstype, @LineType, @po, @poitem, @POItemLine, @itemtype, @sl, @slitem,
	@jcco, @job, @phasegroup, @phase, @jcctype, @emco, @wo, @woitem, @equip, @emgroup, @costcode,
	@emctype, @comptype, @component, @inco, @loc, @matlgroup, @matl, @glco, @glacct, @linedesc,
	@um, @apunits, @apunitcost, @ecm, @suppliergroup, @supplier, @paytype, @grossamt, @miscamt, @miscyn,
	@taxgroup, @taxcode, @taxtype, @taxbasis, @taxamt, @retainage, @discount, @burunitcost, @becm, @paycategory,
	@oldlinetype, @oldpo, @oldpoitem, @OldPOItemLine, @olditemtype, @oldsl, @oldslitem, @oldjcco, @oldjob, @oldphasegroup,
	@oldphase, @oldjcctype, @oldemco, @oldwo, @oldwoitem, @oldequip, @oldemgroup, @oldcostcode, @oldemctype,
	@oldcomptype, @oldcomponent, @oldinco, @oldloc, @oldmatlgroup, @oldmatl, @oldglco, @oldglacct,
	@oldlinedesc, @oldum, @oldunits, @oldunitcost, @oldecm, @oldpaytype, @oldgrossamt, @oldmiscamt,
	@oldmiscyn, @oldtaxgroup, @oldtaxcode, @oldtaxtype, @oldtaxbasis, @oldtaxamt, @oldretainage,
	@olddiscount, @oldburunitcost, @oldbecm, @linepaidyn, @oldsupplier, @oldpaycategory,@smco, 
	@smworkorder, @scope, @smcosttype, @oldsmco, @oldsmworkorder, @oldscope, @oldsmcosttype, @aptlkeyid,
	@smjccosttype, @oldsmjccosttype, @smphasegroup, @oldsmphasegroup, @smphase,@oldsmphase,@OldSubjToOnCostYN, @SubjToOnCostYN
         
  	if @@fetch_status <> 0 goto bspexit
  
	select @errorstart = 'Seq#: ' + isnull(convert(varchar(6),@batchseq), '') + 
	' Line: ' + isnull(convert(varchar(6),@apline), '') + ' '  --#23061

	/* Reset some processing variables */
	select @payTaxAmt = 0, @retgTaxAmt = 0, @gstTaxAmt = 0, @retgGstTaxAmt = 0, @pstTaxAmt = 0, @retgPstTaxAmt = 0, 
	@VATgstTaxAmt = 0, @VATpstTaxAmt = 0,@oldpayTaxAmt = 0, @oldretgTaxAmt = 0, @oldgstTaxAmt = 0, @oldretgGstTaxAmt = 0,
	@oldpstTaxAmt = 0, @oldretgPstTaxAmt = 0,@oldVATgstTaxAmt = 0, @oldVATpstTaxAmt = 0,@poslTaxAmt =0,@poslGSTtaxAmt = 0,
	@oldposlTaxAmt =0, @oldposlGSTtaxAmt =0

	/*Issue 14529*/
	-- check for Tax Code
	if @taxamt > 0 and @taxcode is null
	begin
		select @errortext = @errorstart + ' -  Tax Code missing where Tax Amount does not equal $0.00'
		goto APLB_error
	end
  
	--  validate Batch Transaction Type
	if @linetranstype not in ('A', 'C', 'D')
	begin
		select @errortext = @errorstart + ' -  Invalid transaction type, must be (A),(C), or (D).'
		goto APLB_error
	end

	if @headertranstype in ('A','D') and @linetranstype <> @headertranstype
	begin
		select @errortext = @errorstart + ' - Invalid transaction type, must match header.'
		goto APLB_error
	end

	-- validate Batch Transaction type delete 
	if @linetranstype = 'D' and @linepaidyn='Y'
	begin
		select @errortext = @errorstart + ' -  Cannot delete a paid line.'
		goto APLB_error
	end

	-- validate Line Type
	if @LineType < 1 or @LineType > 8
	begin
		select @errortext = @errorstart + ' Invalid Line Type!'
		goto APLB_error
	end

	--validate PayCategory
	if @paycategory is not null
	begin
		select @retpaytype=RetPayType, @discoffglacct=DiscOffGLAcct 
		from bAPPC with (nolock)
		where APCo=@apco and PayCategory=@paycategory
		if @@rowcount=0
		begin
			select @errortext = @errorstart + ' Invalid Pay Category!'
			goto APLB_error
		end
	end
	else
	begin
		select @retpaytype=@APretpaytype, @discoffglacct=@APdiscoffglacct
	end
	
	--Build out the description so that it can be saved off with
	--the GL Transaction Entries. Only currently used for SM Line types.
	SET @TransactionDescription = RTRIM(dbo.vfToString(CASE 
		--PO Lines need to be translated based on their item type
		CASE WHEN @LineType = 6 AND @itemtype = 6 THEN 8 /*The SMLineType the only line type that doesn't directly translate*/ WHEN @LineType = 6 THEN @itemtype ELSE @LineType END
			WHEN 1 THEN @GLJobDetailDesc		-- job
          	WHEN 2 THEN @GLInvDetailDesc		-- inventory
          	WHEN 3 THEN @GLExpDetailDesc		-- expense
          	WHEN 4 THEN @GLEquipDetailDesc		-- equipment
          	WHEN 5 THEN @GLEquipDetailDesc		-- work order - equipment
          	WHEN 7 THEN @GLJobDetailDesc		-- subcontract - job
          	WHEN 8 THEN @GLExpTransDesc			-- SM currently we don't have a transaction level description. This may need to change.
			ELSE @GLExpTransDesc END))

	SELECT
		@TransactionDescription = REPLACE(@TransactionDescription, 'InvDesc', dbo.vfToString(@transdesc)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Vendor#', dbo.vfToString(@vendor)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'SortName', dbo.vfToString(@sortname)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'APRef', dbo.vfToString(@apref)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'InvDate', dbo.vfToString(CONVERT(VARCHAR, @invdate, 107))),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Line', dbo.vfToString(@apline)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'LineDesc', dbo.vfToString(@linedesc)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Matl', dbo.vfToString(@matl)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'JCCo', dbo.vfToString(@jcco)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Job', dbo.vfToString(@job)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Phase', dbo.vfToString(@phase)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'JCCT', dbo.vfToString(@jcctype)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'INCo', dbo.vfToString(@inco)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Loc', dbo.vfToString(@loc)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'EMCo', dbo.vfToString(@emco)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'Equip', dbo.vfToString(@equip)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'CostCode', dbo.vfToString(@costcode)),
		@TransactionDescription = REPLACE(@TransactionDescription, 'EMCT', dbo.vfToString(@emctype))
		--We don't update the Trans# description since we don't know it yet. 
		--If it is in there at the time of posting we should put it in.

	--Retrieve the HQDistributionID created in bspAPHBVal
	EXEC @rcode = dbo.vspHQBatchDistributionGet @BatchCo = @apco, @BatchMth = @mth, @BatchId = @batchid, @HQBatchDistributionID = @HQBatchDistributionID OUTPUT, @msg = @errmsg OUTPUT
	IF @rcode <> 0
	BEGIN
		SELECT @errortext = @errorstart + '- ' + dbo.vfToString(@errmsg)
		GOTO APLB_error
	END
	
	SET @HQBatchLineID = NULL
	
	IF @oldlinetype = 8 OR @LineType = 8
	BEGIN
		--Currently detail is only associated with SM Work Completed and so if 
		--the new line is not going to be an SM line then the detail should be deleted
		--If ever it is changed so the detail is captured on the APTL record then the line
		--should no longer be marked as deleted so that it doens't end up deleting the detail.
		INSERT dbo.vHQBatchLine (Co, Mth, BatchId, Seq, Line, BatchTransType, HQDetailID)
		SELECT @apco, @mth, @batchid, @batchseq, @apline, CASE WHEN @LineType <> 8 THEN 'D' ELSE @linetranstype END, (SELECT CostDetailID FROM dbo.vSMWorkCompleted WHERE APTLKeyID = @aptlkeyid)
		
		SET @HQBatchLineID = SCOPE_IDENTITY()
	END

	if @linetranstype in ('A','C')  -- common validation for Add and Change entries
	begin
		exec @rcode = bspAPLBValNew @apco, @mth, @batchid, @batchseq, @invdate, @apline, @apglco, @expjrnl, @pototyn, @sltotyn,
		@netamtopt,@retpaytype, @discoffglacct, @retholdcode, @HQBatchDistributionID, @recyn output, @slitemtype output,
		@jcum output, @jcunits output, @emum output, @emunits output, @stdum output, @stdunits output,
		@costopt output, @fixedunitcost output, @fixedecm output, @burdenyn output, @loctaxglacct output,
		@locmiscglacct output, @locvarianceglacct output, @intercoarglacct output, @intercoapglacct output,
		@apglacct output, @taxaccrualacct output, @taxphase output, @taxct output, @taxglacct output, @taxrate output,
		@retglacct output, @curunitcost output, @curecm output, @potaxrate output, @avgecm output, @valueadd output,
		@gstrate output,@pstrate output,@dbtGLAcct output, @dbtRetgGLAcct output, @poGSTrate output,@sltaxrate output,
		@slGSTrate output, @crdRetgGSTGLAcct output, @crdRetgPSTGLAcct output, @errmsg output

		if @rcode <> 0
		begin
			select @errortext = @errorstart + '- ' + isnull(@errmsg,'')
			goto APLB_error
		end
    
		/*DC #122288  Get POIT !Tax Rate
		I wasn't sure where else bspAPLBValPO gets called.  bspAPLBValNew does call bspAPLBValPO and I wasn't
		sure what else in AP calls bspAPLBValNew.  for issue #122288 I need to get the tax rate from POIT so 
		I just reset the same variables that was being used to the tax rate in POIT.  A future enhancement should 
		clean up bspAPLBValPO to return POIT Tax Rate.			  
		*/        	    
		if @LineType = 6
		BEGIN  
			SELECT @potaxrate = TaxRate, @poGSTrate = GSTRate
			FROM vPOItemLine (NOLOCK) 
			WHERE POCo=@apco AND PO=@po AND POItem=@poitem AND POItemLine=@POItemLine
			--bPOIT with (NOLOCK) where POCo = @apco and PO = @po and POItem = @poitem
		END
			  
		/*DC #130175  Get SLIT !Tax Rate
		I wasn't sure where else bspAPLBValSL gets called.  bspAPLBValNew does call bspAPLBValSL and I wasn't
		sure what else in AP calls bspAPLBValNew.  for issue #130175 I need to get the tax rate from SLIT so 
		I just reset the same variables that was being used to the tax rate in SLIT.  A future enhancement should 
		clean up bspAPLBValSL to return SLIT Tax Rate.			  
		*/        	    
		if @LineType = 7
		BEGIN  
			select @sltaxrate = TaxRate, @slGSTrate = GSTRate
			from bSLIT with (NOLOCK) where SLCo = @apco and SL = @sl and SLItem = @slitem
		END			          	    
        	 
        IF (@taxgroup iS NOT NULL) AND (@taxcode IS NOT NULL)
        BEGIN   
			-- validate GST Debit Tax GL Account if there is one
			IF @dbtGLAcct IS NOT NULL
			BEGIN
				EXEC @rcode = bspGLACfPostable @glco, @dbtGLAcct, null, @errmsg output
				IF @rcode <> 0
				BEGIN
					SELECT @errortext = @errorstart + '- Tax Code GST Expense GL Acct: ' + isnull(@dbtGLAcct, '') + 
					':  ' + isnull(@errmsg,'')  
					GOTO APLB_error
				END
				
				-- validate GST retainage Debit Tax GL Account
				IF @dbtRetgGLAcct IS NOT NULL
				BEGIN
					EXEC @rcode = bspGLACfPostable @glco, @dbtRetgGLAcct, null, @errmsg output
					IF @rcode <> 0
					BEGIN
						SELECT @errortext = @errorstart + '- Tax Code Retg GST Expense GL Acct: ' + isnull(@dbtRetgGLAcct, '') + 
						':  ' + isnull(@errmsg,'')  
						GOTO APLB_error
					END
				END
			END	-- end validation for GST GL Accts
		
			-- validate Credit Retainage GST GL Acct 
			IF @crdRetgGSTGLAcct IS NOT NULL
			BEGIN
				EXEC @rcode = bspGLACfPostable @glco, @crdRetgGSTGLAcct, NULL, @errmsg OUTPUT
				IF @rcode <> 0
				BEGIN
					SELECT @errortext = @errorstart + '- Tax Code GST Payable GL Acct: ' + ISNULL(@crdRetgGSTGLAcct, '') + 
					':  ' + isnull(@errmsg,'')  
					GOTO APLB_error
				END
			END
			ELSE 
			BEGIN
				-- IF APCO TaxBasisNetRetg flag is checked and there is retainage on the line, then a Tax Code Credit GST/PST Payable GL Acct is required
				IF @APCOTaxBasisNetRetg = 'Y' AND ISNULL(@retainage,0) <> 0
				BEGIN
					SELECT @errortext = @errorstart + '- when tax basis is net of retention/holdback, a Credit GL Ret/Hbk Tax Acct is required in the tax code.'   
					GOTO APLB_error
				END
			END
		
			-- validate Credit Retainage PST GL Acct 
			IF @crdRetgPSTGLAcct IS NOT NULL 
			BEGIN
				EXEC @rcode = bspGLACfPostable @glco, @crdRetgPSTGLAcct, NULL, @errmsg OUTPUT
				IF @rcode <> 0
				BEGIN
					SELECT @errortext = @errorstart + '- Tax Code PST Payable GL Acct: ' + ISNULL(@crdRetgPSTGLAcct, '') + 
					':  ' + isnull(@errmsg,'')  
					GOTO APLB_error
				END
			END
			ELSE 
			BEGIN
				-- IF APCO TaxBasisNetRetg flag is checked then a Tax Code PST Payable GL Acct is required
				IF @APCOTaxBasisNetRetg = 'Y' AND @pstrate <> 0 AND ISNULL(@retainage,0) <> 0
				BEGIN
					SELECT @errortext = @errorstart + '- when tax basis is net of retention/holdback, a Credit GL Ret/Hbk Tax Acct is required in the tax code.'   
					GOTO APLB_error
				END
			END
		END 
			
		--validate supplier if one exists issue 6335 
		if @supplier is not null
		begin
			if @vendor = @supplier
			begin
				select @errortext = @errorstart + 'Supplier # cannot be the same as the Invoice Vendor.'
				goto APLB_error
			end
			if @vendorgroup <> @suppliergroup
			begin
				select @errortext = @errorstart + 'Vendor Group for your Supplier and Vendor must be the same.'
				goto APLB_error
			end
			--check for valid supplier is done bspAPLBValNew
		end
  	end -- common validation for Add and Change entries
  
	-- validate vendor against PO or SL vendor - issue 18720
	if @headertranstype = 'C' and @LineType in (6,7)	-- validate vendor against PO and SL lines in bAPTL 
	begin
		exec @rcode = bspAPVendValPOSL @apco, @mth, @batchid, @batchseq,@vendor,'APEntry',0,@errmsg output
		if @rcode <> 0
		begin
			select @errortext = 'Seq#: ' + isnull(convert(varchar(6),@batchseq), '') +  isnull(@errmsg,'')
			goto APLB_error
		end
	end
	
	if @linetranstype in ('A','C')	-- validate vendor for PO and SL lines in bAPLB
	begin
		if @LineType = 6 --PO
		begin
			if exists(select top 1 1 from bPOHD WITH (NOLOCK) where POCo=@apco and PO=@po and Vendor <> @vendor)
			begin
				select @errortext = @errorstart + '- Vendor does not match PO vendor.' 
				goto APLB_error
			end
		end
		
  		if @LineType = 7 --SL
		begin
			if exists(select top 1 1 from bSLHD WITH (NOLOCK) where SLCo= @apco and SL=@sl and Vendor <> @vendor)
			begin
				select @errortext = @errorstart + '- Vendor does not match SL vendor.' 
				goto APLB_error
			end
		end
	end
	
   	if @linetranstype in ('C', 'D')     -- common validation for Change and Delete entries
    begin
		-- compare to existing AP Transaction Line
        exec @rcode = bspAPLBValTrans @apco, @mth, @batchid, @batchseq, @aptrans, @apline, @errmsg output
        if @rcode <> 0
        begin
			select @errortext = @errorstart + isnull(@errmsg,'')
            goto APLB_error
        end
		-- check for any Cleared Transaction Detail -- #14164 - allow paid transactions
		if exists(select top 1 1 from bAPTD WITH (NOLOCK) where APCo = @apco and Mth = @mth
		and APTrans = @aptrans and APLine = @apline and Status > 3)
		begin
			select @errortext = @errorstart + '- Some or all of this Line has been cleared.  Cannot change or delete.'
			goto APLB_error
		end
  
  		-- Validate paid lines, check that only allowable fields were changed.
  		if @linetranstype ='C' and @linepaidyn = 'Y'
		begin
  			if isnull(@um,'') <> isnull(@oldum,'')
  			or isnull(@apunits,0) <> isnull(@oldunits,0) or isnull(@apunitcost,0) <> isnull(@oldunitcost,0)
  			or isnull(@ecm,'') <> isnull(@oldecm,'')or isnull(@supplier,0) <> isnull(@oldsupplier,0)
  			or isnull(@paytype,0) <> isnull(@oldpaytype,0)or isnull(@grossamt,0) <> isnull(@oldgrossamt,0)
  			or isnull(@miscamt,0) <> isnull(@oldmiscamt,0)or isnull(@miscyn,'') <> isnull(@oldmiscyn,'')
  			or isnull(@taxcode,'') <> isnull(@oldtaxcode,'') or (@taxcode is not null and isnull(@taxtype,0) <> isnull(@oldtaxtype,0))
  			or isnull(@taxbasis,0) <> isnull(@oldtaxbasis,0)or isnull(@taxamt,0) <> isnull(@oldtaxamt,0)
  			or isnull(@retainage,0) <> isnull(@oldretainage,0)or isnull(@discount,0) <> isnull(@olddiscount,0)
  			begin
  				select @errortext = @errorstart + '- Cannot change some fields in paid lines.'
  				goto APLB_error
  			end
  			
  			-- if type is PO,cannot change any line fields
  			if @LineType = 6
  			begin
  				if isnull(@po,'' ) <> isnull(@oldpo,'') or isnull(@poitem,0) <> isnull(@oldpoitem,0) OR
  					ISNULL(@POItemLine,0) <> ISNULL(@OldPOItemLine,0)or
  					isnull(@linedesc,'') <> isnull(@oldlinedesc,'') or isnull(@glacct,'') <> isnull(@oldglacct,'')
  				begin
  					select @errortext = @errorstart + '- Cannot make any changes to paid PO lines.'
  	        		goto APLB_error
  				end
  	        end
  		
  			-- if type is SL, cannot make any changes
  			if @LineType = 7
  			begin
  				if isnull(@sl,'') <> isnull(@oldsl,'') or isnull(@slitem,0) <> isnull(@oldslitem,0)
  				or isnull(@linedesc,'') <> isnull(@oldlinedesc,'') or isnull(@glacct,'') <> isnull(@oldglacct,'')
  				begin
  					select @errortext = @errorstart + '- Cannot make any changes to paid SL lines.'
  	        		goto APLB_error
  	        	end 
  			end
  		end
  
		-- validate old PO and Item
		select @oldrecyn = @recyn

		if @oldlinetype = 6 --PO
		begin
			exec @rcode = bspAPLBValPO @apco, @mth, @batchid, @invdate, @oldpo, @oldpoitem, @OldPOItemLine,@olditemtype, @oldmatl,
			@oldum, @oldjcco, @oldemco, @oldinco, @oldglco, @oldloc, @oldjob, @oldphase, @oldjcctype,
			@oldequip, @oldcostcode, @oldemctype, @oldcomptype, @oldcomponent, @oldwo, @oldwoitem,
			@pototyn, @oldsmco, @oldsmworkorder, @oldscope, @oldrecyn output, @oldcurunitcost output, @oldcurecm output, @oldpotaxrate output,
			@oldpotaxcode output,@oldpotaxgroup output, @oldpoGSTrate output, @errmsg output
			
			if @rcode <> 0
			begin
				select @errortext = @errorstart + isnull(@errmsg,'')
				goto APLB_error
			end
  
			/*DC #122288  Get POIT !Tax Rate
			I wasn't sure where else bspAPLBValPO gets called.  bspAPLBValNew does call bspAPLBValPO and I wasn't
			sure what else in AP calls bspAPLBValNew.  for issue #122288 I need to get the tax rate from POIT so 
			I just reset the same variables that was being used to the tax rate in POIT.  A future enhancement should 
			clean up bspAPLBValPO to returne POIT Tax Rate.			  
			*/
			select @oldpotaxrate = TaxRate, @oldpoGSTrate = GSTRate
			FROM vPOItemLine (NOLOCK)
			WHERE POCo=@apco AND PO = @oldpo and POItem = @oldpoitem AND POItemLine = @OldPOItemLine
			--from bPOIT with (NOLOCK) where POCo = @apco and PO = @oldpo and POItem = @oldpoitem
			    
			-- get PO Company info
			select @receiptupdate = ReceiptUpdate
			from bPOCO WITH (NOLOCK) where POCo = @apco
			if @@rowcount = 0
			begin
				select @errmsg = ' Invalid PO Company!', @rcode = 1
				goto bspexit
			end
			
			if @receiptupdate = 'Y' and @oldrecyn = 'Y'
			begin
				if @linetranstype = 'C' OR @linetranstype = 'D'
				begin
					select @pounits = -1 * isnull(@apunits,0), @pogrossamt =  isnull(@grossamt,0) * -1
					select @oldpounits = -1 * isnull(@oldunits,0), @oldpogrossamt =  isnull(@oldgrossamt,0) * -1

					exec @rcode = bspPORBExpVal @apco, @mth, @batchid, @batchseq, @apline, @linetranstype, null,
					@po, @poitem, @invdate, null, @linedesc, @pounits, @pogrossamt, 0, 0, null,
					@oldpo, @oldpoitem,@oldinvdate, null, @oldlinedesc, @oldpounits, @oldpogrossamt, null,
					null, null, @POItemLine, @OldPOItemLine, @HQBatchDistributionID, @errmsg output
					if @rcode <> 0 goto bspexit
				end
				else
				begin
					select @oldpounits = isnull(@oldunits,0), @oldpogrossamt =  isnull(@oldgrossamt,0)
					exec @rcode = bspPORBExpVal @apco, @mth, @batchid, @batchseq, @apline, @linetranstype, null,
					null, null, null, null, null, 0, 0, 0, 0, null, @oldpo, @oldpoitem, @oldinvdate, null,
					@oldlinedesc, @oldpounits, @oldpogrossamt, null, null, null, 
					@POItemLine, @OldPOItemLine, @HQBatchDistributionID, @errmsg output
					if @rcode <> 0 goto bspexit
				end
			end 
		end -- End PO
  
		-- validate old SL and Item
		if @oldlinetype = 7
		begin
			exec @rcode = bspAPLBValSL @apco, @mth, @batchid, @oldsl, @oldslitem, @oldjcco, @oldjob,
			@oldphase, @oldjcctype, @oldum, @sltotyn, @oldslitemtype output, @oldcurunitcost output,
			null,null,@oldsltaxrate output,@oldslGSTrate output, @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- ' + isnull(@errmsg,'')
				goto APLB_error
			end

			/*DC #130175  Get SLIT !Tax Rate
			I wasn't sure where else bspAPLBValSL gets called.  bspAPLBValNew does call bspAPLBValSL and I wasn't
			sure what else in AP calls bspAPLBValNew.  for issue #130175 I need to get the tax rate from SLIT so 
			I just reset the same variables that was being used to the tax rate in SLIT.  A future enhancement should 
			clean up bspAPLBValSL to returne SLIT Tax Rate.			  
			*/
			
			select @oldsltaxrate = TaxRate, @oldslGSTrate = GSTRate
			from bSLIT with (NOLOCK) where SLCo = @apco and SL = @oldsl and SLItem = @oldslitem

		end
		
		-- validate old JCCo, Job, Phase, and JC Cost Type
		select @oldjcum = @jcum, @oldjcunits = @jcunits
		if (@oldlinetype in (1,7) or (@oldlinetype = 6 and @olditemtype = 1)) and
		(isnull(@jcco,0) <> @oldjcco or isnull(@job,'') <> @oldjob or isnull(@phase,'') <> @oldphase
		or isnull(@jcctype,0) <> @oldjcctype or isnull(@matl,'') <> isnull(@oldmatl,'')
		or isnull(@um,'') <> isnull(@oldum,'') or @apunits <> @oldunits or @linetranstype = 'D')
		begin
			exec @rcode = bspAPLBValJob @oldjcco, @oldphasegroup, @oldjob, @oldphase, @oldjcctype, @oldmatlgroup, @oldmatl,
			@oldum, @oldunits, @oldjcum output, @oldjcunits output, @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- ' + isnull(@errmsg,'')
				goto APLB_error
			end
		end
		
		-- validate old Work Order and Item
		if (@oldlinetype = 5 or (@oldlinetype = 6 and @olditemtype = 5)) and
		(isnull(@emco,0) <> @oldemco or isnull(@wo,'') <> @oldwo or isnull(@woitem,0) <> @oldwoitem or @linetranstype = 'D')
		begin
			exec @rcode = bspAPLBValWO @oldemco, @oldwo, @oldwoitem, @oldequip, @oldcomptype, @oldcomponent,
			@oldemgroup, @oldcostcode, @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + isnull(@errmsg,'')
				goto APLB_error
			end
		end
		
      	-- validate EMCo, Equip, Cost Code, EM Cost Type, Component Type, and Component
        select @oldemum = @emum, @oldemunits = @emunits
  
		if (@oldlinetype in (4,5) or (@oldlinetype = 6 and @olditemtype in (4,5))) and
		(isnull(@emco,0) <> @oldemco or isnull(@equip,'') <> @oldequip or isnull(@costcode,'') <> @oldcostcode
		or isnull(@emctype,0) <> @oldemctype or isnull(@comptype,'') <> isnull(@oldcomptype,'')
		or isnull(@component,'') <> isnull(@oldcomponent,'') or isnull(@um,'') <> isnull(@oldum,'')
		or @apunits <> @oldunits or @linetranstype = 'D')
		begin
			exec @rcode = bspAPLBValEquip @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype,
			@comptype, @oldcomponent,@oldmatlgroup, @oldmatl, @oldum, @oldunits, @oldemum output,
			@oldemunits output, @errmsg output
		
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- ' +isnull(@errmsg,'')
				goto APLB_error
			end
		end
		
		-- validate old IN Co#, Location, Material, and UM
		select @oldstdum = @stdum, @oldstdunits = @stdunits, @oldcostopt = @costopt,
		@oldfixedunitcost = @fixedunitcost, @oldfixedecm = @fixedecm, @oldburdenyn = @burdenyn,
		@oldloctaxglacct = @loctaxglacct, @oldlocmiscglacct = @locmiscglacct,
		@oldlocvarianceglacct = @locvarianceglacct

		if (@oldlinetype = 2 or (@oldlinetype = 6 and @olditemtype = 2)) and (isnull(@inco,0) <> @oldinco
		or isnull(@loc,'') <> @oldloc or isnull(@matl,'') <> @oldmatl or isnull(@um,'') <> @oldum
		or @apunits <> @oldunits or @linetranstype = 'D')
		begin
			exec @rcode = bspAPLBValInv @oldinco, @oldloc, @oldmatlgroup, @oldmatl, @oldum, @oldunits,
			@oldstdum output, @oldstdunits output, @oldcostopt output, @oldfixedunitcost output,
			@oldfixedecm output, @oldburdenyn output, @oldloctaxglacct output, @oldlocmiscglacct output,
			@oldlocvarianceglacct output, @oldavgecm output, @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- ' +isnull(@errmsg,'')
				goto APLB_error
			end
		end
		
		-- validate Expense Jrnl in old GL Co#
		if @oldglco <> @apglco
		begin
			if not exists(select top 1 1 from bGLJR WITH (NOLOCK) where GLCo = @oldglco and Jrnl = @expjrnl)
			begin
				select @errortext = @errorstart + ' - Journal ' + isnull(@expjrnl, '') + 
				' is not valid in GL Co#' + isnull(convert(varchar(3),@oldglco), '')  --#23061
				goto APLB_error
			end
		end
		
		-- validate old GL Co and Expense Month
		if @oldglco <> @glco or @linetranstype = 'D'
		begin
			exec @rcode = bspHQBatchMonthVal @oldglco, @mth, 'AP', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + ' - ' + isnull(@errmsg,'')
				goto APLB_error
			end
		end
              
		-- validate old Posted GL Account
		if @oldglco <> @glco or @oldglacct <> @glacct or @linetranstype = 'D'
		begin
			select @accounttype = null
			if @oldlinetype in (1,7) or (@oldlinetype = 6 and @olditemtype = 1) select @accounttype = 'J'    -- job
			if @oldlinetype = 2 or (@oldlinetype = 6 and @olditemtype = 2) select @accounttype = 'I'          -- inventory
			if @oldlinetype = 3 or (@oldlinetype = 6 and @olditemtype = 3) select @accounttype = 'N'         -- must be null
			if @oldlinetype in (4,5) or (@oldlinetype = 6 and @olditemtype in (4,5)) select @accounttype = 'E'   -- equipment
			if @oldlinetype = 8 or (@oldlinetype = 6 and @olditemtype = 6) select @accounttype = 'S'   -- service
			
			exec @rcode = bspGLACfPostable @oldglco, @oldglacct, @accounttype, @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- GL Account:' + isnull(@oldglacct, '') + ':  ' + isnull(@errmsg,'')  --#23061
				goto APLB_error
			end
		end
		
		-- if old AP GL Co# <> 'Posted To' GL Co# get intercompany accounts
		select @oldintercoarglacct = @intercoarglacct, @oldintercoapglacct = @intercoapglacct
		if @oldglco <> @apglco and (@oldglco <> @glco or @linetranstype = 'D')
		begin
			select @oldintercoarglacct = ARGLAcct, @oldintercoapglacct = APGLAcct
			from bGLIA WITH (NOLOCK)
			where ARGLCo = @apglco and APGLCo = @oldglco
			if @@rowcount = 0
			begin
				select @errortext = @errorstart + ' - Intercompany Accounts not setup in GL. From:' +
				isnull(convert(varchar(3),@apglco), '') + ' To: ' + 
				isnull(convert(varchar(3),@oldglco), '')  --#23061
				goto APLB_error
			end
		
			-- validate intercompany GL Accounts
			exec @rcode = bspGLACfPostable @apglco, @oldintercoarglacct, 'R', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Intercompany AR Account:' + isnull(@oldintercoarglacct, '') + 
				':  ' + isnull(@errmsg,'')  --#23061
				goto APLB_error
			end
			exec @rcode = bspGLACfPostable @oldglco, @oldintercoapglacct, 'P', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Intercompany AP Account:' + isnull(@oldintercoapglacct, '') + 
				':  ' + isnull(@errmsg,'')   --#23061
				goto APLB_error
			end
		end
		
		-- validate old Pay Type and get Payables GL Account
		select @oldapglacct = @apglacct
		if @oldpaytype <> @paytype or @linetranstype = 'D'
		begin
			select @oldapglacct = GLAcct from bAPPT where APCo = @apco and PayType = @oldpaytype
			if @@rowcount = 0
			begin
				select @errortext = @errorstart + '- Invalid Pay Type:' + isnull(convert(varchar(4),@oldpaytype), '')  --#23061
				goto APLB_error
			end
			-- validate Pay Type GL Account
			exec @rcode = bspGLACfPostable @apglco, @oldapglacct, 'P', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- GL Payables Account:' + isnull(@oldapglacct, '') + 
				':  ' + isnull(@errmsg,'')  --#23061
				goto APLB_error
			end
		end
		
		-- validate old Tax Group and Tax code
		IF (@oldtaxgroup IS NOT NULL) AND (@oldtaxcode IS NOT NULL)
		BEGIN
			--use bspHQTaxRateGetAll to return old GST/PST taxrates and old gl accounts 
			EXEC @rcode = bspHQTaxRateGetAll @oldtaxgroup, @oldtaxcode, @oldinvdate, @oldvalueadd output, @oldtaxrate output,
			@oldgstrate output, @oldpstrate output,null,null, @olddbtGLAcct output,
			@olddbtRetgGLAcct output,null, null,@oldcrdRetgGSTGLAcct output,@oldcrdRetgPSTGLAcct output
			 
			-- use bspHQTaxRateGet to get old taxphase and old taxct
			EXEC @rcode = bspHQTaxRateGet @oldtaxgroup, @oldtaxcode, @oldinvdate, null, @oldtaxphase output,
			@oldtaxct output, @errmsg output
			IF @rcode <> 0
			BEGIN
				SELECT @errortext = @errorstart + ' - Tax Group: ' + isnull(convert(varchar(3),@oldtaxgroup), '') + 
				'- Tax Code: ' + isnull(@oldtaxcode, '') + ':  ' + isnull(@errmsg,'')  --#23061
				GOTO APLB_error
			END
			
			-- validate TaxType against ValueAdd - only TaxType 3 should have a Value Add tax code
			IF (@oldtaxtype <> 3 and isnull(@oldvalueadd,'N') = 'Y') or (@oldtaxtype = 3 and isnull(@oldvalueadd,'N') = 'N')
			BEGIN
				SELECT @errortext = @errorstart + ' - Tax Type: ' + isnull(convert(varchar(3),@oldtaxtype), '') + 
				' is invalid with Tax Code: ' + isnull(@oldtaxcode, '') 
				GOTO APLB_error
			END
			 
			IF @olddbtGLAcct IS NOT NULL
			BEGIN
				EXEC @rcode = bspGLACfPostable @oldglco, @olddbtGLAcct, null, @errmsg output
				IF @rcode <> 0
				BEGIN
					SELECT @errortext = @errorstart + '- Tax Code GST Expense GL Acct:' + isnull(@olddbtGLAcct, '') + 
					':  ' + isnull(@errmsg,'')  
					GOTO APLB_error
				END
				-- validate GST retainage Debit Tax GL Account
				IF @olddbtRetgGLAcct IS NOT NULL
				BEGIN
					EXEC @rcode = bspGLACfPostable @oldglco, @olddbtRetgGLAcct, null, @errmsg output
					IF @rcode <> 0
					BEGIN
						SELECT @errortext = @errorstart + '- Tax Code Retg GST Expense GL Acct:' + isnull(@olddbtRetgGLAcct, '') + 
						':  ' + isnull(@errmsg,'')  
						GOTO APLB_error
					END
				END
				
				-- validate old GST Credit Payable
				IF @oldcrdRetgGSTGLAcct IS NOT NULL
				BEGIN
					EXEC @rcode = bspGLACfPostable @oldglco, @oldcrdRetgGSTGLAcct, null, @errmsg output
					IF @rcode <> 0
					BEGIN
						SELECT @errortext = @errorstart + '- Tax Code GST Payable GL Acct:' + ISNULL(@oldcrdRetgGSTGLAcct, '') + 
						':  ' + isnull(@errmsg,'')  
						GOTO APLB_error
					END
				END
				ELSE -- IF APCO TaxBasisNetRetg flag is checked then Credit Retainage GST GL Acct cannot be null
				BEGIN
					IF @APCOTaxBasisNetRetg = 'Y' AND ISNULL(@oldretainage,0) <> 0
					BEGIN
						SELECT @errortext = @errorstart + '- when tax basis is net of retention/holdback, a Credit GL Ret/Hbk Tax Acct is required in the tax code.'   
						GOTO APLB_error
					END
				END
				
				-- validate PST Credit Payable
				IF @oldcrdRetgPSTGLAcct IS NOT NULL 
				BEGIN
					EXEC @rcode = bspGLACfPostable @oldglco, @oldcrdRetgGSTGLAcct, NULL, @errmsg output
					IF @rcode <> 0
					BEGIN
						SELECT @errortext = @errorstart + '- Tax Code PST Payable GL Acct:' + ISNULL(@oldcrdRetgGSTGLAcct, '') + 
						':  ' + isnull(@errmsg,'')  
						GOTO APLB_error
					END
				END
				ELSE -- IF APCO TaxBasisNetRetg flag is checked then Credit Retainage PST GL Acct cannot be null
				BEGIN
					IF @APCOTaxBasisNetRetg = 'Y' AND ISNULL(@oldpstrate,0) <> 0 AND ISNULL(@oldretainage,0) <> 0
					BEGIN
						SELECT @errortext = @errorstart + '- when tax basis is net of retention/holdback, a Credit GL Ret/Hbk Tax Acct is required in the tax code.'   
						GOTO APLB_error
					END
				END

			END	
			
			-- get old Tax Accrual Account
			if @oldtaxtype = 2 and @oldtaxamt <> 0
			begin
				select @oldtaxaccrualacct = GLAcct
				from bHQTX WITH (NOLOCK)
				where TaxGroup = @oldtaxgroup and TaxCode = @oldtaxcode	-- use 'posted to' Tax Group
				if @@rowcount = 0
				begin
					select @errortext = @errorstart + '- Invalid Tax Code:' + isnull(@oldtaxcode, '')  --#23061
					goto APLB_error
				end
				-- validate Use Tax Accrual GL Account
				exec @rcode = bspGLACfPostable @glco, @oldtaxaccrualacct, 'N', @errmsg output
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Use Tax Accrual Account:' + isnull(@oldtaxaccrualacct, '') +
					':  ' + isnull(@errmsg,'')	--#23061
					goto APLB_error
				end
			end
			-- Tax Phase and Cost Type
			if @oldlinetype in (1,7) or (@oldlinetype = 6 and @olditemtype = 1)  
			begin
				-- use 'posted' phase and cost type unless overridden by tax code
				if @oldtaxphase is null select @oldtaxphase = @oldphase
				if @oldtaxct is null select @oldtaxct = @oldjcctype
				select @oldtaxglacct = @oldglacct     -- default is 'posted' account
				-- Tax may be redirected to another expense account
				if @oldtaxphase <> @oldphase or @oldtaxct <> @oldjcctype
				begin
					-- get GL Account for Tax Expense
					exec @rcode = bspJCCAGlacctDflt @oldjcco, @oldjob, @oldphasegroup, @oldtaxphase, @oldtaxct, 'N',
					@oldtaxglacct output, @errmsg output
					if @rcode <> 0
					begin
						select @errortext = @errorstart + '- Tax Expense GL Acct ' + isnull(@errmsg,'')
						goto APLB_error
					end
					-- validate Tax Account
					exec @rcode = bspGLACfPostable @oldglco, @oldtaxglacct, 'J', @errmsg output
					if @rcode <> 0
					begin
						select @errortext = @errorstart + '- Tax Expense GL Acct:' + isnull(@oldtaxglacct, '') + 
						':  ' + isnull(@errmsg,'')  --#23061
						goto APLB_error
					end
				end
			end
		end  --@oldtaxcode is not null
		
		if @oldtaxcode is null 
		begin
			/* Get taxphase and taxct for committed cost.  If APTL has no taxcode but POIT or SLIT does, use PO or SL tax phase,
			ct, glacct from bspAPLBValNew - #21978, #128288 SL now has tax codes so account for redirected tax */
			if (@oldlinetype = 6 and @olditemtype = 1) or @oldlinetype = 7
			begin
				select @oldtaxphase = @taxphase
				select @oldtaxct = @taxct
				select @oldtaxglacct = @taxglacct
				-- use 'posted' phase and cost type unless overridden by tax code
				if @oldtaxphase is null select @oldtaxphase = @oldphase
				if @oldtaxct is null select @oldtaxct = @oldjcctype
				if @oldtaxglacct is null select @oldtaxglacct = @oldglacct  -- default is 'posted' account
				-- Tax may be redirected to another expense account
				if @oldtaxphase <> @oldphase or @oldtaxct <> @oldjcctype
				begin
					-- get GL Account for Tax Expense
					exec @rcode = bspJCCAGlacctDflt @oldjcco, @oldjob, @oldphasegroup, @oldtaxphase, @oldtaxct, 'N',
					@oldtaxglacct output, @errmsg output
					if @rcode <> 0
					begin
						select @errortext = @errorstart + '- Tax Expense GL Acct ' + isnull(@errmsg,'')
						goto APLB_error
					end
					-- validate Tax Account
					exec @rcode = bspGLACfPostable @oldglco, @oldtaxglacct, 'J', @errmsg output
					if @rcode <> 0
					begin
						select @errortext = @errorstart + '- Tax Expense GL Acct:' + 
						isnull(@oldtaxglacct, '') + ':  ' + isnull(@errmsg,'')  --#23061
						goto APLB_error
					end
				end	
			end
		end
  
		-- validate Retainage info 
		if @oldretainage <> 0 and (@retainage = 0 or @linetranstype = 'D')
		begin
			exec @rcode = bspHQHoldCodeVal @retholdcode, @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + 'Retainage Hold Code : ' + isnull(@errmsg,'')
				goto APLB_error
			end
		end
		
		--validate Old PayCategory
		if @oldpaycategory is not null
		BEGIN
			-- Old Retainage Payable Type
			select @oldretpaytype=RetPayType, @olddiscoffglacct=DiscOffGLAcct from bAPPC with (nolock)
			where APCo=@apco and PayCategory=@oldpaycategory
			if @@rowcount=0
			begin
				select @errortext = @errorstart + ' Invalid Old Pay Category!'
				goto APLB_error
			end
			-- Old Retainage Payable GL Account
			if @oldretainage <> 0 
			begin
				exec @rcode=bspAPPayTypeValForPayCategory @apco, @oldpaycategory, @oldretpaytype, @oldretglacct output, @errmsg output
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Retainage Pay Type:' + 
					isnull(convert(varchar(3), @retpaytype), '') + ':  ' + isnull(@errmsg,'') 
					goto APLB_error
				end
				exec @rcode = bspGLACfPostable @apglco, @oldretglacct, 'P', @errmsg output 
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Retainage Payable GL Account:' + isnull(@oldretglacct, '') + 
					':  ' + isnull(@errmsg,'')  
					goto APLB_error
				end
			end
		END
		else
		begin
			-- Retainage Payable GL Account
			select @oldretpaytype=@APretpaytype, @olddiscoffglacct=@APdiscoffglacct
			if @oldretainage <> 0 
			begin
				exec @rcode=bspAPPayTypeVal @apco, @oldretpaytype, @oldretglacct output, @errmsg output
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Retainage Pay Type:' + 
					isnull(convert(varchar(3), @oldretpaytype), '') + ':  ' + isnull(@errmsg,'')  --#23061
					goto APLB_error
				end
				exec @rcode = bspGLACfPostable @apglco, @oldretglacct, 'P', @errmsg output
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Retainage Payable GL Account:' + isnull(@oldretglacct, '') + 
					':  ' + isnull(@errmsg,'')  --#23061
					goto APLB_error
				end
			end
		end
  
		-- validate Old Discount Offered GL Account
		if (@olddiscount <> 0 and @netamtopt = 'Y') and (@discount = 0 or @linetranstype = 'D')
		begin
			exec @rcode = bspGLACfPostable @apglco, @olddiscoffglacct, 'N', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Discount offered GLAcct:' + 
				isnull(@discoffglacct, '') + ':  ' + isnull(@errmsg,'')  
				goto APLB_error
			end
		end
	end	-- common validation for Change and Delete entries
  
	-- validate that if there is a discount that a discount date has been entered #10146 kb
	if @discount <> 0 and exists(select 1 from bAPHB WITH (NOLOCK) where Co = @apco and Mth = @mth
	and BatchId = @batchid and BatchSeq = @batchseq and DiscDate is null)
	begin
		select @errortext = @errorstart + '- Discount date is required if discounts are used.'
		goto APLB_error
	end
	
	
  
update_audit:	-- add JC, EM, IN, and GL distributions
	select @change = 'N'    -- flag indicating that changes have been made
	if @linetranstype = 'C' and (@vendor <> @oldvendor or isnull(@apref,'') <> isnull(@oldapref,'')
		or isnull(@transdesc,'') <> isnull(@oldtransdesc,'') or @invdate <> @oldinvdate
		or isnull(@po,'') <> isnull(@oldpo,'') or isnull(@poitem,0) <> isnull(@oldpoitem,0) OR ISNULL(@POItemLine,0) <> ISNULL(@OldPOItemLine,0)
		or isnull(@sl,'') <> isnull(@oldsl,'') or isnull(@slitem,0) <> isnull(@oldslitem,0)
		or isnull(@jcco,0) <> isnull(@oldjcco,0) or isnull(@job,'') <> isnull(@oldjob,'')
		or isnull(@phase,'') <> isnull(@oldphase,'') or isnull(@jcctype,0) <> isnull(@oldjcctype,0)
		or isnull(@emco,0) <> isnull(@oldemco,0) or isnull(@wo,'') <> isnull(@oldwo,'')
		or isnull(@woitem,0) <> isnull(@oldwoitem,0) or isnull(@equip,'') <> isnull(@oldequip,'')
		or isnull(@costcode,'') <> isnull(@oldcostcode,'') or isnull(@emctype,0) <> isnull(@oldemctype,0)
		or isnull(@comptype,'') <> isnull(@oldcomptype,'') or isnull(@component,'') <> isnull(@oldcomponent,'')
		or isnull(@inco,0) <> isnull(@oldinco,0) or isnull(@loc,'') <> isnull(@oldloc,'')
		or isnull(@matl,'') <> isnull(@oldmatl,'') or @glco <> @oldglco or @glacct <> @oldglacct
		or isnull(@linedesc,'') <> isnull(@oldlinedesc,'') or isnull(@um,'') <> isnull(@oldum,'')
		or @apunits <> @oldunits or @paytype <> @oldpaytype or @grossamt <> @oldgrossamt
		or @miscamt <> @oldmiscamt or @oldmiscyn <> @miscyn or isnull(@taxcode,'') <> isnull(@oldtaxcode,'')
		or isnull(@taxtype,99) <> isnull(@oldtaxtype,99) or @taxamt <> @oldtaxamt 
		or @retainage <> @oldretainage or @discount <> @olddiscount
		or isnull(@paycategory,0) <> isnull(@oldpaycategory,0))
		or isnull(@smco, 0) <> isnull(@oldsmco, 0) or isnull(@smworkorder,-1) <> isnull(@oldsmworkorder,-1)
   	    or isnull(@scope,-1) <> isnull(@oldscope,-1) or isnull(@oldsmcosttype,'') <> isnull(@oldsmcosttype,'')
   	    OR ISNULL(@smjccosttype,'') <> ISNULL(@oldsmjccosttype,'') OR ISNULL(@smphasegroup,'') <> ISNULL(@oldsmphasegroup,'') OR ISNULL(@smphase,'') <> ISNULL(@oldsmphase,'')
   	    OR ISNULL(@OldSubjToOnCostYN,'') <> ISNULL(@SubjToOnCostYN,'')

   	    BEGIN
			select @change = 'Y'   -- something changed
		END
  
  	-- 'Old' JC distributions
    if (@oldlinetype in (1,7) or (@oldlinetype = 6 and @olditemtype = 1)) and (@linetranstype = 'D' or @change = 'Y')
    begin
		-- If job closed get closed job gl account - #134876 
		select @status=JobStatus,@contract=Contract from bJCJM where JCCo=@oldjcco and Job=@oldjob
		if @status = 3 -- Old Job is hard closed
		begin
			-- get the department
			select @dept = Department from bJCCM where JCCo=@oldjcco and Contract=@contract
			-- get closed GLAcct from phase in Dept override 
			select @closedGLAcct = null
			select @closedGLAcct=ClosedExpAcct from bJCDO where JCCo=@oldjcco and Department=@dept 
			and PhaseGroup=@oldphasegroup and Phase=@oldphase
			if @closedGLAcct is not null
			begin
				exec @rcode = bspGLACfPostable @oldglco, @closedGLAcct, 'J', @errmsg output
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Closed GL Account:' + isnull(@closedGLAcct, '') + ':  ' + isnull(@errmsg,'')  
					goto APLB_error
				end
				else
				begin
					select @oldglacct = @closedGLAcct
					select @oldtaxglacct = NULL
				end
			end
			else -- get closed GLAcct from Costtype  
			begin
				select @closedGLAcct=ClosedExpAcct from bJCDC where JCCo=@oldjcco and Department=@dept
				and PhaseGroup=@oldphasegroup and CostType=@oldjcctype
				if @closedGLAcct is not null 
				begin
					exec @rcode = bspGLACfPostable @oldglco, @closedGLAcct, 'J', @errmsg output
					if @rcode <> 0
					begin
						select @errortext = @errorstart + '- Closed GL Account:' + isnull(@closedGLAcct, '') + ':  ' + isnull(@errmsg,'')  
						goto APLB_error
					end
					else
					begin
						select @oldglacct = @closedGLAcct
						select @oldtaxglacct = NULL
					end
				end
				else
				begin
					-- no Gl Acct set up for closed job
					select @errortext = @errorstart + ' Missing closed GL Acct for Job: ' + isnull(@oldjob,'') + ' Phase: ' 
					+ isnull(@oldphase,'') + ' CT: ' + isnull(convert(varchar(5),@oldjcctype),'')
					goto APLB_error
				end
			end 
		end -- end @status = 3
		
		IF ISNULL(@oldvalueadd,'N') = 'N'
		BEGIN
			SELECT @oldpayTaxAmt = @oldtaxamt
		END
		
		/* Breakout and establish all VAT related tax amounts. */
		IF ISNULL(@oldvalueadd,'N') = 'Y'
		BEGIN
			IF @oldpstrate = 0
			BEGIN
				/* When @oldpstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				IF  isnull(@APCOTaxBasisNetRetg, 'N') = 'N' or @APHBCheckRevYN = 'Y' --#136500/#133107 Check Reversal
				BEGIN
						-- GST tax basis is not net of retainage - calculate on full gross
					SELECT @oldretgTaxAmt = @oldretainage * @oldtaxrate --TK-17202 case @oldgrossamt when 0 then 0 else (@oldretainage/@oldgrossamt) * @oldtaxamt end
					SELECT @oldpayTaxAmt = @oldtaxamt - @oldretgTaxAmt
					SELECT @oldgstTaxAmt = @oldpayTaxAmt
					SELECT @oldretgGstTaxAmt = @oldretgTaxAmt
					SELECT @oldVATgstTaxAmt = @oldgstTaxAmt + @oldretgGstTaxAmt
					SELECT @oldVATpstTaxAmt = 0
				END
				ELSE  -- GST tax basis is net of retainage 
				BEGIN
					SELECT @oldretgGstTaxAmt = @oldretainage * @oldtaxrate --TK-17202 case @oldgrossamt when 0 then 0 else (@oldgrossamt * @oldtaxrate) * (@oldretainage/@oldgrossamt) end 
					SELECT @oldgstTaxAmt = @oldtaxamt -- GST was calculated on taxbasis net retainage in the form
					SELECT @oldVATgstTaxAmt = @oldgstTaxAmt 
					SELECT @oldVATpstTaxAmt = 0
					SELECT @oldpayTaxAmt = 0
				END
			END
			ELSE
			BEGIN
			-- PST/GST tax basis is not net of retainage - calculate on full gross
				IF  isnull(@APCOTaxBasisNetRetg, 'N') = 'N' or @APHBCheckRevYN = 'Y' --#136500/#133107 Check Reversal
				BEGIN
					SELECT @oldretgTaxAmt = @oldretainage * @oldtaxrate --TK-17202 case @oldgrossamt when 0 then 0 else (@oldretainage/@oldgrossamt) * @oldtaxamt end
					SELECT @oldpayTaxAmt = @oldtaxamt - @oldretgTaxAmt
					SELECT @oldgstTaxAmt = case @oldtaxrate when 0 then 0 else (@oldpayTaxAmt * @oldgstrate) / @oldtaxrate end	
					SELECT @oldpstTaxAmt = @oldpayTaxAmt - @oldgstTaxAmt	
					SELECT @oldretgGstTaxAmt = case @oldtaxrate when 0 then 0 else (@oldretgTaxAmt * @oldgstrate) / @oldtaxrate end
					SELECT @oldretgPstTaxAmt = @oldretgTaxAmt - @oldretgGstTaxAmt
					SELECT @oldVATgstTaxAmt = @oldgstTaxAmt + @oldretgGstTaxAmt
					SELECT @oldVATpstTaxAmt = @oldpstTaxAmt + @oldretgPstTaxAmt
				END
				ELSE
				BEGIN
					-- PST and GST tax basis is net of retainage
					SELECT @oldretgGstTaxAmt = (@oldretainage * @oldgstrate)		-- retainage GST tax 
					SELECT @oldretgPstTaxAmt = (@oldretainage * @oldpstrate)		-- retainage PST tax 
					SELECT @oldretgTaxAmt = (@oldretainage * @oldtaxrate)			-- total retainage tax 
					SELECT @oldgstTaxAmt = @oldtaxbasis * @oldgstrate				-- open GST tax
					SELECT @oldpstTaxAmt = @oldtaxamt - @oldgstTaxAmt 				-- open PST tax 
					SELECT @oldVATgstTaxAmt = @oldgstTaxAmt + @oldretgGstTaxAmt		-- total of open + retainage GST tax
					SELECT @oldVATpstTaxAmt = @oldpstTaxAmt + @oldretgPstTaxAmt		-- total of open + retainage PST tax
				END
			END
			/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC Expense GL Acct
			then include the GST portion of tax in the Job Expense acct */
			IF @olddbtGLAcct IS NULL
			BEGIN
				SELECT @oldpayTaxAmt= @oldVATpstTaxAmt + @oldVATgstTaxAmt
				SELECT @oldVATgstTaxAmt = 0
			END  
			ELSE
			BEGIN
				SELECT @oldpayTaxAmt = @oldVATpstTaxAmt
			END
		END

		SELECT @i = 0
OldJC_loop:

		select @remcmtdcost = 0, @jcunitcost = 0, @rniunits = 0, @rnicost = 0, @remcmtdunits = 0,
		@totalcmtdunits = 0, @totalcmtdcost = 0,
		@totalcmtdtax = 0, @remcmtdtax = 0  --DC #122288
		if @i = 0  -- Old Posted Amount (tax may be redirected so exclude it on this pass)
		begin
			if @oldlinetype = 7 select @oldcurecm = 'E'
			select @factor = case @oldcurecm when 'C' then 100 when 'M' then 1000 else 1 end
			-- old total cost may include misc amt if paid to vendor, less discount if net option is used
			select @totalcost = @oldgrossamt + (case @oldmiscyn when'Y' then @oldmiscamt else 0 end) - (case @netamtopt when 'Y' then @olddiscount else 0 end)
			-- POs will update Remaining Committed Cost, Units
			
			if @oldlinetype = 6 
			begin
				SELECT @origunits=OrigUnits, @origcost=OrigCost, @curunits = CurUnits, @curcost = CurCost
				--select @origunits=OrigUnits, @origcost=OrigCost, @curunits = CurUnits, @curcost = CurCost from bPOIT
				--select @curunits = CurUnits, @curcost = CurCost from bPOIT
				FROM vPOItemLine
				WHERE POCo = @apco AND PO = @oldpo AND POItem = @oldpoitem AND POItemLine = @OldPOItemLine
				if (@origunits = 0 and @curunits = 0) and (@origcost = 0 and @curcost=0) and @oldrecyn = 'N' -- standing PO w/o receiving
				--if @curunits = 0 and @curcost=0 and @oldrecyn = 'N' -- 19926 standing PO not flagged for rcvng
				begin
					select @remcmtdcost = 0 --Total cost - invoiced cost = remaining cmtd cost
					select @remcmtdunits = 0 --total units - invoiced units = remaining cmtd units
					select @totalcmtdunits = @oldjcunits -- Received units + BO units = total cmtd units
					select @totalcmtdcost = @oldgrossamt	-- Received cost + BO cost = total cmtd cost
				end
				else	-- Regular PO or standing PO flagged for receiving
				begin
					select @remcmtdcost = case when @oldum = 'LS' then @oldgrossamt	else (@oldunits * @oldcurunitcost) / @factor end
					select @remcmtdunits = @oldjcunits    -- will be 0.00 if 'LS'
					select @totalcmtdunits = 0
					select @totalcmtdcost = 0
				end
			end
			
			if @oldlinetype = 7 and @oldslitemtype <> 3
			-- SLs (except Backcharge Item) will update Remaining Committed Cost
			begin
				select @remcmtdcost = case when @oldum = 'LS' then @oldgrossamt	else (@oldunits * @oldcurunitcost) / @factor end
				select @remcmtdunits = @oldjcunits   -- #19926 - will be 0.00 if 'LS'
			end
			-- RNI only applies to PO Items flagged for receiving
			if @oldlinetype = 6 and @oldrecyn = 'Y'
			begin
				select @rniunits = @oldjcunits   -- will be 0.00 if 'LS'
				select @rnicost = @remcmtdcost -- change to RNI Cost will equal change to Rem Cmtd Cost
			end
			
			-- JC Unit Cost only calculated on this pass so include tax unless tax is being redirected --30264
			if @oldjcunits <> 0 
			begin
				if isnull(@oldtaxphase, @oldphase) <> @oldphase or isnull(@oldtaxct,@oldjcctype) <> @oldjcctype
				begin
					select @jcunitcost = (@totalcost / @oldjcunits)
				end
				else
				begin
					select @jcunitcost = (@totalcost + @oldpayTaxAmt) / @oldjcunits
				end
			end

			-- reverse sign on totalcost and jc units, use old posted phase, cost type, etc.
			select @totalcost = (-1 * @totalcost), @upphase = @oldphase, @upjcctype = @oldjcctype,
			@upglacct = @oldglacct, @upum = @oldum, @upunits = (-1 * @oldunits), @upjcum = @oldjcum,
			@upjcunits = (-1 * @oldjcunits), @upjcecm = 'E', @uptaxbasis = 0, @uptaxamt = 0,
			@usetaxamt = 0, @totalcmtdunits = (-1 * @totalcmtdunits), @totalcmtdcost=(-1 * @totalcmtdcost)
		end
		
		if @i = 1  -- Tax amount (included as part of total cost)
		begin
			select @totalcost = (-1 * @oldpayTaxAmt), @uptaxbasis = (-1 * @oldtaxbasis), @uptaxamt = (-1 * @oldpayTaxAmt)
			
			-- update Remaining Committed Cost with tax for PO
			if @oldlinetype = 6
			begin
				if @curunits = 0 and @curcost=0 and @oldrecyn = 'N' -- 19926 standing PO not flagged for recvng
				begin
					select @remcmtdcost = 0
					select @totalcmtdcost = @totalcost 
				end
				else
				begin
					select @posltaxbasis = (@oldunits * @oldcurunitcost)/@factor -- 28714	
					select @oldposlTaxAmt= case when @um = 'LS' then (@oldgrossamt * isnull(@oldpotaxrate,0)) else (@posltaxbasis * @oldpotaxrate) end
					--calculate remaining commited cost for tax
					if @olddbtGLAcct is null
					begin
						select @remcmtdcost = (@oldposlTaxAmt)
						select @remcmtdtax = (@oldposlTaxAmt) --DC #122288
					end
					else
					begin
						if @oldpoGSTrate = 0 select @oldpoGSTrate=@oldpotaxrate
						--calculate GST portion of po tax to back out of remaining commited tax cost
						select @oldposlGSTtaxAmt = case @oldpotaxrate when 0 then 0 else (@oldposlTaxAmt * @oldpoGSTrate) / @oldpotaxrate end
						select @remcmtdcost = (@oldposlTaxAmt - @oldposlGSTtaxAmt)
						select @remcmtdtax = (@oldposlTaxAmt - @oldposlGSTtaxAmt)  --DC #122288
					end
				end
			end
			
			if @oldlinetype = 7 and @oldslitemtype <> 3
			begin
				select @posltaxbasis = (@oldunits * @oldcurunitcost)/@factor -- 28714
				select @oldposlTaxAmt= case when @um = 'LS' then (@oldgrossamt * isnull(@oldsltaxrate,0)) else (@posltaxbasis * @oldsltaxrate) end

				--calculate remaining commited cost for tax
				if @olddbtGLAcct is null
				begin
					select @remcmtdcost = (@oldposlTaxAmt)
					select @remcmtdtax = (@oldposlTaxAmt)  --DC #122288
				end
				else
				begin
					-- if GSTrate is 0 then taxcode is GST only, set GSTrate to sltaxrate
					if @oldslGSTrate = 0 select @oldslGSTrate = @oldsltaxrate
					--calculate GST portion of po tax to back out of remaining commited tax cost
					select @oldposlGSTtaxAmt = case @oldsltaxrate when 0 then 0 else (@oldposlTaxAmt * @oldslGSTrate) / @oldsltaxrate end
					select @remcmtdcost = (@oldposlTaxAmt - @oldposlGSTtaxAmt)
					select @remcmtdtax = (@oldposlTaxAmt - @oldposlGSTtaxAmt)  --DC #122288
				end
			end

			-- RNI only applies to PO Items flagged for receiving
			if @oldlinetype = 6 and @oldrecyn = 'Y' select @rnicost = isnull(@remcmtdcost,0)
			-- Old tax phase and cost type	- #19063
			select @upphase = case when @oldtaxphase is not null then @oldtaxphase else @upphase end,
			@upjcctype = case when @oldtaxct is not null then @oldtaxct else @upjcctype end,
			@upglacct = case when @oldtaxglacct is not null then @oldtaxglacct else @upglacct end,
			/*select @upphase = @oldtaxphase, @upjcctype = @oldtaxct, @upglacct = @oldtaxglacct,*/
			@upum = null,@upunits = 0, @upjcum = null, @upjcunits = 0, @upjcecm = null
			-- include Use Tax on this pass to add GL Accrual distribution
			select @usetaxamt = case @oldtaxtype when 2 then (-1 * @oldtaxamt) else 0 end
		end
		
		-- add old APJC entry
		if ((@totalcost <> 0) or (@i = 1 and @uptaxbasis <> 0 and @oldtaxcode is not null)) 
		or @upunits <> 0 or @rniunits <> 0 or isnull(@rnicost,0) <> 0
		or isnull(@remcmtdcost,0) <> 0 or isnull(@totalcmtdcost,0) <> 0
		exec @rcode = bspAPLBValJCInsert @apco, @mth, @batchid, @oldjcco, @oldjob, @oldphasegroup,
		@upphase, @upjcctype, @batchseq, @apline, 0, @aptrans, @oldvendorgroup, @oldvendor,
		@oldapref, @oldtransdesc, @oldinvdate, @oldsl, @oldslitem, @oldpo, @oldpoitem, @OldPOItemLine, @oldmatlgroup,
		@oldmatl, @oldlinedesc, @oldglco, @upglacct, @upum, @upunits, @upjcum, @upjcunits,
		@jcunitcost, @upjcecm, @totalcost, @rniunits, @rnicost, @remcmtdcost, @oldtaxgroup,
		@oldtaxcode, @oldtaxtype, @uptaxbasis, @uptaxamt, @remcmtdunits, @totalcmtdunits, @totalcmtdcost,
		@totalcmtdtax, @remcmtdtax  --DC #122288
		 --add old APGL entry - will make intercompany entries if needed

		if @totalcost <> 0 or @usetaxamt <> 0 or @oldVATgstTaxAmt <> 0 OR @oldretgGstTaxAmt <> 0 --TK-08150
		begin
			if @i = 0 -- APGL for Job Expense - Gross Amt 
			begin
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @upglacct, @batchseq, @apline,
				0, @aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
				@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @totalcost, @apglco, @oldintercoarglacct, @oldintercoapglacct,
				@usetaxamt, @oldtaxaccrualacct
			end
			
			if @i = 1 
			begin
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @upglacct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
				@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @totalcost, @apglco, @oldintercoarglacct, @oldintercoapglacct,
				@usetaxamt, @oldtaxaccrualacct	
				-- retainage GST is broken out 
				if @olddbtRetgGLAcct is not null and @oldretainage <> 0		
				begin
					IF @oldgstTaxAmt <> 0 --133107
					BEGIN
						select @oldgstTaxAmt = (-1 * @oldgstTaxAmt)
						--APGL for GST Tax
						exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtGLAcct, @batchseq, @apline, 0,
						@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
						@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
						@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
						@oldmatlgroup, @oldmatl, @oldgstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
						0, @oldtaxaccrualacct
					END 
					IF @oldretgGstTaxAmt <> 0 --133107
					BEGIN
						SELECT @oldretgGstTaxAmt = (-1 * @oldretgGstTaxAmt)
						--APGL for retgGST Tax
						exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtRetgGLAcct, @batchseq, @apline, 0,
						@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
						@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
						@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
						@oldmatlgroup, @oldmatl, @oldretgGstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
						0, @oldtaxaccrualacct
					END
				end
				
				-- retainage GST is not broken out but GST is or retg GST is broken out but there is no retainage #131275
				if (@olddbtRetgGLAcct is null and @olddbtGLAcct is not null ) or (@olddbtRetgGLAcct is not null and @oldretainage = 0) 
				begin
					--APGL for GST Tax
					select @oldVATgstTaxAmt = (-1 * @oldVATgstTaxAmt)
					select @olddbtGLAcct = isnull(@olddbtGLAcct,@upglacct) 
					exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtGLAcct, @batchseq, @apline, 0,
					@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
					@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
					@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
					@oldmatlgroup, @oldmatl, @oldVATgstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
					0, @oldtaxaccrualacct
				end
			end
		end
		
		select @i = @i + 1
        if @i < 2 goto OldJC_loop
  	end
  	
 	-- 'New' JC distributions
	if (@LineType in (1,7) or (@LineType = 6 and @itemtype = 1)) and (@linetranstype = 'A' or @change = 'Y')
	begin
		-- If job is closed get closed job gl account - #134876
		select @status=JobStatus,@contract=Contract from bJCJM where JCCo=@jcco and Job=@job
		if @status = 3 -- Job is hard closed
		begin
			-- get the department
			select @dept = Department from bJCCM where JCCo=@jcco and Contract=@contract
			-- get closed GLAcct from phase in Dept override 
			select @closedGLAcct = null
			select @closedGLAcct=ClosedExpAcct from bJCDO where JCCo=@jcco and Department=@dept 
			and PhaseGroup=@phasegroup and Phase=@phase
			if @closedGLAcct is not null
			begin
				exec @rcode = bspGLACfPostable @glco, @closedGLAcct, 'J', @errmsg output
				if @rcode <> 0
				begin
					select @errortext = @errorstart + '- Closed GL Account:' + isnull(@closedGLAcct, '') + ':  ' + isnull(@errmsg,'')  
					goto APLB_error
				end
				else
				begin
					select @glacct = @closedGLAcct
					select @taxglacct = @closedGLAcct
				end
			end
			else -- get closed GLAcct from Costtype  
			begin
				select @closedGLAcct=ClosedExpAcct from bJCDC where JCCo=@jcco and Department=@dept
				and PhaseGroup=@phasegroup and CostType=@jcctype
				if @closedGLAcct is not null 
				begin
					exec @rcode = bspGLACfPostable @glco, @closedGLAcct, 'J', @errmsg output
					if @rcode <> 0
					begin
						select @errortext = @errorstart + '- Closed GL Account:' + isnull(@closedGLAcct, '') + ':  ' + isnull(@errmsg,'')  
						goto APLB_error
					end
					else
					begin
						select @glacct = @closedGLAcct
						select @taxglacct = @closedGLAcct
					end
				end
				else
				begin
					-- no Gl Acct set up for closed job
					select @errortext = @errorstart + ' Missing closed GL Acct for Job: ' + isnull(@job,'') + ' Phase: ' 
					+ isnull(@phase,'') + ' CT: ' + isnull(convert(varchar(5),@jcctype),'')
					goto APLB_error
				end
			end 
		end -- end @status = 3

		/*Break out PST/GST tax amount before doing distributions. */
		if isnull(@valueadd,'N') = 'N'
		begin
			select @payTaxAmt = @taxamt
		end
		/* Breakout and establish all VAT related tax amounts. */
		if isnull(@valueadd,'N') = 'Y'
		begin
			if @pstrate = 0
			begin
				/* When @pstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				if  isnull(@APCOTaxBasisNetRetg, 'N') = 'N' or @APHBCheckRevYN = 'Y' --#136500/#133107 Check Reversal
				begin
					-- GST tax basis is not net of retainage - calculate on full gross
					select @retgTaxAmt = @retainage * @taxrate --TK-17202 case @grossamt when 0 then 0 else (@retainage/@grossamt) * @taxamt end
					select @payTaxAmt = @taxamt - @retgTaxAmt
					select @gstTaxAmt = @payTaxAmt
					select @retgGstTaxAmt = @retgTaxAmt
					select @VATgstTaxAmt = @gstTaxAmt + @retgGstTaxAmt
					select @VATpstTaxAmt = 0
				end
				else  -- GST tax basis is net of retainage 
				begin
					select @retgGstTaxAmt = @retainage * @taxrate --TK-17202 case @grossamt when 0 then 0 else (@grossamt * @taxrate) * (@retainage/@grossamt) end
					select @gstTaxAmt =  @taxamt  
					select @VATgstTaxAmt = @gstTaxAmt 
					select @VATpstTaxAmt = 0
					select @payTaxAmt = 0
				end
			end
			else
			begin
			-- PST/GST tax basis is not net of retainage - calculate on full gross
				IF  isnull(@APCOTaxBasisNetRetg, 'N') = 'N' or @APHBCheckRevYN = 'Y' --#136500/#133107 Check Reversal
				BEGIN
					select @retgTaxAmt = @retainage * @taxrate --TK-17202 case @grossamt when 0 then 0 else (@retainage/@grossamt) * @taxamt end
					select @payTaxAmt = @taxamt - @retgTaxAmt
					select @gstTaxAmt = case @taxrate when 0 then 0 else (@payTaxAmt * @gstrate) / @taxrate end	
					select @pstTaxAmt = @payTaxAmt - @gstTaxAmt	
					select @retgGstTaxAmt = case @taxrate when 0 then 0 else (@retgTaxAmt * @gstrate) / @taxrate end
					select @retgPstTaxAmt = @retgTaxAmt - @retgGstTaxAmt
					select @VATgstTaxAmt = @gstTaxAmt + @retgGstTaxAmt
					select @VATpstTaxAmt = @pstTaxAmt + @retgPstTaxAmt
				END
				ELSE
				BEGIN
					-- PST and GST tax basis is net of retainage
					SELECT @retgGstTaxAmt = (@retainage * @gstrate)		-- retainage GST tax 
					SELECT @retgPstTaxAmt = (@retainage * @pstrate)		-- retainage PST tax 
					SELECT @retgTaxAmt = (@retainage * @taxrate)		-- total retainage tax
					SELECT @gstTaxAmt = case @taxrate when 0 then 0 else (@taxamt * @gstrate) / @taxrate end --@taxbasis * @gstrate			-- open GST tax
					SELECT @pstTaxAmt = @taxamt - @gstTaxAmt --TK-17202 @taxbasis * @pstrate			-- open PST tax 
					SELECT @VATgstTaxAmt = @gstTaxAmt + @retgGstTaxAmt	-- total of open + retainage GST tax
					SELECT @VATpstTaxAmt = @pstTaxAmt + @retgPstTaxAmt	-- total of open + retainage PST tax
				END
			end

			
			/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC account
			for credit then include the GST portion of tax with the PST portion (same as Sales tax) */
			if @dbtGLAcct is null
			begin
				select @payTaxAmt= @VATpstTaxAmt + @VATgstTaxAmt
				select @VATgstTaxAmt = 0
			end  
			else
			begin
				select @payTaxAmt = @VATpstTaxAmt
			end
		end
		
        select @i = 0	-- make two passes, 1 for the gross amount and 1 for tax
NewJC_loop:
		select @remcmtdcost = 0, @jcunitcost = 0, @rniunits = 0, @rnicost = 0, @remcmtdunits = 0,
		@totalcmtdunits = 0, @totalcmtdcost = 0,
		@totalcmtdtax = 0, @remcmtdtax = 0  --DC #122288
		if @i = 0 -- Posted Amount (tax may be redirected so exclude it on this pass)
		begin
			if @LineType = 7 select @curecm = 'E'
			select @factor = case @curecm when 'C' then 100 when 'M' then 1000 else 1 end
			-- total cost may include misc amt if paid to vendor, less discount if net option is used
			select @totalcost = @grossamt + (case @miscyn when'Y' then @miscamt else 0 end)	- (case @netamtopt when 'Y' then @discount else 0 end)
			-- POs will update Remaining Committed Cost, Units
			if @LineType = 6 
			begin
				SELECT @origunits=OrigUnits, @origcost=OrigCost, @curunits = CurUnits, @curcost = CurCost
				FROM vPOItemLine
				--select @origunits=OrigUnits, @origcost=OrigCost, @curunits = CurUnits, @curcost = CurCost from bPOIT
				--select @curunits = CurUnits, @curcost = CurCost from bPOIT
				WHERE POCo = @apco AND PO = @po AND POItem = @poitem AND POItemLine = @POItemLine
				if (@origunits = 0 and @curunits = 0) and (@origcost = 0 and @curcost=0) and @recyn = 'N' -- standing PO w/o receiving
				--if @curunits = 0 and @curcost=0 and @recyn = 'N' 
				begin
					select @remcmtdcost = 0 --Total cost - invoiced cost = remaining cmtd cost
					select @remcmtdunits = 0 --total units - invoiced units = remaining cmtd units
					select @totalcmtdunits = @jcunits -- Received units + BO units = total cmtd units
					select @totalcmtdcost = @grossamt	-- Received cost + BO cost = total cmtd cost
				end
				else	-- regular PO or standing PO flagged for receiving
				begin
					select @remcmtdcost = case when @um = 'LS' then -@grossamt else -(@apunits * @curunitcost) / @factor end
					select @remcmtdunits = -@jcunits    -- will be 0.00 if 'LS'
					select @totalcmtdunits = 0
					select @totalcmtdcost = 0
				end
			end
			
			if @LineType = 7 and @slitemtype <> 3
			-- SLs (except Backcharge Item) will update Remaining Committed Cost
			begin
				select @remcmtdcost = case when @um = 'LS' then -@grossamt else -(@apunits * @curunitcost) / @factor end
				select @remcmtdunits = -@jcunits   -- #19926 - will be 0.00 if 'LS'
			end
			
			-- RNI only applies to PO Items flagged for receiving
			if @LineType = 6 and @recyn = 'Y'
			begin
				select @rniunits = -@jcunits    -- will be 0.00 if 'LS'
				select @rnicost = @remcmtdcost	-- change to RNI Cost will equal change to Rem Cmtd Cost
			end
			
			-- JC Unit Cost only calculated on this pass so include tax unless tax is being redirected --30264
			if @jcunits <> 0 
			begin
				if isnull(@taxphase, @phase) <> @phase or isnull(@taxct,@jcctype) <> @jcctype
				begin
					select @jcunitcost = (@totalcost / @jcunits)
				end
				else
				begin
					select @jcunitcost = (@totalcost + @payTaxAmt) / @jcunits
				end
			end
			
			-- use posted phase, cost type, etc.
			select @upphase = @phase, @upjcctype = @jcctype, @upglacct = @glacct, @upum = @um,
			@upunits = @apunits, @upjcum = @jcum, @upjcunits = @jcunits, @upjcecm = 'E',
			@uptaxbasis = 0, @uptaxamt = 0, @usetaxamt = 0
		end
		
		if @i = 1 -- Tax amount
		begin
			select @totalcost = @payTaxAmt, @uptaxbasis = @taxbasis, @uptaxamt = @payTaxAmt,@remcmtdunits = 0 
			select @factor = case @curecm when 'C' then 100 when 'M' then 1000 else 1 end
			-- update Remaining Commited Cost with tax for POs 
			if @LineType = 6
			begin
				if @curunits = 0 and @curcost=0 and @recyn = 'N' -- blanket PO not flagged for recvng
				begin
					select @remcmtdcost = 0
					select @totalcmtdcost = @totalcost 
				end
				else	-- reg PO or standing PO flagged for receiving
				begin
					select @posltaxbasis = (@apunits * @curunitcost)/@factor -- 28714
					select @poslTaxAmt= case when @um = 'LS' then (@grossamt * isnull(@potaxrate,0)) else (@posltaxbasis * @potaxrate) end
					--calculate remaining commited cost for tax
					if @dbtGLAcct is not null
					begin
						-- if this is a GST only taxcode @polGSTrate will be 0, set it to @potaxrate
						if @poGSTrate = 0 select @poGSTrate = @potaxrate
						--calculate GST portion of po tax to back out of remaining commited cost
						select @poslGSTtaxAmt = case @potaxrate when 0 then 0 else (@poslTaxAmt * @poGSTrate) / @potaxrate end
						select @remcmtdcost = -(@poslTaxAmt - @poslGSTtaxAmt)
						select @remcmtdtax = -(@poslTaxAmt - @poslGSTtaxAmt) --DC #122288
					end
					else
					begin
						select @remcmtdcost = -(@poslTaxAmt)
						select @remcmtdtax = -(@poslTaxAmt) --DC #122288
					end
				end
			end
			
			-- update Remaining Committed Cost with tax for SL
			if @LineType = 7 and @slitemtype <> 3
			begin
				select @posltaxbasis = (@apunits * @curunitcost)/@factor -- 28714
				select @poslTaxAmt= case when @um = 'LS' then (@grossamt * isnull(@sltaxrate,0)) else (@posltaxbasis * @sltaxrate) end
				--calculate remaining commited cost for tax
			
				if @dbtGLAcct is not null
				begin
					-- if this is a GST only taxcode @slGSTrate will be 0, set it to @sltaxrate
					if @slGSTrate = 0 select @slGSTrate = @sltaxrate
					--calculate GST portion of sl tax to back out of remaining commited cost
					select @poslGSTtaxAmt = case @sltaxrate when 0 then 0 else (@poslTaxAmt * @slGSTrate) / @sltaxrate end
					select @remcmtdcost = -(@poslTaxAmt - @poslGSTtaxAmt)
					select @remcmtdtax = -(@poslTaxAmt - @poslGSTtaxAmt) --DC #122288
				end
				else
				begin
					select @remcmtdcost = -(@poslTaxAmt)
					select @remcmtdtax = -(@poslTaxAmt)  --DC #122288
				end
			end
			
			-- RNI only applies to PO Items flagged for receiving
			if @LineType = 6 and @recyn = 'Y'
			begin
				select @rnicost = isnull(@remcmtdcost,0)
			end
			
			-- Tax phase and cost type
			select @upphase = @taxphase, @upjcctype = @taxct, @upglacct = @taxglacct, @upum = null,
			@upunits = 0, @upjcum = null, @upjcunits = 0, @upjcecm = null
			-- include Use Tax on this pass to add GL Accrual distribution
			select @usetaxamt = case @taxtype when 2 then @taxamt else 0 end
		end
		
		-- add new APJC entry
		IF ((@totalcost <> 0) or (@i = 1 and @uptaxbasis <> 0 and @taxcode is not null)) /*#29610*/
			or @upunits <> 0 or @rniunits <> 0 or isnull(@rnicost,0) <> 0 
			or isnull(@remcmtdcost,0) <> 0 or isnull(@totalcmtdcost,0) <> 0
		BEGIN
				exec @rcode = bspAPLBValJCInsert @apco, @mth, @batchid, @jcco, @job, @phasegroup, @upphase,
				@upjcctype, @batchseq, @apline, 1, @aptrans, @vendorgroup, @vendor, @apref, @transdesc,
				@invdate, @sl, @slitem, @po, @poitem, @POItemLine, @matlgroup, @matl, @linedesc, @glco, @upglacct,
				@upum, @upunits, @upjcum, @upjcunits, @jcunitcost, @upjcecm, @totalcost, @rniunits, @rnicost,
				@remcmtdcost, @taxgroup, @taxcode, @taxtype, @uptaxbasis, @uptaxamt, @remcmtdunits, @totalcmtdunits,
				@totalcmtdcost,@totalcmtdtax, @remcmtdtax  --DC #122288
		END
		
		-- add new APGL entry - will make intercompany entries if needed
		if @totalcost <> 0 or @usetaxamt <> 0 or @VATgstTaxAmt <> 0 OR @retgGstTaxAmt <> 0 --TK-08150
		begin
			if @i = 0 -- APGL for Job Expense - Gross Amt 
			begin
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @upglacct, @batchseq, @apline, 1,
				@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
				@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
				@emctype, @inco, @loc, @matlgroup, @matl, @totalcost, @apglco, @intercoarglacct, @intercoapglacct,
				@usetaxamt, @taxaccrualacct
			end
			
			if @i = 1 
			begin
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @upglacct, @batchseq, @apline, 1,
				@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
				@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
				@emctype, @inco, @loc, @matlgroup, @matl, @totalcost, @apglco, @intercoarglacct, @intercoapglacct,
				@usetaxamt, @taxaccrualacct	

				-- retainage GST is broken out 
				if @dbtRetgGLAcct is not null and @retainage <> 0 
				begin
					IF @gstTaxAmt <> 0 --133107
					BEGIN
						--APGL for GST Tax
						exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @dbtGLAcct, @batchseq, @apline, 1,
						@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
						@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
						@emctype, @inco, @loc, @matlgroup, @matl, @gstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
						0, @taxaccrualacct
					END

					IF @retgGstTaxAmt <> 0 --133107
					BEGIN
						--APGL for retgGST Tax
						exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @dbtRetgGLAcct, @batchseq, @apline, 1,
						@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
						@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
						@emctype, @inco, @loc, @matlgroup, @matl, @retgGstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
						0, @taxaccrualacct
					END
				end

				-- retainage GST is not broken out but GST is or retg GST is broken out but there is no retainage #131275
				if (@dbtRetgGLAcct is null and @dbtGLAcct is not null ) or (@dbtRetgGLAcct is not null and @retainage = 0) 
				begin
					--APGL for GST Tax
					/* if the user set up a ValueAdd taxcode with a GST rate but is not tracking the GST in an ITC account
					for credit then send the GST portion of tax to the Expense acct */
					select @dbtGLAcct = isnull(@dbtGLAcct,@upglacct)
					exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco,@dbtGLAcct,
					@batchseq, @apline, 1,@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType,
					@itemtype,@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
					@emctype, @inco, @loc, @matlgroup, @matl, @VATgstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
					0, @taxaccrualacct
				end
			end
		end
		
		select @i = @i + 1
		if @i < 2 goto NewJC_loop
		
	end  --End New JC Distributions

	-- 'Old' EM distributions
	if (@oldlinetype in (4,5) or (@oldlinetype = 6 and @olditemtype in (4,5)))	and (@linetranstype = 'D' or @change = 'Y')
	begin
		if isnull(@oldvalueadd,'N') = 'N'
		begin
			select @oldpayTaxAmt = @oldtaxamt
		end

		/* Breakout and establish all VAT related tax amounts. */
		if isnull(@oldvalueadd,'N') = 'Y'
		begin
			if @oldpstrate = 0
			begin
				/* When @oldpstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				select @oldpayTaxAmt = @oldtaxamt 
				select @oldgstTaxAmt = @oldpayTaxAmt
				select @oldVATgstTaxAmt = @oldgstTaxAmt 
				select @oldVATpstTaxAmt = 0
			end
			else
			begin
				select @oldpayTaxAmt = @oldtaxamt 
				select @oldgstTaxAmt = case @oldtaxrate when 0 then 0 else (@oldpayTaxAmt * @oldgstrate) / @oldtaxrate end	
				select @oldpstTaxAmt = @oldpayTaxAmt - @oldgstTaxAmt
				select @oldVATgstTaxAmt =  @oldgstTaxAmt
				select @oldVATpstTaxAmt =  @oldpstTaxAmt
			end		

			/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC Expense GL Acct
			then include the GST portion of tax in the Inventory Expense acct */
			if @olddbtGLAcct is null
			begin
				select @oldpayTaxAmt= @oldVATpstTaxAmt + @oldVATgstTaxAmt
				select @oldVATgstTaxAmt = 0
			end  
			else
			begin
				select @oldpayTaxAmt = @oldVATpstTaxAmt
			end
		end
		
		-- set update amounts
		select @totalcost = @oldgrossamt + @oldpayTaxAmt + (case @oldmiscyn when'Y' then @oldmiscamt else 0 end)
		- (case @netamtopt when 'Y' then @olddiscount else 0 end)
		select @c1 = (-1 * @totalcost)
		select @usetaxamt = case @oldtaxtype when 2 then (-1 * @oldtaxamt) else 0 end
		-- add old APEM entry
		if @totalcost <> 0 or @oldunits <> 0
		begin
			select @u1 = (-1 * @oldunits), @u2 = (-1 * @oldemunits),		-- reverse sign for old entry
			@t1 = (-1 * @oldtaxbasis), @t2 = (-1 * @oldpayTaxAmt)	-- Issue #139910, Out --> @t2 = (-1 * @oldtaxamt)   
			--select @usetaxamt = case @oldtaxtype when 2 then (-1 * @oldtaxamt) else 0 end
			exec @rcode = bspAPLBValEMInsert @apco, @mth, @batchid, @oldemco, @oldequip, @oldemgroup, @oldcostcode,
			@oldemctype, @batchseq, @apline, 0, @aptrans, @oldvendorgroup, @oldvendor, @oldapref, @oldtransdesc,
			@oldinvdate, @oldpo, @oldpoitem, @OldPOItemLine, @oldwo, @oldwoitem, @oldcomptype, @oldcomponent, @oldmatlgroup,
			@oldmatl, @oldlinedesc, @oldglco, @oldglacct, @oldum, @u1, @oldunitcost, @oldecm,
			@oldemum, @u2, @c1, @oldtaxgroup, @oldtaxcode, @oldtaxtype, @t1, @t2
		end
		
		-- add old APGL entry - will make intercompany entries if needed
		if @totalcost <> 0 or @usetaxamt <> 0
		begin
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @oldglacct, @batchseq, @apline, 0,
			@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
			@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
			@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
			@oldmatlgroup, @oldmatl, @c1, @apglco, @oldintercoarglacct, @oldintercoapglacct,
			@usetaxamt, @oldtaxaccrualacct
			-- post GST portion of tax to GST Payables
			if @oldVATgstTaxAmt <> 0 
			begin
				select @oldVATgstTaxAmt = (-1 * (@oldVATgstTaxAmt))
				--APGL for GST Tax
				/* if the user set up a ValueAdd GST taxcode but is not tracking the GST in an ITC account
				for credit then send the GST portion of tax to the Expense acct */
				select @olddbtGLAcct = isnull(@olddbtGLAcct,@oldglacct)
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtGLAcct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
				@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @oldVATgstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
				@usetaxamt, @oldtaxaccrualacct
			end
		end
	end
  
	-- 'New' EM distributions
	if (@LineType in (4,5) or (@LineType = 6 and @itemtype in (4,5))) and (@linetranstype = 'A' or @change = 'Y')
	begin
		/* Sales or Use Tax. */
		if isnull(@valueadd,'N') = 'N'
		begin
			select @payTaxAmt = @taxamt
		end
		/* Breakout and establish all VAT related tax amounts. */
		if isnull(@valueadd,'N') = 'Y'
		begin
			if @pstrate = 0
			begin
				/* When @pstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				select @payTaxAmt = @taxamt 
				select @gstTaxAmt = @payTaxAmt
				select @VATgstTaxAmt = @gstTaxAmt 
				select @VATpstTaxAmt = 0
			end
			else
			begin
				select @payTaxAmt = @taxamt 
				select @gstTaxAmt = case @taxrate when 0 then 0 else (@payTaxAmt * @gstrate) / @taxrate end	
				select @pstTaxAmt = @payTaxAmt - @gstTaxAmt	
				select @VATgstTaxAmt = @gstTaxAmt 
				select @VATpstTaxAmt = @pstTaxAmt
			end
			/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC account
			for credit then include the GST portion of tax with PST */
			if @dbtGLAcct is null
			begin
				select @payTaxAmt= @VATpstTaxAmt + @VATgstTaxAmt
				select @VATgstTaxAmt = 0
			end  
			else
			begin
				select @payTaxAmt = @VATpstTaxAmt
			end
		end
		
		-- set update amounts
		select @totalcost = @grossamt + @payTaxAmt + (case @miscyn when 'Y' then @miscamt else 0 end) - (case @netamtopt when 'Y' then @discount else 0 end)
		select @usetaxamt = case @taxtype when 2 then @taxamt else 0 end
		-- add new APEM entry
		
		if @totalcost <> 0 or @apunits <> 0
		BEGIN
			exec @rcode = bspAPLBValEMInsert @apco, @mth, @batchid, @emco, @equip, @emgroup, @costcode,
			@emctype, @batchseq, @apline, 1, @aptrans, @vendorgroup, @vendor, @apref, @transdesc,
			@invdate, @po, @poitem, @POItemLine, @wo, @woitem, @comptype, @component, @matlgroup,
			@matl, @linedesc, @glco, @glacct, @um, @apunits, @apunitcost, @ecm,
			@emum, @emunits, @totalcost, @taxgroup, @taxcode, @taxtype, @taxbasis, @payTaxAmt
		END
		
		-- add new APGL entry - will make intercompany entries if needed
		if @totalcost <> 0 or @usetaxamt <> 0
		begin
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @glacct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @totalcost, @apglco, @intercoarglacct, @intercoapglacct,
			@usetaxamt, @taxaccrualacct

			-- post GST portion of tax to GST Payables
			if isnull(@VATgstTaxAmt,0) <> 0  
			begin
				--APGL for GST Tax
				/* if the user set up a ValueAdd GST taxcode but is not tracking the GST in an ITC account
				for credit then send the GST portion of tax to the Expense acct */
				select @dbtGLAcct = isnull(@dbtGLAcct,@glacct)
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @dbtGLAcct, @batchseq, @apline, 1,
				@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
				@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
				@emctype, @inco, @loc, @matlgroup, @matl, @VATgstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
				@usetaxamt, @taxaccrualacct
			end
		end
	end

--Old SM
	IF (@oldlinetype = 8 or (@oldlinetype = 6 and @olditemtype = 6)) and (@linetranstype = 'D' or @change = 'Y')
	BEGIN
		-- AP Type 6 (PO) -> SM Type 5 (Purchase), AP Type 8 (SM) -> SM Type 3 (Misc)
		SELECT @oldsmtype = CASE @oldlinetype WHEN 6 THEN 5 WHEN 8 THEN 3 END, @smoldnew = 0

		IF (isnull(@smco, 0) <> isnull(@oldsmco, 0) or isnull(@smworkorder,-1) <> isnull(@oldsmworkorder,-1) or isnull(@scope,-1) <> isnull(@oldscope,-1))
		BEGIN
			--If this is a change transaction and we have changed the SMCompany or Work Order treat this side
			--of the transaction as a delete.  
			SELECT @linetranstype = 'D'
		END

		SELECT
			@oldpayTaxAmt = @oldtaxamt,
			@usetaxamt = CASE @oldtaxtype WHEN 2 THEN (-1 * @oldpayTaxAmt) ELSE 0 END

		/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC account
		then there is no need to break out the GST amount */
		IF @oldvalueadd = 'Y' AND @olddbtGLAcct IS NOT NULL
		BEGIN
			SELECT
				@oldgstTaxAmt = 
					CASE
						--If the PST rate is 0 then the tax amount is all GST
						WHEN @oldpstrate = 0 THEN @oldpayTaxAmt 
						WHEN @oldtaxrate <> 0 THEN (@oldpayTaxAmt *  @oldgstrate) / @oldtaxrate ELSE 0 
					END,
				@oldpayTaxAmt = @oldpayTaxAmt - @oldgstTaxAmt,
				-- reverse sign for old entries
				@oldgstTaxAmt = -@oldgstTaxAmt

			IF @oldgstTaxAmt <> 0
			BEGIN
				EXEC @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtGLAcct, @batchseq, @apline, 0,
					@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
					@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
					@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
					@oldmatlgroup, @oldmatl, @oldgstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
					@usetaxamt, @oldtaxaccrualacct
			END
		END

		-- set update amounts
		SELECT @totalcost = @oldgrossamt + @oldpayTaxAmt + (CASE @oldmiscyn WHEN 'Y' THEN @oldmiscamt ELSE 0 END) 
		- (CASE @netamtopt WHEN 'Y' THEN @olddiscount ELSE 0 END)
		SELECT @totalcost = (@totalcost * -1)

		IF @oldlinetype = 6
		BEGIN
			INSERT dbo.vPOItemLineDistribution (HQBatchDistributionID, POCo, PO, POItem, POItemLine, InvUnits, InvCost, InvTaxBasis, InvDirectExpenseTax, InvTotalCost)
			VALUES (@HQBatchDistributionID, @apco, @oldpo, @oldpoitem, @OldPOItemLine, -@oldunits, -@oldgrossamt, -@oldtaxbasis, -@oldpayTaxAmt, @totalcost)
		END

		SELECT @smlinedesc = isnull(@matl,'') + isnull(@linedesc,'')
	
		SELECT @oldsmservicesite = ServiceSite FROM dbo.SMWorkOrder WHERE SMCo=@oldsmco and WorkOrder=@oldsmworkorder
		
		/* Validate Workorder Scope and get Scope related defaults */
		EXEC @rcode = vspSMWorkCompletedScopeVal @SMCo=@oldsmco, @WorkOrder=@oldsmworkorder, @Scope=@oldscope,
			@LineType=@oldsmtype, @AllowProvisional='Y', @SMCostType=@oldsmcosttype, @msg=@errortext OUTPUT
		IF (@rcode=1)
		BEGIN
			set @errortext = 'Scope validation: ' + @errortext
			GOTO APLB_error
		END

		exec @rcode = vspAPLBValSMInsert @apco, @mth, @batchid, @batchseq, @oldlinetype, @aptrans, @aptlkeyid, @apline, @oldsmco, 
		@oldsmservicesite, @oldsmworkorder, @oldscope, @oldsmtype, @oldsmcosttype, @oldsmjccosttype, @oldsmphasegroup, @oldsmphase,
		@oldpo, @oldpoitem, @OldPOItemLine, @oldinvdate, @oldum, 
		@oldunits, @oldunitcost, @oldgrossamt, @totalcost, NULL,
		@oldsmlinedesc, @oldglco, @oldglacct, @smoldnew, @oldmiscyn, @oldmiscamt, @linetranstype, NULL, NULL, NULL
		
		IF @rcode <> 0
		BEGIN
			SELECT @errortext = @errorstart + ' - ' + 'Unable to create SM distribution.'
			GOTO APLB_error
		END

		INSERT dbo.vSMDetailTransaction (IsReversing, Posted, HQBatchLineID, HQBatchDistributionID, LineType, TransactionType, SourceCo, Mth, BatchId, GLCo, GLAccount, Amount, SMWorkCompletedID, SMWorkOrderScopeID, SMWorkOrderID)
		SELECT 1 IsReversing, 0 IsPosted, @HQBatchLineID, @HQBatchDistributionID, @oldsmtype, 'C'/*C for cost*/, @apco, @mth, @batchid, @oldglco, @oldglacct, @totalcost,
			CASE @oldlinetype 
				WHEN 6 THEN (SELECT vSMWorkCompleted.SMWorkCompletedID FROM dbo.vPOItemLine INNER JOIN dbo.vSMWorkCompleted ON vPOItemLine.SMCo = vSMWorkCompleted.SMCo AND vPOItemLine.SMWorkOrder = vSMWorkCompleted.WorkOrder AND vPOItemLine.SMWorkCompleted = vSMWorkCompleted.WorkCompleted WHERE vPOItemLine.POCo = @apco AND  vPOItemLine.PO = @oldpo AND  vPOItemLine.POItem = @oldpoitem AND  vPOItemLine.POItemLine = @OldPOItemLine)
				WHEN 8 THEN (SELECT SMWorkCompletedID FROM dbo.vSMWorkCompleted WHERE APTLKeyID = @aptlkeyid)
			END,
			(SELECT SMWorkOrderScopeID FROM dbo.vSMWorkOrderScope WHERE SMCo = @oldsmco AND WorkOrder = @oldsmworkorder AND Scope = @oldscope),
			(SELECT SMWorkOrderID FROM dbo.vSMWorkOrder WHERE SMCo = @oldsmco AND WorkOrder = @oldsmworkorder)

		exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @oldglacct, @batchseq, @apline, @smoldnew,
		@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
		@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
		@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
		@oldmatlgroup, @oldmatl, @totalcost, @apglco, @oldintercoarglacct, @oldintercoapglacct,
		@usetaxamt, @oldtaxaccrualacct
	END
	
--New SM
	IF ((@LineType = 8 or (@LineType = 6 and @itemtype = 6)) and (@linetranstype = 'A' or @change = 'Y'))
	BEGIN
		SELECT @smoldnew = 1
		
		IF @LineType = 8
		BEGIN
			SELECT @smtype = 3
			
			IF EXISTS(SELECT 1 FROM dbo.vfSMGetAccountingTreatment(@smco, @smworkorder, @scope, @smtype, @smcosttype) WHERE dbo.vfIsEqual(GLCo, @glco) = 0 OR dbo.vfIsEqual(CurrentCostGLAcct, @glacct) = 0)
			BEGIN
				SELECT @errortext = @errorstart + ' - ' + 'The gl account assigned to the line doesn''t match the account that will be given the work completed line. Clear the scope field and re-enter the scope to default the correct account.'
				GOTO APLB_error
			END

			IF (isnull(@smco, 0) <> isnull(@oldsmco, 0) or isnull(@smworkorder,-1) <> isnull(@oldsmworkorder,-1) or isnull(@scope,-1) <> isnull(@oldscope,-1))
			BEGIN
				--If this is a change transaction and we have changed the SMCompany or Work Order treat this side
				--of the transaction as a new add.  
				SELECT @linetranstype = 'A' --, @aptlkeyid = null
			END
		END
		ELSE
		BEGIN
			SELECT @smtype = 5
		END
		
		----Validate Work Order
		exec @rcode = vspAPLBValSM @smco, @smworkorder, @scope, @smcosttype, @smjccosttype, @smphasegroup, @smphase, @smtype, @invdate, @aptlkeyid, @taxgroup, @taxcode,
			@smservicesite OUTPUT, @smtaxtype OUTPUT, @smtaxgroup OUTPUT, @smtaxcode OUTPUT, @smtaxrate OUTPUT, @errmsg OUTPUT
		IF @rcode <> 0
		BEGIN
			SELECT @errortext = @errorstart + ' - ' + isnull(@errmsg,'')
			GOTO APLB_error
		END

		SELECT
			@payTaxAmt = @taxamt,
			@usetaxamt = CASE @taxtype WHEN 2 THEN @payTaxAmt ELSE 0 END

		/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC account
		then there is no need to break out the GST amount */
		IF @valueadd = 'Y' AND @dbtGLAcct IS NOT NULL
		BEGIN
			SELECT
				@gstTaxAmt = 
					CASE
						--If the PST rate is 0 then the tax amount is all GST
						WHEN @pstrate = 0 THEN @payTaxAmt 
						WHEN @taxrate <> 0 THEN (@payTaxAmt * @gstrate) / @taxrate ELSE 0 
					END,
				@payTaxAmt = @payTaxAmt - @gstTaxAmt

			IF @gstTaxAmt <> 0
			BEGIN
				EXEC @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @dbtGLAcct, @batchseq, @apline, 1,
					@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
					@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
					@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
					@matlgroup, @matl, @gstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
					@usetaxamt, @taxaccrualacct
			END
		END

		-- set update amounts
		select @totalcost = @grossamt + @payTaxAmt + (case @miscyn when 'Y' then @miscamt else 0 end)
		 - (case @netamtopt when 'Y' then @discount else 0 end)

		SELECT @smlinedesc = isnull(@matl,'') + isnull(@linedesc,'')

		--The tax rate should be null unless a tax amount should be able to be calculated for a misc line
		select @smtaxamt = @totalcost*@smtaxrate
		
		exec @rcode = vspAPLBValSMInsert @apco, @mth, @batchid, @batchseq, @LineType, @aptrans, @aptlkeyid, 
		@apline, @smco, @smservicesite, @smworkorder, @scope, @smtype, @smcosttype, @smjccosttype, @smphasegroup,@smphase,
		@po, @poitem, @POItemLine,
		@invdate, @um, @apunits, @apunitcost, @grossamt, @totalcost, @smtaxgroup,  
		@smlinedesc, @glco, @glacct, @smoldnew, @miscyn, @miscamt, @linetranstype, @smtaxcode, @smtaxamt, @smtaxtype
		
		IF @rcode <> 0
		BEGIN
			SELECT @errortext = @errorstart + ' - ' + 'Unable to create SM distribution.'
			GOTO APLB_error
		END
				
		IF @LineType = 6
		BEGIN
			INSERT dbo.vPOItemLineDistribution (HQBatchDistributionID, POCo, PO, POItem, POItemLine, InvUnits, InvCost, InvTaxBasis, InvDirectExpenseTax, InvTotalCost)
			VALUES (@HQBatchDistributionID, @apco, @po, @poitem, @POItemLine, @apunits, @grossamt, @taxbasis, @payTaxAmt, @totalcost)
		END

		INSERT dbo.vSMDetailTransaction (IsReversing, Posted, HQBatchLineID, HQBatchDistributionID, LineType, TransactionType, SourceCo, Mth, BatchId, GLCo, GLAccount, Amount, SMWorkCompletedID, SMWorkOrderScopeID, SMWorkOrderID)
		SELECT 0 IsReversing, 0 IsPosted, @HQBatchLineID, @HQBatchDistributionID, @smtype, 'C'/*C for cost*/, @apco, @mth, @batchid, @glco, @glacct, @totalcost,
			--WorkCompleted may already exist for an add record when the work order or scope changes.
			CASE
				WHEN @LineType = 6 THEN (SELECT vSMWorkCompleted.SMWorkCompletedID FROM dbo.vPOItemLine INNER JOIN dbo.vSMWorkCompleted ON vPOItemLine.SMCo = vSMWorkCompleted.SMCo AND vPOItemLine.SMWorkOrder = vSMWorkCompleted.WorkOrder AND vPOItemLine.SMWorkCompleted = vSMWorkCompleted.WorkCompleted WHERE  vPOItemLine.POCo = @apco AND  vPOItemLine.PO = @po AND  vPOItemLine.POItem = @poitem AND  vPOItemLine.POItemLine = @POItemLine) 
				WHEN @linetranstype = 'C' AND @LineType = 8 THEN (SELECT SMWorkCompletedID FROM dbo.vSMWorkCompleted WHERE APTLKeyID = @aptlkeyid)
			END,
			(SELECT SMWorkOrderScopeID FROM dbo.vSMWorkOrderScope WHERE SMCo = @smco AND WorkOrder = @smworkorder AND Scope = @scope),
			(SELECT SMWorkOrderID FROM dbo.vSMWorkOrder WHERE SMCo = @smco AND WorkOrder = @smworkorder)
	
		EXEC @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @glacct, @batchseq, @apline, 1,
		@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
		@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
		@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
		@matlgroup, @matl, @totalcost, @apglco, @intercoarglacct, @intercoapglacct,
		@usetaxamt, @taxaccrualacct

		EXEC @GLEntryID = dbo.vspGLCreateEntry @Source = 'AP Entry', @TransactionsShouldBalance = 0, @msg = @errortext OUTPUT
	
		IF @GLEntryID = -1
		BEGIN
			--Log error
			GOTO APLB_error
		END
		
		INSERT dbo.vGLEntryBatch (GLEntryID, Co, Mth, BatchId, BatchSeq, Line, Trans, InterfacingCo)
		VALUES (@GLEntryID, @apco, @mth, @batchid, @batchseq, @apline, @aptrans, @apco)

		INSERT dbo.vGLEntryTransaction (GLEntryID, GLTransaction, GLCo, GLAccount, Amount, ActDate, [Description])
		VALUES (@GLEntryID, 1, @glco, @glacct, @totalcost, dbo.vfDateOnly(), @TransactionDescription)
		
		INSERT dbo.vAPTLGLEntry (GLEntryID, GLTransactionForAPTransactionLineAccount)
		VALUES (@GLEntryID, 1)
	
	END

	-- 'Old' Expense distributions  (SM is using Expense type distributions) - 131640
	if (@oldlinetype = 3 or (@oldlinetype = 6 and @olditemtype = 3)) and (@linetranstype = 'D' or @change = 'Y')
	--if (@oldlinetype = 3 or (@oldlinetype = 6 and @olditemtype in (3,6))) and (@linetranstype = 'D' or @change = 'Y')  --<-- TK-02798 revert to original.  SM will have its own.
	begin
		-- set update amounts
		select @totalcost = @oldgrossamt + (case isnull(@oldvalueadd,'N') when 'N' then @oldtaxamt else 0 end) 
		+ (case @oldmiscyn when'Y' then @oldmiscamt else 0 end)
		- (case @netamtopt when 'Y' then @olddiscount else 0 end)
		select @c1 = (-1 * @totalcost)  -- reverse sign for old amount
		select @usetaxamt = case @oldtaxtype when 2 then (-1 * @oldtaxamt) else 0 end
		-- add old APGL entry - will make intercompany entries if needed
		if @totalcost <> 0 or @usetaxamt <> 0
		BEGIN
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @oldglacct, @batchseq, @apline, 0,
			@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
			@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
			@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
			@oldmatlgroup, @oldmatl, @c1, @apglco, @oldintercoarglacct, @oldintercoapglacct,
			@usetaxamt, @oldtaxaccrualacct
		END
		
		-- add APGL entry for old PST/GST tax 
		if isnull(@oldvalueadd,'N') = 'Y' -- VAT value added tax
		begin
			/* Breakout and establish all VAT related tax amounts now. */
			if @oldpstrate = 0 --TK-04672/#143321 changed @pstrate to @oldpstrate
			begin
				/* When @oldpstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				select @oldpayTaxAmt = @oldtaxamt 
				select @oldgstTaxAmt = @oldpayTaxAmt
				select @oldVATgstTaxAmt = @oldgstTaxAmt 
				select @oldVATpstTaxAmt = 0
			end
			else
			begin
				select @oldpayTaxAmt = @oldtaxamt 
				select @oldgstTaxAmt = case @oldtaxrate when 0 then 0 else (@oldpayTaxAmt * @oldgstrate) / @oldtaxrate end	
				select @oldpstTaxAmt = @oldpayTaxAmt - @oldgstTaxAmt	
				-- reverse sign for old entries
				select @oldVATgstTaxAmt = @oldgstTaxAmt 
				select @oldVATpstTaxAmt = @oldpstTaxAmt 
			end	
				
			-- reverse the sign
			select @oldVATgstTaxAmt = (-1 * @oldVATgstTaxAmt)
			select @oldVATpstTaxAmt = (-1 * @oldVATpstTaxAmt)
			-- post non-GST portion of tax to AP Payables
			if @oldVATpstTaxAmt <> 0
			begin
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @oldglacct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
				@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @oldVATpstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
				@usetaxamt, @oldtaxaccrualacct
			end

			-- post GST portion of tax to GST Payables
			if @oldVATgstTaxAmt <> 0 
			begin
				--APGL for GST Tax
				/* if the user set up a ValueAdd GST taxcode but is not tracking the GST in an ITC account
				for credit then send the GST portion of tax to the Expense acct */
				select @olddbtGLAcct = isnull(@olddbtGLAcct,@oldglacct)
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtGLAcct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype,@oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @upphase,
				@upjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @oldVATgstTaxAmt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
				@usetaxamt, @oldtaxaccrualacct
			end
		end
	end --End 'Old' Expense distributions

	-- 'New' Expense distributions (SM is using Expense type distributions)  131640
	if (@LineType = 3 or (@LineType = 6 and @itemtype = 3)) and (@linetranstype = 'A' or @change = 'Y')
	--if (@LineType = 3 or (@LineType = 6 and @itemtype in(3,6))) and (@linetranstype = 'A' or @change = 'Y') --<-- TK-02798 revert to original.  SM will have its own.
	begin
		-- set update amounts
		select @totalcost = @grossamt + (case isnull(@valueadd,'N') when 'N' then @taxamt else 0 end)
		+ (case @miscyn when'Y' then @miscamt else 0 end)
		- (case @netamtopt when 'Y' then @discount else 0 end)
		select @usetaxamt = case @taxtype when 2 then @taxamt else 0 end
		-- add new APGL entry - will make intercompany entries if needed
		if @totalcost <> 0 or @usetaxamt <> 0
		BEGIN
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @glacct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @totalcost, @apglco, @intercoarglacct, @intercoapglacct,
			@usetaxamt, @taxaccrualacct
		END
		
		-- add new APGL entry for PST/GST tax 
		if isnull(@valueadd,'N') = 'Y' -- VAT value added tax
		begin	
			/* Breakout and establish all VAT related tax amounts now. */
			if @pstrate = 0
			begin
				/* When @pstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				select @payTaxAmt = @taxamt 
				select @gstTaxAmt = @payTaxAmt
				select @VATgstTaxAmt = @gstTaxAmt 
				select @VATpstTaxAmt = 0
			end
			else
			begin
				select @payTaxAmt = @taxamt 
				select @gstTaxAmt = case @taxrate when 0 then 0 else (@payTaxAmt * @gstrate) / @taxrate end	
				select @pstTaxAmt = @payTaxAmt - @gstTaxAmt	
				select @VATgstTaxAmt = @gstTaxAmt 
				select @VATpstTaxAmt = @pstTaxAmt 
			end

			-- post non-GST portion of tax to AP Payables
			if @VATpstTaxAmt <> 0
			begin
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @glacct, @batchseq, @apline, 1,
				@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
				@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
				@emctype, @inco, @loc, @matlgroup, @matl, @VATpstTaxAmt, @apglco,@intercoarglacct,
				@intercoapglacct,@usetaxamt, @taxaccrualacct
			end

			-- post GST portion of tax to GST Payables
			if @VATgstTaxAmt <> 0 
			begin
				--APGL for GST Tax
				/* if the user set up a ValueAdd GST taxcode but is not tracking the GST in an ITC account
				for credit then send the GST portion of tax to the Expense acct */
				select @dbtGLAcct = isnull(@dbtGLAcct,@glacct)
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @dbtGLAcct, @batchseq, @apline, 1,
				@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc, @LineType, @itemtype,
				@linedesc, @jcco, @job, @phasegroup, @upphase, @upjcctype, @emco, @equip, @emgroup, @costcode,
				@emctype, @inco, @loc, @matlgroup, @matl, @VATgstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
				@usetaxamt, @taxaccrualacct
			end
		end
	end
  
	-- 'Old' IN distributions
	if (@oldlinetype = 2 or (@oldlinetype = 6 and @olditemtype = 2)) and (@linetranstype = 'D' or @change = 'Y')
	begin
		/*Because tax amount is included with the gross if costs are burdened we need to calculate now how much of the total tax amount 
		should be added to gross (if burdened).  If the taxcode is not value added (Sales or Use) then include all the tax amount. 
		If it is a value added taxcode determine the PST and GST portions. The PST portion will be added to the gross if burdenend
		but the GST should not unless the taxcode is set up as value added with GST BUT they are not tracking the GST portion in an
		ITC expense account(@dbtGLAcct is snull) then the GST portion should be treated as Sales and included in the tax amount added
		to gross for burdened costs. */
		/* Sales or Use Tax. */
		if isnull(@oldvalueadd,'N') = 'N'
		begin
			select @oldpayTaxAmt = @oldtaxamt
		end
		/* Breakout and establish all VAT related tax amounts. */
		if isnull(@oldvalueadd,'N') = 'Y'
		begin
			if @oldpstrate = 0
			begin
				/* When @oldpstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				select @oldpayTaxAmt = @oldtaxamt 
				select @oldgstTaxAmt = @oldpayTaxAmt
				select @oldVATgstTaxAmt = @oldgstTaxAmt 
				select @oldVATpstTaxAmt = 0
			end
			else
			begin
				select @oldpayTaxAmt = @oldtaxamt 
				select @oldgstTaxAmt = case @oldtaxrate when 0 then 0 else (@oldpayTaxAmt * @oldgstrate) / @oldtaxrate end	
				select @oldpstTaxAmt = @oldpayTaxAmt - @oldgstTaxAmt
				select @oldVATgstTaxAmt =  @oldgstTaxAmt
				select @oldVATpstTaxAmt =  @oldpstTaxAmt
			end		
			
			/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC Expense GL Acct
			then include the GST portion of tax in the Inventory Expense acct */
			if @olddbtGLAcct is null
			begin
				select @oldpayTaxAmt= @oldVATpstTaxAmt + @oldVATgstTaxAmt
				select @oldVATgstTaxAmt = 0
			end  
			else
			begin
				select @oldpayTaxAmt = @oldVATpstTaxAmt
			end
		end
		
		-- set update amounts
		select @totalcost = 0
		select @totalcost = @oldgrossamt - (case @netamtopt when 'Y' then isnull(@olddiscount,0) else 0 end)
		if @oldburdenyn = 'Y' select @totalcost = isnull(@totalcost,0) + isnull(@oldpayTaxAmt,0) +  isnull(@oldmiscamt,0) 
		select @stdtotalcost = @totalcost  -- set inventory total equal to posted total
		select @unitcost = 0, @stdunitcost = 0, @stdecm = isnull(@oldavgecm,@avgecm) /*'E'*/ -- #29558
		select @i = case @oldecm when 'C' then 100 when 'M' then 1000 else 1 end
		if @oldunits <> 0 select @unitcost = (@totalcost / @oldunits) * @i  -- unit cost per posted u/m
		select @i = case @stdecm when 'C' then 100 when 'M' then 1000 else 1 end -- #29558
		if @oldstdunits <> 0 select @stdunitcost = (@stdtotalcost / @oldstdunits) * @i -- unit cost per std u/m --#29558
		
		if @oldcostopt = 3     -- standard unit cost method
		begin
			select @stdunitcost = @oldfixedunitcost, @stdecm = @oldfixedecm
			select @i = case @stdecm when 'C' then 100 when 'M' then 1000 else 1 end
			select @stdtotalcost = (@stdunitcost * @oldstdunits) / @i    -- update IN using fixed unit cost
		end

		select @variance = @totalcost - @stdtotalcost  -- difference will only exist if using std cost method
		-- add old APIN entry
		if @totalcost <> 0 or @oldunits <> 0
		begin
			select @u1 = (-1 * @oldunits), @u2 = (-1 * @oldstdunits)
			select @c1 = (-1 * @totalcost), @c2 = (-1 * @stdtotalcost) -- reverse sign for old entries
			exec @rcode = bspAPLBValINInsert @apco, @mth, @batchid, @oldinco, @oldloc, @oldmatlgroup, @oldmatl,
			@batchseq, @apline, 0, @aptrans, @oldvendorgroup, @oldvendor, @oldapref, @oldtransdesc,
			@oldinvdate, @oldpo, @oldpoitem, @OldPOItemLine, @oldlinedesc, @oldglco, @oldglacct, @oldum, @u1, @unitcost,
			@oldecm, @c1, @oldstdum, @u2, @stdunitcost, @stdecm, @c2
		end

		-- add old APGL entries - will make intercompany entries if needed
		select @i = 0
OldINGL_loop:
		select @glamt = 0, @usetaxamt = 0
		-- Inventory
		if @i = 0
		begin
			select @glamt = (-1 * @stdtotalcost), @upglacct = @oldglacct
			if @oldtaxtype = 2 select @usetaxamt = (-1 * @oldtaxamt) -- handle use tax on first pass
		end

		-- Tax if Unit Cost is not burdened - #16892- do tax GL distribution for all non burdened cost options
		if @i = 1 and @oldburdenyn = 'N' /*and @oldcostopt <> 3 */ and @oldtaxamt <> 0
		begin
			exec @rcode = bspGLACfPostable @oldglco, @oldloctaxglacct, 'I', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Inventory Tax GL Account:' + 
				isnull(@oldloctaxglacct, '') + ':  ' + isnull(@errmsg,'')  
				goto APLB_error
			end
			select @glamt = (-1 * @oldpayTaxAmt /*@oldtaxamt*/), @upglacct = @oldloctaxglacct
		end

		-- Misc Amount if Unit Cost is not burdened - #16892 do miscamt GL distribution for all non burdened cost options
		if @i = 2 and @oldburdenyn = 'N' /*and @oldcostopt <> 3 */ and @oldmiscamt <> 0 and @oldmiscyn = 'Y'
		begin
			exec @rcode = bspGLACfPostable @oldglco, @oldlocmiscglacct, 'I', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Inventory Freight/Misc GL Account:' + 
				isnull(@oldlocmiscglacct, '') + ':  ' + isnull(@errmsg,'') 
				goto APLB_error
			end
			select @glamt = (-1 * @oldmiscamt), @upglacct = @oldlocmiscglacct
		end

		-- Cost Variance if using Fixed Unit Cost
		if @i = 3 and @oldcostopt = 3 and @variance <> 0
		begin
			exec @rcode = bspGLACfPostable @oldglco, @oldlocvarianceglacct, 'I', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Inventory Cost Variance GL Account:' + 
				isnull(@oldlocvarianceglacct, '') + ':  ' + isnull(@errmsg,'')  
				goto APLB_error
			end
			select @glamt = (-1 * @variance), @upglacct = @oldlocvarianceglacct
		end
		
		if @glamt <> 0 or @usetaxamt <> 0
		BEGIN
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @upglacct, @batchseq, @apline, 0,
			@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
			@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
			@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
			@oldmatlgroup, @oldmatl, @glamt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
			@usetaxamt, @oldtaxaccrualacct
		END
		
		select @i = @i + 1
		if @i < 4 goto OldINGL_loop

		/* post GST portion of tax to GST Payables - this is separate from burdened and unburdened GL expensing */
		if isnull(@oldvalueadd,'N')='Y' and @olddbtGLAcct is not null and isnull(@oldVATgstTaxAmt,0) <> 0
		begin
			select @glamt = (-1 * @oldVATgstTaxAmt)
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @oldglco, @olddbtGLAcct, @batchseq, @apline, 0,
			@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
			@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
			@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
			@oldmatlgroup, @oldmatl, @glamt, @apglco, @oldintercoarglacct, @oldintercoapglacct,
			@usetaxamt, @oldtaxaccrualacct
		end
	end  -- End 'Old' IN distributions

	-- 'New' IN distributions
	if (@LineType = 2 or (@LineType = 6 and @itemtype = 2)) and (@linetranstype = 'A' or @change = 'Y')
	begin
		/*Because tax amount is included with the gross if costs are burdened we need to calculate now how much of the total tax amount 
		should be added to gross (if burdened).  If the taxcode is not value added then include all the tax amount. 
		If it is a value added taxcode determine the PST and GST portions. The PST portion will be added to the gross if burdenend
		the GST should not unless the taxcode is set up as value added with GST BUT they are not tracking the GST portion in an
		ITC expense account then the GST portion should be treated as Sales and included in the tax amount added to gross for
		burdened costs. */
		/* Sales or Use Tax. */
		if isnull(@valueadd,'N') = 'N'
		begin
			select @payTaxAmt = @taxamt
		end
		/* Breakout and establish all VAT related tax amounts. */
		if isnull(@valueadd,'N') = 'Y'
		begin
			if @pstrate = 0
			begin
				/* When @pstrate = 0:  Either VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate. */
				select @payTaxAmt = @taxamt 
				select @gstTaxAmt = @payTaxAmt
				select @VATgstTaxAmt = @gstTaxAmt 
				select @VATpstTaxAmt = 0
			end
			else
			begin
				select @payTaxAmt = @taxamt 
				select @gstTaxAmt = case @taxrate when 0 then 0 else (@payTaxAmt * @gstrate) / @taxrate end	
				select @pstTaxAmt = @payTaxAmt - @gstTaxAmt	
				select @VATgstTaxAmt = @gstTaxAmt 
				select @VATpstTaxAmt = @pstTaxAmt
			end
			/* if the user set up a ValueAdd GST taxcode but is NOT tracking the GST in an ITC account
			for credit then send the GST portion of tax to the Expense acct */
			if @dbtGLAcct is null
			begin
				select @payTaxAmt= @VATpstTaxAmt + @VATgstTaxAmt
				select @VATgstTaxAmt = 0
			end  
			else
			begin
				select @payTaxAmt = @VATpstTaxAmt
			end
		end
		
		-- set update amounts
		select @totalcost = @grossamt - (case @netamtopt when 'Y' then @discount else 0 end)
		if @burdenyn = 'Y' select @totalcost = (@totalcost + isnull(@payTaxAmt,0) + isnull(@miscamt,0))
		select @stdtotalcost = @totalcost  -- set inventory total equal to posted total
		select @unitcost = 0, @stdunitcost = 0, @stdecm = @avgecm 
		select @i = case @ecm when 'C' then 100 when 'M' then 1000 else 1 end
		if @apunits <> 0 select @unitcost = (@totalcost / @apunits) * @i  -- unit cost per posted u/m
		select @i = case @stdecm when 'C' then 100 when 'M' then 1000 else 1 end --#29558
		if @stdunits <> 0 select @stdunitcost = (@stdtotalcost / @stdunits) * @i -- unit cost per std u/m --#29558
		
		if @costopt = 3     -- standard cost method
		begin
			select @stdunitcost = @fixedunitcost, @stdecm = @fixedecm
			select @i = case @stdecm when 'C' then 100 when 'M' then 1000 else 1 end
			select @stdtotalcost = (@stdunitcost * @stdunits) / @i    -- update IN using fixed unit cost
		end
		
		select @variance = @totalcost - @stdtotalcost  -- difference will only exist if using std cost method

		-- add new APIN entry
		if @apunits <> 0 or @totalcost <> 0
		BEGIN
			exec @rcode = bspAPLBValINInsert @apco, @mth, @batchid, @inco, @loc, @matlgroup, @matl,
			@batchseq, @apline, 1, @aptrans, @vendorgroup, @vendor, @apref, @transdesc,
			@invdate, @po, @poitem, @POItemLine, @linedesc, @glco, @glacct, @um, @apunits, @unitcost, @ecm,
			@totalcost, @stdum, @stdunits, @stdunitcost, @stdecm, @stdtotalcost
		END
		
		-- add new APGL entries - will make intercompany entries if needed
		select @i = 0
NewINGL_loop:

		select @glamt = 0, @usetaxamt = 0
		-- Inventory
		if @i = 0
		begin
			select @glamt = @stdtotalcost, @upglacct = @glacct
			if @taxtype = 2 select @usetaxamt = @taxamt -- handle use tax on first pass
		end

		-- Tax if Unit Cost is not Burdened - #16892 do taxamt GL distribution for all non burdened cost options
		if @i = 1 and @burdenyn = 'N' /*and @costopt <> 3 */ and @taxamt <> 0
		begin
			exec @rcode = bspGLACfPostable @glco, @loctaxglacct, 'I', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Inventory Tax GL Account:' + isnull(@loctaxglacct, '') + ':  ' + isnull(@errmsg,'')  
				goto APLB_error
			end
			
			select @glamt = @payTaxAmt /*@taxamt*/, @upglacct = @loctaxglacct
		end
		
		-- Misc Amount if Unit Cost is not burdened - #16892 do miscamt GL distribution for all non burdened cost options 
		if @i = 2 and @burdenyn = 'N' /*and @oldcostopt <> 3 */ and @miscamt <> 0 and @miscyn = 'Y'
		begin
			exec @rcode = bspGLACfPostable @glco, @locmiscglacct, 'I', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Inventory Freight/Misc GL Account:' + 
				isnull(@locmiscglacct,'') + ':  ' + isnull(@errmsg,'')
				goto APLB_error
			end
			select @glamt = @miscamt, @upglacct = @locmiscglacct
		end

		-- Variance if using Fixed Unit Cost
		if @i = 3 and @costopt = 3 and @variance <> 0
		begin
			exec @rcode = bspGLACfPostable @glco, @locvarianceglacct, 'I', @errmsg output
			if @rcode <> 0
			begin
				select @errortext = @errorstart + '- Inventory Cost Variance GL Account:' + isnull(@locvarianceglacct, '') + ':  ' + isnull(@errmsg,'')  --#23061
				goto APLB_error
			end
			select @glamt = @variance, @upglacct = @locvarianceglacct
		end
		
		if @glamt <> 0 or @usetaxamt <> 0
		begin
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @upglacct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @glamt, @apglco, @intercoarglacct, @intercoapglacct,
			@usetaxamt, @taxaccrualacct
		end
		
		select @i = @i + 1
		if @i < 4 goto NewINGL_loop
		/* post GST portion of tax to GST Payables - this is separate from burdened and unburdened GL expensing */
		if isnull(@valueadd,'N')='Y' and @dbtGLAcct is not null and @VATgstTaxAmt <> 0
		begin
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @glco, @dbtGLAcct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @VATgstTaxAmt, @apglco, @intercoarglacct, @intercoapglacct,
			@usetaxamt, @taxaccrualacct
		end
	end  --'New' IN distributions
  
	-- Remaining 'Old' GL distributions
	IF @linetranstype = 'D' or @change = 'Y'
	BEGIN -- BEGIN Old GL distributions
		select @i = 0
OldGL_loop:
		select @glamt = 0
		-- Old Discount Offered (if Net to Subledgers)
		if @i = 0 and @netamtopt = 'Y' select @glamt = (-1 * @olddiscount), @upglacct = @olddiscoffglacct
		-- Posted Payable - include Misc if paid to Vendor, and Sales Tax
		if @i = 1
		BEGIN -- begin posted payables
			-- Sales Tax - retainage is not broken out in Payables posting
			if isnull(@oldvalueadd,'N') = 'N'
			BEGIN
				SELECT @glamt = (
									@oldgrossamt 
									+ (case @oldmiscyn when 'Y' then @oldmiscamt else 0 end)
									+ (case @oldtaxtype when 1 then @oldtaxamt else 0 end) 
									- @oldretainage
								)
				SELECT @upglacct = @oldapglacct
			END 
	
			-- VAT Tax - retainage tax may be broken out in Payables posting
			IF ISNULL(@oldvalueadd,'N') = 'Y' 
			BEGIN
				IF isnull(@APCOTaxBasisNetRetg, 'N') = 'N' OR @APHBCheckRevYN = 'Y' 
				BEGIN
					-- Tax basis is NOT net of retg so back out Retg GST from the tax amount
					SELECT @oldretgTaxAmt = @oldretainage * @oldtaxrate
					SELECT @glamt = (
										@oldgrossamt 
										+ (CASE @oldmiscyn WHEN 'Y' THEN @oldmiscamt ELSE 0 END)
										+ (@oldtaxamt - CASE @olddbtRetgGLAcct WHEN NULL THEN 0 ELSE @oldretgTaxAmt END)
										- @oldretainage
									 )
				END
				ELSE
				BEGIN

					-- Tax basis IS net of retg so tax amount is already minus the retg GST 
					SELECT @glamt = (
										@oldgrossamt 
										+ (case @oldmiscyn when 'Y' then @oldmiscamt else 0 end)
										+ @oldtaxamt 
										- @oldretainage
									)
				END
				SELECT @upglacct = @oldapglacct
			END
		END	-- end posted payables	

		-- Retainage Payable
		if @i = 2
		BEGIN -- retainage payables
			-- retainage does not include GST tax
			if isnull(@oldvalueadd,'N') = 'N' select @glamt = @oldretainage, @upglacct = @oldretglacct
			-- retainage includes GST tax
			if isnull(@oldvalueadd,'N') = 'Y'
			BEGIN
			IF @oldretainage <> 0
			BEGIN
				IF isnull(@APCOTaxBasisNetRetg, 'N') = 'N' 
				BEGIN
					-- Tax basis is NOT net of retainage.   
					SELECT @oldretgTaxAmt = @oldretainage * @oldtaxrate
					SELECT @glamt = (
										@oldretainage 
										+ CASE @olddbtRetgGLAcct WHEN NULL THEN 0 ELSE @oldretgTaxAmt END
									)
					SELECT @upglacct = @oldretglacct
				END
				ELSE 
				BEGIN
					-- Tax basis IS net of retainage so tax amount is already minus the retg PST/GST tax.
					SELECT @glamt = (
										@oldretainage 
									 )
					SELECT @upglacct = @oldretglacct
				END
			END 
			ELSE -- retainage = 0
			BEGIN
				-- If there is no retainage then taxamt is all open payables
				SELECT @glamt = (@oldretainage)
				SELECT @upglacct = @oldretglacct
			END
			END
		END -- retainage payables	
		
			-- #17041 add offsetting credit to the IN Misc GL acct for burdened costs when Inc(freight)='N' (miscyn=N).
			if @i = 3 and (@oldlinetype = 2 or (@oldlinetype = 6 and @olditemtype = 2)) and @oldburdenyn='Y' and @oldmiscyn='N'
			begin
				select @glamt = @oldmiscamt, @upglacct = @oldlocmiscglacct
			end

			-- add old APGL entry - no intercompany entries will be needed
			if @glamt <> 0
			BEGIN
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @apglco, @upglacct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
				@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @glamt, @apglco, @intercoarglacct, @intercoapglacct, 0, null
			END
			
			-- Retainage PST Tax is broken out into its own payables acct - TK-09243
			IF @i = 2 AND @oldcrdRetgPSTGLAcct IS NOT NULL AND @APCOTaxBasisNetRetg = 'Y' AND @oldretgPstTaxAmt <> 0 -- TK-09243
			BEGIN
				select @glamt = @oldretgPstTaxAmt,@upglacct = @oldcrdRetgPSTGLAcct
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @apglco, @upglacct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
				@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @glamt, @apglco, @intercoarglacct, @intercoapglacct, 0, null
			END
			
			-- CA Holdback GST is broken out into its own payables acct - #136500/#141846
			IF @i = 2 AND @oldcrdRetgGSTGLAcct IS NOT NULL AND @APCOTaxBasisNetRetg = 'Y' AND @oldretgGstTaxAmt <> 0 -- #133107
			begin
				select @glamt = (-1 * @oldretgGstTaxAmt),@upglacct = @oldcrdRetgGSTGLAcct
				exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @apglco, @upglacct, @batchseq, @apline, 0,
				@aptrans, @oldvendorgroup, @oldvendor, @oldsortname, @oldinvdate, @oldapref, @oldtransdesc,
				@oldlinetype, @olditemtype, @oldlinedesc, @oldjcco, @oldjob, @oldphasegroup, @oldphase,
				@oldjcctype, @oldemco, @oldequip, @oldemgroup, @oldcostcode, @oldemctype, @oldinco, @oldloc,
				@oldmatlgroup, @oldmatl, @glamt, @apglco, @intercoarglacct, @intercoapglacct, 0, null
			end


			select @i = @i + 1
			if @i < 4 goto OldGL_loop
		end

		 --Remaining 'New' GL distributions
		if @linetranstype = 'A' or @change = 'Y'
		begin
		select @i = 0

NewGL_loop:
		select @glamt = 0
		-- Discount entry needed in AP GL Co# if updating Net to subledgers
		if @i = 0 and @netamtopt = 'Y' select @glamt = @discount, @upglacct = @discoffglacct
		-- Posted Payables Type - include Misc (if paid to Vendor) and Tax either Sales or VAT
		if @i = 1 
		begin
			-- Sales Tax - retainage is not broken out in Payables posting
			if isnull(@valueadd,'N') = 'N'
			BEGIN
				SELECT @glamt = -1 * (
										@grossamt 
										+ (case @miscyn when 'Y' then @miscamt else 0 end)
										+ (case @taxtype when 1 then @taxamt else 0 end) 
										- @retainage
									 )
				SELECT @upglacct = @apglacct
			END 
	
			-- VAT Tax - retainage tax may be broken out in Payables posting
			IF ISNULL(@valueadd,'N') = 'Y' 
			BEGIN

				BEGIN
					IF isnull(@APCOTaxBasisNetRetg, 'N') = 'N' or @APHBCheckRevYN = 'Y' --#136500/#133107 Check Reversal
					BEGIN
						-- Tax basis is NOT net of retg so back out Retg tax amount
						SELECT  @retgTaxAmt = @retainage * @taxrate
						SELECT @glamt = -1 * (
												@grossamt 
												+ (CASE @miscyn WHEN 'Y' THEN @miscamt ELSE 0 END)
												+ (@taxamt - CASE @dbtRetgGLAcct WHEN NULL THEN 0 ELSE @retgTaxAmt END)
												- @retainage
											 )
					END
					ELSE
					BEGIN
						-- Tax basis IS net of retg so tax amount is already minus the retg tax 
						SELECT @glamt = -1 * (
												@grossamt 
												+ (case @miscyn when 'Y' then @miscamt else 0 end)
												+ @taxamt 
												- @retainage
											  )
					END
				END
				SELECT @upglacct = @apglacct
			END
		end
		
		-- Retainage Payable
		if @i = 2
		begin
			-- retainage does not include GST tax
			if isnull(@valueadd,'N') = 'N' select @glamt = (-1 * @retainage), @upglacct = @retglacct
			-- retainage includes GST tax
			IF isnull(@valueadd,'N') = 'Y'
			BEGIN
				IF @retainage <> 0
				BEGIN
					IF isnull(@APCOTaxBasisNetRetg, 'N') = 'N' 
					BEGIN
						-- Tax basis is NOT net of retg - backout tax amt.   
						SELECT  @retgTaxAmt = @retainage * @taxrate
						SELECT @glamt = -1 * (
												@retainage 
												+ CASE @dbtRetgGLAcct WHEN NULL THEN 0 ELSE @retgTaxAmt END
											 )
						SELECT @upglacct = @retglacct
					END
					ELSE 
					BEGIN
						-- Tax basis IS net of retg so tax amount is already minus the retg PST/GST tax.
						SELECT @glamt = -1 * (@retainage)
						SELECT @upglacct = @retglacct
					END
				END 
				ELSE -- retainage = 0
				BEGIN
					-- If there is no retainage then taxamt is all open payables
					SELECT @glamt = -1 * (@retainage)
					SELECT @upglacct = @retglacct
				END
			END	
		end
		
		-- #17041 add offsetting credit to the IN Misc GL acct for burdened costs when include freight = 'N'.
		if @i = 3 and (@LineType = 2 or (@LineType = 6 and @itemtype = 2)) and @burdenyn='Y' and @miscyn='N'
		begin
			select @glamt = -1 * @miscamt, @upglacct = @locmiscglacct
		end

		-- add new APGL entry - no intercompany entries will be needed
		if @glamt <> 0
		BEGIN
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @apglco, @upglacct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @glamt, @apglco, @intercoarglacct, @intercoapglacct, 0, null
		END

		-- Retainage PST Tax is broken out into its own payables acct - TK-09243
		IF @i = 2 AND @crdRetgPSTGLAcct IS NOT NULL AND @APCOTaxBasisNetRetg = 'Y' AND @retgPstTaxAmt <> 0 -- TK-09243
		BEGIN
			select @glamt = -1 * (@retgPstTaxAmt),@upglacct = @crdRetgPSTGLAcct
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @apglco, @upglacct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @glamt, @apglco, @intercoarglacct, @intercoapglacct, 0, null
		END

		-- Retainage GST Tax is broken out into its own payables acct - #136500/#141846
		IF @i = 2 AND @crdRetgGSTGLAcct IS NOT NULL AND @APCOTaxBasisNetRetg = 'Y' AND @retgGstTaxAmt <> 0 -- #133107
		begin
			select @glamt = -1 * (@retgGstTaxAmt),@upglacct = @crdRetgGSTGLAcct
			exec @rcode = bspAPLBValGLInsert @apco, @mth, @batchid, @apglco, @upglacct, @batchseq, @apline, 1,
			@aptrans, @vendorgroup, @vendor, @sortname, @invdate, @apref, @transdesc,
			@LineType, @itemtype, @linedesc, @jcco, @job, @phasegroup, @phase,
			@jcctype, @emco, @equip, @emgroup, @costcode, @emctype, @inco, @loc,
			@matlgroup, @matl, @glamt, @apglco, @intercoarglacct, @intercoapglacct, 0, null
		end

		select @i = @i + 1
		if @i < 4 goto NewGL_loop
	end

goto APLB_loop  -- next Line
  
APLB_error:     -- record the validation error and skip to the next line
	exec @rcode = bspHQBEInsert @apco, @mth, @batchid, @errortext, @errmsg output
	if @rcode <> 0 goto bspexit
	goto APLB_loop
  
bspexit:
	if @openAPLB = 1
	begin
		close bcAPLB
		deallocate bcAPLB
	end

	select @errmsg = isnull(@errmsg,'') + char(13) + char(10) --+ '[bspAPLBVal]'
	return @rcode
GO
PRINT N'Refreshing [dbo].[vrvPRCrewEquipSub]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCrewEquipSub]'
GO
PRINT N'Refreshing [dbo].[viFact_INPlantCosts]'
GO
EXEC sp_refreshview N'[dbo].[viFact_INPlantCosts]'
GO
PRINT N'Refreshing [dbo].[brvEMRevenueCost]'
GO
EXEC sp_refreshview N'[dbo].[brvEMRevenueCost]'
GO
PRINT N'Refreshing [dbo].[HREH]'
GO
EXEC sp_refreshview N'[dbo].[HREH]'
GO
PRINT N'Refreshing [dbo].[HREG]'
GO
EXEC sp_refreshview N'[dbo].[HREG]'
GO
PRINT N'Refreshing [dbo].[HRED]'
GO
EXEC sp_refreshview N'[dbo].[HRED]'
GO
PRINT N'Refreshing [dbo].[HRDT]'
GO
EXEC sp_refreshview N'[dbo].[HRDT]'
GO
PRINT N'Refreshing [dbo].[HRAP]'
GO
EXEC sp_refreshview N'[dbo].[HRAP]'
GO
PRINT N'Refreshing [dbo].[EMTF]'
GO
EXEC sp_refreshview N'[dbo].[EMTF]'
GO
PRINT N'Altering [dbo].[bspAPPurge]'
GO


/****** Object:  Stored Procedure dbo.bspbcAPPurge    Script Date: 8/28/99 9:34:04 AM ******/
      ALTER       proc [dbo].[bspAPPurge]
    
      /****************************************************************************************
       * CREATED BY: kb 10/10/97
       * MODIFIED By : kb 8/4/98
       *              GR 07/23/99     -- Modified to use tables instead of views
       *              GG 07/26/99     -- Added Temporary Vendor purge
       *              GR 01/17/00     -- corrected temporary vendor purge
       *              GR 012/12/00    -- modified to scroll through each transaction line instead
       *                                 of just being by each transaction to check for existence before deleting\
       *              kb 10/29/2 - issue #18878 - fix double quotes
       *				MV 08/19/03 - #22086 remove pseudo cursors and old style joins 
   	   *				MV 09/19/03 - #22517 - purge lineless transactions, commented out purge flag for selected vendor
   	   *				MV 02/10/04 - #23691 - close cursors only if they were opened.
       *				MV 12/21/05 - #119693 - don't check for null in @tempandpaidyn
	   *				MV 02/20/07 - #12127 - check for vendor in bAPPH and delete from bAPAA 
	   *				MV 10/23/08 - #126754 - purge Pay History before purging temp vendors
	   *				GF 06/24/2010 - issue #135813 expanded SL to varchar(30)
       *				TRL  07/27/2011  TK-07143  Expand bPO parameters/varialbles to varchar(30)
	   *				GF 02/28/2013 TFS-42481 added option and year to purge ATO annual tax payments
	   *
       *
       * Called by AP Purge program to delete paid transactions, temporary vendors,
       * monthly vendor totals, annual 1099 totals, and/or payment history.
       * Will skip transactions posted to POs or Subcontracts that still exist.
       *
       * INPUT PARAMETERS
       *  @co                     AP Company
       *  @tempandpaidyn          'Y' = purge paid transactions and temporary vendors
       *  @vendorgroup            Vendor Group
       *  @vendor                 Vendor to purge paid transaction - if null, all Vendors where Selective Purge = 'N'
       *  @transmth               Purge through month for transactions - no payments after this month
       *  @vendortotsyn           'Y' = purge vendor activity totals
       *  @vendortotmth           Purge through month for vendor activity totals
       *  @1099totsyn             'Y' = purge 1099 totals
       *  @1099year               Purge through year ending month for 1099 totals
       *  @payhistoryyn           'Y' = purge payment history
       *  @payhistorymth          Purge through month for payment history
       *
       * OUTPUT PARAMETERS
       *  @nothing                0 = something purged, 1 = nothinbg was purged
       *  @msg                    error message
       *
       * RETURN VALUE
       *  @rcode                  0 = success, 1 = failure
       ****************************************************************************************/
          (@co bCompany, @tempandpaidyn bYN = null, @vendorgroup bGroup = null, @vendor bVendor = null,
          @transmth bMonth = null, @vendortotsyn bYN = null, @vendortotmth bMonth = null, @1099totsyn bYN = null,
          @1099year bMonth=null, @payhistoryyn bYN = null, @payhistorymth bMonth = null,
		  ----TFS-42481
		  @ATOPurge bYN = 'N', @ATOTaxYear CHAR(4) = NULL,
          @nothing tinyint output, @msg varchar(255) output)
    
      as
    
      set nocount on
    
      declare @rcode int,  @KeyMonth bMonth, @KeyTrans bTrans, @KeyVendor bVendor, @KeyLine  int,
            @validcnt1 int, @validcnt2 int, @opencursor int, @mth bMonth, @aptrans int, @po varchar(30),
   		 @sl VARCHAR(30), @tempvendor bVendor
    
      select @rcode=0, @nothing=1, @validcnt1=0, @validcnt2=0,@opencursor = 0
    
      -- Paid Transactions and Temporary Vendors
      if @tempandpaidyn ='Y' and @transmth is not null
      	BEGIN
      	if @vendor is null -- all Vendors, except those flagged for selective purge
      	begin
   		-- get transactions to purge  
   		declare bcAPPurge cursor LOCAL FAST_FORWARD for
   		select Mth, APTrans
   			from bAPTH h WITH (NOLOCK)
   			JOIN bAPVM v WITH (NOLOCK) on h.VendorGroup=v.VendorGroup and
   			h.Vendor=v.Vendor
   			WHERE h.APCo=@co and h.Mth <=@transmth and h.OpenYN='N' and v.Purge = 'N'	
   
   		open bcAPPurge
   		select @opencursor = 1
   
   		APPurge_loop:
   		fetch next from bcAPPurge into @mth, @aptrans
   
   		if @@fetch_status <> 0 goto APPurge_end
   
   		-- POs and SLs must be purged before deleting their paid transactions
   		select @po=PO, @sl=SL from bAPTL WITH (NOLOCK) where APCo=@co and Mth=@mth
   			and APTrans=@aptrans and LineType in (6, 7)
   			if @@rowcount > 0
   			begin
   			if @po is not null and exists (select 1 from bPOHD WITH (NOLOCK) where
   				POCo=@co and PO=@po) goto APPurge_loop
   			if @sl is not null and exists (select 1 from bSLHD WITH (NOLOCK) where
   				SLCo=@co and SL=@sl) goto APPurge_loop
   			end
   
   		-- Check for unpaid detail or detail with paid month > transmth 
   		if exists (select top 1 1 from bAPTD WITH (NOLOCK)
   		 	where APCo=@co and Mth=@mth and APTrans=@aptrans and
   			((Status < 3)  or (PaidMth>@transmth)))goto APPurge_loop
   			
   		-- set Purge flag to prevent HQ auditing
      	    update bAPTH set Purge='Y' where APCo=@co and Mth=@mth and APTrans=@aptrans
    		--delete transaction
            delete from bAPTD where APCo=@co and Mth=@mth and APTrans=@aptrans
   			delete from bAPTL where APCo=@co and Mth=@mth and APTrans=@aptrans
   			delete from bAPTH where APCo=@co and Mth=@mth and APTrans=@aptrans
   
   		 if @@rowcount=0  select @nothing=1 else select @nothing=0	
   
   		-- get next transaction
   		goto APPurge_loop	
   		end		
   	
   	
   -- #22086 COMMENTED OUT PSEUDO CURSOR CODING
   --      -- get first Month
   --    		select @KeyMonth=min(Mth) from bAPTH where APCo=@co
   --    		while @KeyMonth is not null
   --    			begin
   --                -- get the first Transaction
   --    			select @KeyTrans=min(l.APTrans) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    				where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    				and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    				and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    				and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 and b.Purge='N'
   --    				/*and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    				bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    				from bSLHD where SLCo=@co)))*/ and (c.APTrans not in (select APTrans from bAPTD
   --    				where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    				PaidMth is null))))
   --  
   --    			while @KeyTrans is not null
   --    				begin
   --              --get the total count on transaction lines
   --              select @validcnt1=Count(*) from bAPTL
   --                  where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  
   --  			--get the first line
   --  				select @KeyLine=min(l.APLine) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    					where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    					and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    					and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    					and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 and b.Purge='N'
   --    					and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    					bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    					from bSLHD where SLCo=@co))) and (c.APTrans not in (select APTrans from bAPTD
   --    					where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    					PaidMth is null)))) and l.APTrans=@KeyTrans
   --  
   --  				while @KeyLine is not null
   --  					begin
   --                 		select @validcnt2=@validcnt2+1
   --  			--get next line
   --  					select @KeyLine=min(l.APLine) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    						where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    						and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    						and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    						and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 and b.Purge='N'
   --    						and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    						bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    						from bSLHD where SLCo=@co))) and (c.APTrans not in (select APTrans from bAPTD
   --    						where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    						PaidMth is null)))) and l.APTrans=@KeyTrans and l.APLine >@KeyLine
   --  					if @@rowcount=0 select @KeyLine=null
   --  					end
   --  
   --                  if @validcnt1=@validcnt2
   --                      begin
   --  			-- set Purge flag to prevent HQ auditing
   --                 	    update bAPTH set Purge='Y' where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  			--delete transaction
   --                      delete from bAPTD where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --    				    delete from bAPTL where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  				    delete from bAPTH where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  
   --    				    if @@rowcount=0  select @nothing=1
   --                  			else select @nothing=0
   --                      end
   --  
   --  		    --set the counters to zero
   --                  select @validcnt1=0, @validcnt2=0
   --  
   --              -- get next Transaction
   --    				select @KeyTrans=min(l.APTrans) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    					where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    					and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    					and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    					and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 and b.Purge='N'
   --    					/*and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    					bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    					from bSLHD where SLCo=@co)))*/ and (c.APTrans not in (select APTrans from bAPTD
   --    					where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    					PaidMth is null)))) and l.APTrans>@KeyTrans
   --    				if @@rowcount=0 select @KeyTrans=null
   --    				end
   --             -- get next Month
   --    			select @KeyMonth=min(Mth) from bAPTH where APCo=@co and Mth>@KeyMonth
   --    			if @@rowcount=0 select @KeyMonth=null
   --    			end
   --    		end
    	-- END COMMENT OUT
   
        -- purge paid transactions for select Vendor
      	if @vendor is not null
      	begin
   		-- get transactions to purge  
   		declare bcAPPurge cursor LOCAL FAST_FORWARD for
   		select Mth, APTrans
   			from bAPTH h WITH (NOLOCK)
   			JOIN bAPVM v WITH (NOLOCK) on h.VendorGroup=v.VendorGroup and
   			h.Vendor=v.Vendor
   			WHERE h.APCo=@co and h.Mth <=@transmth and h.Vendor=@vendor and h.OpenYN='N' /*and v.Purge = 'N' #22517*/
   		open bcAPPurge
   		select @opencursor = 1
   
   		APPurge2_loop:
   		fetch next from bcAPPurge into @mth, @aptrans
   
   		if @@fetch_status <> 0 goto APPurge_end
   
   		-- POs and SLs must be purged before deleting their paid transactions
   		select @po=PO, @sl=SL from bAPTL WITH (NOLOCK) where APCo=@co and Mth=@mth
   			and APTrans=@aptrans and LineType in (6, 7)
   			if @@rowcount > 0
   			begin
   			if @po is not null and exists (select 1 from bPOHD WITH (NOLOCK) where
   				POCo=@co and PO=@po) goto APPurge_loop
   			if @sl is not null and exists (select 1 from bSLHD WITH (NOLOCK) where
   				SLCo=@co and SL=@sl) goto APPurge_loop
   			end
   
   		-- Check for unpaid detail or detail with paid month > transmth 
   		if exists (select top 1 1 from bAPTD WITH (NOLOCK)
   		 	where APCo=@co and Mth=@mth and APTrans=@aptrans and
   			((Status < 3)  or (PaidMth>@transmth)))goto APPurge_loop
   			
   		-- set Purge flag to prevent HQ auditing
      	    update bAPTH set Purge='Y' where APCo=@co and Mth=@mth and APTrans=@aptrans
    		--delete transaction
            delete from bAPTD where APCo=@co and Mth=@mth and APTrans=@aptrans
   		 delete from bAPTL where APCo=@co and Mth=@mth and APTrans=@aptrans
   		 delete from bAPTH where APCo=@co and Mth=@mth and APTrans=@aptrans
   
   		 if @@rowcount=0  select @nothing=1 else select @nothing=0	
   
   		-- loop back for next transaction
   		goto APPurge2_loop
   		end
   
   	APPurge_end:
   		if @opencursor = 1
   		begin   
   			close bcAPPurge
   	    	deallocate bcAPPurge
   	    	select @opencursor = 0
   		end
   
    	-- Purge transactions without lines #22517
   	declare bcAPPurgeNoLines cursor LOCAL FAST_FORWARD for
   		select Mth, APTrans
   			from bAPTH h WITH (NOLOCK)
   			JOIN bAPVM v WITH (NOLOCK) on h.VendorGroup=v.VendorGroup and
   			h.Vendor=v.Vendor
   			WHERE h.APCo=@co and h.Mth <=@transmth and v.Purge = 'N'	
   
   		open bcAPPurgeNoLines
   		select @opencursor = 1
   
   	APPurgeNoLines_loop:
   		fetch next from bcAPPurgeNoLines into @mth, @aptrans
   
   		if @@fetch_status <> 0 goto APPurgeNoLines_end
   
   		select top 1 1 from bAPTL WITH (NOLOCK) where APCo=@co and Mth=@mth and APTrans=@aptrans
   		if @@rowcount = 0
   		begin
   		delete from bAPTH where APCo=@co and Mth=@mth and APTrans=@aptrans
   		if @@rowcount=0  select @nothing=1 else select @nothing=0	
   		end
   
   		goto APPurgeNoLines_loop
   
   	APPurgeNoLines_end:
   		if @opencursor = 1
   		begin   
   			close bcAPPurgeNoLines
   	    	deallocate bcAPPurgeNoLines
   	    	select @opencursor = 0
   		end
   
   	END -- End of Paid Transactions and Temporary Vendors
   
   	-- #22086 COMMENTED OUT PSEUDO CURSOR CODING
   --          -- get first month
   --    		select @KeyMonth=min(Mth) from bAPTH where APCo=@co
   --    		while @KeyMonth is not null
   --    			begin
   --              -- get first Transaction
   --    			select @KeyTrans=min(l.APTrans) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    				where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    				and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    				and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   -- 
   --    				and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 --and b.Purge='N'
   --    				/*and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    				bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    					from bSLHD where SLCo=@co)))*/ and (c.APTrans not in (select APTrans from bAPTD
   --    				where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    				PaidMth is null)))) and c.VendorGroup=@vendorgroup and c.Vendor=@vendor
   --  
   --    			while @KeyTrans is not null
   --    				begin
   --                  --get the total count on transaction lines
   --                  select @validcnt1=Count(*) from bAPTL
   --                  where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  
   --  				--get the first line
   --  				select @KeyLine=min(l.APLine) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    					where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    					and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    					and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    					and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 --and b.Purge='N'
   --    					and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    					bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    					from bSLHD where SLCo=@co))) and (c.APTrans not in (select APTrans from bAPTD
   --    					where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    					PaidMth is null)))) and c.VendorGroup=@vendorgroup and c.Vendor=@vendor and l.APTrans=@KeyTrans
   --  
   --  				while @KeyLine is not null
   --  					begin
   --  			        select @validcnt2=@validcnt2+1
   --  			--get next line
   --  					select @KeyLine=min(l.APLine) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    						where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    						and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    						and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    						and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 --and b.Purge='N'
   --    						and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    						bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    						from bSLHD where SLCo=@co))) and (c.APTrans not in (select APTrans from bAPTD
   --    						where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    						PaidMth is null)))) and c.VendorGroup=@vendorgroup and c.Vendor=@vendor
   --  						and l.APTrans=@KeyTrans and l.APLine>@KeyLine
   --  					if @@rowcount=0 select @KeyLine=null
   --  					end
   --  
   --                  if @validcnt1=@validcnt2
   --                      begin
   --                 	    update bAPTH set Purge='Y' where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  			     -- delete transaction
   --    				  delete from bAPTD where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans    --and APLine=@KeyLine
   --    				  delete from bAPTL where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans    --and APLine=@KeyLine
   --  				  delete from bAPTH where APCo=@co and Mth=@KeyMonth and APTrans=@KeyTrans
   --  
   --    				    if @@rowcount=0  select @nothing=1
   --                  			else select @nothing=0
   --                      end
   --  
   --                   --set the counters to zero
   --                      select @validcnt1=0, @validcnt2=0
   --  
   --                  -- get next Transaction
   --    				select @KeyTrans=min(l.APTrans), @KeyLine=min(l.APLine) from bAPTH c, bAPTL l, bAPTD d, bAPVM b
   --    					where c.APCo=d.APCo and c.Mth=d.Mth and c.APTrans=d.APTrans
   --    					and c.APCo=l.APCo and c.Mth=l.Mth and c.APTrans=l.APTrans
   --    					and b.VendorGroup=c.VendorGroup and b.Vendor=c.Vendor
   --    					and d.APCo=@co and d.Mth=@KeyMonth and d.Status>=3 --and b.Purge='N'
   --    					/*and (l.LineType<6 or (l.LineType=6 and l.PO not in (select PO from
   --    					bPOHD where POCo=@co)) or (l.LineType=7 and l.SL not in (select SL
   --    					from bSLHD where SLCo=@co)))*/ and (c.APTrans not in (select APTrans from bAPTD
   --    					where APCo=@co and Mth=@KeyMonth and (Status<3 or (PaidMth>@transmth or
   --    					PaidMth is null)))) and l.APTrans>@KeyTrans and c.VendorGroup=@vendorgroup
   --    					and c.Vendor=@vendor
   --    				if @@rowcount=0 select @KeyTrans=null
   --    				end
   --              -- get next Month
   --    			select @KeyMonth=min(Mth) from bAPTH where APCo=@co and Mth>@KeyMonth
   --    			if @@rowcount=0 select @KeyMonth=null
   --    			end
   --    		end
   --    	end
    -- END COMMENT OUT 
   
-- Purge Payment History
      if @payhistoryyn='Y'
      	begin
          -- update Purge flag to prevent HQ auditing during delete
      	update bAPPH set PurgeYN='Y' where APCo=@co and PaidMth<=@payhistorymth
          -- purge Payment History
   		delete bAPPD from bAPPD p JOIN bAPPH h on p.APCo=h.APCo and p.CMCo=h.CMCo and p.CMAcct=h.CMAcct
      		and p.PayMethod=h.PayMethod and p.CMRef=h.CMRef and p.CMRefSeq=h.CMRefSeq and
      		p.EFTSeq=h.EFTSeq
   		where h.APCo=@co and h.PaidMth <=@payhistorymth
   	 
      	delete bAPPH where APCo=@co and PaidMth<=@payhistorymth
    
      	if @@rowcount=0 and @nothing=1 select @nothing=1              --nothing purged
         else select @nothing=0                                      --something purged
    
      	end
    
     	-- purge Temporary Vendors
     	-- Skip Vendors that have any bAPTH, bPOHD, bSLHD, bAPRH, bAPPH entries in any AP Co#
     	select @vendorgroup = VendorGroup from bHQCO WITH (NOLOCK) where HQCo = @co
   		declare bcTempPurge cursor LOCAL FAST_FORWARD for
   		select Vendor from bAPVM WITH (NOLOCK) WHERE VendorGroup = @vendorgroup and TempYN = 'Y'
   
   		open bcTempPurge
   		select @opencursor = 1
   
   	APTempPurge_loop:
   		fetch next from bcTempPurge into @tempvendor
   
   		if @@fetch_status <> 0 goto APTempPurge_end
   		
   		-- check temp vendor for transactions, POs, SLs, recurring, unapproved, payment history 
   		if exists ( select top 1 1 from bAPTH WITH (NOLOCK) where VendorGroup = @vendorgroup and Vendor=@tempvendor)
   			goto APTempPurge_loop
   		if exists ( select top 1 1 from bPOHD WITH (NOLOCK) where VendorGroup = @vendorgroup and Vendor=@tempvendor)
   			goto APTempPurge_loop
   		if exists ( select top 1 1 from bSLHD WITH (NOLOCK) where VendorGroup = @vendorgroup and Vendor=@tempvendor)
   			goto APTempPurge_loop
   		if exists ( select top 1 1 from bAPRH WITH (NOLOCK) where VendorGroup = @vendorgroup and Vendor=@tempvendor)
   			goto APTempPurge_loop
   		if exists ( select top 1 1 from bAPUI WITH (NOLOCK) where VendorGroup = @vendorgroup and Vendor=@tempvendor)
   			goto APTempPurge_loop
		if exists ( select top 1 1 from bAPPH WITH (NOLOCK) where VendorGroup = @vendorgroup and Vendor=@tempvendor)
   			goto APTempPurge_loop
   
   		-- remove Vendor 1099 Totals
         	delete bAPFT where VendorGroup = @vendorgroup and Vendor = @tempvendor
         	-- remove Vendor Activity
         	delete bAPVA where VendorGroup = @vendorgroup and Vendor = @tempvendor
         	-- remove Vendor Compliance
         	delete bAPVC where VendorGroup = @vendorgroup and Vendor = @tempvendor
         	-- remove Vendor Hold Codes
         	delete bAPVH where VendorGroup = @vendorgroup and Vendor = @tempvendor
         	-- remove Addtional Addresses
         	delete bAPAA where VendorGroup = @vendorgroup and Vendor = @tempvendor
			-- remove Vendor Master
         	delete bAPVM where VendorGroup = @vendorgroup and Vendor = @tempvendor
         	if @@rowcount=0 and @nothing=1 select @nothing=1              --nothing purged
         	else select @nothing=0                                        --something purged
    
   		-- loop back for next temp vendor
   		goto APTempPurge_loop
   
   	APTempPurge_end:
   		if @opencursor = 1
   		begin   
   			close bcTempPurge
   	    	deallocate bcTempPurge
   	    	select @opencursor = 0	
   		end
   
   
   /* #22086  - COMMENTED OUT PSEUDO CURSOR CODING
     select @KeyVendor=min(Vendor) from bAPVM where VendorGroup = @vendorgroup and TempYN = 'Y'
         and Vendor not in (select distinct Vendor from bAPTH where VendorGroup = @vendorgroup)
    
         and Vendor not in (select distinct Vendor from bPOHD where VendorGroup = @vendorgroup)
         and Vendor not in (select distinct Vendor from bSLHD where VendorGroup = @vendorgroup)
     and Vendor not in (select distinct Vendor from bAPRH where VendorGroup = @vendorgroup)
    
     while @KeyVendor is not null
         begin
         -- remove Vendor 1099 Totals
         delete bAPFT where VendorGroup = @vendorgroup and Vendor = @KeyVendor
         -- remove Vendor Activity
         delete bAPVA where VendorGroup = @vendorgroup and Vendor = @KeyVendor
         -- remove Vendor Compliance
         delete bAPVC where VendorGroup = @vendorgroup and Vendor = @KeyVendor
         -- remove Vendor Hold Codes
         delete bAPVH where VendorGroup = @vendorgroup and Vendor = @KeyVendor
         -- remove Vendor Master
         delete bAPVM where VendorGroup = @vendorgroup and Vendor = @KeyVendor
   t=0 and @nothing=1 select @nothing=1              --nothing purged
         else select @nothing=0                                        --something purged
    
         -- get next Vendor
         select @KeyVendor=min(Vendor) from bAPVM where VendorGroup = @vendorgroup and TempYN = 'Y'
             and Vendor not in (select distinct Vendor from bAPTH where VendorGroup = @vendorgroup)
             and Vendor not in (select distinct Vendor from bPOHD where VendorGroup = @vendorgroup)
             and Vendor not in (select distinct Vendor from bSLHD where VendorGroup = @vendorgroup)
             and Vendor not in (select distinct Vendor from bAPRH where VendorGroup = @vendorgroup)
    
         if @@rowcount=0 select @KeyVendor=null
         end
   */ --END COMMENT OUT
    
      -- Purge Vendor Activity
      if @vendortotsyn='Y'
      	begin
      	delete bAPVA where APCo=@co and Mth<=@vendortotmth
    
      	if @@rowcount=0 and @nothing=1 select @nothing=1              --nothing purged
        else select @nothing=0                                        --something purged
    
      	end
    
      -- Purge Vendor 1099 Totals
      if @1099totsyn='Y'
      	begin
      	delete bAPFT where APCo=@co and YEMO<=@1099year
    
      	if @@rowcount=0 and @nothing=1 select @nothing=1              --nothing purged
        else select @nothing=0                                        --something purged
    
      	end



---- TFS-42481 Purge Annual Tax Payment History
IF @ATOPurge = 'Y'
	BEGIN
    
	---- delete tax payments
	BEGIN TRY
    
		---- start a transaction, commit after fully processed
		BEGIN TRANSACTION;
  
		---- delete ATO payee data
		DELETE FROM dbo.vAPAUPayeeTaxPaymentATO WHERE APCo = @co AND TaxYear = @ATOTaxYear

		---- delete ATO payer data
		DELETE FROM dbo.vAPAUPayerTaxPaymentATO WHERE APCo = @co AND TaxYear = @ATOTaxYear

		if @@rowcount=0 and @nothing=1 select @nothing=1              --nothing purged
			else select @nothing=0                                    --something purged

		---- insert for payee payments has completed. commit transaction
		COMMIT TRANSACTION;

	END TRY
	BEGIN CATCH
		-- Test XACT_STATE:
			-- If 1, the transaction is committable.
			-- If -1, the transaction is uncommittable and should 
			--     be rolled back.
			-- XACT_STATE = 0 means that there is no transaction and
			--     a commit or rollback operation would generate an error.
		IF XACT_STATE() <> 0
			BEGIN
			ROLLBACK TRANSACTION
			SET @msg = CAST(ERROR_MESSAGE() AS VARCHAR(200)) 
			SET @rcode = 1
			END
	END CATCH

	END




bspexit:
	return @rcode



GO
PRINT N'Refreshing [dbo].[vrvPRCrewNonJobEarnings]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCrewNonJobEarnings]'
GO
PRINT N'Refreshing [dbo].[viFact_JCCompanySecureUsers]'
GO
EXEC sp_refreshview N'[dbo].[viFact_JCCompanySecureUsers]'
GO
PRINT N'Refreshing [dbo].[EMChangeEquipEMCoCol]'
GO
EXEC sp_refreshview N'[dbo].[EMChangeEquipEMCoCol]'
GO
PRINT N'Refreshing [dbo].[brvEMTax]'
GO
EXEC sp_refreshview N'[dbo].[brvEMTax]'
GO
PRINT N'Refreshing [dbo].[PRLD]'
GO
EXEC sp_refreshview N'[dbo].[PRLD]'
GO
PRINT N'Altering [dbo].[bspEMBFRevBdownVal]'
GO



ALTER       procedure [dbo].[bspEMBFRevBdownVal]
/***********************************************************
* CREATED BY: 	 bc 02/08/99
* MODIFIED By : bc 04/17/01  for issue 13107  Added addtional code for std rate and
*                             modified calcuation when rate is overridden
*               bc 05/03/01 - if EMRH.ORideFlag = 'N' then send the code-flow into EMRR_Catgy
*                             for the breakdowncode information
*	 JM 5-13-02 Ref Issue 17259 - @base_rate can be 0 causing a division by zero error;
*		see approx line 432.
*	 TV 02/11/04 - 23061 added isnulls
*	 TV 07/12/2005 - issue 29254 - Allow Deptartment and Category to be Null.
*				GF 01/18/2013 TK-20836 when creating old entries use EMBR for value to back out
*				GF 04/04/2013 TFS-46093 NS 42471 get old GLCo for old transactions if needed.
*
*
*	 
* USAGE:  Called to validate revenue breakdown code(s) for a piece of equipement
*	and processes any gl accounts accociated with the revenue breakdown code in the
*	department table into EMBC for inserting or updating EMGL back in EMBFUsageVal
*
* For a change to an existing transaction, the old values will come from EMRB for the breakdown
* codes. This will be the revenue code, breakdown code, amount, GL Company, and GL Account. All
* other information will derive based on the current EM setup.
*
*
* INPUT PARAMETERS
*	@co  		mbtkFormCo
*	@emgroup
*	@batchid
*	@seq
*	@mth
*	@dept 		department of the equipment doing the work
*	@revcode
* 	@equip		equipment doing the work
*	@catgy		of the equipment doing the work
* 	@jcco		job company that the equip is working for
*	@job		job the equipment is assigned to
*	@transtype	J, E, X or W
*	@revrate	rate input from the entry form
*	@oldnew		if the value = 1 then the entry is new and treated accordingly in the code
*			if the vaule = 0 then the entry is old and the input parameters should represent
*			the previous values posted as well as reverse the rates that are inserted into EMBC.
*	@post_to_gl	if 'Y' that means that there is not a revenue code set up in EMDR for this trans,
*			meaning the Revenue Breakdown code is going to drive the GL distribution.
*			if 'N' then Revenue Codes drive GL but we still come in here for
*			the rate amounts for posting to EMRB.
*
*
* OUTPUT PARAMETERS
*   @errmsg     if something went wrong.  ie  @errorcount > 0
* RETURN VALUE
*   0   success
*   1   fail
*****************************************************/
(@co bCompany, @emgroup bGroup, @batchid bBatchID, @seq int, @mth bMonth, @dept bDept, @revcode bRevCode,
 @equip bEquip, @catgy bCat, @jcco bCompany = null, @job bJob = null, @transtype char(1),
 @revrate bDollar, @oldnew tinyint, @post_to_gl bYN,
 ----TK-20836
 @OldRevTotal bDollar = 0,
 @emtrans bTrans = NULL,
 @errmsg varchar(255) OUTPUT)
as
set nocount on
   
declare @rcode int, @cnt int, @transacct bGLAcct, @revbdowncode varchar(10), @bdown_rate bDollar,
		@bdown_glco bCompany, @revtemp varchar(10), @base_rate bDollar, @running_total bDollar,
		@rate_diff bDollar, @errortext varchar(255), @errorstart varchar(50), @errorcount int,
		@typeflag char(1), @oriderate bYN
		----TK-20836
		,@OldRevBDownTotal bDollar
   
select @rcode = 0, @cnt = 0, @running_total = 0, @errorcount = 0

select @errorstart = 'Seq#' + isnull(convert(varchar(6),@seq),'')

----TFS-46093
DECLARE @oldglco bCompany
SELECT @oldglco = GLCo
FROM dbo.bEMCO
WHERE EMCo = @co
IF @@ROWCOUNT = 0 SET @oldglco = @co


---- TK-20836 IF PROBLEM OCCURS CREATEING OUT OLD BREAKDOWN CODE DISTRIBUTION
---- THIS SECTION CAN BE REMMED OUT. OF COURSE, THEN WE WILL USING NEW REVENUE
---- BREAKDOWN SETUP WHICH MAY RESULT IN INCORRECT ACCOUNTS AND AMOUNTS.
IF @oldnew = 0
	BEGIN
	---- reverse the old revenue total
	SET @OldRevTotal = -(@OldRevTotal)

	---- log error for missing EM Transaction
	IF @emtrans IS NULL
		BEGIN      
		SELECT @errmsg = ' - missing EM Transaction for Batch Sequence.'
		SELECT @errorcount = @errorcount + 1
		SELECT @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
       	EXEC @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
		if @rcode <> 0 goto bspexit
		END

	---- insert old records from EMRB join EMDB for GLAccount if not in EMRB  
	INSERT INTO dbo.bEMBC(EMCo, Mth, BatchId, BatchSeq, OldNew, EMGroup, EMTrans, Equipment, RevBdownCode,
					RevCode, GLCo, Account, BdownRate)
	SELECT @co, @mth, @batchid, @seq, 0, @emgroup, @emtrans, EMRB.Equipment, EMRB.RevBdownCode,
					----TFS-46093
					EMRB.RevCode, ISNULL(EMRB.GLCo, @oldglco), ISNULL(EMRB.Account, EMDB.GLAcct), -(EMRB.Amount)
	FROM dbo.bEMRB EMRB WITH (NOLOCK)
	LEFT JOIN dbo.bEMDB EMDB WITH (NOLOCK) ON EMDB.EMCo=EMRB.EMCo AND EMDB.Department=@dept AND EMDB.EMGroup=EMRB.EMGroup AND EMDB.RevBdownCode=EMRB.RevBdownCode
	WHERE EMRB.EMCo = @co
		AND EMRB.Mth = @mth
		AND EMRB.Trans = @emtrans

		

	---- NEED TO VALIDATE THAT THE SUM OF OLD REVENUE BREAKDOWN CODES EQUAL THE OLD REVENUE VALUE
	---- IF NOT THEN THE FIRST BREAKDOWN SHOULD BE UPDATED WITH THE DIFFERENCE.
	---- SHOULD NEVER HAPPEN, BUT WE DO NOT WANT THE OLD DEBITS <> OLD CREDITS
	SET @OldRevBDownTotal = 0
	SELECT @OldRevBDownTotal = SUM(ISNULL(BdownRate,0))
	FROM dbo.bEMBC
	WHERE EMCo = @co
		AND Mth = @mth
		AND BatchId = @batchid
		AND BatchSeq = @seq
		AND OldNew = 0

	IF @OldRevBDownTotal IS NULL SET @OldRevBDownTotal = 0
	IF @OldRevTotal IS NULL SET @OldRevTotal = 0
	---- old revenue breakdown total <> old revenue total adjust first revenue breakdown code
	IF @OldRevBDownTotal <> @OldRevTotal
		BEGIN
		UPDATE t
			SET t.BdownRate = t.BdownRate + (@OldRevTotal - @OldRevBDownTotal)      
		FROM (SELECT TOP 1 *
			  FROM dbo.bEMBC
			  WHERE EMCo = @co
				AND Mth = @mth
				AND BatchId = @batchid
				AND BatchSeq = @seq
				AND OldNew = 0
			  ORDER BY RevBdownCode ASC) t
		END
 

	---- validate old GL Accounts 
	---- when flag is 'Y' then the revenue breakdown codes will drive the GL distributions
	IF @post_to_gl = 'Y'
		BEGIN
		---- spin through the revenue breakdown codes and validate GL Accounts
		SELECT @revbdowncode = MIN(RevBdownCode)
		FROM dbo.bEMBC
		WHERE EMCo = @co
			AND Mth = @mth
			AND BatchId = @batchid
			AND BatchSeq = @seq
			AND OldNew = 0

		WHILE @revbdowncode IS NOT NULL
			BEGIN
			---- get GL info
			SET @bdown_glco = NULL
			SET @transacct = NULL
			SELECT @bdown_glco = GLCo,
					@transacct = Account
			FROM dbo.bEMBC
			WHERE EMCo = @co
				AND Mth = @mth
				AND BatchId = @batchid
				AND BatchSeq = @seq
				AND OldNew = 0
				AND RevBdownCode = @revbdowncode

			---- log error for missing GL Account
			IF @transacct IS NULL
				BEGIN      
				SELECT @errmsg = ' - the Old Revenue Breakdown Code: ' + dbo.vfToString(@revbdowncode) +
   								 ' for Revenue Code: ' + dbo.vfToString(@revcode) +
								 ' is not set up in Department: ' + dbo.vfToString(@dept) +
   								 ' for Equipment: ' + dbo.vfToString(@equip)
				SELECT @errorcount = @errorcount + 1
				SELECT @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
       			EXEC @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
				if @rcode <> 0 goto bspexit
				END
            ELSE
				BEGIN
				---- validate old GL Account              
				EXEC @rcode = bspGLACfPostable @bdown_glco, @transacct, 'E', @errmsg output
				if @rcode <> 0
					BEGIN
					SELECT @errorcount = @errorcount + 1
					SELECT @errortext = dbo.vfToString(@errorstart) +
								' - the Old Revenue Breakdown Code: ' + dbo.vfToString(@revbdowncode) + 
								': GL Account: ' + dbo.vfToString(@transacct) +
								': ' + dbo.vfToString(@errmsg)
					EXEC @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					IF @rcode <> 0 goto bspexit
					END
				END                  

			---- next revenue breakdown code
			SELECT @revbdowncode = MIN(RevBdownCode)
			FROM dbo.bEMBC
			WHERE EMCo = @co
				AND Mth = @mth
				AND BatchId = @batchid
				AND BatchSeq = @seq
				AND OldNew = 0
				AND RevBdownCode > @revbdowncode
			END

		END ---- end IF @post_to_gl = 'Y'

	END	---- end IF @oldnew = 0

---- done with old entries
IF @oldnew = 0 GOTO bspexit



SET @revbdowncode = NULL
SET @bdown_glco = NULL
SET @transacct = NULL

/* Get the base value of the revenue rate from EMRR */
select @base_rate = min(Rate)
from bEMRR
where EMCo = @co and EMGroup = @emgroup and isnull(Category,'') = isnull(@catgy,'') and RevCode = @revcode

/* get the offset acct(s) for EMGL based on the department revenue bdown code(s) */
if @transtype = 'J'
    BEGIN
   
     /* Check to see if there is a template set up for this job */
     select @revtemp = RevTemplate
     from bEMJT
     where EMCo = @co and JCCo = @jcco and Job = @job
   
     if @revtemp is not null
     /* check to see if the RevCode passed in is used in this template */
       BEGIN
   
       select @typeflag = TypeFlag
       from bEMTH
       where EMCo = @co and RevTemplate = @revtemp
   
       select @cnt = count(*)
       from bEMTE
       where EMCo = @co and RevTemplate = @revtemp and Equipment = @equip and EMGroup = @emgroup and RevCode = @revcode
   
       if @cnt = 1
       /* the RevCode is setup in this template */
         Begin
   
         if @typeflag = 'O'
           begin
           select @base_rate = Rate
           from bEMTE
           where EMCo = @co and RevTemplate = @revtemp and Equipment = @equip and EMGroup = @emgroup and RevCode = @revcode
           end
   
   
         /* spin through the rev bdown codes for this Equip/RevCode/Template.
            if they are all valid in the department table then insert information into EMBC */
         select @revbdowncode = min(RevBdownCode)
         from bEMTF
         where EMCo = @co and EMGroup = @emgroup and RevTemplate = @revtemp and Equipment = @equip and
          	    RevCode = @revcode
   
         while @revbdowncode is not null
           Begin --3
           select @bdown_glco = null, @transacct = null
           select @bdown_glco = GLCo, @transacct = GLAcct
           from bEMDB
           where EMCo = @co and isnull(Department,'') = isnull(@dept,'') and EMGroup = @emgroup and RevBdownCode = @revbdowncode
   
           if @post_to_gl = 'Y'
             begin
             if @transacct is null
               begin
               select @errmsg = ' - In the equipment job template ' + isnull(@revtemp,'') + ', the RevBdownCode ' + isnull(@revbdowncode,'') +
   			   ' for revenue code ' + isnull(@revcode,'') + ' is not set up in department ' + isnull(@dept,'') +
   			   ' for equipment ' + isnull(@equip,'')
   	        select @errorcount = @errorcount + 1
               select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
       	    exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
               if @rcode <> 0 goto bspexit
   
               goto loop1
   	        end
   
             exec @rcode = bspGLACfPostable @bdown_glco, @transacct, 'E', @errmsg output
             if @rcode <> 0
               begin
               select @errorcount = @errorcount + 1
               select @errortext = isnull(@errorstart,'') + '- GLAcct:' + isnull(@transacct,'') + ':  ' + isnull(@errmsg,'')
               exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
               if @rcode <> 0 goto bspexit
       	    goto loop1
       	    end
             end
   
           select @bdown_rate = Rate
           from bEMTF
           where EMCo = @co and EMGroup = @emgroup and RevTemplate = @revtemp and Equipment = @equip and
                 RevCode = @revcode and RevBdownCode = @revbdowncode
   
           insert into bEMBC(EMCo, Mth, BatchId, BatchSeq, OldNew, EMGroup, Equipment, RevBdownCode, RevCode,
                             GLCo, Account, BdownRate)
           values(@co, @mth, @batchid, @seq, @oldnew, @emgroup, @equip, @revbdowncode, @revcode,
					----TFS-46093
                  ISNULL(@bdown_glco, @oldglco), @transacct, case @oldnew when 1 then @bdown_rate else -(@bdown_rate) end)
   
           loop1:
           select @revbdowncode = min(RevBdownCode)
           from bEMTF
           where EMCo = @co and EMGroup = @emgroup and RevTemplate = @revtemp and Equipment = @equip and
                 RevCode = @revcode and RevBdownCode > @revbdowncode
           end
         End
   
       /* check category template for revenue breakdown codes */
       Else
         Begin
   
         select @cnt = count(*)
         from bEMTC
         where EMCo = @co and RevTemplate = @revtemp and isnull(Category,'') = isnull(@catgy,'') and EMGroup = @emgroup and RevCode = @revcode
   
         if @cnt = 1
           /* the RevCode is set up for this template */
           begin
   
           if @typeflag = 'O'
             begin
             select @base_rate = Rate
             from bEMTC
             where EMCo = @co and RevTemplate = @revtemp and isnull(Category,'') = isnull(@catgy,'') and EMGroup = @emgroup and RevCode = @revcode
             end
   
           /* spin through the rev bdown codes for this Catgy/RevCode/Template.
              if they are all valid in the department table then insert information into EMBC */
           select @revbdowncode = min(RevBdownCode)
           from bEMTD
           where EMCo = @co and EMGroup = @emgroup and RevTemplate = @revtemp and isnull(Category,'') = isnull(@catgy,'') and
           	    RevCode = @revcode
   
           while @revbdowncode is not null
             begin
             select @bdown_glco = null, @transacct = null
             select @bdown_glco = GLCo, @transacct = GLAcct
             from bEMDB
             where EMCo = @co and isnull(Department,'') = isnull(@dept,'') and EMGroup = @emgroup and RevBdownCode = @revbdowncode
   
             if @post_to_gl = 'Y'
               begin
               if @transacct is null
                 begin
                 select @errmsg = ' - In the category job template ' + isnull(@revtemp,'') + ', the RevBdownCode ' + isnull(@revbdowncode,'') +
    			     ' for revenue code ' + isnull(@revcode,'') + ' is not set up in department ' + isnull(@dept,'') +
   			     ' for equipment ' + isnull(@equip,'')
   
                 select @errorcount = @errorcount + 1
                 select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
       	      exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                 if @rcode <> 0 goto bspexit
    	          goto loop2
                 end
   
               exec @rcode = bspGLACfPostable @bdown_glco, @transacct, 'E', @errmsg output
     	        if @rcode <> 0
       	      begin
       	      select @errorcount = @errorcount + 1
       	      select @errortext = isnull(@errorstart,'') + '- GLAcct:' + isnull(@transacct,'') + ':  ' + isnull(@errmsg,'')
     	          exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
       	      if @rcode <> 0 goto bspexit
   
                 goto loop2
       	      end
               end
   
             select @bdown_rate = Rate
   	      from bEMTD
             where EMCo = @co and EMGroup = @emgroup and RevTemplate = @revtemp and isnull(Category,'') = isnull(@catgy,'') and
   	        RevCode = @revcode and RevBdownCode = @revbdowncode
   
             insert into bEMBC(EMCo, Mth, BatchId, BatchSeq, OldNew, EMGroup, Equipment, RevBdownCode, RevCode,
                			    GLCo, Account, BdownRate)
             values(@co, @mth, @batchid, @seq, @oldnew, @emgroup, @equip, @revbdowncode, @revcode,
                    @bdown_glco, @transacct, case @oldnew when 1 then @bdown_rate else -(@bdown_rate) end)
   
             loop2:
   	      select @revbdowncode = min(RevBdownCode)
   	      from bEMTD
             where EMCo = @co and EMGroup = @emgroup and RevTemplate = @revtemp and isnull(Category,'') = isnull(@catgy,'') and
   	            RevCode = @revcode and RevBdownCode > @revbdowncode
   	      end
           end
         End
       END --RevTemplate Not Null
     END -- TransType = 'J'
   
   
   
   /* validate revenue breakdown codes for a revenue code that was not included in a job template */
   select @cnt = count(*)
   from bEMBC
   where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = @oldnew
   
   if @cnt = 0
   BEGIN
     select @cnt = count(*)
     from bEMRH
     where EMCo = @co and EMGroup = @emgroup and Equipment = @equip and RevCode = @revcode
     if @cnt = 1
       /* the RevCode is setup for this piece of equipment */
       Begin
   
       select @oriderate = ORideRate
       from bEMRH
       where EMCo = @co and EMGroup = @emgroup and Equipment = @equip and RevCode = @revcode
   
       /* go get rate and revenue breakdown info from the category set up
          if the EMEH.ORideRate = N */
       if @oriderate = 'N' goto EMRR_Catgy
   
       select @base_rate = Rate
       from bEMRH
       where EMCo = @co and EMGroup = @emgroup and Equipment = @equip and RevCode = @revcode
   
   
       /* spin through the rev bdown codes for this Equip/RevCode.
          if they are all valid in the department table then insert information into EMBC */
       select @revbdowncode = min(RevBdownCode)
       from bEMBE
       where EMCo = @co and EMGroup = @emgroup and Equipment = @equip and RevCode = @revcode
   
       while @revbdowncode is not null
         begin
         select @bdown_glco = null, @transacct = null
         select @bdown_glco = GLCo, @transacct = GLAcct
         from bEMDB
         where EMCo = @co and isnull(Department,'') = isnull(@dept,'') and EMGroup = @emgroup and RevBdownCode = @revbdowncode
   
         if @post_to_gl = 'Y'
           begin
           if @transacct is null
             begin
             select @errmsg = ' - RevBdownCode ' + isnull(@revbdowncode,'') +
   			   ' for revenue code ' + isnull(@revcode,'') + ' is not set up in department ' + isnull(@dept,'') +
   			   ' for equipment ' + isnull(@equip,'')
   
   	      select @errorcount = @errorcount + 1
       	  select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
       	  exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
       	  if @rcode <> 0 goto bspexit
   
    	      goto loop3
   	      end
   
   	    exec @rcode = bspGLACfPostable @bdown_glco, @transacct, 'E', @errmsg output
     	    if @rcode <> 0
       	  begin
       	  select @errorcount = @errorcount + 1
       	  select @errortext = isnull(@errorstart,'') + '- GLAcct:' + isnull(@transacct,'') + ':  ' + isnull(@errmsg,'')
       	  exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
       	  if @rcode <> 0 goto bspexit
       	  goto loop3
       	  end
           end
   
         select @bdown_rate = Rate
         from bEMBE
        where EMCo = @co and EMGroup = @emgroup and Equipment = @equip and RevCode = @revcode and RevBdownCode = @revbdowncode
   
         insert into bEMBC(EMCo, Mth, BatchId, BatchSeq, OldNew, EMGroup, Equipment, RevBdownCode, RevCode,
         			      GLCo, Account, BdownRate)
         values(@co, @mth, @batchid, @seq, @oldnew, @emgroup, @equip, @revbdowncode, @revcode,
				----TFS-46093
         	     ISNULL(@bdown_glco, @oldglco), @transacct, case @oldnew when 1 then @bdown_rate else -(@bdown_rate) end)
   
         loop3:
         select @revbdowncode = min(RevBdownCode)
         from bEMBE
     where EMCo = @co and EMGroup = @emgroup and Equipment = @equip and RevCode = @revcode and RevBdownCode > @revbdowncode
         end
       End
   
     Else
       /* look on the category side */
       Begin
   
       /**********/
       EMRR_Catgy:
       /**********/
   
       select @cnt = count(*)
       from bEMRR
       where EMCo = @co and EMGroup = @emgroup and isnull(Category,'') = isnull(@catgy,'') and RevCode = @revcode
       if @cnt = 1
         begin
   
         /* spin through the rev bdown codes for this Catgy/RevCode.
            if they are all valid in the department table then insert information into EMBC */
         select @revbdowncode = min(RevBdownCode)
         from bEMBG
         where EMCo = @co and EMGroup = @emgroup and isnull(Category,'') = isnull(@catgy,'') and RevCode = @revcode
   
         while @revbdowncode is not null
   	    begin
   	    select @bdown_glco = null, @transacct = null
   	    select @bdown_glco = GLCo, @transacct = GLAcct
   	    from bEMDB
   	    where EMCo = @co and isnull(Department,'') = isnull(@dept,'') and EMGroup = @emgroup and RevBdownCode = @revbdowncode
   
   	    if @post_to_gl = 'Y'
   	    begin
   	      if @transacct is null
   	        begin
   	     select @errmsg = ' - RevBdownCode ' + isnull(@revbdowncode,'') +
   			     ' for revenue code ' + isnull(@revcode,'') + ' is not set up in department ' + isnull(@dept,'') +
   			     ' for equipment ' + isnull(@equip,'')
   
   	        select @errorcount = @errorcount + 1
       	    select @errortext = @errorstart + ' ' + @errmsg
       	    exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
       	    if @rcode <> 0 goto bspexit
   
    	        goto loop4
   	        end
   
   	     exec @rcode = bspGLACfPostable @bdown_glco, @transacct, 'E', @errmsg output
     	     if @rcode <> 0
       	       begin
       	       select @errorcount = @errorcount + 1
       	       select @errortext = isnull(@errorstart,'') + '- GLAcct:' + isnull(@transacct,'') + ':  ' + isnull(@errmsg,'')
       	       exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
       	       if @rcode <> 0 goto bspexit
       	       goto loop4
       	       end
   	    end
   
   	   select @bdown_rate = Rate
   	   from bEMBG
   	   where EMCo = @co and EMGroup = @emgroup and isnull(Category,'') = isnull(@catgy,'') and RevCode = @revcode and RevBdownCode = @revbdowncode
   
         	   insert into bEMBC(EMCo, Mth, BatchId, BatchSeq, OldNew, EMGroup, Equipment, RevBdownCode, RevCode,
         	  			   GLCo, Account, BdownRate)
              values(@co, @mth, @batchid, @seq, @oldnew, @emgroup, @equip, @revbdowncode, @revcode,
             	  @bdown_glco, @transacct, case @oldnew when 1 then @bdown_rate else -(@bdown_rate) end)
   
   	   loop4:
   	   select @revbdowncode = min(RevBdownCode)
   
   	   from bEMBG
   	   where EMCo = @co and EMGroup = @emgroup and isnull(Category,'') = isnull(@catgy,'') and RevCode = @revcode and RevBdownCode > @revbdowncode
   	   end
   	end
   	else
   
   	/* the revenue side is not set up for this piece of equipment */
   	  begin
         select @errorcount = @errorcount + 1
   	  select @errmsg = 'There are no revenue breakdown code rates set up by equipment or category for equipment ' + isnull(@equip,'')
   	  select @errortext = isnull(@errorstart,'') + ' - ' + isnull(@errmsg,'')
         exec @rcode = bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
         if @rcode <> 0 goto bspexit
   	  goto bspexit
   	  end
     end
   END
   
   /* calculate breakdown rates for an override (or underride) of EMRR standard rate.
      if, for some reason, there is a remainder amount after all the revbdowncodes have been processed
      then update the last revbdown code account with whatever is left */
   
   if @revrate <> @base_rate
     Begin
   
     select @revbdowncode = min(RevBdownCode)
     from bEMBC
     where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = @oldnew
   
     while @revbdowncode is not null
       /* loop through the rates in EMBC and + or - them in proportion to how much over or under the
          revrate is compared to the standard rate in EMRR */
       begin
       select @bdown_rate = BdownRate
       from bEMBC
       where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and
       	  RevBdownCode = @revbdowncode and OldNew = @oldnew
   
       /* magical calculation for percentage of posting overrides */
       -- JM 5-13-02 Ref Issue 17259 - @base_rate can be 0 causing a division by zero error
       if @base_rate = 0
   	select @bdown_rate = 0
       else
   	select @bdown_rate = (@bdown_rate/@base_rate) * @revrate
   
   
       select @running_total = @running_total + @bdown_rate
   
       Update bEMBC
       Set BdownRate = @bdown_rate
       where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and
       	  RevBdownCode = @revbdowncode and OldNew = @oldnew
   
       select @revbdowncode = min(RevBdownCode)
       from bEMBC
       where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and
       	  OldNew = @oldnew and RevBdownCode > @revbdowncode
   
       end
   
     /* throw any remainder into last bdown code */
     select @revrate = case @oldnew when 1 then @revrate else -(@revrate) end
     if @running_total <> @revrate
       begin
       select @rate_diff = @revrate - @running_total
       select @revbdowncode = max(RevBdownCode)
       from bEMBC
       where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = @oldnew

   
       update bEMBC
       set BdownRate = BdownRate + @rate_diff
       where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and
       	  RevBdownCode = @revbdowncode and OldNew = @oldnew
       end
     End
   
   bspexit:
   
   	if @errorcount > 0 select @rcode = 1
   	if @rcode<>0 select @errmsg=isnull(@errmsg,'')
   	return @rcode


GO
PRINT N'Refreshing [dbo].[vrvPRCrewOtherJob]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCrewOtherJob]'
GO
PRINT N'Refreshing [dbo].[EMLM]'
GO
EXEC sp_refreshview N'[dbo].[EMLM]'
GO
PRINT N'Refreshing [dbo].[viFact_JCDetail]'
GO
EXEC sp_refreshview N'[dbo].[viFact_JCDetail]'
GO
PRINT N'Refreshing [dbo].[DDDSPurge]'
GO
EXEC sp_refreshview N'[dbo].[DDDSPurge]'
GO
PRINT N'Refreshing [dbo].[EMEMCompOfEquip]'
GO
EXEC sp_refreshview N'[dbo].[EMEMCompOfEquip]'
GO
PRINT N'Refreshing [dbo].[brvEquipSTDMtnGrpItemWOCnt]'
GO
EXEC sp_refreshview N'[dbo].[brvEquipSTDMtnGrpItemWOCnt]'
GO
PRINT N'Altering [dbo].[bspEMBFVal_Usage]'
GO





ALTER  procedure [dbo].[bspEMBFVal_Usage]
/***********************************************************
 * CREATED: 	bc 01/28/99
 * MODIFIED: bc 10/16/00- changed which bsp validates the Employee
 *           mv 04/10/01- Issue # 12062 - allow posting to down equipment
 *           bc 05/29/01 - added @phase as input parameter to bspEMUsageGlacctDflt
 *           bc 05/30/01 - added case statment to EMJC insert for old records to adhere to the JCCT.TrackHours flag
 *	        JM 08/02/01 - Ref Issue 14068 - Added validation of PRCo before its first use in validating Employee, approx line 254.
 *           bc 08/14/01 - Validate the Expense GLCo when it's different than the FormCo's GLCo
 *        	bc 02/09/02 - issue # 16232
 *           bc 03/19/02 - issue #14415 revisited
 *           JM 04/22/02 - issue #16508 Add JC Distrbution when Hours are not zero and dollars are.
 *           bc 05/16/02 - issue #17385 Add JC Distriution when WorkUnits <> 0 and RevCode Unint Based.
 *           bc 06/03/02 - issue #17541 GL out of balance due to RevBdown Code rounding problem
 *			SR 07/09/02 - issue 17738 added @phasegroup to bspJCVCOSTTYPE
 *           CMW 08/07/02 - issue #18177 - added bspJCVPHASE to validation to pick up inactive entries.
 *           bc 11/04/02 - Needed to correct Cycle 3.  The Revenue Code info should be at the end of the cycle
 *                         and contained in an If ... Then statement depending on @transacct.  
 *                         EMBC calculations should always be computed.
 *			RM 10/02/02 - issue #18613 Fixed not posting work units.
 *           TV 12/10/03 - issue 23061 - Isnulls and dbo.
 *			TV 3/11/04 22518 - If user is applying TotalOnly (with no units) then rev Dollars should be used	
 *			TV 05/12/04 24311 - Added auto usage flag
 *			TV 08/03/04 25252 - needed to compare new vs old
 *			TV 11/16/04 24034  - Insert PRCrew into EMJC
 *			TV 07/12/2005 - issue 29254 - Allow Deptartment and Category to be Null.
 *			TV 08/15/05 28474- EM Usage Post: Cannot enter Cost Detail/ trigger errorInactive Cost Type
 *			TV 09/22/05 29478 - Need to validate Cost Code on EM Usage imports, make sure it's set up
 *			TV 10/11/05 - 29989 Batch validation needs to catch invalid GL Acct.
 *			DANF 06/13/07 - 124114 Remove Automatic GL on Usage
 *			TJL 12/18/07 - Issue #29824, Provide Greater detail relative to New/Old Phase and CostType validation errors
*			GF 01/19/2008 - issue #125146 add @@rowcount checks to update statements for bEMBC and bEMGL to throw batch error.
 *			GP 05/13/2008 - Issue #124391 added error check for Work Orders that have Inactive items.
*			GF 06/06/2008 - issue #128555 added validate RevCode in EMRR based upon Category of Used/Usage Equipment
*			GF 07/02/2008 - issue #128793 added check for cycle = 3 when updating breakdown total only when @transacct is null
*			GF 08/12/2008 - issue #129385 do not check rowcount when updating bEMGL when trans account is null.
*			Dan So 08/21/2008 - Issue #129426 - NULL out CostCode(EMCostCode in EMRD) and EMCOstType when EMTransType = J or X
*			TJL 03/24/09 - Issue #132867 - ANSI Null evaluating FALSE instead of TRUE
*			TRL 06/30/09 - Issue 133140 - changed @parameter for getting Transaction GL Account
*			TRL 06/30/09 - Issue 135745 - changed @parameter for getting Transaction GL Account
*			GF 10/01/2010 - issue #141031 - use date only function
*			GF 01/21/2013 TK-20836 when creating old entries use EMBR for value to back out
*			GF 04/03/2013 TFS-46093 NS-42471 for old revenue breakdown codes, GLCo may be null set to @oldglco
*
*
*
 * USAGE:
 * Rates are not caluclated here.  If a user imports info into the batch table we
 * will take care of the rate lookup with a completely separate bsp prior to validation.
 *
 * The revenue GL acct(s) are determined solely inside of this routine base on dept, rev code or rev bdown code
 *
 * Errors in batch added to bHQBE using bspHQBEInsert
 * Job distributions added to bEMJC
 * GL Account distributions added to bEMGL
 *
 * GL debit and credit totals must balance.
 *
 * bHQBC Status updated to 2 if errors found, or 3 if OK to post
 *
 * INPUT PARAMETERS
 *   EMCo        EM Co
 *   Month       Month of batch
 *   BatchId     Batch ID to validate
 * OUTPUT PARAMETERS
 *   @errmsg     if something went wrong
 * RETURN VALUE
 *   0   success
 *   1   fail
 *****************************************************/
(@co bCompany, @mth bMonth, @batchid bBatchID, @errmsg varchar(255) output)
as
set nocount on

declare @rcode int, @errortext varchar(255), @source bSource, @tablename char(20),
		@inuseby bVPUserName, @status tinyint, @opencursorEMBF tinyint, @maxopen tinyint,
		@accttype char(1), @itemcount int, @deletecount int, @errorstart varchar(50)

/*EMBF declarations*/
declare @seq int, @batchtranstype char(1), @emtranstype varchar(10), @emtrans bTrans, @emgroup bGroup, @equip bEquip,
		@revcode bRevCode, @costcode bCostCode, @emct bEMCType, @actualdate bDate, @glco bCompany,
		@offsetacct bGLAcct, @prco bCompany, @employee bEmployee, @workorder bWO,
		@woitem bItem, @workum bUM, @timeum bUM, @jcco bCompany, @job bJob, @phasegroup bGroup, @phase bPhase,
		@jcct bJCCType, @revrate bDollar, @revworkunits bUnits, @revtimeunits bUnits, @revdollars bDollar,
		@usedonequipco bCompany, @usedonequipgroup bGroup, @offsetglco bCompany, @usedonequip bEquip,
		@comptype varchar(10), @component bEquip,@prehourmeter bHrs, @currhourmeter bHrs,
		@preodometer bHrs, @currodometer bHrs, @oldemtranstype varchar(10), @oldemgroup bGroup,
		@oldequip bEquip, @oldrevcode bRevCode, @oldcostcode bCostCode, @oldemct bEMCType,
		@oldactualdate bDate, @oldglco bCompany, @oldoffsetacct bGLAcct, @oldprco bCompany,
		@oldemployee bEmployee, @oldworkorder bWO, @oldwoitem bItem, @oldworkum bUM, @oldtimeum bUM,
		@oldjcco bCompany, @oldjob bJob, @oldphasegroup bGroup, @oldphase bPhase, @oldjcct bJCCType,
		@oldrevrate bDollar, @oldrevworkunits bUnits, @oldrevtimeunits bUnits, @oldrevdollars bDollar,
		@oldusedonequipco bCompany, @oldusedonequipgroup bGroup, @oldoffsetglco bCompany,
		@oldusedonequip bEquip, @oldcomptype varchar(10), @oldcomponent bEquip, @oldprehourmeter bHrs,
		@oldcurrhourmeter bHrs, @oldpreodometer bHrs, @oldcurrodometer bHrs, @usegljrnl bJrnl,
		@usegllvl tinyint, @total_Bdown_dist bDollar, @diff bDollar, @save_bdown_code varchar(10),
		@autousage bYN, @prcrew varchar(10), @oldprcrew varchar(10)

/* Miscellaeous declarations */
declare @userateoride bYN, @gloverride bYN, @hoursum bUM,
		@emco_glco bCompany, @emco_prco bCompany, @dept bDept,
		@emem_jcco bCompany, @emem_job bJob, @emem_emct bEMCType, @catgy bCat,
		@compupdatehrs bYN, @compupdatemiles bYN, @attachpostrev bYN,
		@post_work_units bYN, @allow_rate_oride bYN, @rev_basis char(1), @oldrev_basis char(1),
		@jobflag bYN, @grp int, @hrsfactor int, @oldhrsfactor int, @jc_timeunits bUnits,
		@oldjc_timeunits bUnits

declare @transacct bGLAcct, @revbdowncode varchar(10), @base_rate bUnitCost, @bdown_rate bUnitCost,
		@bdown_glco bCompany, @arglacct bGLAcct, @xglco bCompany, @old_xglco bCompany, @apglacct bGLAcct,
		@jcco_glco bCompany, @lastmthsubclsd bMonth

declare @cycle int, @trackhours bYN, @oldtrackhours bYN, @switch_a_roo varchar(15), @parameter char(1)
declare @distglco bCompany, @distglacct bGLAcct, @distamt bDollar, @distequip bEquip
declare @oldtransacct bGLAcct, @olddept bDept, @oldcatgy bCat, @newentry bYN, @oldentry bYN, @changed bYN

select @rcode = 0, @opencursorEMBF = 0, @cycle = 0

/* validate HQ Batch */
exec @rcode = dbo.bspHQBatchProcessVal @co, @mth, @batchid, 'EMRev', 'EMBF', @errmsg output, @status output
if @rcode <> 0
begin
	select @errmsg = @errmsg, @rcode = 1
	goto bspexit
end

if @status < 0 or @status > 3
begin
	select @errmsg = 'Invalid Batch status!', @rcode = 1
	goto bspexit
end

/* set HQ Batch status to 1 (validation in progress) */
update bHQBC set Status = 1
where Co = @co and Mth = @mth and BatchId = @batchid
if @@rowcount = 0
begin
	select @errmsg = 'Unable to update HQ Batch Control status!', @rcode = 1
	goto bspexit
end

/* clear HQ Batch Errors */
delete bHQBE where Co = @co and Mth = @mth and BatchId = @batchid
/* clear GL Distributions Audit */
delete bEMGL where EMCo = @co and Mth = @mth and BatchId = @batchid
/* clear Job Cost Distributions Audit */
delete bEMJC where EMCo = @co and Mth = @mth and BatchId = @batchid
/* clear Revenue Breakdown Audit */
delete bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid
/*clear and refresh HQCC entries */
delete bHQCC where Co = @co and Mth = @mth and BatchId = @batchid

insert into bHQCC(Co, Mth, BatchId, GLCo)
select distinct Co, Mth, BatchId, GLCo 
from bEMBF
where Co=@co and Mth=@mth and BatchId=@batchid

/* get Company info from EMCO */
select @userateoride = UseRateOride, @usegljrnl = UseGLJrnl, @usegllvl = UseGLLvl,
@hoursum = HoursUM, @gloverride = GLOverride, @emco_glco = GLCo, @emco_prco = PRCo
from bEMCO where EMCo = @co

/* JM 1/17/02 - Ref Issue 15605 - Make sure the UseGLJrnl is not null in EMCO if GLLvl > 0 */
if @usegljrnl is null and @usegllvl >0
	begin
	select @errortext = isnull(@errorstart,'') + 'UseGLJrnl may not be null in bEMCO for a Usage transaction'
	exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
	if @rcode <> 0 goto bspexit
	end

-- *********************************************************** --
-- NULL OUT CostCode(EMRD.EMCostCode) AND EMCostType - #129426 --
-- *********************************************************** --
UPDATE bEMBF
   SET CostCode = NULL,
	   EMCostType = NULL
 WHERE Co = @co 
   AND Mth = @mth 
   AND BatchId = @batchid
   AND EMTransType IN ('J','X')

/* declare cursor on EM Batch for validation */
declare bcEMBF cursor for select BatchSeq, Source, BatchTransType, EMTransType, EMTrans, EMGroup, Equipment, RevCode,
		CostCode, EMCostType, ActualDate, GLCo, GLOffsetAcct, PRCo, PREmployee, WorkOrder,
		WOItem, UM, TimeUM, JCCo, Job, PhaseGrp, JCPhase, JCCostType, RevRate,
		RevWorkUnits, RevTimeUnits, RevDollars, RevUsedOnEquipCo, RevUsedOnEquipGroup, OffsetGLCo,
		RevUsedOnEquip, ComponentTypeCode, Component, PreviousHourMeter, CurrentHourMeter, PreviousOdometer, CurrentOdometer,
		OldEMTransType, OldEMGroup, OldEquipment, OldRevCode,
		OldCostCode, OldEMCostType, OldActualDate, OldGLCo, OldGLOffsetAcct, OldPRCo, OldPREmployee, OldWorkOrder,
		OldWOItem, OldUM, OldTimeUM, OldJCCo, OldJob, OldPhaseGrp, OldJCPhase, OldJCCostType, OldRevRate,
		OldRevWorkUnits, OldRevTimeUnits, OldRevDollars, OldRevUsedOnEquipCo, OldRevUsedOnEquipGroup, OldOffsetGLCo,
		OldRevUsedOnEquip, OldComponentTypeCode, OldComponent, OldPreviousHourMeter, OldCurrentHourMeter, OldPreviousOdometer, OldCurrentOdometer,
		AutoUsage, PRCrew, OldPRCrew
from bEMBF 
where Co = @co and Mth = @mth and BatchId = @batchid

/* open cursor */
open bcEMBF
select @opencursorEMBF = 1


get_next_bcEMBF:
fetch next from bcEMBF into @seq, @source, @batchtranstype, @emtranstype, @emtrans, @emgroup, @equip,
		@revcode, @costcode, @emct, @actualdate, @glco, @offsetacct, @prco, @employee, @workorder,
		@woitem, @workum, @timeum, @jcco, @job, @phasegroup, @phase, @jcct, @revrate,
		@revworkunits, @revtimeunits, @revdollars, @usedonequipco, @usedonequipgroup, @offsetglco,
		@usedonequip, @comptype, @component, @prehourmeter, @currhourmeter, @preodometer, @currodometer,
		@oldemtranstype, @oldemgroup, @oldequip, @oldrevcode, @oldcostcode, @oldemct, @oldactualdate,
		@oldglco, @oldoffsetacct, @oldprco, @oldemployee, @oldworkorder,
		@oldwoitem, @oldworkum, @oldtimeum, @oldjcco, @oldjob, @oldphasegroup, @oldphase, @oldjcct,
		@oldrevrate, @oldrevworkunits, @oldrevtimeunits, @oldrevdollars, @oldusedonequipco,
		@oldusedonequipgroup, @oldoffsetglco, @oldusedonequip, @oldcomptype, @oldcomponent,
		@oldprehourmeter, @oldcurrhourmeter, @oldpreodometer, @oldcurrodometer, @autousage,
		@prcrew, @oldprcrew 

/* loop through all rows */
while (@@fetch_status = 0)
	BEGIN
	/* initialize some variables that are not fetched with the cursor and need to be reset */
	select @transacct = null, @oldtransacct = null, @jcco_glco = null, @arglacct = null, @apglacct = null, @oldrev_basis = null

	/* validate EM Batch info for each entry */
	select @errorstart = 'Seq#' + isnull(convert(varchar(6),@seq),'')
          
	/* validate batch transaction type */
	if @batchtranstype not in ('A','C','D')
		begin
		select @errortext = isnull(@errorstart,'') + ' -  Invalid transaction type, must be A,C, or D.'
		exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
		if @rcode <> 0 goto bspexit
		goto nextseq
		end

	/* validate revenue transaction type */
	if @emtranstype not in ('J','E','X','W')
		begin
		select @errortext = isnull(@errorstart,'') + ' -  Invalid revenue transaction type, must be J,E,X or W.'
		exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
		if @rcode <> 0 goto bspexit
		goto nextseq
		end

	/* get the trackhours flag to know whether or not we need to add the hour related values into EMJC */
	if @emtranstype = 'J'
		begin
		select @trackhours = TrackHours
		from bJCCT
		where PhaseGroup = @phasegroup and CostType = @jcct
		select @oldtrackhours = TrackHours
		from bJCCT
		where PhaseGroup = @oldphasegroup and CostType = @oldjcct
		end

	/* validation specific to Add types of transactions */
	if @batchtranstype = 'A'
		Begin
		/* check Trans number to make sure it is null*/
		if not @emtrans is null
			begin
			select @errortext = isnull(@errorstart,'') + ' - invalid to have transaction number on new entries!'
			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
			if @rcode <> 0 goto bspexit
			end

		if not (@oldemgroup is null and @oldequip is null and @oldrevcode is null and
				@oldcostcode is null and @oldemct is null and @oldactualdate is null and @oldglco is null and
				@oldoffsetacct is null and @oldprco is null and @oldemployee is null and @oldworkorder is null and
				@oldwoitem is null and @oldworkum is null and @oldtimeum is null and @oldjcco is null and
				@oldjob is null and @oldphasegroup is null and @oldphase is null and @oldjcct is null and
				@oldrevrate is null and @oldrevworkunits is null and @oldrevtimeunits is null and @oldrevdollars is null and
				@oldusedonequipco is null and @oldusedonequipgroup is null and @oldoffsetglco is null and
				@oldusedonequip is null and @oldcomptype is null and @oldcomponent is null and @oldprehourmeter is null and
				@oldcurrhourmeter is null and @oldpreodometer is null and @oldcurrodometer is null and @oldprcrew is null)
			begin
			select @errortext = isnull(@errorstart,'') + ' - all old values must be null for add records!'
			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
			if @rcode <> 0 goto bspexit
			end
		End  /* type Adds */

	/* validation specific to Add and Change types of transactions */
	if @batchtranstype in ('A','C')
		BEGIN
		/* validate the equipment and retrieve other important info while we are there */
		select @dept = Department, @catgy = Category, @emem_jcco = JCCo, @emem_job = Job, @emem_emct = UsageCostType,
				@compupdatehrs = CompUpdateHrs, @compupdatemiles = CompUpdateMiles,
				@attachpostrev = AttachPostRevenue
		from bEMEM
		where EMCo = @co and Equipment = @equip and Status in ('A', 'D')
		if @@rowcount <> 1
			begin
			select @errortext = isnull(@errorstart,'') + ' - invalid equipment!'
			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
			if @rcode <> 0 goto bspexit
			goto nextseq
			end

		/* validate the category */
		exec @rcode = dbo.bspEMCategoryVal @co, @catgy, @jobflag output, @msg = @errmsg output
		if @rcode <> 0
			begin
			select @errortext = isnull(@errorstart,'') + ' ' + @errmsg
			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
			if @rcode <> 0 goto bspexit
			goto nextseq
			end

		/* validate the department */
		if not exists(select * from EMDM where EMCo = @co and isnull(Department,'') = isnull(@dept,''))
			begin
			select @errortext = isnull(@errorstart,'') + ' Department ' + isnull(@dept,'') + ' is invalid on equipment ' + 
			isnull(@equip,'')
			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
			if @rcode <> 0 goto bspexit
			goto nextseq
			end

		---- Validate RevCode in EMRR based upon Category of Used/Usage Equipment #128555
		if not exists(select * from EMRR with (nolock) where EMCo=@co and RevCode=@revcode
				and EMGroup=@emgroup and Category=@catgy)
			begin
			select @errortext = isnull(@errorstart,'') + ' Revenue code: ' + isnull(@revcode,'') + ' must be setup in Revenue Rates by Category.'
			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
			if @rcode <> 0 goto bspexit
			goto nextseq
			end




            /* validate the form company glco */
            exec dbo.bspGLCompanyVal @glco, @msg = @errmsg output
            if @rcode <> 0
              begin
              select @errortext = isnull(@errorstart,'') + ' ' + @errmsg
              exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
              if @rcode <> 0 goto bspexit
              goto nextseq
              end
            
            /* JM 08/02/01 - Ref Issue 14068 - Validate @prco before it's first use in validating Employee. */
            if @prco is not null
              begin
              exec @rcode = dbo.bspPRCompanyVal @prco, @msg = @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              end
          
            /* validate employee */
            if @employee is not null
              begin
              select @switch_a_roo = convert(varchar(15),@employee)
              exec @rcode = dbo.bspPREmplValName @prco, @switch_a_roo, 'Y', @msg = @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              end
          
            /* validate revenue code and/or the job and retrieve some important usage flags */
            exec @rcode = dbo.bspEMUsageFlagsGet @co, @emgroup, @emtranstype, @equip, @catgy, @revcode,@jcco,
                  			   @job, @post_work_units = @post_work_units output, @allow_rate_oride = @allow_rate_oride output,
                  			   @rev_basis = @rev_basis output, @msg=@errmsg output
            if @rcode <> 0
              begin
              select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
              exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
              if @rcode <> 0 goto bspexit
              goto nextseq
              end
          
            /* set some basic defaults */
            ----#141031
            if @actualdate is null SET @actualdate = dbo.vfDateOnly()
          
			/* validate fields for line type of Job */
			if @emtranstype = 'J'
				Begin
				/* validate the job info for that piece of equipment when the Restrict To Current Job flag = Y */
				if (@jobflag = 'Y' and @autousage = 'N')and (@jcco <> @emem_jcco or @job <> @emem_job)
					begin
					select @errortext = isnull(@errorstart,'') + 
					' - job information does not match that of the Equipment Master for equipment ' + isnull(@equip,'')
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					if @rcode <> 0 goto bspexit
					goto nextseq
					end

				/* validate phase */ -- CMW 08/07/02 added (issue # 18177)
				exec @rcode = dbo.bspJCVPHASE @jcco, @job, @phase, @phasegroup, 'N', @msg = @errmsg output
				if @rcode <> 0
					begin
					select @errortext = isnull(@errorstart,'') + ': ' + 'New Job Cost values, '
					select @errortext = @errortext + 'JCCo ' + isnull(convert(varchar(3), @jcco), '') + ', Job ' + isnull(@job, '')
					select @errortext = @errortext  + ', Phase ' + isnull(@phase, '')
					select @errortext = @errortext + ' - ' + isnull(@errmsg,'')
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					if @rcode <> 0 goto bspexit
					goto nextseq
					end

				/* validate the job/phase/costtype with a heavy hitting stored procedure */
				select @switch_a_roo = convert(varchar(5),@jcct)
				exec @rcode = dbo.bspJCVCOSTTYPE @jcco, @job, @phasegroup, @phase, @switch_a_roo, 'N', @msg = @errmsg output
				if @rcode <> 0
					begin
					select @errortext = isnull(@errorstart,'') + ': ' + 'New Job Cost values, '
					select @errortext = @errortext + 'JCCo ' + isnull(convert(varchar(3), @jcco), '') + ', Job ' + isnull(@job, '')
					select @errortext = @errortext  + ', Phase ' + isnull(@phase, '') + ', CostType' + isnull(convert(varchar(3), @switch_a_roo), '')
					select @errortext = @errortext + ' - ' + isnull(@errmsg,'')
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					if @rcode <> 0 goto bspexit
					goto nextseq
					end
   
				-- TV 09/22/05 29478 - Need to validate Cost Code on EM Usage imports, make sure it's set up
				if @costcode is not null
					begin
					update bEMBF set CostCode = null
					where Co = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
					if @@rowcount <> 1
						begin
						select @errortext =  isnull(@errorstart,'') + ' error occurred updating Cost Code.'
						exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
						if @rcode <> 0 goto bspexit
						goto nextseq
						end
					end	
				End /* job type line */


            /* validate fields for line type of Equipment */
            if @emtranstype = 'E'
              Begin
              /* validate the expense em company */
              exec @rcode = dbo.bspEMCompanyVal @usedonequipco, @msg = @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          
              /* validate the expense side group */
              select @grp = EMGroup
              from bHQCO
              where HQCo = @usedonequipco
              if @grp <> @usedonequipgroup
                begin
                select @errortext = @errorstart + ' - Equipment group is not set up in HQCO!'
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              
              /* validate the used on equipment company and the used on equipment */
              exec @rcode = dbo.bspEMEquipVal @usedonequipco, @usedonequip, @msg = @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          
              /* component validation */
              if @comptype is not null or @component is not null
                begin
                /* validate the component type code */
                exec @rcode = dbo.bspEMComponentTypeCodeVal @usedonequipco, @comptype, @component, @equip, @emgroup, @msg = @errmsg output
                if @rcode <> 0
                  begin
                  select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                  exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                  if @rcode <> 0 goto bspexit
                  goto nextseq
               	end
              
                /* validate the component itself */
                exec @rcode = dbo.bspEMComponentVal @usedonequipco, @component, @usedonequip, @emgroup, @msg = @errmsg output
                if @rcode <> 0
                  begin
                  select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
               	exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
               	if @rcode <> 0 goto bspexit
               	goto nextseq
               	end
                end
          
              /* validate the used on : group, cost code and cost type */
              select @switch_a_roo = convert(varchar(5),@emct)
              exec @rcode = dbo.bspEMCostTypeCostCodeVal @usedonequipgroup, @costcode, @switch_a_roo, @msg = @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              /* end equipment type line */
              End
          
              /* validate fields for line type of Work Order */
              if @emtranstype = 'W'
                Begin
                /* validate the work order */
                exec @rcode = dbo.bspEMWOVal @usedonequipco, @workorder, @msg = @errmsg output
                if @rcode <> 0
                  begin
                  select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                  exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                  if @rcode <> 0 goto bspexit
                  goto nextseq
                  end
          
                /* validate the work order item */
                exec @rcode = dbo.bspEMWOItemVal @usedonequipco, @workorder, @woitem, @msg = @errmsg output
                if @rcode <> 0
                  begin
                  select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
               	exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
               	if @rcode <> 0 goto bspexit
               	goto nextseq
                  end

				/* validate that work order equipment components are not set to Inactive */
				if exists(select top 1 1 from bEMRD e join bEMEM r on e.UsedOnEquipCo = r.EMCo 
					and e.UsedOnComponent = r.Equipment and e.WOItem = @woitem and r.Status = 'I')
					begin
						select @errortext = @errorstart + ' - Work order item equipment is Inactive!'
						exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
						if @rcode <> 0 goto bspexit
						goto nextseq
					end
 
                /* validate the used on : group, cost code and cost type */
                select @switch_a_roo = convert(varchar(5),@emct)
                exec @rcode = dbo.bspEMCostTypeCostCodeVal @usedonequipgroup, @costcode, @switch_a_roo, @msg = @errmsg output
                if @rcode <> 0
                  begin
                  select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
               	exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
               	if @rcode <> 0 goto bspexit
               	goto nextseq
                  end
               /* end work order field validation */
               End
          
               /* validate fields for line type of Expense */
               /* the off set account must be present on an expense type because there is no where for us to get one otherwise */
               if @emtranstype = 'X' and @offsetacct is null
                 begin
                 select @errortext = isnull(@errorstart,'') + ' - missing gl offset account!'
                 exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                 if @rcode <> 0 goto bspexit
                 goto nextseq
           end
          
            /* GENERAL NON-LINETYPE VALIDATION */
            /* get intercompany gl accounts */
            /* first set default xglco to formCo glco */
            select @xglco = @glco
          
            if @emtranstype in ('E','W') and @co <> @usedonequipco select @xglco = @offsetglco
          
            if @emtranstype = 'J'
            begin
				select @jcco_glco = GLCo   from bJCCO where JCCo = @jcco
				if @jcco_glco is null
                begin
					select @errortext = isnull(@errorstart,'') + '- gl company missing from job cost company ' + 
					isnull(convert(char(2),@jcco),'') + ' !'
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					
					if @rcode <> 0 goto bspexit
				 
					goto nextseq
   
                end
              select @xglco = @jcco_glco
             end
          
            /* if the line is cross company, get the inter company accounts */
            if @glco <> @xglco
            begin
          
                /* validate the expense GLCo */
                select @lastmthsubclsd = null
                select @lastmthsubclsd = LastMthSubClsd
                from bGLCO
                where GLCo = @xglco
          
                if @mth <= @lastmthsubclsd
                  begin
                  select @errortext = isnull(@errorstart,'') + ' Month is closed in GL Company ' + 
                  isnull(convert(varchar(3),@xglco),'')
               	exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
               	if @rcode <> 0 goto bspexit
               	goto nextseq
                  end
          
              select @arglacct = ARGLAcct, @apglacct = APGLAcct
              from bGLIA
              where ARGLCo = @glco and APGLCo = @xglco
              if @arglacct is null or @apglacct is null
                begin
                select @errortext = isnull(@errorstart,'') + '- Missing cross company gl account(s) !'
    
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              end
          
            /* Search for the proper offset account if nothing had been entered in EMBF.
               If auto GL is set to yes then the account was not sought after during user entry because this routine
               would do it anyway */
            if @offsetacct is null or
               @batchtranstype = 'C' and (@jcco <> @oldjcco or @job <> @oldjob or @jcct <> @oldjcct or @phase <> @oldphase or
            			      	@usedonequipco <> @oldusedonequipco or @usedonequip <> @oldusedonequip or
            			      	@costcode <> @oldcostcode or @emct <> @oldemct)
              begin
              exec @rcode = dbo.bspEMUsageGlacctDflt @co, @emgroup, @emtranstype, @jcco, @job, @phase, @jcct,
               	                               @usedonequipco, @usedonequip, @costcode, @emct,
               	                               @glacct = @offsetacct output, @msg = @errmsg output
              if @offsetacct is null
                begin
                select @errortext = isnull(@errorstart,'') + 
                ' - no offset account is set up in the EM or JC department form for revenue code ' + 
                isnull(@revcode,'') + ' or job ' + isnull(@job,'') + ' !'
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              end
          
            /* validate the offset gl account */
             /*Issue 133140*/
            select @parameter = case @emtranstype when 'J' then 'J' else 'E' end
            exec @rcode = dbo.bspGLACfPostable @xglco, @offsetacct, @parameter, @errmsg output
            if @rcode <> 0
              begin
              select @errortext = isnull(@errorstart,'') + ' - '  + @errmsg
              exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
              if @rcode <> 0 goto bspexit
              goto nextseq
              end
          
            /**************************************************************************************************
             * get the revenue acct(s) for EMGL based on the department revenue code or revenue bdown code(s) *
             * insert into EMBC any revbdowncode accts for a given entry.                                     *
             * revbdownval also inflates or deflates the bdown rates if the standard rate was overridden      *
             *************************************************************************************************/
            select @transacct = null
            select @transacct = GLAcct
            from bEMDR
            where EMCo = @co and EMGroup = @emgroup and isnull(Department,'') = isnull(@dept,'') and RevCode = @revcode
            if @transacct is not null
              begin
			 /*Issue 135745*/
              exec @rcode = dbo.bspGLACfPostable @glco, @transacct, 'E', @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' - ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          	end
 
			/* update EMBF with the transacct based on the revenue code in EMDR so that we can update EMRD and JCCD */
			---- TV 10/11/05 - 29989 always update with Dept Revenue Account
			update bEMBF set GLTransAcct = @transacct
			where Co = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
			if @@rowcount <> 1
				begin
				select @errortext =  isnull(@errorstart,'') + ' error occurred updating GL Transaction Account.'
				exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
				if @rcode <> 0 goto bspexit
				goto nextseq
				end
              
          
            /* build the EMBC table for EMRB distirbutions and, potentially, GLDT distirbution */
            /* if a problem occurs in this bsp it will be written to the hqbe table within */
            select @parameter = case when isnull(@transacct,'') = '' then 'Y' else 'N' end
            exec @rcode = dbo.bspEMBFRevBdownVal @co, @emgroup, @batchid, @seq, @mth, @dept, @revcode, @equip, @catgy, @jcco, @job,
            				   @emtranstype, @revrate, 1, @parameter,
							   ----TK-20836
							   0, @emtrans, @errmsg = @errmsg output
            if @rcode <> 0
              begin
              select @rcode = 0
              goto nextseq
              end
          
            /* validate Units of Measure */
            /* unit based requirements */
            if @rev_basis = 'U'
              begin
              if @workum is null
                begin
                select @errortext = isnull(@errorstart,'') + ' - Work unit of measure required!'
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              select @jc_timeunits = @revtimeunits
              end
          
            /* hour based requirements */
            if @rev_basis = 'H'
              begin
              if @timeum is null
                begin
                select @errortext = isnull(@errorstart,'') + ' - Time unit of measure required!'
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          
              /* convert time unit of measure into hours for job cost and hour meter update */
              select @hrsfactor = HrsPerTimeUM
              from bEMRC
              where EMGroup = @emgroup and RevCode = @revcode
              select @jc_timeunits = @revtimeunits * @hrsfactor
              end
          
            if @workum is not null
              begin
              exec @rcode = dbo.bspHQUMVal @workum, @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@workum,'') + ': ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
              end
          
            if @timeum is not null
              begin
              exec @rcode = dbo.bspHQUMVal @timeum, @msg = @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
          
                goto nextseq
                end
              end
            /* end type Add of Change type lines */
            END
          
          /* BEGIN the Change or Delete batch type lines */
          if @batchtranstype in ('C','D')
            BEGIN
            /* get 'old' dept and 'old' category based on the current settings of @oldequip */
            select @olddept = Department, @oldcatgy = Category
            from bEMEM
            where EMCo = @co and Equipment = @oldequip
          
   
            /* get old xglco */
            select @old_xglco = @oldglco
          
            if @emtranstype in ('E','W') and @co <> @oldusedonequipco select @old_xglco = @oldoffsetglco
          
        
			if @emtranstype = 'J'
				begin
				select @jcco_glco = GLCo
				from bJCCO
				where JCCo = @oldjcco
				if @jcco_glco is null
					begin
					select @errortext = isnull(@errorstart,'') + 
					'- gl company missing from old job cost company ' + isnull(convert(char(3),@oldjcco),'') + ' !'
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					if @rcode <> 0 goto bspexit
					goto nextseq
					end
				select @old_xglco = @jcco_glco
			    
				-- TV 08/15/05 28474- EM Usage Post: Cannot enter Cost Detail/ trigger error Inactive Cost Type
				if (@jcco <> @oldjcco or @job <> @oldjob or @phase <> @oldphase or @jcct <> @oldjcct)
					begin
					exec @rcode = dbo.bspJCVPHASE @oldjcco, @oldjob, @oldphase, @oldphasegroup, 'N', @msg = @errmsg output
					if @rcode <> 0
						begin
						select @errortext = isnull(@errorstart,'') + ': ' + 'Old Job Cost values, '
						select @errortext = @errortext + 'JCCo ' + isnull(convert(varchar(3), @oldjcco), '') + ', Job ' + isnull(@oldjob, '')
						select @errortext = @errortext  + ', Phase ' + isnull(@oldphase, '')
						select @errortext = @errortext + ' - ' + isnull(@errmsg,'')
						exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
						if @rcode <> 0 goto bspexit
						goto nextseq
						end
					end

					select @switch_a_roo = convert(varchar(5),@oldjcct)
					exec @rcode = dbo.bspJCVCOSTTYPE @oldjcco, @oldjob, @oldphasegroup, @oldphase, @switch_a_roo, 'N', @msg = @errmsg output
					if @rcode <> 0
						begin
						select @errortext = isnull(@errorstart,'') + ': ' + 'Old Job Cost values, '
						select @errortext = @errortext + 'JCCo ' + isnull(convert(varchar(3), @oldjcco), '') + ', Job ' + isnull(@oldjob, '')
						select @errortext = @errortext  + ', Phase ' + isnull(@oldphase, '') + ', CostType' + isnull(convert(varchar(3), @switch_a_roo), '')
						select @errortext = @errortext + ' - ' + isnull(@errmsg,'')
						exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
						if @rcode <> 0 goto bspexit
						goto nextseq
						end
					end
          
            if @oldglco <> @old_xglco
              Begin
              /* validate the old expense GLCo */
              select @lastmthsubclsd = null
              select @lastmthsubclsd = LastMthSubClsd
              from bGLCO
              where GLCo = @old_xglco
          
              if @mth <= @lastmthsubclsd
                begin
                select @errortext = isnull(@errorstart,'') + ' Month is closed in the old GL Company ' + 
                isnull(convert(varchar(3),@old_xglco),'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          
              select @arglacct = ARGLAcct, @apglacct = APGLAcct
              from bGLIA
              where ARGLCo = @oldglco and APGLCo = @old_xglco
              if @arglacct is null or @apglacct is null
                begin
                select @errortext = isnull(@errorstart,'') + '- Missing old cross company gl account(s) !'
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          
              End
          
            /* get old revenue basis & old jc_timeunits,
               they really should not be changing a revcode basis or the hours conversion factor. if they do..... */
            select @oldrev_basis = Basis
            from bEMRC
            where EMGroup = @oldemgroup and RevCode = @oldrevcode
            if @oldrev_basis is null
                begin
         
                select @errortext = isnull(@errorstart,'') + ' - The old transactions revenue code: ' + 
                isnull(@oldrevcode,'') + ' no longer exists!'
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          
            if @oldrev_basis = 'U' select @oldjc_timeunits = @oldrevtimeunits
            if @oldrev_basis = 'H'
                begin
                select @oldhrsfactor = HrsPerTimeUM
                from bEMRC
                where EMGroup = @oldemgroup and RevCode = @oldrevcode
                select @oldjc_timeunits = @oldrevtimeunits * @oldhrsfactor
                end
          
            /* get the revenue acct(s) for EMGL based on the old department revenue code or revenue bdown code(s) */
            /* insert into EMBC any revbdowncode accts for a given entry.
               revbdownval also inflates or deflates the bdown rates if the standard rate was overridden */
            select @oldtransacct = GLAcct
            from bEMDR
            where EMCo = @co and EMGroup = @oldemgroup and isnull(Department,'') = isnull(@olddept,'') and RevCode = @oldrevcode
            if @oldtransacct is not null
              begin
              exec @rcode = dbo.bspGLACfPostable @glco, @oldtransacct, 'E', @errmsg output
              if @rcode <> 0
                begin
                select @errortext = isnull(@errorstart,'') + ' - ' + isnull(@errmsg,'')
                exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
                if @rcode <> 0 goto bspexit
                goto nextseq
                end
          	end

			/* update EMBF with the oldtransacct based on the old revenue code in EMDR so that we can update EMRD and JCCD */
			update bEMBF set OldGLTransAcct = @oldtransacct
			where Co = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
			if @@rowcount <> 1
				begin
				select @errortext =  isnull(@errorstart,'') + ' error occurred updating Old GL Transaction Account.'
				exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
				if @rcode <> 0 goto bspexit
				goto nextseq
				end

            /* build the EMBC table for EMRB distirbutions and, potentially, GLDT distirbution */
            /* if a problem occurs in this bsp it will be written to the hqbe table within */
            select @parameter = case when @oldtransacct is null then 'Y' else 'N' end
            exec @rcode = dbo.bspEMBFRevBdownVal @co, @oldemgroup, @batchid, @seq, @mth, @olddept, @oldrevcode, @oldequip,
          				   @oldcatgy, @oldjcco, @oldjob, @oldemtranstype, @oldrevrate, 0, @parameter,
						   ----TK-20836
						   @oldrevdollars, @emtrans, @errmsg = @errmsg output
            if @rcode <> 0
              begin
              select @rcode = 0
              goto nextseq
              END
           
            /* end change & delete code */
            END
          
          /* validation specific for Deletion of a transaction */
          if @batchtranstype = 'D'
            BEGIN
            select @itemcount = count(*)
            from bEMRD
            where EMCo=@co and Mth=@mth and Trans=@emtrans
            select @deletecount= count(*)
            from bEMBF
            where Co=@co and Mth=@mth and BatchId=@batchid and BatchSeq=@seq and BatchTransType='D'
            if @itemcount <> @deletecount
              begin
              select @errortext = isnull(@errorstart,'') + 
              ' - In order to delete a transaction all entries must be in the current batch and marked for delete! '
              exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
              if @rcode <> 0 goto bspexit
              end
          
            select @deletecount= count(*)
            from bEMBF
            where Co=@co and Mth=@mth and BatchId=@batchid and BatchSeq=@seq and BatchTransType<>'D'
            if  @deletecount  <> 0
              begin
              select @errortext = isnull(@errorstart,'') + 
              ' - In order to delete a transaction you cannot have any Add or Change lines! '
              exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
              if @rcode <> 0 goto bspexit
              end
          
            END /*Delete */
          
          /* update EMGL and if neccessary, EMJC */
          update_audit:
          
          /*JC distributions */
          /* first back out any old entry */
          select @changed = 'N'
          if @oldemtranstype = 'J'
            begin
            /* skip jc update on a change type transaction if nothing did indeed change */
            if @batchtranstype = 'C' and (isnull(@jcco,0) <> isnull(@oldjcco,0) or isnull(@job,'') <> isnull(@oldjob,'') or
               isnull(@phasegroup,0) <> isnull(@oldphasegroup,0) or isnull(@phase,'') <> isnull(@oldphase,'') or
               isnull(@jcct,0) <> isnull(@oldjcct,0) or isnull(@equip,'') <> isnull(@oldequip,'') or isnull(@emgroup,0) <> isnull(@oldemgroup,0) or
               isnull(@revcode,0) <> isnull(@oldrevcode,0) or isnull(@oldglco,0) <> isnull(@jcco_glco,0) or
               isnull(@offsetacct,'') <> isnull(@oldoffsetacct,'') or isnull(@prco,0) <> isnull(@oldprco,0) or
               isnull(@employee,'') <> isnull(@oldemployee,0) or isnull(@workum,'') <> isnull(@oldworkum,'') or
               isnull(@revworkunits,0) <> isnull(@oldrevworkunits,0) or isnull(@timeum,'') <> isnull(@oldtimeum,'') or
               isnull(@revtimeunits,0) <> isnull(@oldrevtimeunits,0) or-- TV 08/03/04 25252 - needed to compare new vs old
               isnull(@revdollars,0) <> isnull(@oldrevdollars,0) or isnull(@actualdate,'') <> isnull(@oldactualdate,'')) select @changed = 'Y'
          
            if @batchtranstype = 'D' or @changed = 'Y'
              begin
              if @oldrevdollars <> 0 or
                 (((case @oldtrackhours when 'Y' then isnull(@oldjc_timeunits,0) else 0 end) <> 0) or
                 --(@rev_basis = 'U' and @oldrevworkunits <> 0))
          		(@oldrevworkunits <> 0))
         
                begin
                insert into bEMJC (EMCo, Mth, BatchId, JCCo, Job, PhaseGroup, Phase, JCCType, BatchSeq,
                                   OldNew, Equipment, TransDesc, ActualDate, EMGroup, RevCode, GLCo, GLAcct, PRCo, PREmployee,
              		         WorkUM, WorkUnits, TimeUM, TimeUnits,
                                   UnitCost, TotalCost,PRCrew)
                values (@co, @mth, @batchid, @oldjcco, @oldjob, @oldphasegroup, @oldphase, @oldjcct, @seq,
           	      0, @oldequip, 'Equipment Usage', @oldactualdate, @emgroup, @oldrevcode, @old_xglco, @oldoffsetacct, @oldprco, @oldemployee,
           	      @oldworkum, -1*@oldrevworkunits, @oldtimeum, case @oldtrackhours when 'Y' then -1 * isnull(@oldjc_timeunits,0) else 0 end,
                        0, -1 * @oldrevdollars, @prcrew)
                end
              end
            end
          
          if @emtranstype = 'J' and (@batchtranstype = 'A' or @changed = 'Y')
            begin
            /* insert new entry */
            if @revdollars <> 0 or 
               (((case @trackhours when 'Y' then isnull(@jc_timeunits,0) else 0 end) <> 0) or
                --(@rev_basis = 'U' and @revworkunits <> 0))
         		(@revworkunits <> 0))
              
              begin
              insert into bEMJC (EMCo, Mth, BatchId, JCCo, Job, PhaseGroup, Phase, JCCType, BatchSeq,
              		       OldNew, Equipment, TransDesc, ActualDate, EMGroup, RevCode, GLCo, GLAcct, PRCo, PREmployee,
              		       WorkUM, WorkUnits, TimeUM, TimeUnits,
                                 UnitCost, TotalCost, PRCrew)
           	values (@co, @mth, @batchid, @jcco, @job, @phasegroup, @phase, @jcct, @seq,
           	       	1, @equip, 'Equipment Usage', @actualdate, @emgroup, @revcode, @xglco,  @offsetacct, @prco, @employee,
           		@workum, @revworkunits, @timeum, case @trackhours when 'Y' then isnull(@jc_timeunits,0) else 0 end,
                          0, @revdollars, @prcrew)
              end
            /* end JC distributions */
            end
          
          
          /* begin gl distributions */
          if @batchtranstype <> 'A'  /* do old entries */
            BEGIN
            if @old_xglco = @oldglco select @cycle = 3 else select @cycle = 1
          /* do gl distributions */
            while @cycle < 5
              Begin
              /* cycle 1.  debit cross company ap account */
              if @cycle = 1 select @distglco = @old_xglco, @distglacct = @apglacct, @distamt = @oldrevdollars, @distequip = @oldequip
              
              /* cycle 2.  credit cross company ar account */
              if @cycle = 2
                begin
                select @distglco = @oldglco, @distglacct = @arglacct, @distamt = -1 *@oldrevdollars,
                			 @distequip = case @emtranstype when 'E' then @oldusedonequip else @oldequip end
                end
          
/* cycle 3.  debit revenue account */     
if @cycle = 3
	Begin
	if @oldtransacct is not null
		begin
		select @distglco = @oldglco, @distglacct = @oldtransacct, @distamt = @oldrevdollars, @distequip = @oldequip
		end
	else
		/* Bdownrate is not updated in EMBC from old records since the previous transaction that was sent to
		EMRB is to be deleted after which the new transactions value is freshly inserted.
		An adjustment to the amount only happens in this section if the GL is influenced by the
		breakdown codes in lieu of the rev codes. */
		----TK-20836 ONLY REMMED OUT OLD CODE IN CASE PROBLEM ARISE
		BEGIN
		SET @save_bdown_code = null
		select @revbdowncode = min(RevBdownCode)
		from dbo.bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = 0
		while @revbdowncode is not null
			BEGIN
			---- get revenue breakdown info          
			SELECT  @distglco	= GLCo,
					@distglacct = Account,
					@distamt	= BdownRate,
					@distequip	= Equipment
			FROM dbo.bEMBC
			WHERE EMCo = @co 
				AND Mth = @mth
				AND BatchId = @batchid
				AND BatchSeq = @seq
				AND RevBdownCode = @revbdowncode
				AND OldNew = 0  
			
			---- TFS-46093 for old entries may be null set to old values
			IF @distglco IS NULL SET @distglco = @oldglco
			IF @distglacct IS NULL SET @distglacct = @oldtransacct

			---- update EMGL distributions for old revenue breakdown
			UPDATE dbo.bEMGL SET Amount = Amount + -(@distamt)
			WHERE EMCo = @co
				AND Mth = @mth
				AND BatchId = @batchid
				AND GLCo = @distglco
				AND GLAcct = @distglacct
				AND BatchSeq = @seq
				AND OldNew = 0
			IF @@ROWCOUNT = 0
				BEGIN
                ---- if no update occured, insert the new record
				INSERT INTO dbo.bEMGL(EMCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, OldNew, EMTrans, Equipment,
						ActualDate, Source, EMTransType, JCCo, Job, EMGroup, RevCode,
						RevBdownCode, WorkOrder, WOItem, Amount)
				SELECT @co, @mth, @batchid, @distglco, @distglacct, @seq, 0, @emtrans, @distequip,
						@oldactualdate, @source, @emtranstype, @oldjcco, @oldjob, @oldemgroup, @oldrevcode,
						@revbdowncode, @oldworkorder, @oldwoitem, -(@distamt)
				FROM dbo.bEMBC EMBC
				WHERE EMBC.EMCo = @co
					AND EMBC.Mth = @mth
					AND EMBC.BatchId = @batchid
					AND EMBC.BatchSeq = @seq
					and EMBC.RevBdownCode = @revbdowncode
					AND EMBC.OldNew = 0
				END

			---- save rev breakdown code
			SET @save_bdown_code = @revbdowncode

			SELECT @revbdowncode = min(RevBdownCode)
			from dbo.bEMBC WHERE EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
				AND OldNew = 0 and RevBdownCode > @revbdowncode
			END    /* end while loop */

			----TV 3/11/04 22518 - If user is applying TotalOnly (with no units) then rev Dollars should be used
		--	if (@oldrev_basis = 'H' and  @oldrevtimeunits <> 0) or (@oldrev_basis = 'U' and  @oldrevworkunits <> 0)
		--		begin
		--		select @distglco = GLCo, @distglacct = Account,
		--				@distamt = BdownRate * -(case @oldrev_basis when 'H' then @oldrevtimeunits else @oldrevworkunits end),
		--				@distequip = Equipment
		--		from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
		--		and RevBdownCode = @revbdowncode and OldNew = 0
		--		end
		--	else
		--		begin
		--		select @distglco = GLCo, @distglacct = Account, @distamt = (@oldrevdollars), @distequip = Equipment
		--		from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
		--		and RevBdownCode = @revbdowncode and OldNew = 0
		--		end

		--	/* change the EMBC rate right here so that the amount going over to EMRB is properly adjusted */
		--	/* also need to switch the sign back on an update from here on EMBC */
		--	update bEMBC set BdownRate = -(@distamt)
		--	where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
		--	and OldNew = 0 and RevBdownCode = @revbdowncode
		--	if @@rowcount <> 1
		--		begin
		--		select @errortext =  isnull(@errorstart,'') + ' error occurred updating Breakdown rate.'
		--		exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
		--		if @rcode <> 0 goto bspexit
		--		goto nextseq
		--		end

		--	select @distglco = GLCo, @distglacct = Account, @distamt = (@oldrevdollars), @distequip = Equipment
		--	from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
		--	and RevBdownCode = @revbdowncode and OldNew = 0

		--	if @distamt <> 0
		--		begin
		--		update bEMGL set Amount  = Amount + @distamt
		--		where EMCo = @co and Mth = @mth and BatchId = @batchid and GLCo = @distglco
		--		and GLAcct = @distglacct and BatchSeq = @seq and OldNew = 0
		--		/* if no update occured, insert the new record */
		--		if @@rowcount = 0
		--			begin
		--			insert into bEMGL(EMCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, OldNew, EMTrans, Equipment, ActualDate, Source, EMTransType,
		--					JCCo, Job, EMGroup, RevCode, RevBdownCode, WorkOrder, WOItem, Amount)
		--			values(@co, @mth, @batchid, @distglco, @distglacct, @seq, 0, @emtrans, @distequip, @oldactualdate, @source, @emtranstype,
		--					@oldjcco, @oldjob, @oldemgroup, @oldrevcode, @revbdowncode, @oldworkorder, @oldwoitem, @distamt)
		--			end
		--		end

		--	-- save rev breakdown code
		--	select @save_bdown_code = @revbdowncode

		--	select @revbdowncode = min(RevBdownCode)
		--	from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and
		--	OldNew = 0 and RevBdownCode > @revbdowncode
		--	end    /* end while loop */

		--/* Need to make sure that old rev dollars is equal to old total rev breakdown amounts */
		--select @total_Bdown_dist = isnull(sum(BdownRate),0)
		--from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = 0
		--if @@rowcount <> 0 ----HACK
		--	begin
		--	if @save_bdown_code is not null and @total_Bdown_dist <> -1 * @oldrevdollars 
		--		begin
		--		select @diff = 0
		--		select @diff = @oldrevdollars + @total_Bdown_dist

		--		update bEMBC set BdownRate = BdownRate - @diff
		--		where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
		--		and OldNew = 0 and RevBdownCode = @save_bdown_code  --should be the last bdown code from the above psuedo-cursor
		--		if @@rowcount <> 1
		--			begin
		--			select @errortext =  isnull(@errorstart,'') + ' error occurred updating Breakdonw rate.'
		--			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
		--			if @rcode <> 0 goto bspexit
		--			goto nextseq
		--			end

		--		update bEMGL set Amount  = Amount + @diff
		--		where EMCo = @co and Mth = @mth and BatchId = @batchid and GLCo = @distglco
		--		and GLAcct = @distglacct and BatchSeq = @seq and OldNew = 0  --@diff is added to EMGL which is differnet than the update to EMBC
		--		if @@rowcount <> 1
		--			begin
		--			select @errortext =  isnull(@errorstart,'') + ' error occurred updating Amount for distribution GL account.' + ' <> A'
		--			exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
		--			if @rcode <> 0 goto bspexit
		--			goto nextseq
		--			end
		--		end
		--	end

		/* If the code fell into this section, GL has already been updated.  Increment now. */
		goto old_increment
		end
	End    /* end cycle 3 */

	/* cycle 4.  credit the offset account */
	if @cycle = 4
		begin
		select @distglco = @old_xglco, @distglacct = @oldoffsetacct, @distamt = -1 * @oldrevdollars,
		@distequip = case @emtranstype when 'E' then @oldusedonequip else @oldequip end
		end

	/* first try an update in case a record already exists */
	update bEMGL
	set Amount  = Amount + @distamt
	where EMCo = @co and Mth = @mth and BatchId = @batchid and GLCo = @distglco and GLAcct = @distglacct
	and BatchSeq = @seq and RevCode = @oldrevcode and OldNew = 0
	/* if no update occured, insert the new record */
	if @@rowcount = 0
		begin
		insert into bEMGL(EMCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, OldNew, Equipment, ActualDate, Source, EMTransType,
			JCCo, Job, EMGroup, CostCode, EMCostType, RevCode, Amount)
		values(@co, @mth, @batchid, @distglco, @distglacct, @seq, 0, @distequip, @actualdate, @source, @emtranstype,
			@oldjcco, @oldjob, @oldemgroup, @oldcostcode, @oldemct, @oldrevcode, @distamt)
		end

	old_increment:
	select @cycle = @cycle + 1
	End /* while gl dist loop */

END /* audit type <> A */

if @batchtranstype <> 'D'  /* do new entries */
	BEGIN
	if @xglco = @glco select @cycle = 3 else select @cycle = 1
	/* do gl distributions */
	while @cycle < 5
		Begin
		/* cycle 1.  credit cross company ap account */
		if @cycle = 1 select @distglco = @xglco, @distglacct = @apglacct, @distamt = -1 * @revdollars, @distequip = @equip

		/* cycle 2.  debit cross company ar account */
		if @cycle = 2
			begin
			select @distglco = @glco, @distglacct = @arglacct, @distamt = @revdollars,
			@distequip = case @emtranstype when 'E' then @usedonequip else @equip end
			end

		/* cycle 3.  credit revenue account */
		if @cycle = 3
			BEGIN
			/* if transacct is null then post to GL at the rev breakdown code level.
			Even if gl is not to be updated by revenue breakdown codes, this code must be executed so that the
			update to EMRB is accurate */

			select @save_bdown_code = null

			select @revbdowncode = min(RevBdownCode)
			from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = 1
			while @revbdowncode is not null
				begin
				----TV 3/11/04 22518 - If user is applying TotalOnly (with no units) then rev Dollars should be used	
				if (@rev_basis = 'H' and  @revtimeunits <> 0) or (@rev_basis = 'U' and  @revworkunits <> 0)
					begin
					select @distglco = GLCo, @distglacct = Account,
							@distamt = BdownRate * -(case @rev_basis when 'H' then @revtimeunits else @revworkunits end),
							@distequip = Equipment
					from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
					and OldNew = 1 and RevBdownCode = @revbdowncode
					end
				else
					begin
					select @distglco = GLCo, @distglacct = Account, @distamt =  - (@revdollars), @distequip = Equipment
					from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
					and OldNew = 1 and RevBdownCode = @revbdowncode
					end

				/* change the EMBC rate right here so that the amount going over to EMRB is properly adjusted */
				/* also need to switch the sign back on an update from here on EMBC */
				update bEMBC set BdownRate = -(@distamt)
				where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
				and OldNew = 1 and RevBdownCode = @revbdowncode
				if @@rowcount <> 1
					begin
					select @errortext =  isnull(@errorstart,'') + ' error occurred updating breakdown rate.'
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					if @rcode <> 0 goto bspexit
					goto nextseq
					end

			/* if the transacct is not null then gl dist. will be driven by the revenue codes.
			otherwise gl distribution will be driven by revenue breakdown codes */
			--Do not remove @transacct from this statement.  It needs to be here and nowhere else.
			if @distamt <> 0 and @transacct is null  
				begin
				update bEMGL set Amount  = Amount + @distamt
				where EMCo = @co and Mth = @mth and BatchId = @batchid and GLCo = @distglco
				and GLAcct = @distglacct and BatchSeq = @seq and OldNew = 1
				if @@rowcount = 0
					begin
					insert into bEMGL(EMCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, OldNew, Equipment, ActualDate, Source, EMTransType,
						JCCo, Job, EMGroup, RevCode, RevBdownCode, WorkOrder, WOItem, Amount)
					values(@co, @mth, @batchid, @distglco, @distglacct, @seq, 1, @distequip, @actualdate, @source, @emtranstype,
						@jcco, @job, @emgroup, @revcode, @revbdowncode, @workorder, @woitem, @distamt)
					end
				end  /* emgl update or insert */

			select @save_bdown_code = @revbdowncode

			select @revbdowncode = min(RevBdownCode)
			from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
			and OldNew = 1 and RevBdownCode > @revbdowncode
			end  /* end while loop */

		/* Need to make sure that rev dollars is equal to total rev breakdown amounts */
		select @total_Bdown_dist = isnull(sum(BdownRate),0)
		from bEMBC where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and OldNew = 1
		IF @@rowcount <> 0 ----HACK
			begin
			if @save_bdown_code is not null and @total_Bdown_dist <> @revdollars 
				begin
				select @diff = 0
				select @diff = @revdollars - @total_Bdown_dist  --subtract these two from each other on new transactions

				update bEMBC set BdownRate = BdownRate + @diff
				where EMCo = @co and Mth = @mth and BatchId = @batchid and BatchSeq = @seq
				and OldNew = 1 and RevBdownCode = @save_bdown_code  --should be the last bdown code from the above psuedo-cursor
				if @@rowcount <> 1
					begin
					select @errortext =  isnull(@errorstart,'') + ' error occurred updating Breakdown Rate.'
					exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
					if @rcode <> 0 goto bspexit
					goto nextseq
					end

				if @transacct is null ---- issue #128793
					begin
					update bEMGL set Amount  = Amount - @diff  --@diff is subtracted out of EMGL which is differnet than the update to EMBC
					where EMCo = @co and Mth = @mth and BatchId = @batchid and GLCo = @distglco
					and GLAcct = @distglacct and BatchSeq = @seq and OldNew = 1
					---- #129385 if unable to update distglacct do not throw error
----					if @@rowcount <> 1
----						begin
----						select @errortext =  isnull(@errorstart,'') + ' error occurred updating Amount for distribution GL Account.'
----						exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
----						if @rcode <> 0 goto bspexit
----						goto nextseq
----						end
					end
				end
			end

		If @transacct is not null  -- do not move this code to the top of Cycle 3.  It needs to be right here.
			/* Override BreakDown Code GL Accounts with Revenue Code GL Accounts and amount.
			This code must come after the above RevBreakDown section or EMRB will be incorrect ! */
			begin
			select @distglco = @glco, @distglacct = @transacct, @distamt = - 1 * @revdollars, @distequip = @equip
			end
		Else
			begin        
			goto increment
			end
		END    /* end cycle 3 */

	/* cycle 4.  debit the offset account */
	if @cycle = 4
		begin
		select @distglco = @xglco, @distglacct = @offsetacct, @distamt = @revdollars,
		@distequip = case @emtranstype when 'E' then @usedonequip else @equip end
		end

	if @distamt <> 0
		begin
        /* first try an update in case a record already exists */
        update bEMGL set Amount  = Amount + @distamt
        where EMCo = @co and Mth = @mth and BatchId = @batchid and GLCo = @distglco and GLAcct = @distglacct
		and BatchSeq = @seq and RevCode = @revcode and OldNew = 1
        /* if no update occured, insert the new record */
        if @@rowcount = 0
			begin
			insert into bEMGL(EMCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, OldNew, Equipment, ActualDate, Source, EMTransType,
					JCCo, Job, EMGroup, CostCode, EMCostType, RevCode, WorkOrder, WOItem, Amount)
			values(@co, @mth, @batchid, @distglco, @distglacct, @seq, 1, @distequip, @actualdate, @source, @emtranstype,
					@jcco, @job, @emgroup, @costcode, @emct, @revcode, @workorder, @woitem, @distamt)
			end
        end

	increment:
	select @cycle = @cycle + 1
	End /* while gl dist loop */
  
    END /* audit type <> D */
          
	nextseq:
	goto get_next_bcEMBF

END /*EMBF LOOP*/

close bcEMBF
deallocate bcEMBF
select @opencursorEMBF=0
          
-- make sure debits and credits balance
select @glco = GLCo
from bEMGL

where EMCo = @co and Mth = @mth and BatchId = @batchid
group by GLCo
having isnull(sum(Amount),0) <> 0
if @@rowcount <> 0
	begin
	select @errortext =  'GL Company ' + isnull(convert(varchar(3), @glco),'') + ' entries dont balance!'
	exec @rcode = dbo.bspHQBEInsert @co, @mth, @batchid, @errortext, @errmsg output
	if @rcode <> 0 goto bspexit
	end






bspexit:
	---- check HQ Batch Errors and update HQ Batch Control status
	select @status = 3	/* valid - ok to post */
	if exists(select * from bHQBE where Co = @co and Mth = @mth and BatchId = @batchid)
	select @status = 2	/* validation errors */
	update bHQBC set Status = @status
	where Co = @co and Mth = @mth and BatchId = @batchid
	if @@rowcount <> 1
		begin
		select @errmsg = 'Unable to update HQ Batch Control status!', @rcode = 1
		goto bspexit
		end

	if @opencursorEMBF = 1
		begin
		close bcEMBF
		deallocate bcEMBF
		end

	return @rcode






GO
PRINT N'Refreshing [dbo].[vrvPRCrewTimesheet]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRCrewTimesheet]'
GO
PRINT N'Refreshing [dbo].[POIBGrid]'
GO
EXEC sp_refreshview N'[dbo].[POIBGrid]'
GO
PRINT N'Refreshing [dbo].[viFact_JCForecast]'
GO
EXEC sp_refreshview N'[dbo].[viFact_JCForecast]'
GO
PRINT N'Refreshing [dbo].[brvEstCostPayItem]'
GO
EXEC sp_refreshview N'[dbo].[brvEstCostPayItem]'
GO
PRINT N'Altering [dbo].[bspMSIBVal]'
GO


/**************************************************/
ALTER  procedure [dbo].[bspMSIBVal]
/***********************************************************
* CREATED BY: GG 11/18/00
* MODIFIED By :GG 01/09/01 - fixed ARFields
*              GF 01/19/2001 - another fix to ARFields
*              GF 05/11/2001 - fix for null misc distribution code
*              GG 07/03/01 - add hierarchal Quote search  - #13888
*				GG 02/07/02 - #14177 - AR auto payments
*				GF 03/21/2003 - issue #20798 - added validation for active location and material
*				GF 06/26/2003 - #21682 added with nolock to select statements
*				GF 12/05/2003 - #23205 - check error messages, wrap concatenated values with isnull
*				GG 02/02/04 - #20538 - split GL units flag
*				GF 02/24/2003 - #23824 - need to check GLSaleFlag whether there is a @matlvendor for
*								update units to GL account.
*				GF 06/14/2004 - #24820 - not converting to std units correctly. Need to use temp var for row count
*				GF 04/05/2005 - issue #27601 - validate AR TaxGroup to MSTD TaxGroup must be same
*				GF 05/08/2007 - issue #124383 added error checking for unit price more than 12 char when AR Interface level 3
*				GF 07/07/2008 - issue #128290 MS International tax enhancement
*				MV 02/04/10 - issue #136500 - bspHQTaxRateGetAll added NULL output param
*				GF 04/01/2010 - issue #129350 surcharges
*				GF 05/16/2011 - issue #143485 surcharge with no haul 'N' use sales account
*				ERICV 06/14/11 - Issue 142792 Added check for null GL accounts: @salesglacct, @lmcustsurrevoutglacct, @lmcustsurrevequipglacct
*				MV 10/25/11 - TK-09243 - bspHQTaxRateGetAll added NULL output param
*				GF 08/15/2012 TK-17081 validation for own/outside haul sales account depending on hauler type.
*				GF 08/17/2012 TK-17283 added tax group and tax code for hauler MSAR transaction
*				GF 03/25/2013 TFS-44951 backed out TK-17283. Need to redo that issue.
*
*
* USAGE:
* Called from MS Batch Process form to validate an Invoice batch.
* Adds distribution entries in bMSAR for AR Lines, bMSIG for GL,
* and bMSMX for AR Misc Distributions.
*
* Errors in batch added to bHQBE using bspHQBEInsert
*
* INPUT PARAMETERS
*   @msco          MS Co#
*   @mth           Batch Month
*   @batchid       Batch ID
*
* OUTPUT PARAMETERS
*   @errmsg        error message
*
* RETURN VALUE
*   0              success
*   1              fail
*****************************************************/
@msco bCompany, @mth bMonth, @batchid bBatchID, @errmsg varchar(255) output
as
set nocount on
   
declare @rcode int, @errorstart varchar(30), @errortext varchar(255), @status tinyint, @msglco bCompany,
		@jrnl bJrnl, @arco bCompany, @arglco bCompany, @openMSIBcursor tinyint, @seq int, @msinv varchar(10),
		@custgroup bGroup, @customer bCustomer, @custjob varchar(20), @custpo varchar(20), @description bDesc,
		@paymenttype char(1), @rectype tinyint, @payterms bPayTerms, @invdate bDate, @applytoinv varchar(10),
		@intercoinv bYN, @interfaced bYN, @void bYN, @msihmth bMonth, @msihcustgroup bGroup, @msihcustomer bCustomer,
		@msihcustjob varchar(20), @msihcustpo varchar(20), @msihpaymenttype char(1), @msihrectype tinyint,
		@msihinvdate bDate, @msihapplytoinv varchar(10), @msihintercoinv bYN, @msihinusebatchid bBatchID,
		@msihvoid bYN, @arstatus char(1), @ardistcode varchar(10), @misconinv bYN, @recglacct bGLAcct, @armth bMonth,
		@artrans bTrans, @openMSIDcursor tinyint, @mstrans bTrans, @fromloc bLoc, @matlvendor bVendor, @matlgroup bGroup,
		@material bMatl, @matlum bUM, @matlunits bUnits, @unitprice bUnitCost, @ecm char(1), @matltotal bDollar,
		@haultype char(1), @haultotal bDollar, @taxgroup bGroup, @taxcode bTaxCode, @taxtype tinyint, @taxbasis bDollar,
		@taxtotal bDollar, @discoff bDollar, @taxdisc bDollar, @matlcategory varchar(10), @stdum bUM, @glunits bYN,
		@umconv bUnitCost, @stkunits bUnits, @losalesglacct bGLAcct, @loqtyglacct bGLAcct, @lmsalesglacct bGLAcct,
		@lmqtyglacct bGLAcct, @lohaulrevequipglacct bGLAcct, @lohaulrevoutglacct bGLAcct, @lmhaulrevequipglacct bGLAcct,
		@lmhaulrevoutglacct bGLAcct, @salesglacct bGLAcct, @qtyglacct bGLAcct, @arfields varchar(125), @glco bCompany,
		@arglacct bGLAcct, @apglacct bGLAcct, @gltotal bDollar, @msdistcode varchar(10), @miscdistcode varchar(10),
		@haulrevglacct bGLAcct, @taxglacct bGLAcct, @arinterfacelvl tinyint, @arrectype tinyint, @autoapply bYN,
		@cmco bCompany, @cmacct bCMAcct, @msihcmco bCompany, @msihcmacct bCMAcct, @cmglacct bGLAcct, @cmglco bCompany,
		@discdate bDate, @msihdiscdate bDate, @ardiscglacct bGLAcct, @lmdiscglacct bGLAcct, @discglacct bGLAcct,
		@validcnt int, @artaxgroup bGroup,
		----International Sales Tax
		@taxrate bRate, @gstrate bRate, @pstrate bRate, @valueadd varchar(1), @saledate bDate,
		@HQTXcrdGLAcct bGLAcct, @oldHQTXcrdGLAcct bGLAcct, @HQTXcrdGLAcctPST bGLAcct, @oldHQTXcrdGLAcctPST bGLAcct, 
		@TaxAmount bDollar, @TaxAmountPST bDollar, @oldTaxAmount bDollar, @oldTaxAmountPST bDollar,
		---- #129350
		@SurchargeKeyID bigint, @SurchargeCode varchar(10),
		@lmcustsurrevequipglacct bGLAcct, @lmcustsurrevoutglacct bGLAcct, @surchargerevglacct bGLAcct
		---- #129350



set @rcode = 0


---- validate HQ Batch
exec @rcode = bspHQBatchProcessVal @msco, @mth, @batchid, 'MS Invoice', 'MSIB', @errmsg output, @status output
if @rcode <> 0 goto bspexit
if @status < 0 or @status > 3
	begin
	select @errmsg = 'Invalid Batch status!', @rcode = 1
	goto bspexit
	end
    
---- set HQ Batch status to 1 (validation in progress)
update bHQBC set Status = 1
where Co = @msco and Mth = @mth and BatchId = @batchid
if @@rowcount = 0
	begin
	select @errmsg = 'Unable to update HQ Batch Control status!', @rcode = 1
	goto bspexit
	end

---- clear HQ Batch Errors
delete bHQBE where Co = @msco and Mth = @mth and BatchId = @batchid

---- clear AR, GL, and AR Misc distribution entries
delete bMSAR where MSCo = @msco and Mth = @mth and BatchId = @batchid
delete bMSIG where MSCo = @msco and Mth = @mth and BatchId = @batchid
delete bMSMX where MSCo = @msco and Mth = @mth and BatchId = @batchid

---- get Company info from MS Company
select @msglco = GLCo, @jrnl = Jrnl, @arco = ARCo,
	   @arinterfacelvl = ARInterfaceLvl, @autoapply = AutoApplyCash
from bMSCO with (nolock) where MSCo = @msco
if @@rowcount = 0
	begin
    select @errmsg = 'Invalid MS Company #' + convert(varchar(3),isnull(@msco,'')), @rcode = 1
    goto bspexit
    end
---- validate Month in MS GL Co# - subledgers must be open
exec @rcode = bspHQBatchMonthVal @msglco, @mth, 'MS', @errmsg output
if @rcode <> 0 goto bspexit

---- validate Journal
if not exists(select top 1 1 from bGLJR with (nolock) where GLCo = @msglco and Jrnl = @jrnl)
	begin
    select @errmsg = 'Invalid Journal ' + isnull(@jrnl,'') + ' assigned in MS Company!', @rcode = 1
    goto bspexit
    end
    
---- validate AR Co#
select @arglco = GLCo from bARCO with (nolock) where ARCo = @arco
if @@rowcount = 0
	begin
	select @errmsg = 'Invalid AR Company #' + convert(varchar(3),isnull(@arco,'')), @rcode = 1
	goto bspexit
	end

---- get AR Company Tax Group from HQ
select @artaxgroup = TaxGroup from bHQCO with (nolock) where HQCo=@arco
if @@rowcount = 0
	begin
	select @errmsg = 'Unable to get HQ information for AR Company #' + convert(varchar(3),isnull(@arco,'')), @rcode = 1
	goto bspexit
	end

---- validate Month in AR GL Co# - subledgers must be open
if @arglco <> @msglco
	begin
	exec @rcode = bspHQBatchMonthVal @arglco, @mth, 'AR', @errmsg output
	if @rcode <> 0 goto bspexit
	---- validate Journal
	if not exists(select top 1 1 from bGLJR with (nolock) where GLCo = @arglco and Jrnl = @jrnl)
		begin
    	select @errmsg = 'Journal ' + isnull(@jrnl,'') + ' is invalid in AR GL Company!', @rcode = 1
    	goto bspexit
    	end
	end
    
---- declare cursor on MS Invoice Batch Header for validation
declare bcMSIB cursor LOCAL FAST_FORWARD for
select BatchSeq, MSInv, CustGroup, Customer, CustJob, CustPO, Description,
		PaymentType, RecType, PayTerms, InvDate, DiscDate, ApplyToInv, InterCoInv,
		Interfaced, Void, CMCo, CMAcct
from bMSIB with (nolock)
where Co = @msco and Mth = @mth and BatchId = @batchid

-- open cursor
open bcMSIB

-- set open cursor flag to true
select @openMSIBcursor = 1

MSIB_loop:
fetch next from bcMSIB into @seq, @msinv, @custgroup, @customer, @custjob, @custpo, @description,
			@paymenttype, @rectype, @payterms, @invdate, @discdate, @applytoinv, @intercoinv,
			@interfaced, @void, @cmco, @cmacct

if @@fetch_status <> 0 goto MSIB_end

---- save Batch Sequence # for any errors that may be found
select @errorstart = 'Seq#' + convert(varchar(6),@seq)

-- validate Invoice #
if @interfaced = 'Y' or @void = 'Y' -- previously interfaced or to be voided
	begin
	select @msihmth = Mth, @msihcustgroup = CustGroup, @msihcustomer = Customer, @msihcustjob = CustJob,
			@msihcustpo = CustPO, @msihpaymenttype = PaymentType, @msihrectype = RecType, @msihinvdate = InvDate,
			@msihdiscdate = DiscDate, @msihapplytoinv = ApplyToInv, @msihintercoinv = InterCoInv,
			@msihinusebatchid = InUseBatchId, @msihvoid = Void, @msihcmco = CMCo, @msihcmacct = CMAcct
	from bMSIH with (nolock) 
	where MSCo = @msco and MSInv = @msinv
	if @@rowcount = 0
		begin
		select @errortext = @errorstart + ' -  Invalid Invoice #.'
		goto MSIB_error
		end
		
	if @msihvoid = 'Y'
		begin
		select @errortext = @errorstart + ' - Invoice already voided.'
		goto MSIB_error
		end
		
	if isnull(@msihinusebatchid,0) <> @batchid
		begin
		select @errortext = @errorstart + ' - Existing Invoice is not locked by this batch.'
		goto MSIB_error
		end
		
	if @msihmth <> @mth
		begin
		select @errortext = @errorstart + ' - Existing Invoice was posted in another month.'
		goto MSIB_error
		end
		
	if @msihcustgroup <> @custgroup or @msihcustomer <> @customer or isnull(@msihcustjob,'') <> isnull(@custjob,'')
			or isnull(@msihcustpo,'') <> isnull(@custpo,'') or @msihpaymenttype <> @paymenttype
			or @msihrectype <> @rectype or @msihinvdate <> @invdate or isnull(@msihdiscdate,'') <> isnull(@discdate,'')
			or isnull(@msihapplytoinv,'') <> isnull(@applytoinv,'') or @msihintercoinv <> @intercoinv
			or isnull(@msihcmco,0) <> isnull(@cmco,0) or isnull(@msihcmacct,0) <> isnull(@cmacct,0)
		begin
		select @errortext = @errorstart + ' - Batch header information does not match existing Invoice header.'
		goto MSIB_error
		end
	end

---- if already Interfaced and not being Voided (reprint only), skip remaining validation and distributions
if @interfaced = 'Y' and @void = 'N' goto MSIB_loop
    
---- validate Customer
select @arstatus = Status, @ardistcode = MiscDistCode, @misconinv = MiscOnInv
from bARCM with (nolock) 
where CustGroup = @custgroup and Customer = @customer
if @@rowcount = 0
	begin
	select @errortext = @errorstart + ' - Invalid Customer.'
	goto MSIB_error
	end
if @arstatus = 'I'
	begin
	select @errortext = @errorstart + ' - Inactive Customer.'
	goto MSIB_error
	end
	
---- validate Payment Type
if @paymenttype not in ('A','C','X')
	begin
	select @errortext = @errorstart + ' - Invalid Payment Type, must be A, C, or X.'
	goto MSIB_error
	end
	
if @paymenttype = 'C' and @autoapply = 'Y'
	begin
	---- validate CM Co# and CM Account
	select @cmglco = GLCo, @cmglacct = GLAcct
	from bCMAC with (nolock) where CMCo = @cmco and CMAcct = @cmacct
	if @@rowcount = 0
		begin
		select @errortext = @errorstart + ' - Invalid CM Co# and Account, valid values needed to apply payment.'
		goto MSIB_error
		end
	
	---- validate Month in CM GL Co# - subledgers must be open
	if @cmglco not in (@msglco, @arglco)
		begin
		exec @rcode = bspHQBatchMonthVal @cmglco, @mth, 'CM', @errmsg output
		if @rcode <> 0
			begin
			select @errortext = @errorstart + ' - ' + @errmsg
			goto MSIB_error
			end
			
		---- validate Journal
		if not exists(select top 1 1 from bGLJR with (nolock) where GLCo = @cmglco and Jrnl = @jrnl)
			begin
			select @errortext = @errorstart + ' - Journal ' + isnull(@jrnl,'') + ' is invalid in CM GL Company!'
			goto MSIB_error
			end
		end
	end

if (@paymenttype <> 'C' or @autoapply = 'N') and (@cmco is not null or @cmacct is not null)
	begin
	select @errortext = @errorstart + ' - CM Co# and CM Account must be null.'
	goto MSIB_error
	end
	
---- validate Receivable Type
select @recglacct = GLARAcct, @ardiscglacct = GLDiscountAcct
from bARRT with (nolock) where ARCo = @arco and RecType = @rectype
if @@rowcount = 0
	begin
	select @errortext = @errorstart + ' - Invalid Receivable Type.'
	goto MSIB_error
	end
	
---- validate Payment Terms
if @payterms is not null
	begin
	if not exists(select top 1 1 from bHQPT with (nolock) where PayTerms = @payterms)
		begin
		select @errortext = @errorstart + ' - Invalid Payment Terms.'
		goto MSIB_error
		end
	end

---- validate Discount Date 
if @discdate is null and (select sum(d.DiscOff) from bMSID i with (nolock)
		join bMSTD d with (nolock) on i.Co = d.MSCo and i.Mth = d.Mth and i.MSTrans = d.MSTrans
		where i.Co = @msco and i.Mth = @mth and i.BatchId = @batchid and i.BatchSeq = @seq) <> 0
	begin
	select @errortext = @errorstart + ' - Discount Date is required when discount is offered.'
	goto MSIB_error
	end

---- validate Apply To Invoice
if @applytoinv is not null
	begin
	---- get first transaction with matching info
	select @armth = null
	select top 1 @armth = Mth, @artrans = ARTrans, @arrectype = RecType
	from bARTH with (nolock) 
	where ARCo = @arco and ARTransType = 'I' and CustGroup = @custgroup
	and Customer = @customer and Invoice = @applytoinv
	order by Mth, ARTrans
	
	if @armth is null
		begin
		select @errortext = @errorstart + ' - Apply To Invoice for the Customer does not exist in AR.'
		goto MSIB_error
		end
		
	if @arrectype <> @rectype
		begin
		select @errortext = @errorstart + ' - Apply To Invoice posted to a different Receivable Type.'
		goto MSIB_error
		end
	end

---- declare cursor on MS Invoice Batch Detail for validation and distributions
declare bcMSID cursor LOCAL FAST_FORWARD 
for select MSTrans
from bMSID with (nolock) where Co = @msco and Mth = @mth and BatchId = @batchid and BatchSeq = @seq

---- open cursor
open bcMSID

---- set open cursor flag to true
select @openMSIDcursor = 1

MSID_loop:
fetch next from bcMSID into @mstrans

if @@fetch_status <> 0 goto MSID_end

---- add MS Trans# to error message
select @errorstart = 'Seq#' + convert(varchar(6),@seq) + ' Trans#' + convert(varchar(8),@mstrans)

---- validate Trans# and get info for distributions
select @fromloc = FromLoc, @matlvendor = MatlVendor, @custjob = CustJob, @custpo = CustPO,
		@matlgroup = MatlGroup, @material = Material, @matlum = UM, @matlunits = MatlUnits,
		@unitprice = UnitPrice, @ecm = ECM, @matltotal = MatlTotal, @haultype = HaulerType,
		@haultotal = HaulTotal, @taxgroup = TaxGroup, @taxcode = TaxCode, @taxtype = TaxType,
		@taxbasis = TaxBasis, @taxtotal = TaxTotal, @discoff = DiscOff, @taxdisc = TaxDisc,
		@saledate = SaleDate,
		----#129350
		@SurchargeKeyID = SurchargeKeyID, @SurchargeCode = SurchargeCode
		----#129350
from dbo.bMSTD with (nolock) where MSCo = @msco and Mth = @mth and MSTrans = @mstrans
if @@rowcount = 0
	begin
	select @errortext = @errorstart + ' - Invalid or missing MS Transaction#.'
	goto MSID_error
	end

---- Invoice Detail already validated via triggers on bMSID
---- issue #27601 - validate AR TaxGroup to MSTD TaxGroup must be same
if isnull(@taxcode,'') <> ''
	begin
	if @artaxgroup <> @taxgroup
		begin
		select @errortext = @errorstart + ' - MS Ticket Tax Group: ' + isnull(convert(varchar(3),@taxgroup),'') + ' must match AR Tax Group: ' + isnull(convert(varchar(3),@artaxgroup),'') + '.'
		goto MSID_error
		end
	end

---- if Invoice to be voided, reverse signs on units and dollars
if @void = 'Y'
	begin
	select @matlunits = -@matlunits, @matltotal = -@matltotal, @haultotal = -@haultotal,
		   @taxbasis = -@taxbasis, @taxtotal = -@taxtotal, @discoff = -@discoff,
		   @taxdisc = -@taxdisc
	end

---- validate Material - changed per issue #20798
select @matlcategory = Category, @stdum = StdUM
from dbo.bHQMT with (nolock) where MatlGroup = @matlgroup and Material = @material and Active = 'Y'
if @@rowcount = 0
	begin
	select @errortext = @errorstart + ' - Invalid Material, ' + isnull(@material,'') + ' must be setup in HQ and active!'
	goto MSID_error
	end
    
---- get GL units update flag from IN Materials - issue #20798 - issue #23824
select @glunits = 'N', @umconv = 1
if /*@matlvendor is null and*/ @matlunits <> 0
	begin
	---- get stocked material info
	select @glunits = GLSaleUnits from bINMT with (nolock) 
	where INCo = @msco and Loc = @fromloc and MatlGroup = @matlgroup and Material = @material and Active = 'Y'
	---- #24820
	select @validcnt = @@rowcount
	if @validcnt = 0 and @matlvendor is null
		begin
		select @errortext = @errorstart + ' - Invalid Material, ' + isnull(@material,'') + ' at From Location, must be active!'
		goto MSID_error
		end

	---- get material conversion factor
	if @validcnt <> 0 and @matlum <> @stdum
		begin
		select @umconv = Conversion from bINMU with (nolock) 
		where INCo = @msco and Loc = @fromloc and MatlGroup = @matlgroup and Material = @material and UM = @matlum
		---- #24820
		select @validcnt = @@rowcount
		if @validcnt = 0 and @matlvendor is null
			begin
			select @errortext = @errorstart + ' - Invalid Unit of Measure!'
			goto MSID_error
			end
		if @validcnt = 0 and @matlvendor is not null
		select @umconv = 0
		end

	---- convert units sold to std u/m
	select @stkunits = @matlunits * @umconv
	end


---- get GL Accounts based on Location with overrides by Category - issue #20798
select @losalesglacct = null, @loqtyglacct = null
select @lohaulrevequipglacct = null, @lohaulrevoutglacct = null

select @lmsalesglacct = CustSalesGLAcct, @lmqtyglacct = CustQtyGLAcct, @lmdiscglacct = ARDiscountGLAcct,
		@lmhaulrevequipglacct = CustHaulRevEquipGLAcct, @lmhaulrevoutglacct = CustHaulRevOutGLAcct,
	   	---- #129350
		@lmcustsurrevequipglacct = CustSurchargeRevEquipGLAcct,
		@lmcustsurrevoutglacct = CustSurchargeRevOutGLAcct
		---- #129350
from dbo.bINLM with (nolock) where INCo = @msco and Loc = @fromloc and Active = 'Y'
if @@rowcount = 0
	begin
	select errortext = @errorstart + ' - Invalid From Location, ' + isnull(@fromloc,'') + ' must be setup in IN and active!'
	goto MSID_error
	end

---- get any GL Account overrides based on Material Category
select @losalesglacct = CustSalesGLAcct, @loqtyglacct = CustQtyGLAcct,
		@lohaulrevequipglacct = CustHaulRevEquipGLAcct, @lohaulrevoutglacct = CustHaulRevOutGLAcct
from dbo.bINLO with (nolock) 
where INCo = @msco and Loc = @fromloc and MatlGroup = @matlgroup and Category = @matlcategory

---- assign Qty Accounts
set @qtyglacct = isnull(@loqtyglacct,@lmqtyglacct)
---- assign sales accounts
set @salesglacct = isnull(@losalesglacct,@lmsalesglacct)

---- validate Sales Account
exec @rcode = bspGLACfPostable @msglco, @salesglacct, 'I', @errmsg output
if @rcode <> 0
	begin
	select @errortext = @errorstart + ' - Sales Account ' + isnull(@errmsg,'')
	goto MSID_error
	end

----TK-17081 validate surcharge outside haul GL account
if @SurchargeKeyID IS NOT NULL AND @haultype = 'H'
	BEGIN
	IF @lmcustsurrevoutglacct IS NULL
		BEGIN
		SELECT @errortext = @errorstart + 'Missing Haul - Outside Haulers customer sales GL account.'
		GOTO MSID_error
		END
		
	---- validate GL account
	exec @rcode = bspGLACfPostable @msglco, @lmcustsurrevoutglacct, 'I', @errmsg output
	if @rcode <> 0
		BEGIN
		SELECT @errortext = @errorstart + ' - Haul - Outside Haulers customer sales GL accoun ' + isnull(@errmsg,'')
		GOTO MSID_error
		END
	END
	
----TK-17081 validate surcharge own equipment GL account
if @SurchargeKeyID IS NOT NULL AND @haultype = 'E' 
	BEGIN
	IF @lmcustsurrevequipglacct IS NULL
		BEGIN
		SELECT @errortext = @errorstart + 'Missing Haul - Own Equipment customer sales GL account.'
		GOTO MSID_error
		END

	---- validate GL account
	exec @rcode = bspGLACfPostable @msglco, @lmcustsurrevequipglacct, 'I', @errmsg output
	if @rcode <> 0
		BEGIN
		SELECT @errortext = @errorstart + ' - Haul - Own Equipment customer sales GL account ' + isnull(@errmsg,'')
		GOTO MSID_error
		END
	END


---- assign AR interface fields, used to create AR Invoice Lines based on interface level
select @arfields = ''
select @arfields = @arfields + convert(char(10),@fromloc)
---- interfacing material
if @arinterfacelvl > 1
	begin
	select @arfields = @arfields + convert(char(3),@matlgroup) + convert(char(20),@material) + convert(char(3),@matlum)
	end
else
	begin
	select @arfields = @arfields + '                          ' -- 26 spaces
	end

---- interfacing unit price
if @arinterfacelvl > 2
	begin
	---- need to verify unit price will fit in 12 characters, otherwise arithmetic overflow error will occur
	---- for positive number amount must be greater than 999,999.99999
	if @unitprice > 999999.99999
		begin
		select @errortext = @errorstart + ' - Unit Price exceeds the mask allowed for AR Interface level 3'
		goto MSID_error
		end
	if @unitprice < -99999.99999
		begin
		select @errortext = @errorstart + ' - Unit Price exceeds the mask allowed for AR Interface level 3'
		goto MSID_error
		end
		
	---- add unit cost and ecm
	select @arfields = @arfields + convert(char(12),@unitprice) + isnull(@ecm,' ')
	end
else
	begin
	select @arfields = @arfields + '             '	-- 13 spaces
	end

----#129350
---- add GLCo and Sales Account to AR Fields
if @SurchargeKeyID is null
	begin
	select @arfields = @arfields + convert(char(3),@msglco) + convert(char(20),@salesglacct)
	end
else
	begin
	if @haultype = 'N' 
		BEGIN
		IF @salesglacct IS NULL
			BEGIN
			select @errortext = @errorstart + ' - Sales GLAcct is not set.'
			goto MSID_error
			END
		ELSE
			set @arfields = @arfields + convert(char(3),@msglco) + convert(char(20),@salesglacct)
		END
	if @haultype = 'H' 
		BEGIN
		IF @lmcustsurrevoutglacct IS NULL
		BEGIN
			select @errortext = @errorstart + ' - Cust Surcharge RevOut GLAcct is not set.'
			goto MSID_error
		END
		ELSE
			set @arfields = @arfields + convert(char(3),@msglco) + convert(char(20),@lmcustsurrevoutglacct)
	END
	if @haultype = 'E' 
	BEGIN
		IF @lmcustsurrevequipglacct IS NULL
		BEGIN
			select @errortext = @errorstart + ' - Cust Surcharge Rev Equip GLAcct is not set.'
			goto MSID_error
		END
		ELSE
			set @arfields = @arfields + convert(char(3),@msglco) + convert(char(20),@lmcustsurrevequipglacct)
	END
	end
----#129350

---- add tax code to AR Fields
if @taxcode is not null
	begin
	select @arfields = @arfields + convert(char(3),@taxgroup) + convert(char(10),@taxcode)
	end
else
	begin
	select @arfields = @arfields + '             '    -- 13 spaces
	end

---- add customer job to AR Fields
if @custjob is not null
	begin
	select @arfields = @arfields + convert(char(20),@custjob)
	end
else
	begin
	select @arfields = @arfields + '                    '  -- 20 spaces
	end

---- add customer PO to AR Fields
if @custpo is not null
	begin
	select @arfields = @arfields + convert(char(20),@custpo)
	end
else
	begin
	select @arfields = @arfields + '                    '  -- 20 spaces
	end


---- #129350
if @SurchargeKeyID is null
	begin
	---- add AR Line distribution entry for Material, Tax, and Discount (no haul)
	insert bMSAR(MSCo, Mth, BatchId, BatchSeq, ARFields, MSTrans, FromLoc, MatlGroup, Material,
			UM, MatlUnits, UnitPrice, ECM, MatlTotal, HaulTotal, GLCo, GLAcct, TaxGroup, TaxCode,
			TaxBasis, TaxTotal, DiscOff, TaxDisc, CustJob, CustPO)
	values(@msco, @mth, @batchid, @seq, @arfields, @mstrans, @fromloc, @matlgroup, @material,
			@matlum, @matlunits, @unitprice, @ecm, @matltotal, 0, @msglco, @salesglacct, @taxgroup, @taxcode,
			@taxbasis, @taxtotal, @discoff, @taxdisc, @custjob, @custpo)
	end
else
	begin
	---- add AR Line distribution entry for Surcharge, Tax, and Discount
	insert bMSAR(MSCo, Mth, BatchId, BatchSeq, ARFields, MSTrans, FromLoc, MatlGroup, Material,
			UM, MatlUnits, UnitPrice, ECM, MatlTotal, HaulTotal, GLCo, GLAcct, TaxGroup, TaxCode,
			TaxBasis, TaxTotal, DiscOff, TaxDisc, CustJob, CustPO)
	values(@msco, @mth, @batchid, @seq, @arfields, @mstrans, @fromloc, @matlgroup, @material,
			@matlum, @matlunits, @unitprice, @ecm, @matltotal, 0, @msglco,
			case @haultype when 'N' then @salesglacct
						   when 'E' then @lmcustsurrevequipglacct
						   when 'H' then @lmcustsurrevoutglacct end,				 
			@taxgroup, @taxcode, @taxbasis, @taxtotal, @discoff, @taxdisc, @custjob, @custpo)
	end


---- validate AR GL Account based on Invoice Receivable Type
exec @rcode = bspGLACfPostable @msglco, @recglacct, 'R', @errmsg output
if @rcode <> 0
	begin
	select @errortext = @errorstart + ' - AR GL Account ' + isnull(@errmsg,'')
	goto MSID_error
	end

---- AR debit for total sale
update bMSIG set Amount = Amount + @matltotal + @haultotal + @taxtotal
where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
and GLAcct = @recglacct and BatchSeq = @seq
if @@rowcount = 0
	begin
	insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
			CustPO, Description, InvDate, Amount)
	values(@msco, @mth, @batchid, @arglco, @recglacct, @seq, @msinv, @custgroup, @customer, @custjob,
			@custpo, @description, @invdate, @matltotal + @haultotal + @taxtotal)
	end

----#129350
if @SurchargeKeyID is null
	begin
	---- Sales credit for material (no haul or tax) or no surcharges
	update bMSIG set Amount = Amount - @matltotal
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @msglco
	and GLAcct = @salesglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @msglco, @salesglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, -@matltotal)
		end
	end
----#129350

---- Qty Sold --
if @glunits = 'Y' and @qtyglacct is not null
	begin
	---- validate Sales Qty Account
	exec @rcode = bspGLACQtyVal @msglco, @qtyglacct, @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Sales Qty Account ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- Sales Qty (credit units sold)
	update bMSIG set Amount = Amount - @stkunits
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @msglco
	and GLAcct = @qtyglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @msglco, @qtyglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, -@stkunits)
		end
	end

---- Haul Revenue credit
if @haultotal <> 0
	begin
	---- get Haul Revenue GL Accounts (Equip or Outside)
	if @haultype = 'E' select @haulrevglacct = isnull(@lohaulrevequipglacct,@lmhaulrevequipglacct)
	if @haultype = 'H' select @haulrevglacct = isnull(@lohaulrevoutglacct,@lmhaulrevoutglacct)
	-- validate Haul Revenue Account
	exec @rcode = bspGLACfPostable @msglco, @haulrevglacct, 'I', @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Haul Revenue Account ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- Haul Revenue credit
	update bMSIG set Amount = Amount - @haultotal
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @msglco
	and GLAcct = @haulrevglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @msglco, @haulrevglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, -@haultotal)
		end

	---- assign AR interface fields for Haul entry
	select @arfields = ''
	select @arfields = @arfields + convert(char(10),@fromloc)
	select @arfields = @arfields + '                          ' -- 26 spaces (material info)
	select @arfields = @arfields + '             '	-- 13 spaces (unit price info)
	select @arfields = @arfields + convert(char(3),@msglco) + convert(char(20),@haulrevglacct)

	---- spaces for tax info
	select @arfields = @arfields + '             '    -- 13 spaces (tax info)
	
	---- customer job to AR Fields
	if @custjob is not null
		begin
		select @arfields = @arfields + convert(char(20),@custjob)
		end
	else
		begin
		select @arfields = @arfields + '                    '  -- 20 spaces
		end
	
	---- customer po to AR fields
	if @custpo is not null
		begin
		select @arfields = @arfields + convert(char(20),@custpo)
		end
	else
		begin
		select @arfields = @arfields + '                    '  -- 20 spaces
		end

	---- add AR Line distribution entry for Haul
	update bMSAR set HaulTotal = HaulTotal + @haultotal
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and BatchSeq = @seq and ARFields = @arfields
	and MSTrans = @mstrans
	if @@rowcount = 0
		begin
		insert bMSAR(MSCo, Mth, BatchId, BatchSeq, ARFields, MSTrans, FromLoc, MatlGroup, Material, UM,
				MatlUnits, UnitPrice, ECM, MatlTotal, HaulTotal, GLCo, GLAcct, TaxGroup, TaxCode, TaxBasis,
				TaxTotal, DiscOff, TaxDisc, CustJob, CustPO)
		values(@msco, @mth, @batchid, @seq, @arfields, @mstrans, @fromloc, @matlgroup, @material, @matlum,
				0, 0, null, 0, @haultotal, @msglco, @haulrevglacct
				----TFS-44951
				, NULL, NULL, 0, 0, 0, 0, @custjob, @custpo)
		end
	end


----#129350 surcharge revenue credit
if @SurchargeKeyID is not null and @matltotal <> 0
	begin
	---- get surcharge Revenue GL Accounts (Equip or Outside)
	----#143485
	IF @haultype = 'N' SET @surchargerevglacct = @salesglacct
	if @haultype = 'E' set @surchargerevglacct = @lmcustsurrevequipglacct
	if @haultype = 'H' set @surchargerevglacct = @lmcustsurrevoutglacct
	-- validate surcharge Revenue Account
	exec @rcode = bspGLACfPostable @msglco, @surchargerevglacct, 'I', @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Surcharge Revenue Account ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- Surcharge Revenue credit
	update bMSIG set Amount = Amount - @matltotal
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @msglco
	and GLAcct = @surchargerevglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @msglco, @surchargerevglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, -@matltotal)
		end
	end


---- Tax Accrual credit
if @taxtotal <> 0
	begin
	select @HQTXcrdGLAcct = null, @HQTXcrdGLAcctPST = null, @TaxAmount = 0, @TaxAmountPST = 0
	---- get tax rates for international
	exec @rcode = dbo.bspHQTaxRateGetAll @taxgroup, @taxcode, @saledate, null,
				@taxrate output, @gstrate output, @pstrate output, @HQTXcrdGLAcct output,
				null, null, null, @HQTXcrdGLAcctPST output, null, NULL,NULL,@errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Tax Code: ' + isnull(@taxcode,'') + ' is not valid. ' + isnull(@errmsg,'')
		goto MSID_error
		end
	if @pstrate = 0
		begin
			/* When @pstrate = 0:  Either Standard US, VAT SingleLevel using GST only, or VAT MultiLevel GST/PST with PST set to 0.00 tax rate.  
			   In any case:
			   a)  @taxrate is the correct value.  
			   b)  Standard US:	Credit GLAcct */
		select @TaxAmount = @taxtotal
		end
	else
		begin
		---- VAT MultiLevel:  Breakout GST and PST for proper GL distribution.
		if @taxrate <> 0
			begin
			select @TaxAmount = (@taxtotal * @gstrate) / @taxrate		--GST TaxAmount
			select @TaxAmountPST = @taxtotal - @TaxAmount				--PST TaxAmount
			end
		end

	---- validate tax accrual account in AR GL Co#
	exec @rcode = dbo.bspGLACfPostable @arglco, @HQTXcrdGLAcct, 'N', @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Tax Accrual GL account ' + isnull(@errmsg,'')
		goto MSID_error
		end

	---- Tax Accrual credit
	update bMSIG set Amount = Amount - @TaxAmount
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
	and GLAcct = @HQTXcrdGLAcct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer,
			CustJob, CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @arglco, @HQTXcrdGLAcct, @seq, @msinv, @custgroup, @customer,
			@custjob, @custpo, @description, @invdate, -@TaxAmount)
		end

	---- validate PST tax accrual account if we have one
	if @pstrate <> 0 and @TaxAmountPST <> 0
		begin
		exec @rcode = dbo.bspGLACfPostable @arglco, @HQTXcrdGLAcctPST, 'N', @errmsg output
		if @rcode <> 0
			begin
			select @errortext = @errorstart + ' - PST Tax Accrual GL account ' + isnull(@errmsg,'')
			goto MSID_error
			end

		---- Tax Accrual credit - PST
		update bMSIG set Amount = Amount - @TaxAmountPST
		where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
		and GLAcct = @HQTXcrdGLAcctPST and BatchSeq = @seq
		if @@rowcount = 0
			begin
			insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer,
					CustJob, CustPO, Description, InvDate, Amount)
			values(@msco, @mth, @batchid, @arglco, @HQTXcrdGLAcctPST, @seq, @msinv, @custgroup, @customer,
					@custjob, @custpo, @description, @invdate, -@TaxAmountPST)
			end
		end
	end


---- add Intercompany entries if needed
if @arglco <> @msglco
	begin
	---- get interco GL Accounts
	select @arglacct = ARGLAcct, @apglacct = APGLAcct
	from bGLIA with (nolock) where ARGLCo = @msglco and APGLCo = @arglco
	if @@rowcount = 0
		begin
		select @errortext = @errorstart + ' - Intercompany Accounts not setup in GL for these companies!'
		goto MSID_error
		end
		
	---- validate Intercompany AR GL Account
	exec @rcode = bspGLACfPostable @msglco, @arglacct, 'R', @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Intercompany AR Account  ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- Intercompany AR debit (posted in IN/MS GL Co#)
	select @gltotal = @matltotal + @haultotal	-- does not include tax
	update bMSIG set Amount = Amount + @gltotal
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @msglco
	and GLAcct = @arglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @msglco, @arglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, @gltotal)
		end

	---- validate Intercompany AP GL Account
	exec @rcode = bspGLACfPostable @arglco, @apglacct, 'P', @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - Intercompany AP Account  ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- Intercompany AP credit (posted in AR GL Co#)
	update bMSIG set Amount = Amount - @gltotal 
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
	and GLAcct = @apglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @arglco, @apglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, -@gltotal)
		end
	end


---- #14177 - add GL distrubtions for auto payments
if @autoapply = 'Y' and @paymenttype = 'C'
	begin
	---- validate Cash GL Account 
	exec @rcode = bspGLACfPostable @cmglco, @cmglacct, 'C', @errmsg output
	if @rcode <> 0
		begin
		select @errortext = @errorstart + ' - CM Cash Account  ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- Cash debit for payment (posted in CM GL Co#)
	update bMSIG set Amount = Amount + @matltotal + @haultotal + @taxtotal - @discoff - @taxdisc -- less all discounts
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @cmglco
	and GLAcct = @cmglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
				CustPO, Description, InvDate, Amount)
		values(@msco, @mth, @batchid, @cmglco, @cmglacct, @seq, @msinv, @custgroup, @customer, @custjob,
				@custpo, @description, @invdate, (@matltotal + @haultotal + @taxtotal - @discoff))
		end

	---- validate AR Discount GL Account
	if @discoff <> 0
		begin
		select @discglacct = isnull(@lmdiscglacct, @ardiscglacct)
		exec @rcode = bspGLACfPostable @arglco, @discglacct, 'R', @errmsg output
		if @rcode <> 0
			begin
			select @errortext = @errorstart + ' - AR Discount GL Account  ' + isnull(@errmsg,'')
			goto MSID_error
			end
			
		---- Discount taken debit (posted in AR GL Co#)
		update bMSIG set Amount = Amount + @discoff 
		where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
		and GLAcct = @discglacct and BatchSeq = @seq
		if @@rowcount = 0
			begin
			insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
					CustPO, Description, InvDate, Amount)
			values(@msco, @mth, @batchid, @arglco, @discglacct, @seq, @msinv, @custgroup, @customer, @custjob,
					@custpo, @description, @invdate, @discoff)
			end
		end
		
	---- Tax Accural debit (posted in AR GL Co#) - reduces tax liability by tax discount amount
	if @taxdisc <> 0
		begin
		---- Tax Accrual Account validated with Tax - cannot have TaxDisc w/o Tax
		update bMSIG set Amount = Amount + @taxdisc
		where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
		and GLAcct = @taxglacct and BatchSeq = @seq
		if @@rowcount = 0
			begin
			insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
					CustPO, Description, InvDate, Amount)
			values(@msco, @mth, @batchid, @arglco, @taxglacct, @seq, @msinv, @custgroup, @customer, @custjob,
					@custpo, @description, @invdate, @taxdisc)
			end
		end

	---- AR credit for full amount (posted in AR GL Co#) -- account already validated, should offset orig debit
	update bMSIG set Amount = Amount - @matltotal - @haultotal - @taxtotal 
	where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
	and GLAcct = @recglacct and BatchSeq = @seq
	if @@rowcount = 0
		begin
		select @errortext = @errorstart + ' - Unable to add AR credit distribution for payment  ' + isnull(@errmsg,'')
		goto MSID_error
		end
		
	---- add Intercompany entries if needed
	if @arglco <> @cmglco
		begin
		select @gltotal = @matltotal + @haultotal + @taxtotal - @discoff - @taxdisc	-- total less all discounts
		---- get interco GL Accounts
		select @arglacct = ARGLAcct, @apglacct = APGLAcct
		from bGLIA with (nolock) where ARGLCo = @arglco and APGLCo = @cmglco
		if @@rowcount = 0
			begin
			select @errortext = @errorstart + ' - Intercompany Accounts not setup in GL for the AR and CM companies!'
			goto MSID_error
			end
			
		---- validate Intercompany AR GL Account
		exec @rcode = bspGLACfPostable @arglco, @arglacct, 'R', @errmsg output
		if @rcode <> 0
			begin
			select @errortext = @errorstart + ' - Intercompany AR Account  ' + isnull(@errmsg,'')
			goto MSID_error
			end
			
		---- Intercompany AR debit (posted in AR GL Co#) - matches Cash debit
		update bMSIG set Amount = Amount + @gltotal 
		where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @arglco
		and GLAcct = @arglacct and BatchSeq = @seq
		if @@rowcount = 0
			begin
			insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
					CustPO, Description, InvDate, Amount)
			values(@msco, @mth, @batchid, @arglco, @arglacct, @seq, @msinv, @custgroup, @customer, @custjob,
					@custpo, @description, @invdate, @gltotal)
			end
			
		---- validate Intercompany AP GL Account
		exec @rcode = bspGLACfPostable @cmglco, @apglacct, 'P', @errmsg output
		if @rcode <> 0
			begin
			select @errortext = @errorstart + ' - Intercompany AP Account  ' + isnull(@errmsg,'')
			goto MSID_error
			end
			
		---- Intercompany AP credit (posted in AR GL Co#)
		update bMSIG set Amount = Amount - @gltotal 
		where MSCo = @msco and Mth = @mth and BatchId = @batchid and GLCo = @cmglco
		and GLAcct = @apglacct and BatchSeq = @seq
		if @@rowcount = 0
			begin
			insert bMSIG(MSCo, Mth, BatchId, GLCo, GLAcct, BatchSeq, MSInv, CustGroup, Customer, CustJob,
					CustPO, Description, InvDate, Amount)
			values(@msco, @mth, @batchid, @cmglco, @apglacct, @seq, @msinv, @custgroup, @customer, @custjob,
					@custpo, @description, @invdate, -@gltotal)
			end
		end
	end


/****************** finished with GL distributions *******************/
    
---- if Customer flagged for Misc Dist on Invoice, create Misc Dist codes
if @misconinv = 'Y'
	begin
	-- check for Misc Dist Code override on Quote
	select @msdistcode = null
	select @msdistcode = MiscDistCode
	from bMSQH with (nolock) 
	where MSCo = @msco and CustGroup = @custgroup and Customer = @customer
	and isnull(CustJob,'') = isnull(@custjob,'') and isnull(CustPO,'') = isnull(@custpo,'') and Active = 'Y' -- must be Active
	if @@rowcount = 0
		begin
		---- if no Quote found at Customer PO level, check at Customer Job level
		select @msdistcode = MiscDistCode
		from bMSQH with (nolock) 
		where MSCo = @msco and CustGroup = @custgroup and Customer = @customer
		and isnull(CustJob,'') = isnull(@custjob,'') and CustPO is null and Active = 'Y'
		if @@rowcount = 0
			begin
			---- if no Quote found at Customer Job level, check at Customer level
			select @msdistcode = MiscDistCode
			from bMSQH with (nolock) 
			where MSCo = @msco and CustGroup = @custgroup and Customer = @customer
			and CustJob is null and CustPO is null and Active = 'Y'
			end
		end

	---- select Misc Dist Code
	select @miscdistcode = isnull(@msdistcode,@ardistcode)
	if @miscdistcode is null goto MSID_loop
	
	---- validate Misc Dist Code
	if not exists(select top 1 1 from bARMC with (nolock) where CustGroup = @custgroup and MiscDistCode = @miscdistcode)
		begin
		select @errortext = @errorstart + ' - Invalid AR Misc Dist Code'
		goto MSID_error
		end
		
	---- add or update amounts in bMSMX
	update bMSMX set Amount = Amount + @matltotal + @haultotal + @taxtotal
	where MSCo = @msco and Mth = @mth and BatchId = @batchid
	and BatchSeq = @seq and MiscDistCode = @miscdistcode
	if @@rowcount = 0
		begin
		insert bMSMX(MSCo, Mth, BatchId, BatchSeq, MiscDistCode, Amount)
		values(@msco, @mth, @batchid, @seq, @miscdistcode, @matltotal + @haultotal + @taxtotal)
		end
	end


/****** DONE WITH THIS TRANSACTION ******/

goto MSID_loop


MSID_error:	-- record error message and go to next Invoice Detail
	exec @rcode = bspHQBEInsert @msco, @mth, @batchid, @errortext, @errmsg output
	if @rcode <> 0 goto bspexit
	goto MSID_loop

MSID_end:   -- finished with Invoice Detail
	close bcMSID
	deallocate bcMSID
	select @openMSIDcursor = 0
	goto MSIB_loop  -- next Invoice Header

MSIB_error:	-- record error message and go to next Invoice Header
	exec @rcode = bspHQBEInsert @msco, @mth, @batchid, @errortext, @errmsg output
	if @rcode <> 0 goto bspexit
	goto MSIB_loop

MSIB_end:   -- finished with Invoice Headers
	close bcMSIB
	deallocate bcMSIB
	select @openMSIBcursor = 0



---- make sure debits and credits balance
select @glco = m.GLCo from bMSIG m with (nolock) 
join bGLAC g with (nolock) on m.GLCo = g.GLCo and m.GLAcct = g.GLAcct and g.AcctType <> 'M'  -- exclude memo accounts for qtys
where m.MSCo = @msco and m.Mth = @mth and m.BatchId = @batchid
group by m.GLCo
having isnull(sum(Amount),0) <> 0
if @@rowcount <> 0
	begin
	select @errortext = 'GL Company ' + convert(varchar(3),isnull(@glco,'')) + ' entries don''t balance!'
	exec @rcode = bspHQBEInsert @msco, @mth, @batchid, @errortext, @errmsg output
	if @rcode <> 0 goto bspexit
	end

---- check HQ Batch Errors and update HQ Batch Control status
set @status = 3	-- valid - ok to post
if exists(select top 1 1 from bHQBE with (nolock) where Co = @msco and Mth = @mth and BatchId = @batchid)
	begin
	set @status = 2	-- validation errors
	end
	
---- update batch status
update bHQBC
set Status = @status
where Co = @msco and Mth = @mth and BatchId = @batchid
if @@rowcount <> 1
	begin
	select @errmsg = 'Unable to update HQ Batch Control status!', @rcode = 1
	goto bspexit
	end




bspexit:
	if @openMSIDcursor = 1
		begin
		close bcMSID
		deallocate bcMSID
		end
	if @openMSIBcursor = 1
		begin
		close bcMSIB
		deallocate bcMSIB
		end

	if @rcode <> 0 select @errmsg = isnull(@errmsg,'')
	return @rcode



GO
PRINT N'Refreshing [dbo].[POIBTotals]'
GO
EXEC sp_refreshview N'[dbo].[POIBTotals]'
GO
PRINT N'Refreshing [dbo].[viFact_JCRevenueDetail]'
GO
EXEC sp_refreshview N'[dbo].[viFact_JCRevenueDetail]'
GO
PRINT N'Refreshing [dbo].[SMStandardTask]'
GO
EXEC sp_refreshview N'[dbo].[SMStandardTask]'
GO
PRINT N'Refreshing [dbo].[EMWHStdMaintGroupNotes]'
GO
EXEC sp_refreshview N'[dbo].[EMWHStdMaintGroupNotes]'
GO
PRINT N'Refreshing [dbo].[brvGLActtoBud]'
GO
EXEC sp_refreshview N'[dbo].[brvGLActtoBud]'
GO
PRINT N'Altering [dbo].[bspPMSLInitialize]'
GO


/****** Object:  Stored Procedure dbo.bspPMSLInitialize    Script Date: 8/28/99 9:35:18 AM ******/
ALTER proc [dbo].[bspPMSLInitialize]
/*************************************
* CREATED BY:	LM 04/01/1999
* LAST MODIFIED:GF 04/14/2000 - changed how the SLItem description is defaulted.
*				GF 05/02/2000 - fixed the SubCO get next.
*               GF 06/06/2000 - fixed the project/seq not numeric issue.
*               GF 11/30/2000 - consider status when creating SL by project/seq
*               GF 04/03/2001 - change status check to consider pending or open - issue #12828
*               GF 05/11/2001 - change to get max SL to consider length of SL - issue #13405
*				GF 11/15/2001 - problem with @rectype, should be 'O','A','P'
*				GF 10/17/2002 - issue #18996 do not set SubCO for pending change orders
*				GF 05/14/2003 - issue #21267 need to handle multi-part format SL's
*				GF 02/26/2004 - issue #23764 - no longer create PMSL.SLItemDescription if not empty
*				GF 01/11/2005 - issue #26675 - problem with getting max(SL) when creating project/seq and
*								trim trailing spaces for PMSL.SL is 'N'.
*				GF 03/25/2005 - issue #27482 - if using significant part project and have leading spaces
*								in project, need to not count spaces in SL characters of project.
*				GF 09/15/2005 - issue #29785 trim project part of SL when building SL formatted string.
*				GF 10/31/2005 - issue #30146 completely re-wrote getting max(SL) when using project/seq.
*				GF 08/01/2006 - issue #27853 6.x minor changes, return message. check for inactive phases
*				GF 10/19/2006 - issue #120899 use PMCO.SLStartSeq when no SL's exist for project.
*				GF 01/11/2008 - issue #126706 was not checking ACO and PCO correctly, so did not initialize.
*					GF 04/26/2008 - issue #127908 SubCo numbering by ACO
*					GF 08/19/2008 - issue #129451 sequence needs to start with zero, so that increment value for new project will be 1 not 2
*					GF 06/28/2010 - issue #135813 SL expanded to 30 characters
*				GP 12/16/2010 - added insert to vSLInExclusions if related PC Bid Package In/Exclusions exist (reviewed by DanSo)
*				GF 08/01/2011 TK-07189 allow for rec type = 'X' PCO approval
*				GP 08/30/2011 TK-07993 removed code to get and update @subco
*				GF 10/03/2011 TK-08876 PUT BACK TK-07993 CODE
*				DAN SO 03/13/2013 - TK-13139 - Added @CreateSingleChangeOrder and check for adding to same CO
*											 - @CreateSingleChangeOrder takes precedence over @UseApprSubCo
*				GF 03/30/2012 TK-13768 use the @CreateChangeorders flag
*				AW 03/15/2013 TFS-Make generating the next SL Number its own process (commented out code)
*
*
* Pass this a Project and some issue info and it will initialize SLs
*
* Pass:
*   PMCO
*   Project
*   RecType
*   PCOType
*   CO
*   COItem
*
* Success returns:
*	0 on Success, 1 on ERROR
*
* Error returns:
*	1 and error message
**************************************/
(@pmco bCompany=null, @project bJob=null, @rectype char(1)=null, @cotype bDocType=null,
 @co bACO=null, @coitem bACOItem=null, @pmslseqlist varchar(2000) = '',
 -- TK-13139 -- 
 @CreateSingleChangeOrder bYN = NULL,
 @msg varchar(255) output)
as
set nocount on

declare @rcode int, @retcode int, @validcnt int, @apco bCompany,
		--@slno varchar(1), @sigpartjob bYN, @validpartjob varchar(30), @slcharsproject tinyint,  
		--@slmask varchar(30), @sllength varchar(30), @slstartseq SMALLINT,
		--@sigchars smallint, @slcharsvendor tinyint, @slseqlen int, @projectpart bProject, @mseq int,
		--@tmpsl varchar(30), @tmpsl1 VARCHAR(30), @tmpseq varchar(30), @i int, @value varchar(1), @tmpseq1 varchar(30),
		--@vendorPart varchar(30), @paddedstring varchar(60), @dummy_sl varchar(30),
		--
		@vendor bVendor, @seq int,
		@SL VARCHAR(30), @slitem bItem,
		@formattedsl varchar(30),  @phase bPhase, @itemtype int,
		@phasegroup bGroup, 
		@slitemfrompm bItem,  @addon tinyint, @addonpct bPct,
		@addonamt bDollar, @sladdonamt bDollar, @pmaddonamt bDollar, @addonseq int,
		@slrcode int, @slmsg varchar(60), @defpcotype bDocType, @defpco bPCO,
		@defpcoitem bPCOItem,@defaco bACO, @defacoitem bACOItem, 
		@partseq int, @tmpproject varchar(30), @actchars smallint,
		@defrecordtype char(1),  
		@slitemdescription bItemDesc, @lastslseq int,  --bSL,  DC #135813
		
		@active bYN, @phasemsg varchar(100), @opencursor int, @recordtype varchar(1),
		@pcotype bDocType, @pco bACO, @pcoitem bACOItem, @aco bACO, @acoitem bACOItem,
		@lastvendor bVendor, 
		@SLExists CHAR(1),
		---- TK-08876
		@subco INT, @UseApprSubCo CHAR(1)

select @rcode = 0, @opencursor = 0, @slrcode = 0, @lastslseq = 0, @lastvendor = null,
		@phasemsg = '', @msg = ''

if @pmco is null or @project is null
	begin
	select @msg = 'Missing information!', @rcode = 1
	goto bspexit
	end

----if @rectype = 'C' and isnull(@cotype,'') = ''  select @rectype='A'
----if @rectype = 'C' and isnull(@cotype,'') <> '' select @rectype = 'P'
----TK-07189
if @rectype <> 'O' and @rectype <> 'P' and @rectype <> 'A' AND @rectype <> 'X'
       begin
       select @msg = 'Missing Record Type!', @rcode = 1
       goto bspexit
       end

------ get input mask for bSL
--select @slmask=InputMask, @sllength = convert(varchar(30), InputLength)  --DC #135813
--from DDDTShared with (nolock) where Datatype = 'bSL'
--if isnull(@slmask,'') = '' select @slmask = 'L'
--if isnull(@sllength,'') = '' select @sllength = '10'
--if @slmask in ('R','L')
--   	begin
--   	select @slmask = @sllength + @slmask + 'N'
--   	end

------ get HQ company info
select @apco=p.APCo, 
          ----TK-08876
          @UseApprSubCo = p.UseApprSubCo
from dbo.bHQCO h with (nolock) join dbo.bPMCO p with (nolock) on h.HQCo=p.APCo where p.PMCo=@pmco
------ check significant characters of job, if null or zero then not valid.
--if @sigchars is null or @sigchars = 0 select @sigpartjob = 'N'

----TK-13768
if @CreateSingleChangeOrder is null set @CreateSingleChangeOrder = @UseApprSubCo

------ set valid part job
--if @sigpartjob = 'Y'
--       begin
--       if @sigchars > len(@project) select @sigchars = len(@project)
--       select @validpartjob = substring(@project,1,@sigchars)
--       end
--else
--       begin
--       select @validpartjob = @project, @sigchars = len(@project)
--       end

--select @tmpproject = rtrim(ltrim(@validpartjob)), @actchars = len(@tmpproject)
------ get rid of leading spaces
--select @projectpart = substring(ltrim(@project),1,@slcharsproject)
select @itemtype = 0
select @slitemfrompm = 0
select @slitem = 1
--select @mseq = 0

------ need to reset @slcharsproject to project part without any leading spaces
--select @slcharsproject = datalength(ltrim(@projectpart))

------ declare cursor on PMSL with no SL's
declare bcPMSL cursor LOCAL FAST_FORWARD
	for select Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem, Vendor 
from PMSL where PMCo=@pmco and Project=@project and isnull(SL,'') = '' and Vendor is not null
Order By Vendor, SLItemType, Seq

------ open cursor
open bcPMSL
select @opencursor = 1

PMSL_loop:
fetch next from bcPMSL into @seq, @recordtype, @pcotype, @pco, @pcoitem, @aco, @acoitem, @vendor
if @@fetch_status <> 0 goto PMSL_end

---- first check record type 'O' - original or 'C' - change order ('A','P')
----TK-07189
IF @rectype <> 'X'
	BEGIN
	if @recordtype <> 'O' and @rectype = 'O' goto PMSL_loop -- originals only
	if @recordtype = 'O' and @rectype <> 'O' goto PMSL_loop -- change orders only
	END
	
---- if initalizing selected sequences check sequence list to the sequence, if not in list goto next
if isnull(@pmslseqlist,'') <> ''
	begin
	if charindex(';' + convert(varchar(6),@seq) + ';', @pmslseqlist) = 0 goto PMSL_loop
	end

---- if @rectype = 'P' pending change order PMSL data must match CO data if we are
---- restricting to a selected PCO and PCO Item
if @rectype = 'P'
	begin
	---- pending values must exist
	if isnull(@pcotype,'') = '' goto PMSL_loop
	if isnull(@pco,'') = '' goto PMSL_loop
	if isnull(@pcoitem,'') = '' goto PMSL_loop
	---- ACO and ACO item must be empty
	if isnull(@aco,'') <> '' goto PMSL_loop
	if isnull(@acoitem,'') <> '' goto PMSL_loop
	---- pending values must equal restrictions
	if isnull(@cotype,'') <> ''
		begin
		if isnull(@pcotype,'') <> isnull(@cotype,'') goto PMSL_loop
		if isnull(@pco,'') <> isnull(@co,'') goto PMSL_loop
		if isnull(@pcoitem,'') <> isnull(@coitem,'') goto PMSL_loop
		end
	end

---- if @rectype = 'A' approved change order PMSL data must match CO data if we are
---- restricting to a selected ACO and ACO Item
----TK-07189
if @rectype IN ('A','X')
	begin
	------ approved values must exist
	if isnull(@aco,'') = '' goto PMSL_loop
	if isnull(@acoitem,'') = '' goto PMSL_loop
	------ approved values must equal restrictions
	if isnull(@co,'') <> ''
		begin
		if isnull(@aco,'') <> isnull(@co,'') goto PMSL_loop
		if isnull(@acoitem,'') <> isnull(@coitem,'') goto PMSL_loop
		end
	end

------ reset values when vendor changes
if isnull(@lastvendor,'') <> @vendor
	begin
	select @slitemfrompm = 0
	--select @mseq = @mseq + 1
	select @slitem = 1
	end


--select 'Sequence: ' + convert(varchar(6),@seq)
--goto PMSL_loop

select @lastvendor = @vendor
------ read PMSL data
select @phasegroup=PhaseGroup, @phase=Phase, @addon=SLAddon, @addonpct=SLAddonPct,
		@itemtype=SLItemType, @defpcotype=PCOType, @defpco=PCO, @defpcoitem=PCOItem,
		@defaco=ACO, @defacoitem=ACOItem, @defrecordtype=RecordType, @slitemdescription=SLItemDescription
from PMSL with (nolock) where PMCo=@pmco and Project=@project and Vendor=@vendor and Seq=@seq
------ if phase is inactive do not initialize - btPMSLu trigger will error out.
select @active=ActiveYN from bJCJP with (nolock)
where JCCo = @pmco and Job = @project and Phase = @phase
if @@rowcount = 1 and @active = 'N'
	begin
	select @phasemsg = 'One or more subcontract phases are inactive, will not be initialized, ' + isnull(@phase,'') + '.', @rcode = 1
	goto PMSL_loop
	end

------ get SLItem description
if isnull(@slitemdescription,'') = ''
	begin
   	exec @slrcode = dbo.bspPMSLItemDescDefault @pmco, @project, @phasegroup, @phase, @defpcotype,
   					@defpco, @defpcoitem, @defaco, @defacoitem, @seq, @slmsg output
   	if @slrcode <> 0
   	    begin
   	    select @slitemdescription='Description not found'
   	    end
   	else
   	    begin
   	    select @slitemdescription=@slmsg
   	    end
   	end

------ if we are building the subcontract by seq, then we need to retreive the last seq
------ used to build the last subcontract number, then add one to it
--select @tmpsl = null, @tmpsl1 = null
--if @slno='P'
--	begin
--	if exists(select 1 from bPMSL WITH (NOLOCK) where SLCo=@apco and PMCo=@pmco
--				and substring(Project,1,@sigchars)=@validpartjob and SL is not null) 
--			or
--		exists(select 1 from bSLHD with (nolock) where SLCo=@apco and JCCo=@pmco
--				and substring(Job,1,@sigchars)=@validpartjob)
--		begin
--		------ max from PMSL
--		select @tmpsl = max(SL) from bPMSL WITH (NOLOCK)
--		where SLCo=@apco and PMCo=@pmco and substring(Project,1,@sigchars)=@validpartjob
--		and SL is not null and substring(SL,1,len(@projectpart)) = @projectpart
--		and datalength(rtrim(SL)) = len(@projectpart) + @slseqlen
--		------ max from SLHD
--		select @tmpsl1 = max(SL) from bSLHD WITH (NOLOCK)
--		where SLCo=@apco and JCCo=@pmco and substring(Job,1,@sigchars)=@validpartjob
--		and substring(SL,1,len(@projectpart)) = @projectpart
--		and datalength(rtrim(SL)) = len(@projectpart) + @slseqlen
--		------ now use highest to get next sequence
--		if isnull(@tmpsl,'') <> '' and isnull(@tmpsl1,'') = '' select @tmpsl1 = @tmpsl
--		if isnull(@tmpsl1,'') <> '' and isnull(@tmpsl,'') = '' select @tmpsl = @tmpsl1
--		if @tmpsl1 > @tmpsl select @tmpsl = @tmpsl1
--		------ now parse out the seq part by using company definitions
--		select @tmpseq = substring(reverse(rtrim(@tmpsl)),1, @slseqlen), @i = 1, @tmpseq1 = ''
--		while @i <= len(@tmpseq)
--			begin
--			select @value = substring(@tmpseq,@i,1)
--			if @value not in ('0','1','2','3','4','5','6','7','8','9')
--				select @i = len(@tmpseq)
--			else
--				select @tmpseq1 = @tmpseq1 + @value
					
--			select @i = @i + 1
--			end
--		------ check if numeric
--		if isnumeric(@tmpseq1) = 1 select @mseq = convert(int,reverse(@tmpseq1)+1)
--		end
--	else
--		begin
--		---- no subcontracts exist for project so use the @slstartseq if there is one
--		if @slstartseq is not null select @mseq = @slstartseq
--		end
--	end

-------- convert Vendor based on Co parameters
--select @vendorPart = reverse(substring(reverse('0000000000000000000' + ltrim(str(@vendor))),1,@slcharsvendor))
-------- need to pad the seq with leading zeros to the amount specified in company file @slseqlen
--select @paddedstring = reverse(substring(reverse('0000000000000000000' + ltrim(str(@mseq))),1,@slseqlen))
--select @formattedsl = null
  
--if @slno = 'P' select @lastslseq = @mseq
------ Need to see if there are any subcontracts set up already for this vendor.
------ This must be done in two parts depending on how the subcontract is being created.
------ If creating using project/seq (P), then consider subcontract status.
------ Remember that the subcontract is added to SL in the PMSL triggers.
------ If a valid subcontract is found then use.
--if @slno = 'P'
--	begin
--	select @formattedsl = max(SL) from SLHD with (nolock) 
--	where SLCo=@apco and JCCo=@pmco and Vendor=@vendor and substring(Job,1,@sigchars)=@validpartjob and Status in (0,3)
--	if @@rowcount = 0 select @formattedsl = null
--	end

--if @slno = 'V'
--	begin
--	select @formattedsl = max(SL) from SLHD with (nolock) 
--	where SLCo=@apco and JCCo=@pmco and Vendor=@vendor and substring(Job,1,@sigchars)=@validpartjob
--	if @@rowcount = 0 select @formattedsl = null
--	end

------ if no valid subcontract found then build using appropiate value
--if @formattedsl is null
--	begin
--   	if @slno = 'V'
--   		begin
--   		set @dummy_sl = ltrim(rtrim(@projectpart)) + @vendorPart
--   		exec @retcode = dbo.bspHQFormatMultiPart @dummy_sl, @slmask, @formattedsl output
--   		end
--   	else
--   		begin
--   		set @dummy_sl = ltrim(rtrim(@projectpart)) + @paddedstring
--   		exec @retcode = dbo.bspHQFormatMultiPart @dummy_sl, @slmask, @formattedsl output
--   		end
--	end

------ check if subcontract already set up under a different job
--if exists(select 1 from SLHD with (nolock) where SLCo=@apco and JCCo=@pmco and SL=@formattedsl
--           and substring(Job,1,@sigchars)<>@validpartjob)
--	begin
--	select @msg = 'One or more subcontracts are already set up under a different project.', @rcode = 1
--	goto PMSL_loop
--	end

------ check if subcontract already setup under a different vendor
--if exists(select 1 from SLHD with (nolock) where SLCo=@apco and JCCo=@pmco and SL=@formattedsl and Vendor<>@vendor)
--	begin
--	select @msg = 'One or more subcontracts are already set up under a different vendor.' + isnull(@formattedsl,''), @rcode = 1
--	goto PMSL_loop
--	end

-- use sl from vspPMSLGetNextSLSeq
exec @retcode = dbo.vspPMSLGetNextSLSeq @pmco,@project,@vendor,'Y',@formattedsl output,@msg output
if @retcode = 1 
	begin
	select @msg = 'Unable to determine SL. ' + isnull(@msg,''),@rcode=1  
	goto bspexit
	end


------ Now check for lines in SLIT and PMSL take the max
------ if the sl already exists then we need to start the seqs there
if exists(select 1 from SLIT with (nolock) where SLCo=@apco and JCCo=@pmco and SL=@formattedsl)
	begin
	select @slitem = isnull(max(SLItem),0)+1
	from SLIT with (nolock) where SLCo=@apco and SL=@formattedsl
	end

------ get the next sl item from PMSL
if exists(select 1 from PMSL with (nolock) where PMCo=@pmco and SLCo=@apco and SL=@formattedsl)
	begin
	select @slitemfrompm = isnull(max(SLItem),0)+1
	from PMSL with (nolock) where PMCo=@pmco and SLCo=@apco and SL=@formattedsl
	end

------ take the max of the two
if @slitemfrompm > @slitem select @slitem = @slitemfrompm

------ Check to see if it is an Approved change order, if so then fill in SUBCo if necessary
---- TK-08876 check rec type and do not get subco if from the PCO approval process (X)
SET @subco = NULL
---- if initialize from subcontract detail call procedure to get next @rectype <. 'X'
if @defrecordtype = 'C' and isnull(@defaco,'') <> '' AND @rectype <> 'X'
	BEGIN
	if @itemtype in (1,2,4)
   		BEGIN
   		exec @slrcode = dbo.bspPMSLSubCoGet @pmco, @project, @apco, @formattedsl, @slitem,
   						@itemtype, @seq, @subco output, @defaco, @defacoitem, @vendor,
   						@UseApprSubCo, @slmsg output
   		if @slrcode <> 0 or @subco = 0 SET @subco = null
   		END
	END

---- if initialize from PCO approve call procedure to get next @rectype = 'X'
if @defrecordtype = 'C' and isnull(@defaco,'') <> '' AND @rectype = 'X'
	BEGIN
	-- TK-13139 --
	if @itemtype in (1,2,4) AND @CreateSingleChangeOrder = 'Y' --@UseApprSubCo = 'Y'
   		BEGIN
   		exec @slrcode = dbo.bspPMSLSubCoGet @pmco, @project, @apco, @formattedsl, @slitem,
   						@itemtype, @seq, @subco output, @defaco, @defacoitem, @vendor,
   						@CreateSingleChangeOrder, @slmsg output
   		if @slrcode <> 0 or @subco = 0 SET @subco = null
   		END
	END
	
--IF @UseApprSubCo= 'Y'
--	BEGIN
--	if @defrecordtype = 'C' and isnull(@defaco,'') <> ''
--		BEGIN
--   		if @itemtype in (1,2,4)
--       		BEGIN
--       		exec @slrcode = dbo.bspPMSLSubCoGet @pmco, @project, @apco, @formattedsl, @slitem,
--       						@itemtype, @seq, @subco output, @defaco, @defacoitem, @vendor,
--       						@slmsg output
--       		if @slrcode <> 0 or @subco = 0 SET @subco = null
--       		END
--		END
--	END
	
------ update PMSL with formatted SL and item
begin transaction
update PMSL set SL=@formattedsl, SLItem=@slitem, SLItemDescription=@slitemdescription,
			----TK-08876
			SubCO = @subco
where PMCo=@pmco and Project=@project and Seq=@seq
if @@rowcount = 0
	begin
	select @msg = 'Error updating PMSL', @rcode=1
	rollback transaction
	goto bspexit
	end

commit transaction

------ Need to re-calculate addon amount for the sl just intialized for addon
------ item types with a percent type addon. Applies to original record types only
if @rectype = 'O'
begin
	-- Insert PM Subcontract Header - Inclusions/Exclusions records.
	-- Try to exclude records already added.
	if not exists (select top 1 1 from dbo.vSLInExclusions where Co = @pmco and SL = @formattedsl)
	begin
		insert vSLInExclusions (Co, SL, Seq, [Type], PhaseGroup, Phase, Detail, DateEntered, EnteredBy, Notes)
		select @pmco, @formattedsl, row_number() over(order by n.JCCo, n.PotentialProject), 
			n.[Type], n.PhaseGroup, n.Phase, n.Detail, dbo.vfDateOnly(), n.EnteredBy, n.Notes
		from dbo.vPCBidPackageScopeNotes n
		join dbo.vPCPotentialWork p on p.JCCo = n.JCCo and p.PotentialProject = n.PotentialProject
		join dbo.bJCJM m on m.PotentialProjectID = p.KeyID
		join dbo.bPMSL l on l.PMCo = n.JCCo and l.Project = m.Job and l.Phase = n.Phase
		where m.JCCo = @pmco and m.Job = @project 
			and not exists (select top 1 1 from dbo.vSLInExclusions s where s.Co = n.JCCo and s.SL = @formattedsl 
			and s.PhaseGroup = @phasegroup and s.Phase = n.Phase and s.[Type] = n.[Type] 
			and isnull(s.Detail,'') = isnull(n.Detail,'') and isnull(s.Notes,'') = isnull(n.Notes,''))
	end
	else
	begin
		insert vSLInExclusions (Co, SL, Seq, [Type], PhaseGroup, Phase, Detail, DateEntered, EnteredBy, Notes)
		select @pmco, @formattedsl, isnull(max(i.Seq),0) + row_number() over(order by n.JCCo, n.PotentialProject), 
			n.[Type], n.PhaseGroup, n.Phase, n.Detail, dbo.vfDateOnly(), n.EnteredBy, n.Notes
		from dbo.vPCBidPackageScopeNotes n
		join dbo.vPCPotentialWork p on p.JCCo = n.JCCo and p.PotentialProject = n.PotentialProject
		join dbo.bJCJM m on m.PotentialProjectID = p.KeyID
		join dbo.bPMSL l on l.PMCo = n.JCCo and l.Project = m.Job and l.Phase = n.Phase
		join dbo.vSLInExclusions i on i.Co = n.JCCo and i.SL = @formattedsl
		where m.JCCo = @pmco and m.Job = @project 
			and not exists (select top 1 1 from dbo.vSLInExclusions s where s.Co = n.JCCo and s.SL = @formattedsl 
			and s.PhaseGroup = @phasegroup and s.Phase = n.Phase and s.[Type] = n.[Type] 
			and isnull(s.Detail,'') = isnull(n.Detail,'') and isnull(s.Notes,'') = isnull(n.Notes,''))
		group by n.JCCo, n.PotentialProject, n.[Type], n.PhaseGroup, n.Phase, n.Detail, n.EnteredBy, n.Notes		
	end	

	select @addonseq=min(Seq) from PMSL with (nolock) where PMCo=@pmco and Project=@project
	and SL=@formattedsl and SLItemType=4
	while @addonseq is not null
	begin

		select @addonpct=SLAddonPct from PMSL with (nolock) 
		where PMCo=@pmco and Project=@project and SL=@formattedsl and SLItemType=4 and Seq=@addonseq
		If isnull(@addonpct,0) <> 0
			begin
			select @sladdonamt=(sum(isnull(OrigCost,0)) * @addonpct) from SLIT with (nolock) 
			where JCCo=@pmco and Job=@project and SLCo=@apco and SL=@formattedsl and ItemType in (1,2)
   
			select @pmaddonamt=(sum(isnull(Amount,0)) * @addonpct) from PMSL with (nolock) 
			where PMCo=@pmco and Project=@project and SLCo=@apco and SL=@formattedsl
			and InterfaceDate is null and SLItemType in (1,2)
   
			select @addonamt = isnull(@sladdonamt,0) + isnull(@pmaddonamt,0)
	   
			update PMSL set Amount=isnull(@addonamt,0)
			where PMCo=@pmco and Project=@project and Seq=@addonseq
			end

	select @addonseq=min(Seq) from bPMSL with (nolock) 
	where PMCo=@pmco and Project=@project and SL=@formattedsl and SLItemType=4 and Seq>@addonseq
	if @@rowcount = 0 select @addonseq = null
	end
end


goto PMSL_loop

PMSL_end:
	if @opencursor = 1
		begin
		close bcPMSL
		deallocate bcPMSL
		select @opencursor = 0
		end






bspexit:
	if @opencursor = 1
		begin
		close bcPMSL
		deallocate bcPMSL
		select @opencursor = 0
		end

	if @rcode <> 0
		begin
		if isnull(@phasemsg,'') <> '' select @msg = isnull(@msg,'') + char(13) + char(10) + @phasemsg
		select @msg = isnull(@msg,'')
		end

   	return @rcode




GO
PRINT N'Refreshing [dbo].[vrvPRFlash]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRFlash]'
GO
PRINT N'Refreshing [dbo].[viFact_MSQuotes]'
GO
EXEC sp_refreshview N'[dbo].[viFact_MSQuotes]'
GO
PRINT N'Refreshing [dbo].[SMStandardTaskCheckList]'
GO
EXEC sp_refreshview N'[dbo].[SMStandardTaskCheckList]'
GO
PRINT N'Refreshing [dbo].[HQApprovalModuleCompany]'
GO
EXEC sp_refreshview N'[dbo].[HQApprovalModuleCompany]'
GO
PRINT N'Refreshing [dbo].[brvGLFSP1]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSP1]'
GO
PRINT N'Altering [dbo].[vspPRProcessArrearsPayback]'
GO
ALTER procedure [dbo].[vspPRProcessArrearsPayback]
/***********************************************************
* CREATED BY:	CHS 08/16/2012 - B-10152 TK-17277 adding Payback
* MODIFIED BY:	CHS 08/16/2012 - B-10152 TK-17277 taking into account the override amount.
*				KK  09/13/2012 - B-10152 TK-17277 Removed Seq to account for reprocessing a payperiod in which an employee is reprocessed with a + net
*			 DAN SO 09/18/2012 - B-10152 TK-17277 - removed IF statement for LifeToDateBal - want to process paybacks no matter LifeToDateBal 
*													 - wrapped History table insert to only insert when @AmountToPayback <> 0
*													 - Cursor will only pick up Codes SubjectToArrearsPayback
*			 DAN SO 09/25/2012 - B-10152 TK-17277 - Life To Date Balances come from PRED NOT PRArrears
*			 DAN SO 09/28/2012 - B-10152 TK-17277 - Set deduction to zero when the deduction code does not have an associated Earnings code 
*														and there is an outstanding balance on that Deduction code
*													 - Removed the deletion of the Arrears History table - it is already being handle in PRPRocess
*			 DAN SO 09/28/2012 - B-10151 TK-18099 - Added code to process Arrears
*												     - Also moved cursor to support both Paybacks AND Arrears 
*				CHS	10/03/2012 - D-05997 TK-18315 Fix payback for EFTs.
*			 DAN SO 10/09/2012 - D-05975 TK-18128 Use PRDL.RateAmt1 WHEN PRED.RateAmt = 0
*				CHS 10/09/2012 - D-05975 TK-18128 Don't process arrears if net pay = 0
*				CHS 10/09/2012 - D-05975 TK-18128 RED.RateAmt = 0 - redo previously done to deduction when should have been payback
*				CHS 10/09/2012 - D-05975 TK-18128 fixed looping problem
*				CHS 10/15/2012 - D-06057 TK-18537 fixed Arrears EFT.
*				CHS 10/15/2012 - D-06057 TK-18537 fixed Payback Override Amount problem and made changes to EFT.
*				CHS 10/15/2012 - D-06057 TK-18537 fixed pretax that was broken by previous fix.
*			 DAN SO 12/20/2012 - D-06202 TK-20312 Explicitly close cursor
*				CHS	03/19/2013 - 44155 148256 fixed PRED.OverCalcs
*				EN  05/10/2013 - 49954/Task 49970 clear PRDL_OverProcess flag on liabilities when @PaybackRecalculate = 'Y' so that the liabs get recalculated correctly
*				KK  05/13/2013 - 47844/Task 47877 Changed the comparison when Netamt is 0 to only process payback when net amount is positive
*				KK  05/23/2013 - 47844/Task 47877 Removed clause in arrears processing to break when positive. This was preventing all DLCodes for Seq X to accrue arrears.
*
* USAGE:
*	called from PR PRocess to calculate Payback or to adjust Arrears.
*
* INPUT PARAMETERS
*   @PRCo		PR Company
*   @PRGroup	PR Group
*   @PREndDate	PR Ending Date
*   @Employee	Employee to process (null if processing all Employees)
*   @PaySequence	Payment Sequence # (null if processing all Seqs)
*
* OUTPUT PARAMETERS
*	@Recalculate	trigger recalculation of payroll
*   @errmsg     if something went wrong
*
* RETURN VALUE
*   0   success
*   1   fail
*****************************************************/
(@PRCo bCompany, 
 @PRGroup bGroup, 
 @PREndDate bDate, 
 @Employee bEmployee, 
 @PaySequence tinyint,
 @LoopBack char(1), 
 @PaybackRecalculate bYN OUTPUT,
 @errmsg varchar(255) OUTPUT)
    	 
    AS
    
    SET NOCOUNT ON
    
    DECLARE @MyMethod char(1), @DLCode bEDLCode, @PreTax bYN, @PaybackFactor bRate, 
			@PaybackAmount bDollar, @NetPay bDollar, @OpenDLCodes int, @DeductionAmount bDollar,
			--@AmountToPayback bDollar, 
			@PRDTKeyID BigInt, @rcode int, @LifeToDateBalance bDollar,
			@PaybackOverYN bYN, @PaybackOverAmt bDollar, @MaxSequence int,
			@UseOver bYN, @OverAmt bDollar, @LifeToDateArrears bDollar, @LifeToDatePayback bDollar,
			@SubjectAmt bDollar, @EligibleAmt bDollar, @TempKeyID bigint, @ArrearsPaybackFlag char(1),
			@EligibleForArrearsCalc char(1), @PayMethod char(1), @OpenDLCodesKeyID int, @OpenDLCodesPaybackOverAmt int
    
    SELECT @PaybackRecalculate = 'N', @rcode = 0    
    
    --------------------------------------------------------------------
    -- when we re-enter this code after having performed a pre-tax loop, 
    -- we don't want to calc payback or arrears again
    --------------------------------------------------------------------
    SELECT TOP 1 @ArrearsPaybackFlag = ArrearsPayback 
    FROM #EmployeePreTaxDedns
	WHERE PRCo = @PRCo 
			   AND PRGroup = @PRGroup
			   AND PREndDate = @PREndDate
			   AND Employee = @Employee
			   AND ArrearsPayback IS NOT NULL
  

	IF ISNULL(@ArrearsPaybackFlag, 'N') = 'A'
		BEGIN
		GOTO DLCodesSetZero
		END
			   
    IF ISNULL(@ArrearsPaybackFlag,'N') = 'P'
		BEGIN
		GOTO vspExit
		END
		
    IF ISNULL(@LoopBack,'N') = 'Y'
		BEGIN
		GOTO vspExit
		END		
    
	--------------------------------------------
	-- Calc NetPay -> (Earnings - Deductions) --
	--------------------------------------------
	SELECT @NetPay = ISNULL((SELECT Sum(Amount)
						FROM bPRDT
						WHERE PRCo = @PRCo 
							AND PRGroup = @PRGroup  
							AND PREndDate = @PREndDate
							AND Employee = @Employee 
							AND PaySeq = @PaySequence
							AND EDLType = 'E'
						GROUP BY PREndDate), 0) -
		
					ISNULL((SELECT Sum(Amount)
						FROM bPRDT
						WHERE PRCo = @PRCo 
							AND PRGroup = @PRGroup  
							AND PREndDate = @PREndDate
							AND Employee = @Employee 
							AND PaySeq = @PaySequence
							AND EDLType = 'D'
							AND UseOver = 'N'
						GROUP BY PREndDate), 0) -
		        
		        	ISNULL((SELECT Sum(OverAmt)
						FROM bPRDT
						WHERE PRCo = @PRCo 
							AND PRGroup = @PRGroup  
							AND PREndDate = @PREndDate
							AND Employee = @Employee 
							AND PaySeq = @PaySequence
							AND EDLType = 'D'
							AND UseOver = 'Y'
						GROUP BY PREndDate), 0) -
		        
		        	ISNULL((SELECT Sum(PaybackOverAmt)
						FROM bPRDT
						WHERE PRCo = @PRCo 
							AND PRGroup = @PRGroup  
							AND PREndDate = @PREndDate
							AND Employee = @Employee 
							AND PaySeq = @PaySequence
							AND EDLType = 'D'
							AND PaybackOverYN = 'Y'
						GROUP BY PREndDate), 0)
									
	-- we don't want to proceed with arrears processing if net pay is negative OR employee is not active for arrears
	IF @NetPay < 0 AND NOT EXISTS(SELECT TOP 1 1 FROM bPREH 
								  WHERE PRCo = @PRCo 
									AND Employee = @Employee 
									AND ArrearsActiveYN = 'Y')
	BEGIN
		RETURN 0
	END

	-- if we are in an arrears condition, 
	-- we need to look for any Payback Override 
	-- amounts and move them to the arrears history table

	------------------------------------------------------------
	-- SET UP CURSOR TO BE USED FOR PACKBACK OVERRIDE AMOUNTS
	------------------------------------------------------------
	-- bPRDL and bPRED both have to be marked eligible to be included in the cursor record set --
		DECLARE bcDLCodesPaybackOverAmt SCROLL CURSOR FOR
		SELECT 
			dl.PreTax, PaybackOverAmt, dl.DLCode 
			
		FROM bPRDL dl
			JOIN bPRED ed ON ed.PRCo = dl.PRCo AND ed.DLCode = dl.DLCode 
			JOIN bPRDT dt ON dt.PRCo = dl.PRCo AND dt.EDLCode = dl.DLCode AND dt.Employee = ed.Employee 
			JOIN bPRSQ sq ON sq.PRCo = sq.PRCo AND sq.PRGroup = dt.PRGroup AND sq.PREndDate = dt.PREndDate AND sq.Employee = ed.Employee AND sq.PaySeq = dt.PaySeq
		WHERE dl.PRCo = @PRCo 
			AND dl.DLType = 'D' 
			AND ed.Employee = @Employee
			AND ed.EmplBased = 'Y'
			AND dt.PRGroup = @PRGroup
			AND dt.EDLType = 'D'
			AND dt.PREndDate = @PREndDate
			AND dt.PaySeq = @PaySequence
			AND dl.SubjToArrearsPayback = 'Y'
			AND dt.PaybackOverYN = 'Y'
		ORDER BY ed.ProcessSeq, dl.DLCode ASC 
		
		OPEN bcDLCodesPaybackOverAmt
		SELECT @OpenDLCodesPaybackOverAmt = 1

		------------------------	
		-- START NEXT_ DLCode --
		------------------------
		NEXT_DLCodePaybackOverAmt:
		FETCH NEXT FROM bcDLCodesPaybackOverAmt into 
			@PreTax, @PaybackOverAmt, @DLCode
			
		IF @@fetch_status = -1 GOTO DecidePaybackArrears
		IF @@fetch_status <> 0 GOTO NEXT_DLCode		
		
			-- GET next Seq to be inserted into the vPRArrears table --			
			SELECT @MaxSequence = ISNULL(MAX(Seq + 1), 1)
			  FROM vPRArrears 
			 WHERE PRCo = @PRCo
			   AND Employee = @Employee 			
			   AND DLCode = @DLCode  		
			
			INSERT vPRArrears (PRCo, Employee, DLCode, Seq, Date, ArrearsAmt, 
								PaybackAmt, PRGroup, PREndDate, PaySeq, EDLType)
			VALUES	(@PRCo, @Employee, @DLCode, @MaxSequence, dbo.vfDateOnly(), 0, 
						@PaybackOverAmt, @PRGroup, @PREndDate, @PaySequence, 'D')		
		
			--------------------------------------------------
			-- need to look to see if this DLCcode is a pretax and if so, then
			-- preform pretax house keeping then force to recalculate
			--
			-- also, need to set the loop back flag so the payback will be calculated as part of the EFTs
			--------------------------------------------------				
			IF @PreTax = 'Y'
			BEGIN
					
				-- note the names of the variables are inacurate at this point and are confusing.
				-- set payback flag and update Dednamt
				UPDATE #EmployeePreTaxDedns 
				   SET DednAmt = DednAmt + @PaybackOverAmt,
					   ArrearsPayback = CASE WHEN @NetPay > 0 THEN 'P'
														      ELSE 'A'
										END
					   
				 WHERE PRCo = @PRCo 
				   AND PRGroup = @PRGroup
				   AND PREndDate = @PREndDate
				   AND Employee = @Employee
				   AND DLCode = @DLCode
				
				SELECT @PaybackRecalculate = 'Y'				
			END -- @PreTax = 'Y'	
				
				
			--------------------------------------------------				
			-- need to look to see if this DLCcode is a rate of another deduction and if so, then
			-- then force to recalculate
			--------------------------------------------------					
			IF EXISTS(SELECT TOP 1 1	FROM bPRED ed
											JOIN bPRDL dl on ed.PRCo = dl.PRCo AND ed.DLCode = dl.DLCode
										WHERE ed.PRCo = @PRCo 
											AND ed.Employee = @Employee
											AND ed.EmplBased = 'Y' 
											AND dl.Method = 'DN'
											AND dl.DednCode = @DLCode)

			BEGIN
				SELECT @PaybackRecalculate = 'Y'	
			END						
		
		-----------------------	
		-- GOTO NEXT_ DLCode --
		-----------------------
		GOTO NEXT_DLCodePaybackOverAmt		
		
		
		
DecidePaybackArrears:		

	-- we don't want to proceed with payback processing if there are no PRDL 
	-- codes in PRED for this employee which are subject to arrears
	IF NOT EXISTS(SELECT TOP 1 1
					FROM bPRDL l
					JOIN bPRED e ON e.PRCo = l.PRCo 
								AND e.DLCode = l.DLCode
					WHERE e.Employee = @Employee
					  AND l.SubjToArrearsPayback = 'Y')
	BEGIN
		-- D-06202 TK-20312 -- 
		-- If the cursor is open, explicitly close it --
		IF @OpenDLCodesPaybackOverAmt = 1
		BEGIN
			CLOSE bcDLCodesPaybackOverAmt
			DEALLOCATE bcDLCodesPaybackOverAmt
			SELECT @OpenDLCodesPaybackOverAmt = 0
		END		

		RETURN 0
	END										

	------------------------------------------------------------
	-- SET UP CURSOR TO BE USED FOR BOTH Paybacks AND Arrears --
	------------------------------------------------------------
	-- bPRDL and bPRED both have to be marked eligible to be included in the cursor record set --
	DECLARE bcDLCodes SCROLL CURSOR FOR
	SELECT 
		dl.DLCode, dl.PreTax, dt.KeyID as [PRDTKeyID], 
		
		CASE ed.OverCalcs 
			WHEN 'N' THEN dl.RateAmt1
			ELSE ed.RateAmt 
			END AS [DeductionAmount],	
		
		CASE ed.OverrideStdPaybackSettings
			WHEN 'N' 
			THEN dl.PaybackPerPayPeriod
			ELSE ed.PaybackPerPayPeriodOverride
			END AS [MyMethod],		 

		CASE ed.OverrideStdPaybackSettings 
			WHEN 'N' 
			THEN dl.PaybackFactor
			ELSE ed.PaybackFactorOverride			
			END AS [MyFactor],
		
		CASE ed.OverrideStdPaybackSettings 
			WHEN 'N' 
			THEN 
				CASE dl.PaybackPerPayPeriod
					WHEN 'F'
					THEN -- dl.RateAmt1 * dl.PaybackFactor
						CASE ed.OverCalcs 
						WHEN 'N' THEN dl.RateAmt1 * dl.PaybackFactor
						ELSE ed.RateAmt * dl.PaybackFactor
						END 
					ELSE dl.PaybackAmount
					END				
			ELSE 
				CASE ed.PaybackPerPayPeriodOverride
					WHEN 'F'
					THEN -- ed.RateAmt * ed.PaybackFactorOverride	
						CASE ed.OverCalcs 
						WHEN 'N' THEN dl.RateAmt1 * ed.PaybackFactorOverride
						ELSE ed.RateAmt * ed.PaybackFactorOverride
						END 					
					ELSE ed.PaybackAmountOverride
					END						
			END AS [MyPaybackAmount],

		PaybackOverYN, PaybackOverAmt, UseOver, OverAmt, 
		LifeToDateArrears, LifeToDatePayback, SubjectAmt, EligibleAmt,
		EligibleForArrearsCalc, PayMethod
		
	FROM bPRDL dl
		JOIN bPRED ed ON ed.PRCo = dl.PRCo AND ed.DLCode = dl.DLCode 
		JOIN bPRDT dt ON dt.PRCo = dl.PRCo AND dt.EDLCode = dl.DLCode AND dt.Employee = ed.Employee 
		JOIN bPRSQ sq ON sq.PRCo = sq.PRCo AND sq.PRGroup = dt.PRGroup AND sq.PREndDate = dt.PREndDate AND sq.Employee = ed.Employee AND sq.PaySeq = dt.PaySeq
	WHERE dl.PRCo = @PRCo 
		AND dl.DLType = 'D' 
		AND ed.Employee = @Employee
		AND ed.EmplBased = 'Y'
		AND dt.PRGroup = @PRGroup
		AND dt.EDLType = 'D'
		AND dt.PREndDate = @PREndDate
		AND dt.PaySeq = @PaySequence
		AND dl.SubjToArrearsPayback = 'Y'
		--AND dt.PaybackOverYN = 'N'
	ORDER BY ed.ProcessSeq, dl.DLCode ASC 
	
	OPEN bcDLCodes
	SELECT @OpenDLCodes = 1
		
	-----------------------------------------------------------------------------------------------------------------
	-- If NetPay > 0 - Begin looking into paybacks -- We only look at Payback if the employee has a positive net pay
	-----------------------------------------------------------------------------------------------------------------
	IF @NetPay > 0
	BEGIN
		------------------------	
		-- START NEXT_ DLCode --
		------------------------
		NEXT_DLCode:
		FETCH NEXT FROM bcDLCodes into 
			@DLCode, @PreTax, @PRDTKeyID, @DeductionAmount,
			@MyMethod, @PaybackFactor, @PaybackAmount,
			@PaybackOverYN, @PaybackOverAmt, @UseOver, @OverAmt, 
			@LifeToDateArrears, @LifeToDatePayback, @SubjectAmt, 
			@EligibleAmt, @EligibleForArrearsCalc, @PayMethod

		IF @@fetch_status = -1 GOTO vspExit
		IF @@fetch_status <> 0 GOTO NEXT_DLCode

		
		---------------------------------------------------------
		-- Calc LifeToDateBalance -> (ArrearsAmt - PaybackAmt) --
		---------------------------------------------------------
		SET @LifeToDateBalance = (@LifeToDateArrears - @LifeToDatePayback)
			
		-----------------------
		-- Determine Amounts --
		-----------------------		
		-- Deduction --
		IF @UseOver = 'Y'
			BEGIN
			SELECT @DeductionAmount = @OverAmt
			END
			
		---- Doing a payback on a DLCODE that does not have any earnings --
		---- set deduction amount to 0 - otherwise it would take a normal deduction when it should not --
		IF @SubjectAmt = 0 OR @EligibleAmt = 0
			BEGIN
			SET @DeductionAmount = 0
			GOTO NEXT_DLCode
			END
		
		-- if payback causes a negative netpay situation, then abort --
		IF @NetPay - @PaybackAmount < 0 
			BEGIN
			GOTO vspExit
			END
				
		-- this is for when payback is greater than arrears balance - we don't want to pay back more than is in arrears		
		-- Example: Owed: $25  Payback Amt: $50 -- new payback amount is now $25 --
		IF @LifeToDateBalance < @PaybackAmount	
			BEGIN
			SELECT @PaybackAmount = @LifeToDateBalance
			END
							
		--------------------------------------------------
		-- set the calculated payback value in bPRDT on the appropriate deduction code.
		--------------------------------------------------
		UPDATE bPRDT SET PaybackAmt = @PaybackAmount WHERE KeyID = @PRDTKeyID		
				
			
		----------------------------------------------------------------------------	
		-- don't make history table or pretax updates if there is a payback override
		----------------------------------------------------------------------------	
		IF @PaybackOverYN = 'N'
			BEGIN		

			---------------------------------------------
			-- HISTORY TABLE ENTRY - @PaybackAmount --
			---------------------------------------------	
			IF @PaybackAmount <> 0 OR @PaybackOverYN = 'Y'
				BEGIN
				-- GET next Seq to be inserted into the vPRArrears table --			
				SELECT @MaxSequence = ISNULL(MAX(Seq + 1), 1)
				  FROM vPRArrears 
				 WHERE PRCo = @PRCo
				   AND Employee = @Employee 			
				   AND DLCode = @DLCode  					
				
				INSERT vPRArrears (PRCo, Employee, DLCode, Seq, Date, ArrearsAmt, 
									PaybackAmt, PRGroup, PREndDate, PaySeq, EDLType)
				VALUES	(@PRCo, @Employee, @DLCode, @MaxSequence, dbo.vfDateOnly(), 0, 
							@PaybackAmount, @PRGroup, @PREndDate, @PaySequence, 'D')
				END
				
			--------------------------------------------------
			-- need to update @NetPay after it has been theoretically reduced by the payback
			--------------------------------------------------		
			SELECT @NetPay = @NetPay - @PaybackAmount
			
			--------------------------------------------------
			-- need to look to see if this DLCcode is a pretax and if so, then
			-- preform pretax house keeping then force to recalculate
			--
			-- also, need to set the loop back flag so the payback will calculated as part of the EFTs
			--------------------------------------------------				
			IF @PreTax = 'Y'
				BEGIN
					
				-- note the names of the variables are inacurate at this point and oare confusing.
				-- set payback flag and update Dednamt
				UPDATE #EmployeePreTaxDedns 
				   SET DednAmt = @DeductionAmount + @PaybackAmount,
					   ArrearsPayback = 'P'
				 WHERE PRCo = @PRCo 
				   AND PRGroup = @PRGroup
				   AND PREndDate = @PREndDate
				   AND Employee = @Employee
				   AND DLCode = @DLCode
				
				SELECT @PaybackRecalculate = 'Y'				
				END -- @PreTax = 'Y'			
				
			

			--------------------------------------------------				
			-- need to look to see if this DLCcode is a rate of another deduction and if so, then
			-- then force to recalculate
			--------------------------------------------------					
			IF EXISTS(SELECT TOP 1 1	FROM bPRED ed
											JOIN bPRDL dl on ed.PRCo = dl.PRCo AND ed.DLCode = dl.DLCode
										WHERE ed.PRCo = @PRCo 
											AND ed.Employee = @Employee
											AND ed.EmplBased = 'Y' 
											AND dl.Method = 'DN'
											AND dl.DednCode = @DLCode)

				BEGIN
				SELECT @PaybackRecalculate = 'Y'	
				END					
		
						
		END -- IF @PaybackOverYN = 'N'
		
		
		-----------------------	
		-- GOTO NEXT_ DLCode --
		-----------------------
		GOTO NEXT_DLCode
		
		-- remove Deposit Sequences
		DELETE dbo.bPRDS
		WHERE PRCo = @PRCo     			
			AND PRGroup = @PRGroup 
      		AND PREndDate = @PREndDate 
      		AND Employee = @Employee 
      		AND PaySeq = @PaySequence

		EXEC @rcode = bspPRProcessEmplEFT @PRCo, @PRGroup, @PREndDate, @Employee, @PaySequence, @errmsg OUTPUT	
		
	END 
		
	-- @NetPay >= 0.00
	ELSE
	BEGIN	

		------------------------
		-- ARREARS PROCESSING --
		------------------------					
			--------------------------------------------------
			-- BACKOUT DEDUCTIONS STARTING WITH LAST DLCODE --
			--------------------------------------------------
			FETCH LAST FROM bcDLCodes INTO 
				@DLCode, @PreTax, @PRDTKeyID, @DeductionAmount,
				@MyMethod, @PaybackFactor, @PaybackAmount,
				@PaybackOverYN, @PaybackOverAmt, @UseOver, @OverAmt, 
				@LifeToDateArrears, @LifeToDatePayback, @SubjectAmt, 
				@EligibleAmt, @EligibleForArrearsCalc, @PayMethod
							
			------------------------
			-- CYCLE THRU DLCODES --
			------------------------
			WHILE @@FETCH_STATUS = 0  
			BEGIN  
			
				IF(@EligibleForArrearsCalc = 'N')
					BEGIN
					GOTO FetchNextCode
					END
					
				IF(@UseOver = 'Y')
					BEGIN
					GOTO FetchNextCode
					END
					
		   				   			
		   		-- INSERT INTO TEMP TABLE --
		   		INSERT #ArrearsDLCodesProcessed (DLCodeKeyID) VALUES (@PRDTKeyID)
		   		
   				-- GET next sequence for HISTORY TABLE ENTRY --
				SELECT @MaxSequence = ISNULL(MAX(Seq + 1), 1)
				  FROM vPRArrears 
				 WHERE PRCo = @PRCo
				   AND Employee = @Employee 			
				   AND DLCode = @DLCode  
				   
				--------------------------------------------
				-- HISTORY TABLE ENTRY - @DeductionAmount --
				--------------------------------------------
				INSERT vPRArrears (PRCo, Employee, DLCode, Seq, Date, ArrearsAmt, 
									PaybackAmt, PRGroup, PREndDate, PaySeq, EDLType)
				VALUES (@PRCo, @Employee, @DLCode, @MaxSequence, dbo.vfDateOnly(), @DeductionAmount, 
							0, @PRGroup, @PREndDate, @PaySequence, 'D')
		   				  
				-- CHECK IF IT IS A PreTax DEDUCTION
				IF @PreTax = 'Y'
					BEGIN
						UPDATE #EmployeePreTaxDedns 
						   SET DednAmt = @PaybackOverAmt, ArrearsPayback = 'A'
						 WHERE PRCo = @PRCo 
						   AND PRGroup = @PRGroup
						   AND PREndDate = @PREndDate
						   AND Employee = @Employee
						   AND DLCode = @DLCode
													   
						SET @PaybackRecalculate = 'Y'
					END							
		   				   			
		   		-- TRACK UPDATED NetPay --
				SET @NetPay = @NetPay + @DeductionAmount

--KK Not sure if we need this. It is causing records to be skipped for arrears processing when seq 1 timecards = 0.00			
				---- IF @NetPay IS POSITIVE - then we are done processing --
				--If @NetPay > 0 
				--	BEGIN
				--		-- DONE PROCESSING --
				--		BREAK
				--	END
					
				---------------------------
				-- FETCH PREVIOUS RECORD --
				---------------------------
				FetchNextCode:
					FETCH PRIOR FROM bcDLCodes INTO 
						@DLCode, @PreTax, @PRDTKeyID, @DeductionAmount,
						@MyMethod, @PaybackFactor, @PaybackAmount,
						@PaybackOverYN, @PaybackOverAmt, @UseOver, @OverAmt, 
						@LifeToDateArrears, @LifeToDatePayback, @SubjectAmt, 
						@EligibleAmt, @EligibleForArrearsCalc, @PayMethod					
					
			END -- WHILE @@FETCH_STATUS = 0 
		
			IF @PaybackRecalculate = 'Y'
			BEGIN
				GOTO vspExit
			END
		
	END -- IF @NetPay > 0 ELSE    		
    		
    	
---------------------------
-- SET PROCESSED ARREARS --
---------------------------
DLCodesSetZero:
		DECLARE bcDLCodesKeyID CURSOR FOR
		SELECT DLCodeKeyID
		FROM #ArrearsDLCodesProcessed
			
		OPEN bcDLCodesKeyID
		SELECT @OpenDLCodesKeyID = 1
				
		FETCH NEXT FROM bcDLCodesKeyID INTO @TempKeyID
		
		-- cycle thru PRProcess temp table DLCodes --
		WHILE @@FETCH_STATUS = 0  
		BEGIN 
		
			UPDATE bPRDT SET Amount = 0 WHERE KeyID = @TempKeyID

			-- FETCH NEXT RECORD --
			FETCH NEXT FROM bcDLCodesKeyID INTO @TempKeyID
		END
		
	    SELECT @PaybackRecalculate = 'N'
		    
-----------------
-- End Routine --
-----------------
vspExit:	
----------------------------------------------------
-- Update any EFTs 
----------------------------------------------------
		DELETE dbo.bPRDS
		WHERE PRCo = @PRCo     			
			AND PRGroup = @PRGroup 
      		AND PREndDate = @PREndDate 
      		AND Employee = @Employee 
      		AND PaySeq = @PaySequence

	EXEC @rcode = bspPRProcessEmplEFT @PRCo, @PRGroup, @PREndDate, @Employee, @PaySequence, @errmsg OUTPUT	
	
	IF @OpenDLCodes = 1
	BEGIN
			CLOSE bcDLCodes
			DEALLOCATE bcDLCodes
			SELECT @OpenDLCodes = 0
	END		
			
	IF @OpenDLCodesKeyID = 1
	BEGIN
			CLOSE bcDLCodesKeyID
			DEALLOCATE bcDLCodesKeyID
			SELECT @OpenDLCodesKeyID = 0
	END		
						
	IF @OpenDLCodesPaybackOverAmt = 1
	BEGIN
			CLOSE bcDLCodesPaybackOverAmt
			DEALLOCATE bcDLCodesPaybackOverAmt
			SELECT @OpenDLCodesPaybackOverAmt = 0
	END		

	IF @PaybackRecalculate = 'Y'
	BEGIN
			--------------------------------------------------------------------------
			-- Reset Amounts to zero prior to ReCalc so that values are not doubled --
			--------------------------------------------------------------------------
			UPDATE bPRDT 
			   SET SubjectAmt = 0, EligibleAmt = 0, Amount = 0, OverProcess = 'N'
			 WHERE PRCo = @PRCo 
			   AND PRGroup = @PRGroup 
			   AND PREndDate = @PREndDate 
			   AND Employee = @Employee 
			   AND PaySeq = @PaySequence
			   AND EDLType <> 'E'
			   AND (EDLType = 'L' OR EDLCode NOT IN (SELECT DLCode FROM #EmployeePreTaxDedns))
    
			-- remove Timecard Liabilities
			DELETE dbo.bPRTL
    		WHERE PRCo = @PRCo 
    			AND PRGroup = @PRGroup 
    			AND PREndDate = @PREndDate 
    			AND Employee = @Employee 
    			AND PaySeq = @PaySequence
	    
			-- remove Craft Rate Detail
			DELETE dbo.bPRCX
			WHERE PRCo = @PRCo 
    			AND PRGroup = @PRGroup 
    			AND PREndDate = @PREndDate 
    			AND Employee = @Employee 
    			AND PaySeq = @PaySequence
	        
			-- remove Craft Accumulations not updated to AP
			DELETE dbo.bPRCA
			WHERE PRCo = @PRCo 
    			AND PRGroup = @PRGroup 
    			AND PREndDate = @PREndDate 
    			AND Employee = @Employee 
    			AND PaySeq = @PaySequence
				AND OldAPAmt = 0.00
				
			-- reset remaining Craft Accumulations
			UPDATE dbo.bPRCA
			SET Basis = 0.00, Amt = 0.00, EligibleAmt = 0.00, VendorGroup = null, Vendor = null
			WHERE PRCo = @PRCo 
    			AND PRGroup = @PRGroup 
    			AND PREndDate = @PREndDate 
    			AND Employee = @Employee 
    			AND PaySeq = @PaySequence
	    	
			-- remove Insurance Accumulations
			DELETE dbo.bPRIA
			WHERE PRCo = @PRCo     			
				AND PRGroup = @PRGroup 
    			AND PREndDate = @PREndDate 
    			AND Employee = @Employee 
    			AND PaySeq = @PaySequence
    			
			-- remove Deposit Sequences
			DELETE dbo.bPRDS
			WHERE PRCo = @PRCo     			
				AND PRGroup = @PRGroup 
    			AND PREndDate = @PREndDate 
    			AND Employee = @Employee 
    			AND PaySeq = @PaySequence
	END
			

				
RETURN @rcode			
GO
PRINT N'Altering [dbo].[vspPRProcessArrears]'
GO
ALTER  proc [dbo].[vspPRProcessArrears]
/************************************************************************************************
* CREATED BY:   KK 08/20/2012
* MODIFIED By:	EN 08/28/2012 B-10150/TK-17205 Do not post to PRArrears if arrears or payback amount is 0
*				EN 08/28/2012 B-10150/TK-17205 Use dbo.vfDateOnly() instead of GETDATE() in PRArrears Insert statement
*												to get today's date without timestamp.
*				KK 09/12/2012 B-10150/TK-17205 Moved deletion of arrears history record to vspPRGerEmplNoTimecardsForArrears
*												Added condition for arrears sequencing to "refresh"
*				KK 05/21/2013 TFS-47844 Removed superfulous code, added clause to NOT add records with timecards
*
* USAGE:	Called from vspPRGerEmplNoTimecardsForArrears
*			Processes employee/deduction code for Arrears
*			Only valid eligible employee/DL code combinations will be processed here
*			1. Active for Arrears/Payback (PREH) = "Y" Yes
*			2. Eligible for Arrears/Payback (PRED) = "Y" Yes
*			3. Subject to Arrears/Payback (PRDL) = "Y" Yes
*
* INPUT PARAMETERS
*   @prco			PR Co to validate agains t
*	@prgroup		Employees pr group
*	@enddate		Pay period end date
*   @employee		PR Employee to validate against
*	@payseq			Pay period sequence
*   @dlcode			PR Dedn code to validate against
*	@arrearsamt		Amount to accrue to arrears
*	@paybackamt		Amount to payback
*	@timecardYN		Flag to signify if the employee has a timecard or not
*
* OUTPUT PARAMETERS
*   @msg		error message if error occurs otherwise Description of Ded/Earnings/Liab Code
* RETURN VALUE
*   0         Success
*   1         Failure
************************************************************************************************/ 

(@prco bCompany = 0, 
 @employee bEmployee = NULL, 
 @dlcode bEDLCode = NULL,
 @arrearsamt bDollar = 0,
 @paybackamt bDollar = 0,
 @prgroup bGroup = NULL,
 @enddate bDate = NULL,
 @payseq smallint = NULL,
 @timecardYN bYN = NULL,
 @msg varchar(90) OUTPUT)

AS
SET NOCOUNT ON

DECLARE @nextseq smallint

-- Confirm input params are not null
IF @prco IS NULL
BEGIN
	SELECT @msg = 'Missing PR Company!'
	RETURN 1
END
IF @employee IS NULL
BEGIN
	SELECT @msg = 'Missing employee!'
	RETURN 1
END
IF @dlcode IS NULL
BEGIN
	SELECT @msg = 'Missing deduction code!'
	RETURN 1
END

----Check that this record does not have a timecard entry
IF EXISTS (SELECT * FROM dbo.bPRTH
		   WHERE PRCo = @prco
			 AND PRGroup = @prgroup
			 AND PREndDate = @enddate
			 AND Employee = @employee
			 AND PaySeq = @payseq
			 AND Amt >= 0.00)
BEGIN
	RETURN 0
END	

-- Get the next available Seq Empl/Dedn in PRArrears
SELECT @nextseq = ISNULL(MAX(Seq + 1), 1)
FROM dbo.vPRArrears 
WHERE PRCo = @prco
  AND Employee = @employee 			
  AND DLCode = @dlcode  

--------------------------------------------------------------------------
/*				Insert record in PR Arrears table						*/
--------------------------------------------------------------------------
-- Insert into PRArrears
INSERT INTO dbo.vPRArrears (PRCo,			Employee,			DLCode,
							Seq,			Date,				ArrearsAmt,
							PaybackAmt,		PRGroup,			PREndDate,
							PaySeq,			EDLType)
					SELECT  @prco,			@employee,			@dlcode,
							@nextseq,		dbo.vfDateOnly(),	@arrearsamt,
							@paybackamt,	@prgroup,			@enddate,
							@payseq,		'D'	


RETURN 0

GO
PRINT N'Altering [dbo].[vspPRGetEmplNoTimecardsForArrears]'
GO
ALTER  proc [dbo].[vspPRGetEmplNoTimecardsForArrears]
/************************************************************************************************
* CREATED BY:   KK 08/20/2012 B-10150/TK-17205 Created for Arrears/Payback enhancement
*
* MODIFIED By:  EN 08/28/2012 B-10150/TK-17205 allow for possible negative arrears amounts
*				KK 08/28/2012 B-10150/TK-17205 repair select getting employees with no t/c
*				KK 09/11/2012 B-10150/TK-17205 change no timecard search to look in PRTH (t/c header) rather than SQ
*				KK 09/11/2012 B-10150/TK-17205 Created a conditional to delete old arrears history records and insert new
*				KK 10/02/2012 B-10150/TK-16682 Added a check to clear arrears history and bounce out if there are no timecards
*											   for this pay period.
*				KK 10/11/2012 D-06041/TK-18503 Modified selection criteria for deleting employees when reprocessing to clear ALL 
*											   employees with no timecards regardless of eligibility on any level.
*				KK 10/18/2012 D-06083/TK-18611 PR Arrears should calculate arrears with no timecard specific to the sequence NOT paid in
*				EN 04/22/2013 47844/Task 47877 Add provision to calc arrears for seq #1 even when no seq #1 timecards were posted (but other seq(s) were)
*				KK 05/14/2013 47844/Task 47877 Prevent reprocessing/deleting other employee records when an employee is specified
*				KK 05/17/2013 47844/Task 47877 Prevent reprocessing/deleting other sequences when a sequence is specified, added Employee to where clauses
*											   And modified Employee selection to include any employee with an eligible no timecard sequence.
*
* USAGE: Called from bspPRPRocess to create table of employees with no timecards who are 
*		 eligible for arrears/payback
*		 Calls stored proc to process for arrears, vspPRProcessArrears
*     PR Employee must be checked "Y" yes for:
*		1. Active for Arrears/Payback (PREH)
*		2. Eligible for Arrears/Payback (PRED)
*		3. Subject to Arrears/Payback (PRDL)
*
* INPUT PARAMETERS
*   @prco			PR Co to validate agains t
*   @dedncode		PR Dedn code to validate against
*	@prgroup		Employees pr group
*	@enddate		Pay period end date
*	@payseq			Pay period sequence
*
* OUTPUT PARAMETERS
*   @msg		error message if error occurs otherwise Description of Ded/Earnings/Liab Code
*
* RETURN VALUE
*   0         Success
*   1         Failure
************************************************************************************************/ 

(@prco bCompany = 0, 
 @prgroup bGroup = NULL,
 @employee bEmployee = NULL, -- Only comes in if processing as single employee
 @enddate bDate = NULL,
 @payseq smallint = NULL,
 @mode char(1) = NULL,
 @msg varchar(90) OUTPUT)

AS
SET NOCOUNT ON

DECLARE @dlcode bEDLCode,
		@arrearsamt bDollar,
		@predamt bDollar,
		@prdlamt bDollar,
		@rcode tinyint
		
-- Check that if a pay sequence is passed in, it is valid for this pay period
IF (@payseq IS NOT NULL
	AND NOT EXISTS (SELECT * FROM dbo.bPRPS
				   WHERE PRCo = @prco
						AND PRGroup = @prgroup
						AND PREndDate = @enddate
						AND PaySeq = @payseq))
BEGIN RETURN 0 END	
 
-- Check that the mode is A-Process all, C-Process changed or S-Process a specific employee
IF @mode NOT IN ('A', 'C', 'S') BEGIN RETURN 0 END

--------------------------------------------------------------------------
/*	Create table variable to hold eligible employees/dlcodes			*/
--------------------------------------------------------------------------
DECLARE @EmplDednCodeNoTimecard TABLE
(	
	employee bEmployee,
	dedncode bEDLCode,
	payseq tinyint,
	loopkey varchar(14)
)

;WITH caselist (empl, dcode, pseq) AS 
	(SELECT DISTINCT eh.Employee, 
					 ed.DLCode, 
					(CASE WHEN @payseq IS NOT NULL 
							   AND (@payseq = 1 
									OR (@payseq <> 1 
										AND dl.SeqOneOnly = 'N')) THEN @payseq
						  WHEN @payseq IS NULL AND dl.SeqOneOnly = 'Y' THEN 1
						  WHEN @payseq IS NULL AND dl.SeqOneOnly = 'N' THEN ps.PaySeq
					END)
	FROM dbo.bPREH eh						-- Employee Header
	JOIN dbo.bPRED ed ON eh.PRCo = ed.PRCo	-- Employee Dedns/Libs
					 AND eh.Employee = ed.Employee
	JOIN dbo.bPRDL dl ON eh.PRCo = dl.PRCo	-- Dedns/Liabs
					 AND ed.DLCode = dl.DLCode
	JOIN dbo.bPRAF af ON eh.PRCo = af.PRCo	-- Active Frequency
					 AND eh.PRGroup = af.PRGroup
	JOIN dbo.bPRPS ps ON eh.PRCo = ps.PRCo	-- Pay Sequence Control
					 AND eh.PRGroup = ps.PRGroup
	WHERE eh.PRCo = @prco
		AND eh.PRGroup = @prgroup
		AND eh.ArrearsActiveYN = 'Y' --Flagged in PREH active for arrears
		AND eh.Employee = ISNULL(@employee,eh.Employee) --This is a valid employee
		AND (eh.Employee NOT IN(SELECT Employee FROM dbo.bPRTH -- Employees with no timecard for a given sequence
								WHERE PRCo = @prco
								  AND PRGroup = @prgroup
								  AND PREndDate = @enddate
								  AND PaySeq = ISNULL(@payseq,PaySeq)) -- 06083 (KK)
			 OR -- 47844
 			 eh.Employee IN(SELECT DISTINCT t.Employee
								 FROM dbo.bPRTH t
							LEFT JOIN dbo.bPRPS p
								   ON p.PRCo = t.PRCo
								  AND p.PRGroup = t.PRGroup
								  AND p.PREndDate = t.PREndDate 
								WHERE t.PRCo = @prco 
								  AND t.PRGroup = @prgroup
								  AND t.PREndDate = @enddate
								  AND t.PaySeq = ISNULL(@payseq, t.PaySeq)
								  AND t.PaySeq <> p.PaySeq) 
			)
		AND ed.EligibleForArrearsCalc = 'Y' --Flagged in PRED eligible for this deduction code
		AND dl.SubjToArrearsPayback = 'Y' --Flagged in PRDL subject to arrears
		AND af.PREndDate = @enddate --End date is legit in Pay Period Control active frequency
		AND af.Frequency = ed.Frequency --Frequency in PRED matches an active frequency in Pay Period Control
		AND ps.PREndDate = @enddate) --Pay Sequence control is legit
		
-- Create a key to use when looping through the records for processing
INSERT INTO @EmplDednCodeNoTimecard (employee,dedncode,payseq,loopkey)
SELECT empl, dcode, pseq,
		(replace(str(convert(char(6),empl),6), space(1),'0') 
		+ replace(str(convert(char(5),dcode),5), space(1),'0') 
		+ replace(str(convert(char(3),pseq),3), space(1),'0')) AS loopkey
FROM caselist

-- 47844 If we have a specific employee coming in via processing (mode 'S') we only reprocess that employee
-- We have found all possible sequence/deduction code combinations for all employees with at least one "no timecard" line
-- We want to remove all instances where a timecard entry DOES exist for a given Empl/Seq/Dedn Code. 
DELETE FROM @EmplDednCodeNoTimecard WHERE EXISTS
	(SELECT employee FROM dbo.bPRTH
	  WHERE employee = Employee
	    AND payseq = PaySeq
	    AND PRCo = @prco
	    AND PRGroup = @prgroup
	    AND PREndDate = @enddate) 
	    
-- If we are coming into process "Changed" timecards only, this will only pick up those
-- In this case, we are in processing arrears with no timecards, so we will have no PRTH, but we will have a PRSQ
-- and the timecard is being deleted.
IF @mode = 'C'
BEGIN
	DELETE FROM @EmplDednCodeNoTimecard WHERE NOT EXISTS
		(SELECT employee FROM dbo.bPRSQ s
		 WHERE employee = s.Employee 
		   AND payseq = s.PaySeq 
		   AND s.PRCo = @prco
		   AND s.PRGroup = @prgroup
		   AND s.PREndDate = @enddate
		   AND s.Processed = 'N')
END
-- Delete all records in the arrears history table that are being processed as "no timecard" 
-- NOTE: Payback will be 0 when processing arrears, and enddate and pay 
-- will be null for employees with no timecards so they will not be deleted.
DELETE  FROM dbo.vPRArrears WHERE EXISTS
	(SELECT employee FROM @EmplDednCodeNoTimecard 
	 WHERE employee = Employee
	   AND payseq = PaySeq
	   AND PRCo = @prco
	   AND PRGroup = @prgroup
	   AND PREndDate = @enddate) 

-- We have cleared the PR Arrears History table above, so if there are no 
-- timecards in existance for this company and end date, do not process.
IF NOT EXISTS (SELECT * FROM dbo.bPRTH WHERE PRCo = @prco AND PREndDate = @enddate) RETURN 0

----------------------------------------------------------------------------
/*	Processing loop to get arrears amount and call vspPRProcessArrears	*/
--------------------------------------------------------------------------
-- Loop through the table
DECLARE @loopkey char(14)
SELECT @loopkey = MIN(loopkey) FROM @EmplDednCodeNoTimecard
WHILE (@loopkey IS NOT NULL)
BEGIN
	SELECT @employee = employee, 
		   @dlcode = dedncode, 
		   @payseq = payseq 
	FROM @EmplDednCodeNoTimecard
	WHERE loopkey = @loopkey
	-- Get the amount to put in arrears: This will be the override rate amount
	-- from PRED if it exists, otherwise we will use amount #1 in PRDL
	SELECT @predamt = RateAmt 
	FROM dbo.bPRED
	WHERE PRCo = @prco
		AND Employee = @employee
		AND DLCode = @dlcode
	SELECT @prdlamt = RateAmt1 
	FROM dbo.bPRDL
	WHERE PRCo = @prco
		AND DLCode = @dlcode
		
	IF @predamt <> 0 SELECT @arrearsamt = @predamt
	ELSE SELECT @arrearsamt = @prdlamt

	--Call stored procedure to put record into arrears table
	EXEC @rcode = vspPRProcessArrears @prco, 
	  						 @employee,
	  						 @dlcode,
	  						 @arrearsamt,
	  						 0, -- Payback will ever be processed for empls w/o a timecard
	  						 @prgroup,
	  						 @enddate,
	  						 @payseq,
	  						 'N', -- TimecardYN = No
	  						 @msg OUTPUT
	IF @rcode = 1
	BEGIN
		RETURN 1
	END
	SELECT @loopkey = MIN(loopkey) 
	FROM @EmplDednCodeNoTimecard
	WHERE loopkey > @loopkey
END

RETURN 0
GO
PRINT N'Altering [dbo].[bspPRProcessFed]'
GO
ALTER  procedure [dbo].[bspPRProcessFed]
   /***********************************************************
   * CREATED BY: 	 GG  02/19/98
   * MODIFIED BY:    GG 04/09/99
   *                 LM 06/15/99  - Added username column in PRPE for SQL 7.0
   *              GG 07/05/99 - Added routine procedure check
   *              GG 01/06/00 - fix AP Vendor info update to bPRDT
   *              GG 03/06/00 - Employee addon amounts applied only if calculation basis > 0
   *              DANF 08/17/00 - remove reference to system id
   *              GG 01/30/01 - skip calculations for both dedns and liabs if calc basis = 0 (#11690)
   *		 MV 1/28/02 - issue 15711 - check for correct CalcCategory
   *			    - issue 13977 - round @calcamt if RndToDollar flag is set.  
   *				EN 10/9/02 - issue 18877 change double quotes to single
   *				EN 3/24/03 - issue 11030 rate of earnings liability limit
   *				GG 02/10/04 - #23655 fix to dist liab override amt when calc basis = 0.00
   *				EN 7/28/04 - issue 24545  call new routine bspPRExemptRateOfGross
   *				EN 9/24/04 - issue 20562  change from using bPRCO_LiabDist to bPREC_IncldLiabDist to determine whether an earnings code is included in liab distribs
   *				EN 4/8/05 - issue 28379  added @@error check to see if SQL error occured when routine was called
   *				EN 8/21/07 - issue 120519  pass NonResAlien flag to bspPRFWT routine for non-resident alien tax addon
   *				EN 3/7/08 - #127081 in declare statements change bState to varchar(4)
   *				EN 6/03/08 - #127270 call routine bspPR_AU_PAYGxx routine for Australia national tax computation
   *				EN 7/09/08  #127015 include new fields in PRFI (MiscFedDL1-4) when check for federal D/L's to process
   *				EN 8/10/09 - #133605 don't read MiscFedDL3 from bPRFI ... mod for AUS Superannuation Guarantee
   *		TJL 02/19/10 - Issue #137844, as a result of NULL values allowed for AU in the Federal Info file, "selects" needed to skip them
   *				EN 11/27/2012	D-05383/#146657 added call to new routine vspPRMedicareSurcharge
   *				EN 11/30/2012	D-05383/#146657 modified to ignore any federal d/l codes not set up in PRFed
   *				DAN SO 03/18/2013 - Stories 39860, 39862, 39863, 39864, 39865 - ETP Tax Routines
   *				EN 3/22/2013  Story 39859/Task 42411 added call to new routine vspPR_AU_Marginal_PAYG
   *				DAN SO 05/21/2013 - Story 50738 - return Eligible amount`
   *
   * USAGE:
   * Calculates Federal deductions and liabilities for a select Employee and Pay Seq.
   * Called from main bspPRProcess procedure.
   *
   * INPUT PARAMETERS
   *   @prco	PR Company
   *   @prgroup	PR Group
   *   @prenddate	PR Ending Date
   *   @employee	Employee to process
   *   @payseq	Payment Sequence #
   *   @ppds      # of pay periods in a year
   *   @limitmth  Pay Period limit month
   *   @stddays   standard # of days in Pay Period
   *   @bonus     indicates a Bonus Pay Sequence - Y or N
   *   @posttoall earnings posted to all days in Pay Period
   *   @country	country code
   *
   * OUTPUT PARAMETERS
   *   @fedtax	Federal Tax amount
   *   @fedbasis	Federal Tax basis
   *   @errmsg  	Error message if something went wrong
   *
   * RETURN VALUE
   *   0   success
   *   1   fail
   *****************************************************/
    	@prco bCompany, @prgroup bGroup, @prenddate bDate, @employee bEmployee, @payseq tinyint,
    	@ppds tinyint, @limitmth bMonth, @stddays tinyint, @bonus bYN, @posttoall bYN, @country char(2),
        @fedtax bDollar output, @fedbasis bDollar output, @errmsg varchar(255) output
    as
    set nocount on
   
    declare @rcode int, @fedtaxdedn bEDLCode, @futa bEDLCode, @calcbasis bDollar,
    @calcamt bDollar, @procname varchar(30), @eligamt bDollar, @amt2dist bDollar,
    @accumbasis bDollar, @accumelig bDollar, @accumsubj bDollar, @accumamt bDollar,
    @ytdelig bDollar, @ytdamt bDollar, @rate bUnitCost, @liabbasis bDollar,
    @exemptamt bDollar --issue 24545

    -- Standard deduction/liability variables
    declare @dlcode bEDLCode, @dldesc bDesc, @dltype char(1), @method varchar(10), @routine varchar(10),
    @rate1 bUnitCost, @seq1only bYN, @ytdcorrect bYN, @bonusover bYN, @bonusrate bRate,
    @limitbasis char(1), @limitamt bDollar, @limitperiod char(1), @limitcorrect bYN, @autoAP bYN,
    @vendorgroup bGroup, @vendor bVendor, @apdesc bDesc, @calccategory varchar (1), @rndtodollar bYN,
    @limitrate bRate, @empllimitrate bRate, @outaccumbasis bDollar /*issue 11030*/
   
    -- Employee deduction/liability override variables
    declare @filestatus char(1), @regexempts tinyint, @overcalcs char(1), @emprateamt bUnitCost,
    @overlimit bYN, @emplimit bDollar, @addontype char(1), @addonrateamt bDollar, @empvendor bVendor
   
    -- Employee NonResAlienYN flag (issue 120519)
	declare @nonresalienyn bYN

	-- Australia PAYG computation declarations (#127270)
	declare @addlexempts tinyint, @ftb_offset bDollar

    -- Payment Sequence Total variables
    declare @dtvendorgroup bGroup, @dtvendor bVendor, @dtAPdesc bDesc, @useover bYN, @overprocess bYN,
    @overamt bDollar
   
    -- open cursor flags
    declare @openFedDL tinyint
   
    select @rcode = 0
   
    -- reset Federal Tax and Basis amounts
    select @fedtax = 0.00, @fedbasis = 0.00
   
    -- get Federal Tax and FUTA codes
    select @fedtaxdedn = TaxDedn, @futa = FUTALiab
    	from dbo.bPRFI with (nolock)
        where PRCo = @prco
    if @@rowcount = 0
    	begin
    	select @errmsg = 'Missing Federal Tax information!', @rcode = 1
    	goto bspexit
    	end
   
   	-- get NonResAlienYN flag for employee (issue 120519)
   	select @nonresalienyn = NonResAlienYN from dbo.PREH with (nolock)
   	where PRCo = @prco and Employee = @employee

    -- clear Process Earnings table
    delete dbo.bPRPE where VPUserName = SUSER_SNAME()
   
    insert dbo.bPRPE ( VPUserName, PostSeq, PostDate, EarnCode, Factor, IncldLiabDist, Hours, Rate, Amt )   -- Timecards
        select SUSER_SNAME(), t.PostSeq, t.PostDate, t.EarnCode, e.Factor, e.IncldLiabDist, t.Hours, t.Rate, t.Amt
        from dbo.bPRTH t
        join dbo.bPREC e with (nolock) on e.PRCo = t.PRCo and e.EarnCode = t.EarnCode
        where t.PRCo = @prco and t.PRGroup = @prgroup and t.PREndDate = @prenddate and t.Employee = @employee
            and t.PaySeq = @payseq
    insert dbo.bPRPE ( VPUserName, PostSeq, PostDate, EarnCode, Factor, IncldLiabDist, Hours, Rate, Amt )   -- Addons
        select SUSER_SNAME(), t.PostSeq, t.PostDate, a.EarnCode, e.Factor, e.IncldLiabDist, 0, a.Rate, a.Amt
        from dbo.bPRTA a
        join dbo.bPRTH t on t.PRCo = a.PRCo and t.PRGroup = a.PRGroup and t.PREndDate = a.PREndDate and
           t.Employee = a.Employee and t.PaySeq = a.PaySeq and t.PostSeq = a.PostSeq
        join dbo.bPREC e with (nolock) on e.PRCo = a.PRCo and e.EarnCode = a.EarnCode
        where a.PRCo = @prco and a.PRGroup = @prgroup and a.PREndDate = @prenddate and a.Employee = @employee
            and a.PaySeq = @payseq
   
    -- create cursor for all Federal D/Ls
	IF @country = 'US'
	BEGIN
		DECLARE bcFedDL CURSOR FOR
			SELECT TaxDedn FROM dbo.bPRFI WHERE PRCo = @prco
			UNION
			SELECT FUTALiab FROM dbo.bPRFI WHERE PRCo = @prco
			UNION
			SELECT Code=MiscFedDL1 FROM dbo.bPRFI WHERE PRCo = @prco --#127015
			UNION
			SELECT Code=MiscFedDL2 FROM dbo.bPRFI WHERE PRCo = @prco --#127015
			UNION
			SELECT Code=MiscFedDL3 FROM dbo.bPRFI WHERE PRCo = @prco --#127015
			UNION
			SELECT Code=MiscFedDL4 FROM dbo.bPRFI WHERE PRCo = @prco --#127015
			UNION
			SELECT Code=MiscFedDL5 FROM dbo.bPRFI WHERE PRCo = @prco --#127015
			UNION
			SELECT DLCode FROM dbo.bPRFD WHERE PRCo = @prco
	END
	if @country = 'AU'
		begin
		declare bcFedDL cursor for
			select TaxDedn from dbo.bPRFI with (nolock) where PRCo = @prco
			union
			select FUTALiab from dbo.bPRFI with (nolock) where PRCo = @prco and FUTALiab is not null
			union
			select Code=MiscFedDL1 from dbo.bPRFI with (nolock) where PRCo = @prco and MiscFedDL1 is not null	--#127015
			union
			select Code=MiscFedDL2 from dbo.bPRFI with (nolock) where PRCo = @prco and MiscFedDL2 is not null  --#127015
			union
			select DLCode from dbo.bPRFD with (nolock) where PRCo = @prco
		end
   
    open bcFedDL
    select @openFedDL = 1
   
    -- loop through Federal DL cursor
    next_FedDL:
    	fetch next from bcFedDL into @dlcode
    	if @@fetch_status = -1 goto end_FedDL
    	if @@fetch_status <> 0 goto next_FedDL
   
		-- ignore any null dlcodes set up in PRFed
		if @dlcode is null
			begin
			goto next_FedDL
			end

    	-- get standard DL info
    	select @dldesc = Description, @dltype = DLType, @method = Method, @routine = Routine,
    		@rate1= RateAmt1, @seq1only = SeqOneOnly, @ytdcorrect = YTDCorrect, @bonusover = BonusOverride,
    		@bonusrate = BonusRate, @limitbasis = LimitBasis, @limitamt = LimitAmt, @limitperiod = LimitPeriod,
    		@limitcorrect = LimitCorrect, @autoAP = AutoAP, @vendorgroup = VendorGroup, @vendor = Vendor,
   		@calccategory = CalcCategory, @rndtodollar=RndToDollar, @limitrate = LimitRate /*issue 11030*/
    		from dbo.bPRDL with (nolock)
           	where PRCo = @prco and DLCode = @dlcode
    	if @@rowcount = 0
    		begin
    		select @errmsg = 'Dedn/liab code:' + convert(varchar(4),@dlcode) + ' not setup!', @rcode = 1
    		goto bspexit
    		end
   
   	 /* validate calculation category*/
   	if @calccategory not in ('F','A')
   		begin
   		select @errmsg = 'Dedn/liab code:' + convert(varchar(4),@dlcode) + ' must be calculation category F or A!', @rcode = 1
    		goto bspexit
    		end
   
    	-- skip if restricted to Pay Seq #1
    	if @seq1only = 'Y' and @payseq <> 1 goto next_FedDL
   
   
        select @rate = @rate1   -- default to standard DL rate
   
    	-- get Employee info and overrides for this DL
    	select @filestatus = 'S', @regexempts = 0, @empvendor = null, @apdesc = null, @overcalcs = 'N',
            @overlimit = 'N', @addontype = 'N', @addonrateamt = 0.00
    	select @filestatus = FileStatus, @regexempts = RegExempts, @empvendor = Vendor, @apdesc = APDesc,
    		@overcalcs = OverCalcs, @emprateamt = isnull(RateAmt,0.00), @overlimit = OverLimit,
    		@emplimit = isnull(Limit,0.00), @addontype = AddonType, @addonrateamt = isnull(AddonRateAmt,0.00),
   		@empllimitrate = isnull(LimitRate,0.00) /*issue 11030*/
    	from dbo.bPRED with (nolock)
   
        where PRCo = @prco and Employee = @employee and DLCode = @dlcode
   
    	-- check for calculation override on Bonus sequence
    	if @bonus = 'Y' and @bonusover = 'Y' select @method = 'G', @rate = @bonusrate
   
    	-- check for Employee calculation and rate overrides
    	if @overcalcs = 'M' select @method = 'G', @rate = @emprateamt
    	if @overcalcs = 'R' select @rate = @emprateamt
    	if @overlimit = 'Y' select @limitamt = @emplimit
   	if @overlimit = 'Y' select @limitrate = @empllimitrate /*issue 11030*/
   
        -- get calculation, accumulation, and liability distribution basis
        exec @rcode = bspPRProcessGetBasis @prco, @prgroup, @prenddate, @employee, @payseq, @method, --issue 20562
            @posttoall, @dlcode, @dltype, @stddays, @calcbasis output, @accumbasis output,
            @liabbasis output, @errmsg output
        if @rcode <> 0 goto bspexit
   
    	-- check for 0 basis - skip accumulations and calculations
    	if @calcbasis = 0.00
    		begin
    		select @calcamt = 0.00, @eligamt = 0.00
    		goto calc_end
    		end
   
    	-- accumulate actual, subject, and eligible amounts if needed
    	if @limitbasis = 'C' or @limitbasis = 'S' or @ytdcorrect = 'Y'
    		begin
    		exec @rcode = bspPRProcessGetAccums @prco, @prgroup, @prenddate, @employee, @payseq,
    			@dlcode, @dltype, @limitperiod, @limitmth, @ytdcorrect, @accumamt output,
    			@accumsubj output, @accumelig output, @ytdamt output, @ytdelig output, @errmsg output
    		if @rcode <> 0 goto bspexit
    		end
   
    	-- Calculations
    	select @calcamt = 0.00
   
    	/* Flat Amount */
    	if @method = 'A'
    		begin
    		exec @rcode = bspPRProcessAmount @calcbasis, @rate, @limitbasis, @limitamt, @limitcorrect, @accumelig,
    			@accumsubj, @accumamt, @ytdelig, @ytdamt, @calcamt output, @eligamt output, @errmsg output
    		if @rcode<> 0 goto bspexit
    		end
   
    	    -- Rate per Day, Factored Rate per Hour, Rate of Gross, Rate per Hour, Straight Time Equivalent, or Rate of Dedn
            if @method in ('D', 'F', 'G', 'H', 'S', 'DN')
    		begin
    		exec @rcode = bspPRProcessRateBased @calcbasis, @rate, @limitbasis, @limitamt, @ytdcorrect,
                @limitcorrect, @accumelig, @accumsubj, @accumamt, @ytdelig, @ytdamt,
   			 @accumbasis, @limitrate, @outaccumbasis output, --issue 11030 adjust for changes in bspPRProcessRateBased
   			 @calcamt=@calcamt output, @eligamt=@eligamt output, @errmsg=@errmsg output
    		if @rcode<> 0 goto bspexit
   		select @accumbasis = @outaccumbasis --issue 11030 basis may be adjusted to fit rate of earnings limit scheme
    		end
   
    	-- Routine
    	if @method = 'R'
    		begin
    		-- get procedure name
    		select @procname = null
    		select @procname = ProcName from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = @routine
    		if @procname is null
    			begin
    			select @errmsg = 'Missing Routine procedure name for dedn/liab ' + convert(varchar(4),@dlcode), @rcode = 1
    			goto bspexit
    			end
            if not exists(select * from sysobjects where name = @procname and type = 'P')
                 begin
                 select @errmsg = 'Invalid Routine procedure - ' + @procname, @rcode = 1
                 goto bspexit
                 end
   
   	  -- issue 24545
            if @procname = 'bspPRExemptRateOfGross'   -- rate of gross with exemption ... tax calculation withheld until subject amount reaches exemption limit
               begin
   			exec @rcode = bspPRProcessGetAccums @prco, @prgroup, @prenddate, @employee, @payseq,
   			  @dlcode, @dltype, 'A', @limitmth, 'N', @accumamt output,
   			  @accumsubj output, @accumelig output, @ytdamt output, @ytdelig output, @errmsg output
   			if @rcode <> 0 goto bspexit
   	
   			select @exemptamt = MiscAmt1 from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = @routine
   	
   			exec @rcode = @procname @calcbasis, @rate, @accumsubj, @accumelig, @exemptamt, @calcamt output, @eligamt output, @errmsg output
   			-- please put no code between exec and @@error check!
   			if @@error <> 0 select @rcode = 1 --28379 check for error when routine was called
   			if @rcode <> 0 goto bspexit --28379 if error occurred, abort
   
   			select @calcbasis = @eligamt
   			goto routine_end
   			end

			-- #127270 Australia PAYG national tax routine
			if @procname like 'bspPR_AU_PAYG%'
				begin
    			select @addlexempts = 0, @ftb_offset = 0
    			select @addlexempts = AddExempts, @ftb_offset = MiscAmt
    			from dbo.bPRED with (nolock)
				where PRCo = @prco and Employee = @employee and DLCode = @dlcode

    			exec @rcode = @procname @calcbasis, @ppds, @regexempts, @filestatus, @addlexempts, @nonresalienyn, @ftb_offset, @calcamt output, @errmsg output
   				-- please put no code between exec and @@error check!
   				if @@error <> 0 select @rcode = 1
    			if @rcode <> 0 goto bspexit
   
    			if @calcamt is null select @calcamt = 0.00
    			select @eligamt = @calcbasis
   				goto routine_end

				end

			-- D-05383/#146657 if computing the additional Medicare surcharge, assume @limitperiod is annual
			IF @procname like 'vspPRMedicareSurcharge%' 
			BEGIN
				EXEC @rcode = vspPRProcessGetDLYTDSubjectAmount	@prco,		@prgroup,	@prenddate,		
																@employee,	@payseq,	@dlcode,	
																@accumbasis output,
																@errmsg output
    												
    			IF @rcode <> 0 GOTO bspexit
	    		
    			--call stored proc passing in the subject amount (calcbasis) and ytd subject amount (@accumsubj)
    			EXEC @rcode = @procname @calcbasis, @accumbasis, @calcamt OUTPUT, @eligamt OUTPUT, @errmsg OUTPUT
   				-- please put no code between exec and @@error check!
   				IF @@error <> 0 SELECT @rcode = 1
    			IF @rcode <> 0 GOTO bspexit
   
				IF @calcamt IS NULL SELECT @calcamt = 0.00
				SELECT @accumbasis = @calcbasis
   				GOTO routine_end
			END
		
			------------------------------------------------------------------
			-- ETP ROUTINE -- Story 39859/Task 42411 vspPR_AU_Marginal_PAYG --
			------------------------------------------------------------------
			IF @procname = 'vspPR_AU_Marginal_PAYG' 
			BEGIN
				EXEC	@rcode = @procname
						@PRCo = @prco,
						@Employee = @employee,
						@PRGroup = @prgroup,
						@PREndDate = @prenddate,
						@NumberOfPayPdsAnnually = @ppds,
						@SubjectAmount = @calcbasis,
						@TaxAmount = @calcamt OUTPUT,
						@ErrorMsg = @errmsg OUTPUT
   				-- please put no code between exec and @@error check!
   				IF @@error <> 0 SELECT @rcode = 1
    			IF @rcode <> 0 GOTO bspexit
   
				IF @calcamt IS NULL SELECT @calcamt = 0.00
				SELECT @eligamt = @calcbasis
   				GOTO routine_end
			END
	

			------------------
			-- ETP ROUTINES -- Stories 39860, 39862, 39863, 39864, 39865 --
			------------------ 
			If @procname IN ('vspPR_AU_Death',		'vspPR_AU_Invalidity',		'vspPR_AU_Redundancy',
							 'vspPR_AU_Standard',	'vspPR_AU_Unfair')
				BEGIN
					DECLARE @ETPTotalTaxWithheld bDollar, @ETPEligibleAmt bDollar -- 50738 --

					-- CALL CORRESPONDING ETP ROUTINE --
					EXEC @rcode = @procname 
									@prco, @employee, @prenddate, @calcbasis,  
									@TaxAmount = @ETPTotalTaxWithheld OUTPUT,
									@EligibleAmt = @ETPEligibleAmt OUTPUT,
									@ErrorMsg = @errmsg OUTPUT
			
					-- CHECK RETURN CODE --				
    				IF @rcode <> 0 GOTO bspexit
	    		
					-- SET --
					IF @ETPTotalTaxWithheld IS NULL SELECT @ETPTotalTaxWithheld = 0
					SET @calcamt = @ETPTotalTaxWithheld

					-- 50738 --
					IF @ETPEligibleAmt IS NULL SET @ETPEligibleAmt = 0
					SET @eligamt = @ETPEligibleAmt

					GOTO routine_end
				END


    		exec @rcode = @procname @calcbasis, @ppds, @filestatus, @regexempts, @nonresalienyn, @calcamt output, @errmsg output --issue 120519
   		-- please put no code between exec and @@error check!
   		if @@error <> 0 select @rcode = 1 --28379 check for error when routine was called
    		if @rcode <> 0 goto bspexit
   
    		if @calcamt is null select @calcamt = 0.00
    		select @eligamt = @calcbasis
    		end
   
        routine_end:
        -- apply Employee calculation override
        if @overcalcs = 'A'	select @calcamt = @emprateamt
   
    	-- apply Employee addon amounts - only applied if calculation basis is positive
    	if @calcbasis > 0.00
    		begin
    		if @addontype = 'A' select @calcamt = @calcamt + @addonrateamt
    		if @addontype = 'R' select @calcamt = @calcamt + (@calcbasis * @addonrateamt)
    		end
   
   	if @rndtodollar='Y'	select @calcamt = ROUND(@calcamt,0) -- round to the nearest dollar
   
        calc_end:	-- Finished with calculations
            -- save Fed Tax and subject amount
            if @dlcode = @fedtaxdedn select @fedtax = @calcamt, @fedbasis = @calcbasis
   
    	   -- get AP Vendor and Transaction description
    	   select @dtvendorgroup = null, @dtvendor = null, @dtAPdesc = null
    	   if @autoAP = 'Y'
    		  begin
    		  select @dtvendorgroup = @vendorgroup, @dtvendor = @vendor, @dtAPdesc = @dldesc
    		  if @empvendor is not null select @dtvendor = @empvendor
    		  if @apdesc is not null select @dtAPdesc = @apdesc
    		  end
    	   -- update Payment Sequence Totals
    	   update dbo.bPRDT
              set Amount = Amount + @calcamt, SubjectAmt = SubjectAmt + @accumbasis, EligibleAmt = EligibleAmt + @eligamt,
              	VendorGroup = @dtvendorgroup, Vendor = @dtvendor, APDesc = @dtAPdesc
    		  where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee
    		      and PaySeq = @payseq and EDLType = @dltype and EDLCode = @dlcode
    	   if @@rowcount = 0
    		  begin
            	  insert dbo.bPRDT (PRCo, PRGroup, PREndDate, Employee, PaySeq, EDLType, EDLCode, Hours, Amount, SubjectAmt, EligibleAmt,
    			 UseOver, OverAmt, OverProcess, VendorGroup, Vendor, APDesc, OldHours, OldAmt, OldSubject, OldEligible, OldMth,
                 OldVendor, OldAPMth, OldAPAmt)
    		  values (@prco, @prgroup, @prenddate, @employee, @payseq, @dltype, @dlcode, 0, @calcamt, @accumbasis, @eligamt,
    			 'N', 0, 'N', @dtvendorgroup, @dtvendor, @dtAPdesc, 0, 0, 0, 0, null, null, null,0)
   
    	          if @@rowcount <> 1
    			begin
    			select @errmsg = 'Unable to add PR Detail Entry for Employee ' + convert(varchar(6),@employee), @rcode = 1
    			goto bspexit
    			end
    		  end
   
    	   -- check for Override processing
    	   select @useover = UseOver, @overamt = OverAmt, @overprocess = OverProcess
    	   from dbo.bPRDT with (nolock)
           where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee
    		  and PaySeq = @payseq and EDLType = @dltype and EDLCode = @dlcode
   
    	   if @overprocess = 'Y' goto next_FedDL
   
           -- an overridden DL amount is processed only once
    	   if @useover = 'Y'
    		  begin
    		  update dbo.bPRDT
                set OverProcess = 'Y' where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    			     and Employee = @employee and PaySeq = @payseq and EDLType = @dltype and EDLCode = @dlcode
    		  end
   
    	   -- check for Liability distribution - needed even if basis and/or amount are 0.00
    	   if @dltype <> 'L' goto next_FedDL
   
           -- use calculated amount unless overridden
 
    	   select @amt2dist = @calcamt
   		-- #23655 fix to use override amt even if calc basis = 0
    	   if @useover = 'Y' /*and @calcbasis <> 0.00*/ select @amt2dist = @overamt
   
         -- no need to distribute if Basis <> 0 and Amt = 0, but will distibute if both are 0.00
            -- because of possible offsetting timecard entries
            if @calcbasis <> 0.00 and @amt2dist = 0.00 goto next_FedDL
   
           -- call procedure to distribute liability amount
            exec @rcode = bspPRProcessLiabDist @prco, @prgroup, @prenddate, @employee, @payseq, @dlcode,
                    @method, @rate, @liabbasis, @amt2dist, @posttoall, @errmsg output --issue 20562
            if @rcode <> 0 goto bspexit
   
        goto next_FedDL
   
    end_FedDL:
        close bcFedDL
        deallocate bcFedDL
        select @openFedDL = 0
   
    bspexit:
   
        -- clear Process Earnings
        delete dbo.bPRPE where VPUserName = SUSER_SNAME()
   
        if @openFedDL = 1
            begin
       		close bcFedDL
        	deallocate bcFedDL
          	end
   
    	return @rcode


GO
PRINT N'Altering [dbo].[bspPRProcess]'
GO
ALTER procedure [dbo].[bspPRProcess]
/***********************************************************
* CREATED BY: 	GG  01/21/1998
* MODIFIED BY:  GG  02/25/1999
*               GG  11/08/1999 - Fix removal of bPRDT records
*               GG  01/29/2001 - removed PRSQ.InUse
*               GG  01/30/2001 - added call to bspPRProcessCraftAccums to update craft earnings
*				GG	07/09/2002 - #17284 - refresh AP info in bPRDT
*				GG	07/09/2002 - #10865 - added AP info to bPRCA
*				EN	10/09/2002 - #18877 - change double quotes to single
*				GG	03/07/2003 - #19909 - provide fall back default description for AP Desc 
*				GG	02/10/2004 - #23698 - added scroll_locks to bcEmployeeSeq cursor to prevent errors 
*										  when multiple users process same payroll simultaneously
*				EN	03/17/2004 - #20559 - include AP Update info in bPRDT earnings entries where PREC_AutoAP = 'Y'
*				EN	04/22/2004 - #20559 - additional change to allow earnings & liabs to be backed out of AP if check is voided
*				EN	09/24/2004 - #20562 - change from using bPRCO_LiabDist to bPREC_IncldLiabDist to determine whether an earnings code is included in liab distribs
*				GG	10/15/2004 - #25292 - replace dynamic SQL
*				GG	09/21/2005 - #28443 - don't remove bPRSQ if paid, even if all timecards have been deleted, must void first 
*				GG	10/18/2007 - #125457/#125881 - added 'select top 1' to queries for performance
*				EN	11/13/2007 - #125437 - include MidName and Suffix in APDesc for bPRCA and bPRDT
*				EN	03/26/2008 - #127015 - added code to call Canadian Federal tax routine
*				EN	06/18/2008 - #127270 - call same Fed/State process procedures as for USA
*				EN	03/30/2009 - #129888 - For Australian allowances update allowance subject hours to PRDT SubjectAmt
*				EN	07/21/2009 - #134431 - Additional code to PRDT update to update SubjectAmt for AUS allowance subject hours
*				MV	11/03/2010 - #140541 - Pre-tax deduction processing
*				CHS	10/07/2011 - D-03053 - tightened up the frequency code join
*				CHS 10/28/2011 - B-06309 - added PreTaxCatchUpYN
*				CHS	07/16/2012 - D-03348 - #144933 fixed Pretax state problem
*				CHS	07/26/2012 - D-05606 - fixed Pretax state problem with multiple employees.
*				CHS 08/16/2012 - B-10152 - TK-17277 adding Payback
*				CHS 08/16/2012 - B-10152 - TK-17277 adding Payback - added delete of bPRDT line when PaybackOverYN = 'N'
*			  KK/EN 08/28/2012 - B-10150 - Process employees with no timecards for Arrears
*				KK  08/29/2012 - B-10150 - Moved call to process arrears for employees with no timecards before processing to 
*										   preserve the integrety of the employee and/or pay sequence being passed in
*				KK  09/04/2012 - B-10817 - TK-17504 delete entries in Arrears history table when all timecards are deleted from that pay period
*				CHS 09/10/2012 - B-10152 - TK-17277 adding Payback - added setting payback to zero before processing
*				CHS 09/13/2012 - B-10152 - TK-17277 fixed Payback problem with multiple employees - 
*            DAN SO 10/01/2012 - B-10151 - TK-18099 Temp table to hold Arrears processed KeyIDs
*				CHS	10/03/2012 - D-05997 - TK-18315 Fix payback for EFTs.
*				CHS 10/09/2012 - D-05975 - TK-18128 Fixed looping problem
*				KK  12/10/2012 - D-11193 - TK-20133 Call vspPRProcessAllowances for AU allowances processing
*				KK  05/21/2013 - 47844/Task 47877 Prevent reprocessing/deleting other sequences when a sequence is specified
*				KK  05/23/2013 - 47844/Task 47877 Added "mode" parameter when calling process arrears no timecards to process changed
*
* USAGE:
* Primary procedure used to process PR earnings.  Executes other PR Process procedures
* as needed to calculate Addons, Deductions, and Liabilities
*
* INPUT PARAMETERS
*   @prco	PR Company
*   @prgroup	PR Group
*   @prenddate	PR Ending Date
*   @employee	Employee to process (null if processing all Employees)
*   @payseq	Payment Sequence # (null if processing all Seqs)
*   @mode	'A' = All, 'C' = Only those needing processing, 'S' = Select Employee
*
* OUTPUT PARAMETERS
*   @errmsg     if something went wrong
*
* RETURN VALUE
*   0   success
*   1   fail
*****************************************************/
(@prco bCompany, 
 @prgroup bGroup, 
 @prenddate bDate, 
 @employee bEmployee, 
 @payseq tinyint,
 @mode char(1), 
 @errmsg varchar(255) output)

AS
SET NOCOUNT ON    
    
DECLARE @status tinyint,		@tsql varchar(255),			  @rcode int,				@earncode bEDLCode, 
		@hrs bHrs,				@amt bDollar,				  @fedtax bDollar,			@fedbasis bDollar, 
		@ppds tinyint,			@limitmth bMonth,			  @stddays tinyint,			@bonus bYN,
		@posttoall bYN,			@openEmployeeSeq tinyint,	  @openEarning tinyint,		@openAddon tinyint, 
		@openDLVendor tinyint,	@edltype char(1),			  @edlcode bEDLCode,		@edlvendorgroup bGroup, 
		@edlvendor bVendor,		@edvendorgroup bGroup,		  @edvendor bVendor,		@apdesc bDesc, 
		@edldesc bDesc,			@autoAP bYN,				  @vendorgroup bGroup,		@vendor bVendor, 
		@transbyemployee bYN,	@eapdesc bDesc,				  @suffix varchar(4),		@PreTaxEmployee bEmployee, 
		@PreTaxPaySeq tinyint,	@PreTaxProcessingSeq tinyint, @PreTaxDLCode bEDLCode,	@PreTaxCalcCategory varchar(1),
		@YearEndMth tinyint,	@AccumBeginMth bMonth,		  @AccumEndMth bMonth,		@OpenPreTaxProcessing int, 
		@DummyOutput bDollar,	@OpenDedGroup int,			  @PreTaxGroup tinyint,		@AccumAmt bDollar, 
		@TotalAccumAmt bDollar, @OpenDLCodes int,			  @TotalAmount bDollar,		@DednGroupLimit bDollar, 
		@DiffAmt bDollar,		@Craft bCraft,				  @Class bClass,			@Template smallint,
		@EffectDate bDate,		@OldCapLimit bDollar,		  @NewCapLimit bDollar,		@RecipOpt char(1),
		@JobCraft bCraft,		@OpenCraftCalcPrep int,		  @OpenEmplCalcPrep int,	@RemainingDiffAmt bDollar, 
		@DednAmt bDollar,		@AmtToUpdate bDollar,		  @EligibleAmt bDollar,		@PreTaxCatchUpDLCode bEDLCode,	
		@ArrearsActiveYN bYN,	@NetPay bDollar,			  @PaybackRecalculate bYN

-- #127015 declare variables for Canada taxes
DECLARE @country char(2), 
		@A bDollar,	  
		@PP bDollar,		 
		@maxCPP bDollar, 
		@EI bDollar,	  
		@maxEI bDollar, 
		@capstock bDollar, 
		@HD bDollar
    
--#129888 Australian Allowances
DECLARE @routine varchar(10),	
		@rate bUnitCost,			
		@subjectamt bDollar

SELECT	@rcode = 0, 
		@OpenPreTaxProcessing = 0, 
		@OpenDedGroup = 0, 
		@OpenDLCodes = 0, 
		@OpenCraftCalcPrep = 0, 
		@OpenEmplCalcPrep = 0
    
    -- check for input parameters
    if @mode not in ('A','S','C')
    	begin
    	select @errmsg = 'Processing mode must be All, Changed, or Select Employee!', @rcode = 1
    	goto bspexit
    	end
    -- determine number of annual Pay Periods for this PR Group
    select @ppds =
    	case PayFreq
    		when 'W' then 52
    		when 'B' then 26
    		when 'S' then 24
    		when 'M' then 12
    		else 0
    	end
    	from dbo.bPRGR with (nolock) where PRCo = @prco and PRGroup = @prgroup
    if @ppds = 0
    	begin
    	select @errmsg = 'Unable to determine the number of annual Pay Periods for the PR Group!', @rcode = 1
    	goto bspexit
    	end
    
    -- get info from Pay Period Control
    select @limitmth = LimitMth, @stddays = Days, @status = Status
    from dbo.bPRPC with (nolock)
    where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    if @@rowcount = 0
    	begin
    	select @errmsg = 'PR Group and Ending Date not setup in Pay Period Control!', @rcode = 1
    	goto bspexit
    	end
    
    -- check Pay Period status
    if @status <> 0
    	begin
    	select @errmsg = 'Pay Period status must be Open!', @rcode = 1
    	goto bspexit
    	end
    
    select @rcode = 0
 
	-- #127015 read country assigned in HQCO
	select @country = DefaultCountry from dbo.bHQCO with (nolock) where HQCo = @prco
	if @country is null select @country = 'US'
	
	/* Process employees with no timecards for Arrears */ -- B-10150
	EXEC @rcode = vspPRGetEmplNoTimecardsForArrears @prco, @prgroup, @employee, @prenddate, @payseq, @mode, @errmsg output

	----------------------------------------------------------------------------------------------------------
	/* PREPARE FOR PRE-TAX DEDUCTION PROCESSING - #140541 */
	-- create temp table for Craft and Employee based pretax deductions 
	CREATE TABLE #EmployeePreTaxDedns
		(
			PRCo int, PRGroup int, PREndDate smalldatetime,
			Employee int, PaySeq tinyint, ProcessingSeq tinyint,
			CalcCategory varchar (1), DLCode int, BasisAmt float, DednAmt float,
			PreTaxGroup tinyint, PreTaxCatchUpYN char(1), ArrearsPayback char(1)
		)
		
	CREATE TABLE #EmployeePreTaxPRPE
		(
			PostSeq smallint, PostDate smalldatetime, EarnCode int, PreTaxDLCode int
		)	
		
	CREATE TABLE #ArrearsDLCodesProcessed -- B-10151 - TK-18099 --
		(
			  DLCodeKeyID bigint
		)
			
	-- Get AccumBeginMth and AccumEndMth for employee pretax processing
	SELECT @YearEndMth = CASE h.DefaultCountry WHEN 'AU' THEN 6 ELSE 12 END
	FROM dbo.bHQCO h  
	WHERE h.HQCo = @prco

	EXEC vspPRGetMthsForAnnualCalcs @YearEndMth, @limitmth, @AccumBeginMth output, @AccumEndMth output, @errmsg output

----------------------------------------------------------------------------------------------------------
/************ EMPLOYEE-SEQUENCE: Master cursor to cycle through Employee Payment Sequences **************/
----------------------------------------------------------------------------------------------------------
-- #23698 - added scroll_locks to cursor
DECLARE bcEmployeeSeq cursor scroll_locks for
SELECT Employee, PaySeq
FROM dbo.bPRSQ 
WHERE PRCo = @prco 
  AND PRGroup = @prgroup 
  AND PREndDate = @prenddate
  AND Employee = ISNULL(@employee,Employee)
  AND PaySeq = ISNULL(@payseq,PaySeq)
  AND Processed = CASE @mode WHEN 'C' THEN 'N' ELSE Processed END 

OPEN bcEmployeeSeq
SELECT @openEmployeeSeq = 1

-- Begin loop through Employee Pay Sequence cursor
next_EmployeeSeq:
	FETCH NEXT FROM bcEmployeeSeq INTO @employee, @payseq
	IF @@fetch_status = -1 GOTO end_EmployeeSeq
	IF @@fetch_status <> 0 GOTO next_EmployeeSeq
    
    	-- check for unposted timecards
    	if exists(select * from dbo.bPRTB b with (nolock)
    		join dbo.bHQBC h with (nolock) on b.Co = h.Co and b.Mth = h.Mth and b.BatchId = h.BatchId
    		join dbo.bPRPC p with (nolock) on p.PRCo = h.Co and p.PRGroup = h.PRGroup and p.PREndDate = h.PREndDate
        	where p.PRCo = @prco and p.PRGroup = @prgroup and p.PREndDate = @prenddate
    			and b.Employee = @employee and b.PaySeq = @payseq)
    	goto next_EmployeeSeq
    
		----------------------------------------------------------------------------------------------------------
		/* Remove/Reset records */
    	-- reset flags in Employee Payment Sequence control
    	update dbo.bPRSQ
        	set Processed = 'N'
    	where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    	if @@rowcount <> 1
    		begin
    		select @errmsg = 'Unable to update Employee Seq Control entry!', @rcode = 1
    		goto bspexit
    		end
    
    	-- remove Timecard Addons
        delete dbo.bPRTA
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    
    	-- remove Timecard Liabilities 
    	delete dbo.bPRTL
        	where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    
    	-- remove Craft Rate Detail
    	delete dbo.bPRCX
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
        
    	-- remove Craft Accumulations not updated to AP
    	delete dbo.bPRCA
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    		and OldAPAmt = 0.00
    		
    	-- reset remaining Craft Accumulations
    	update dbo.bPRCA
    	set Basis = 0.00, Amt = 0.00, EligibleAmt = 0.00, VendorGroup = null, Vendor = null --, APDesc = null
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    	
    	-- remove Insurance Accumulations
    	delete dbo.bPRIA
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    
    	-- remove Deposit Sequences
    	delete dbo.bPRDS
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    
    	-- remove Pay Sequence Totals if no overrides or previous accumulations update
    	delete dbo.bPRDT
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    		and OldHours = 0.00 and OldAmt = 0.00 and OldSubject = 0.00 and OldEligible = 0.00 and OldAPAmt = 0.00
			and UseOver = 'N' and PaybackOverYN = 'N'
			
    	-- reset calculated amounts in remaining Pay Sequence Totals
    	update dbo.bPRDT
        set Hours = 0, Amount = 0, SubjectAmt = 0, EligibleAmt = 0, OverProcess = 'N', VendorGroup = null, Vendor = null, PaybackAmt = 0
    	where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    	    
    	-- If this employee has a record in any of the following tables go to ADDONS and DO NOT delete the record from PRSQ, 
    	--  if this record DOES NOT exist in any of these tables, delete the PRSQ record and go to the next Employee/Seq
    	if exists(select top 1 1 from dbo.bPRTH with (nolock) where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    		and Employee = @employee and PaySeq = @payseq) 
    	BEGIN 
    	 -- 47844 reset arrears history table record ONLY when there is a timecard for processing or reprocessing for THIS record
			DELETE vPRArrears 
			WHERE PRCo = @prco AND PRGroup = @prgroup AND PREndDate = @prenddate AND Employee = @employee AND PaySeq = @payseq 
    		goto addons 
    	END
    	if exists(select top 1 1 from dbo.bPRDT with (nolock) where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    		and Employee = @employee and PaySeq = @payseq) goto addons
    	if exists(select top 1 1 from dbo.bPRGL with (nolock) where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    		and Employee = @employee and PaySeq = @payseq) goto addons
    	if exists(select top 1 1 from dbo.bPRJC with (nolock) where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    		and Employee = @employee and PaySeq = @payseq) goto addons
    	if exists(select top 1 1 from dbo.bPREM with (nolock) where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
    		and Employee = @employee and PaySeq = @payseq) goto addons			
   		if exists(select top 1 1 from dbo.bPRSQ with (nolock) where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate
   			and Employee = @employee and PaySeq = @payseq and CMRef is not null) goto addons --must first void check to remove CMRef (#28443)
   			
    	-- remove Employee Seq Control ONLY if nothing existed in the tables above for this Employee, then go to next employee
    	delete dbo.bPRSQ where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate 
    		and Employee = @employee and PaySeq = @payseq
   		goto next_EmployeeSeq
   		
    	/* End: Remove/Reset Records - If we did the delete, Goto next_EmployeeSeq, else Goto Addons */
    	----------------------------------------------------------------------------------------------------------
    	
    	/* Addons */
    	addons: 	-- process Craft/Class Addons
            -- get Posted to All flag from Employee Seq Control
    		select @posttoall = PostToAll
    	       	from dbo.bPRSQ with (nolock)
    	       	where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
            	if @@rowcount = 0
    	       		begin
    	       		select @errmsg = 'Missing Employee Seq Control entry!', @rcode = 1
    	       		goto bspexit
    	       		end
    
    		exec @rcode = bspPRProcessAddons @prco, @prgroup, @prenddate, @employee, @payseq, @stddays,
                			@posttoall, @errmsg output
    		if @rcode <> 0 goto bspexit
    
   		-- issue 20559 read employee name for APDesc / issue #125437 include MidName and Suffix if not null
   		select @eapdesc = isnull(FirstName,'') + ' ' + isnull(MidName,'') + ' ' + isnull(LastName,''), @suffix = Suffix
		from dbo.PREH with (nolock)
   		where PRCo = @prco and Employee = @employee

		if @suffix is not null select @eapdesc = @eapdesc + ', ' + @suffix
		
       	/* End: Addons */
       	----------------------------------------------------------------------------------------------------------
    	
    	/* Allowances */
		BEGIN TRY 
			EXEC vspPRProcessAllowances @PRCo = @prco
											, @PRGroup = @prgroup
											, @PREndDate = @prenddate
											, @Employee = @employee
											, @PaySeq = @payseq;
		END TRY
		BEGIN CATCH
			SET @errmsg = 'Error in vspPRProcessAllowances:' + ERROR_MESSAGE();
			RAISERROR(@errmsg,16,1);
		END CATCH
		/* End: Allowances */ --Allowance values have been stored in PRTA (TK-20133)
		
     	----------------------------------------------------------------------------------------------------------
    	/* Update Posted Earnings to Payment Sequence Totals */
    	declare bcEarning cursor for
    	select EarnCode, convert(numeric(10,2),sum(Hours)), convert(numeric(12,2),sum(Amt))
    	from dbo.bPRTH with (nolock)
    	where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    	group by EarnCode
    
    	open bcEarning
    	select @openEarning = 1
    
    	-- loop through Posted Earnings cursor to update Payment Sequence Totals
    	next_Earning:
    		fetch next from bcEarning into @earncode, @hrs, @amt
    
    		if @@fetch_status = -1 goto end_Earning
    		if @@fetch_status <> 0 goto next_Earning
   
    		if @hrs <> 0.00 or @amt <> 0.00
    			begin
   			--issue 20559 look up earnings AP Update info
   	 		select @apdesc = Description, @autoAP = AutoAP, @transbyemployee = TransByEmployee, 
   				@vendorgroup = VendorGroup, @vendor = Vendor
   			from dbo.bPREC with (nolock) 
   			where PRCo = @prco and EarnCode = @earncode
   		 	if @@rowcount = 0
   		 		begin
   		 		select @errmsg = 'Earnings code:' + convert(varchar(4),@earncode) + ' not setup!', @rcode = 1
   		 		goto bspexit
   		 		end
   			if @autoAP = 'Y'
   				begin
   				if @transbyemployee = 'Y' select @apdesc = @eapdesc
   				end
   
    			update dbo.bPRDT
                set Hours = Hours + @hrs, Amount = Amount + @amt, 
   				VendorGroup = @vendorgroup, Vendor = @vendor, APDesc = @apdesc
    			where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee
                    and PaySeq = @payseq and EDLType = 'E' and EDLCode = @earncode
    			if @@rowcount = 0
    				insert dbo.bPRDT (PRCo, PRGroup, PREndDate, Employee, PaySeq, EDLType, EDLCode, Hours, Amount, SubjectAmt, EligibleAmt,
    					UseOver, OverAmt, OverProcess, VendorGroup, Vendor, APDesc, OldHours, OldAmt, OldSubject, OldEligible, OldMth,
                        OldVendor, OldAPMth, OldAPAmt)
    				values (@prco, @prgroup, @prenddate, @employee, @payseq, 'E', @earncode, @hrs, @amt, 0, 0, 'N', 0, 'N', 
   						@vendorgroup, @vendor, @apdesc, 0, 0, 0, 0, null, null, null, 0)
    				end
    			goto next_Earning
    
    	end_Earning:
    		close bcEarning
    		deallocate bcEarning
    		select @openEarning = 0
    	/* End: Update Posted Earnings to Payment Sequence Totals */
     	----------------------------------------------------------------------------------------------------------
     	
     	/* Update Addon Earnings and Allowance Earnings to Payment Sequence Totals */
    	declare bcAddon cursor for
    	select EarnCode, convert(numeric(12,2),sum(Amt)),
			Rate --#129888 also get sum of Rate to compute subject hours for Australian allowances
    	from dbo.bPRTA with (nolock)
    	where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    	group by EarnCode, Rate
    
    	open bcAddon
    	select @openAddon = 1
    
    	-- loop through Addon Earnings cursor to update Payment Sequence Totals
    	next_Addon:
    		fetch next from bcAddon into @earncode, @amt, @rate
    
    		if @@fetch_status = -1 goto end_Addon
    		if @@fetch_status <> 0 goto next_Addon
    
    		if @amt <> 0.00
    			begin
   				--issue 20559 look up earnings AP Update info
				--#129888 also look up Routine ... need to update subject hours to SubjectAmt when Routine='RPSH'
   	 			select @apdesc = Description, @autoAP = AutoAP, @transbyemployee = TransByEmployee, 
   					@vendorgroup = VendorGroup, @vendor = Vendor, @routine = Routine
   				from dbo.bPREC with (nolock)
   				where PRCo = @prco and EarnCode = @earncode
   		 		if @@rowcount = 0
   		 			begin
   		 			select @errmsg = 'Earnings code:' + convert(varchar(4),@earncode) + ' not setup!', @rcode = 1
   		 			goto bspexit
   		 			end
   				if @autoAP = 'Y'
   					begin
   					if @transbyemployee = 'Y' select @apdesc = @eapdesc
   					end
   
				--#129888 for Australian allowances store units as SubjectAmt
				select @subjectamt = 0
				if @routine = 'Allowance' or @routine = 'AllowRDO' select @subjectamt = @amt / @rate

    			update dbo.bPRDT
                		set Amount = Amount + @amt, SubjectAmt = SubjectAmt + @subjectamt, VendorGroup = @vendorgroup, Vendor = @vendor, APDesc = @apdesc
    			where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee and PaySeq = @payseq
    				and EDLType = 'E' and EDLCode = @earncode
    			if @@rowcount = 0
    			insert dbo.bPRDT (PRCo, PRGroup, PREndDate, Employee, PaySeq, EDLType, EDLCode, Hours, Amount, SubjectAmt, EligibleAmt,
    				UseOver, OverAmt, OverProcess, VendorGroup, Vendor, APDesc, OldHours, OldAmt, OldSubject, OldEligible, OldMth,
                    OldVendor, OldAPMth, OldAPAmt)
    			values (@prco, @prgroup, @prenddate, @employee, @payseq, 'E', @earncode, 0, @amt, @subjectamt, 0, 'N', 0, 'N', 
   					@vendorgroup, @vendor, @apdesc, 0, 0, 0, 0, null, null, null, 0)
    			end
    		goto next_Addon
    
    	end_Addon:
    		close bcAddon
    		deallocate bcAddon
    		select @openAddon = 0
     	/* End: Addons/Update Addon Earnings to Payment Sequence Totals */
     	----------------------------------------------------------------------------------------------------------
     	
     	/* prepare for deduction and liability calculations */
    	-- see if this Payment Sequence is a Bonus Sequence
    	select @bonus = Bonus
        from dbo.bPRPS with (nolock)
        where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and PaySeq = @payseq
    	if @@rowcount = 0
    	   	begin
    	   	select @errmsg = 'Missing PR Sequence entry for this Pay Period!', @rcode = 1
    	   	goto bspexit
    	   	end

	----------------------------------------------------------------------------------------------------------
	/* BEGIN PRE-TAX DEDUCTION PROCESSING - #140541 */
			-- Clear Pre Tax temp table 
			DELETE FROM #EmployeePreTaxDedns
			DELETE FROM #EmployeePreTaxPRPE			
			-- B-10151 - TK-18099 --
			DELETE FROM #ArrearsDLCodesProcessed
			
			-- Load temp table with Craft based pretax deductions for current employee and pay seq
			INSERT INTO #EmployeePreTaxDedns
				(
					PRCo,PRGroup,PREndDate,
					Employee, PaySeq, ProcessingSeq,
					CalcCategory, DLCode, BasisAmt, DednAmt,
					PreTaxGroup, PreTaxCatchUpYN -- CHS 10/28/2011	- B-0630
				)			
			SELECT DISTINCT 
					t.PRCo, t.PRGroup,t.PREndDate,
					t.Employee,t.PaySeq,NULL, 
					'C',d.DLCode,0,0,d.PreTaxGroup, 'N'
			FROM dbo.bPRCI c
			JOIN dbo.bPRTH t ON c.PRCo=t.PRCo AND c.Craft=t.Craft 
			JOIN dbo.bPRDL d ON d.PRCo=c.PRCo AND d.DLCode=c.EDLCode
			WHERE t.PRCo=@prco AND t.PRGroup=@prgroup AND t.PREndDate=@prenddate AND 
				t.Employee=@employee AND t.PaySeq=@payseq AND
				d.DLType='D' AND d.PreTax='Y'			
				
			-- Load temp table with Employee based pretax deductions for current employee and pay seq
			INSERT INTO #EmployeePreTaxDedns
				(
					PRCo, PRGroup, PREndDate,
					Employee, PaySeq, ProcessingSeq,
					CalcCategory, DLCode, BasisAmt, DednAmt,
					PreTaxGroup, PreTaxCatchUpYN -- CHS 10/28/2011	- B-0630
				)			
			SELECT DISTINCT 
					t.PRCo, t.PRGroup,t.PREndDate,
					t.Employee,t.PaySeq, d.ProcessSeq,
					'E', l.DLCode,0,0,l.PreTaxGroup, l.PreTaxCatchUpYN -- CHS 10/28/2011	- B-0630
			FROM dbo.bPRTH t
			JOIN dbo.bPRED d ON d.PRCo=t.PRCo AND d.Employee=t.Employee 
			--CHS	10/07/2011	- D-03053 tightened up the frequency code join
			JOIN dbo.bPRAF f ON f.PRCo=d.PRCo AND f.Frequency=d.Frequency and t.PREndDate = f.PREndDate and  f.PRGroup = t.PRGroup
			JOIN dbo.bPRDL l ON l.PRCo=d.PRCo AND l.DLCode=d.DLCode
			WHERE t.PRCo=@prco AND t.PRGroup=@prgroup AND t.PREndDate=@prenddate AND 
				t.Employee=@employee AND t.PaySeq=@payseq AND
				l.DLType='D' AND l.PreTax='Y' AND d.EmplBased = 'Y'							

			-- Create a cursor and loop through each pre tax deduction
			DECLARE bcPreTaxProcessing CURSOR FOR
    		SELECT Employee, PaySeq, ProcessingSeq, CalcCategory, DLCode
			FROM #EmployeePreTaxDedns
			ORDER BY ProcessingSeq, DLCode
	    
    		OPEN bcPreTaxProcessing
    		SELECT @OpenPreTaxProcessing = 1
    
    		-- loop through Pre Tax Processing cursor to update PRDT with pre tax ded amts
    	NEXT_PreTax:
    		FETCH NEXT FROM bcPreTaxProcessing into @PreTaxEmployee, @PreTaxPaySeq, @PreTaxProcessingSeq,
				@PreTaxCalcCategory, @PreTaxDLCode
	    
			IF @@fetch_status = -1 GOTO END_PreTax
			IF @@fetch_status <> 0 GOTO NEXT_PreTax

			-- Call CraftDednLiabCalc to calculate the amount of this craft pre tax deduction - bPRDT is updated
			IF @PreTaxCalcCategory = 'C'
			BEGIN
				-- Get all the craft/class/template records from PRTH for this employee and pre tax dedn code, cycle
				-- through each and get additional 'prep' information and fill bPRPE work table prior to doing the dedn calc
				DECLARE bcCraftCalcPrep CURSOR FOR
				SELECT DISTINCT h.Craft, h.Class, j.CraftTemplate
				FROM dbo.bPRTH h
				LEFT OUTER JOIN bJCJM j ON h.JCCo = j.JCCo AND h.Job = j.Job
				JOIN dbo.#EmployeePreTaxDedns e ON e.PRCo=h.PRCo AND e.PRGroup=h.PRGroup AND e.PREndDate=h.PREndDate
					AND e.Employee=h.Employee AND e.PaySeq=h.PaySeq 
				JOIN dbo.bPRCI c ON c.PRCo=h.PRCo AND c.Craft= h.Craft AND EDLType = 'D' AND c.EDLCode = @PreTaxDLCode 
				WHERE h.PRCo = @prco and h.PRGroup = @prgroup and h.PREndDate = @prenddate and h.Employee = @employee
     				AND h.PaySeq = @payseq AND h.Craft IS NOT NULL AND h.Class IS NOT NULL AND e.CalcCategory='C'
	
				OPEN bcCraftCalcPrep
				SELECT @OpenCraftCalcPrep=1

			NEXT_CraftCalcPrep:
				FETCH NEXT FROM bcCraftCalcPrep into @Craft,@Class,@Template
	    
				IF @@fetch_status = -1 GOTO END_CraftCalcPrep
				IF @@fetch_status <> 0 GOTO NEXT_CraftCalcPrep
			
				
				-- execute CraftCalcPrep to fill bPRPE and get additional required information for calculating craft pre-tax deduction amount			
				EXEC @rcode = dbo.bspPRProcessCraftCalcPrep @prco, @prgroup, @prenddate, @PreTaxEmployee, @PreTaxPaySeq,
					@PreTaxDLCode, @Craft, @Class, @Template, @EffectDate OUTPUT, @OldCapLimit OUTPUT,
					@NewCapLimit OUTPUT, @RecipOpt OUTPUT, @JobCraft OUTPUT, @errmsg OUTPUT
    			IF @rcode <> 0 GOTO bspexit
    			-- execute CraftDednLiabCalc to calculate the pre tax deduction amount - updates bPRDT
				EXEC @rcode = bspPRProcessCraftDednLiabCalc @prco, @PreTaxDLCode,@prgroup, @prenddate, @PreTaxEmployee,
					@PreTaxPaySeq, @ppds,@limitmth, @stddays, @bonus, @posttoall, @Craft,@Class, @Template, @EffectDate,
					@OldCapLimit,@NewCapLimit,@JobCraft,@RecipOpt,@errmsg output
    			IF @rcode <> 0 GOTO bspexit
    			
    			-- save PRPE info for rationing later in PRProcessGetBasis D-03348 
    			INSERT INTO #EmployeePreTaxPRPE
    						(PostSeq, PostDate, EarnCode, PreTaxDLCode)
				SELECT PostSeq, PostDate, EarnCode, @PreTaxDLCode
				FROM bPRPE
				WHERE VPUserName = SUSER_SNAME()
    			
    			-- Clear the work table bPRPE
    			DELETE dbo.bPRPE WHERE VPUserName = SUSER_SNAME()	
    			GOTO NEXT_CraftCalcPrep
    			
    		END_CraftCalcPrep:
    			IF @OpenCraftCalcPrep = 1
				BEGIN
					CLOSE bcCraftCalcPrep
    				DEALLOCATE bcCraftCalcPrep
    				SELECT @OpenCraftCalcPrep = 0
				END
			END -- end CalcCategory C - craft
			IF @PreTaxCalcCategory = 'E'
			BEGIN
				-- call EmplCalcPrep to fill bPRPE to prepare for calculating employee pre-tax deduction amounts
				EXEC @rcode = bspPRProcessEmplCalcPrep @prco, @prgroup, @prenddate, @PreTaxEmployee,
					@PreTaxPaySeq, @PreTaxDLCode
    			IF @rcode <> 0 GOTO bspexit	
				-- call EmplDednLiabCalc to calc employee pre-tax ded amount - bPRDT is updated. 
				EXEC @rcode = bspPRProcessEmplDednLiabCalc @prco, @PreTaxDLCode,@prgroup, @prenddate, @PreTaxEmployee,
					@PreTaxPaySeq, @ppds,@limitmth, @stddays, @bonus, @posttoall,@AccumBeginMth ,
					@AccumEndMth , @DummyOutput OUTPUT, @errmsg output
    			IF @rcode <> 0 GOTO bspexit
    			-- Clear the work table bPRPE before getting the next employee dlcode.
    			
    			
    			-- save PRPE info for rationing later in PRProcessGetBasis D-03348 
    			INSERT INTO #EmployeePreTaxPRPE
    						(PostSeq, PostDate, EarnCode, PreTaxDLCode)
				SELECT PostSeq, PostDate, EarnCode, @PreTaxDLCode
				FROM bPRPE
				WHERE VPUserName = SUSER_SNAME()
				
    			
    			DELETE dbo.bPRPE WHERE VPUserName = SUSER_SNAME()
			END -- end CalcCategory E - employee
		
		GOTO NEXT_PreTax

		END_PreTax:
			IF @OpenPreTaxProcessing = 1
			BEGIN
				CLOSE bcPreTaxProcessing
    			DEALLOCATE bcPreTaxProcessing
    			SELECT @OpenPreTaxProcessing = 0
			END
			
		-- Apply limits from PR Deduction Groups	
		IF EXISTS (SELECT * 
					FROM #EmployeePreTaxDedns WHERE PreTaxGroup IS NOT NULL)
		BEGIN
			-- Spin through temp table Deduction Groups
			DECLARE bcDedGroup CURSOR FOR
    		SELECT DISTINCT PreTaxGroup				
			FROM #EmployeePreTaxDedns
			WHERE PreTaxGroup IS NOT NULL		
			ORDER BY PreTaxGroup
	    
    		OPEN bcDedGroup
    		SELECT @OpenDedGroup = 1
    
    		-- loop through Temp table deduction groups to get limits
    	NEXT_DednGroup:
    		FETCH NEXT FROM bcDedGroup into  @PreTaxGroup
	    
			IF @@fetch_status = -1 GOTO END_DednGroup
			IF @@fetch_status <> 0 GOTO NEXT_DednGroup
			
			-- Get the limit amount for this deduction group 
			SELECT @DednGroupLimit = AnnualLimit 
			FROM dbo.bPRDeductionGroup g
			WHERE g.PRCo=@prco AND g.DednGroup=@PreTaxGroup
			
			-- If Deduction Group Limit is 0 skip
			IF @DednGroupLimit = 0.00 GOTO NEXT_DednGroup 
			
			-- Initialize amount variables		
			SELECT @TotalAmount = 0, @TotalAccumAmt = 0,
				@DiffAmt = 0,@TotalAmount = 0
			 
				-- Now loop through all DLCodes in temp table for this deduction group
				DECLARE bcDLCodes CURSOR FOR
				SELECT DLCode
				FROM #EmployeePreTaxDedns
				WHERE PreTaxGroup=@PreTaxGroup and PreTaxCatchUpYN = 'N' -- CHS 10/28/2011	- B-0630
				ORDER BY DLCode
				
				OPEN bcDLCodes
				SELECT @OpenDLCodes = 1
				
			NEXT_DLCode:
				FETCH NEXT FROM bcDLCodes into @PreTaxDLCode
			
				IF @@fetch_status = -1 GOTO END_DLCodes
				IF @@fetch_status <> 0 GOTO NEXT_DLCode

				-- Get accum amounts for this Dedn Code - ded amts from PREA and PRDT.
				EXEC @rcode = bspPRProcessGetAccums @prco, @prgroup, @prenddate, @employee, @payseq,
    				@PreTaxDLCode, 'D', 'A', @limitmth, 'N', @AccumAmt output,@DummyOutput output, 
    				@DummyOutput output, @DummyOutput output, @DummyOutput output, @errmsg output
    			IF @rcode <> 0 GOTO bspexit
    			-- Add accum amount for this dedn code to total accum amount
    			SELECT @TotalAccumAmt = @TotalAccumAmt + @AccumAmt
    			-- get next deduction code in this deduction group
    			GOTO NEXT_DLCode
    		
    		END_DLCodes:
    			IF @OpenDLCodes = 1
				BEGIN
					CLOSE bcDLCodes
    				DEALLOCATE bcDLCodes
    				SELECT @OpenDLCodes = 0
				END
			-- add the total amount from Accums to the total amount from deduction codes in this deduction group
			SELECT @TotalAmount = @TotalAccumAmt 
			-- If the total amount of (Accums + deduction amounts) is over the limit, get the difference
			IF @TotalAmount > @DednGroupLimit 
			BEGIN
				SELECT 	@DiffAmt = @TotalAmount - @DednGroupLimit
				
				-- Get Dedn Amount from first DLCode in Deduction Group to apply DiffAmt to.
				SELECT TOP 1 @DednAmt = Amount, @PreTaxDLCode = e.DLCode, @EligibleAmt = d.EligibleAmt
				FROM dbo.bPRDT d
				JOIN #EmployeePreTaxDedns e ON e.PRCo=d.PRCo AND e.PRGroup=d.PRGroup AND e.PREndDate=d.PREndDate AND
						e.Employee=d.Employee AND e.PaySeq=d.PaySeq AND e.DLCode=d.EDLCode
				WHERE d.PRCo=@prco AND d.PRGroup=@prgroup AND d.PREndDate=@prenddate AND d.Employee=@employee AND 
					d.PaySeq=@payseq AND d.EDLType = 'D' AND e.PreTaxGroup=@PreTaxGroup AND d.EDLCode=e.DLCode
					AND PreTaxCatchUpYN = 'N' -- CHS 10/28/2011	- B-0630
				-- Calculate what to reduce the dedn amount by, dedn amount cannot go negative, any remaining amount to
				-- be reduced must be applied to the next dlcode in the deduction group
				IF @DednAmt - @DiffAmt < 0 -- dedn amt is less than the diffence between 
				BEGIN
					SELECT @AmtToUpdate = 0 -- set Dedn Amt to 0
					SELECT @EligibleAmt = 0 -- set Eligible Amt to 0
					SELECT @RemainingDiffAmt = @DiffAmt - @DednAmt -- Get remaining amount to reduce next dlcode by
				END
				ELSE
				BEGIN
					SELECT @AmtToUpdate = (@DednAmt - @DiffAmt) -- Get amount to update bPRDT
					SELECT @RemainingDiffAmt = 0
					IF @AmtToUpdate = 0
						BEGIN
						SELECT @EligibleAmt = 0
						END					
				END
				    	   				
				-- Update PRDT reduce the dedn Amt on the first dlcode in the deduction group
				UPDATE dbo.bPRDT SET Amount = @AmtToUpdate, EligibleAmt = @EligibleAmt  
				FROM dbo.bPRDT d
				JOIN #EmployeePreTaxDedns e ON e.PRCo=d.PRCo AND e.PRGroup=d.PRGroup AND e.PREndDate=d.PREndDate AND
						e.Employee=d.Employee AND e.PaySeq=d.PaySeq AND e.DLCode=d.EDLCode
				WHERE d.PRCo=@prco AND d.PRGroup=@prgroup AND d.PREndDate=@prenddate AND d.Employee=@employee AND 
					d.PaySeq=@payseq AND d.EDLType = 'D' AND e.PreTaxGroup=@PreTaxGroup AND d.EDLCode=@PreTaxDLCode
					AND PreTaxCatchUpYN = 'N' -- CHS 10/28/2011	- B-0630
					
				-- If there is a remaining amount to be applied, update the next DLCode in the Deduction Group
				IF @RemainingDiffAmt > 0 
				BEGIN
					-- Get the next Dedn Code in the Dedution Group to apply the remaining amount to
					SELECT TOP 1 @DednAmt = Amount, @PreTaxDLCode = DLCode, @EligibleAmt = d.EligibleAmt
					FROM dbo.bPRDT d
					JOIN #EmployeePreTaxDedns e ON e.PRCo=d.PRCo AND e.PRGroup=d.PRGroup AND e.PREndDate=d.PREndDate AND
							e.Employee=d.Employee AND e.PaySeq=d.PaySeq AND e.DLCode=d.EDLCode
					WHERE d.PRCo=@prco AND d.PRGroup=@prgroup AND d.PREndDate=@prenddate AND d.Employee=@employee AND 
						d.PaySeq=@payseq AND d.EDLType = 'D' AND e.PreTaxGroup=@PreTaxGroup AND d.EDLCode > @PreTaxDLCode
						AND PreTaxCatchUpYN = 'N' -- CHS 10/28/2011	- B-0630
					ORDER BY d.EDLCode 
					
	
					-- if remaining amount is greater than the dedn amt reduce it to 0
					IF @@ROWCOUNT > 0
						BEGIN
						
						IF (@DednAmt - @RemainingDiffAmt) < 0
							BEGIN
								SELECT @AmtToUpdate = 0 	
								SELECT @EligibleAmt = 0 -- set Eligible Amt to 0						
							END
						ELSE
							BEGIN
								SELECT @AmtToUpdate = @DednAmt - @RemainingDiffAmt
								IF @AmtToUpdate = 0
									BEGIN
									SELECT @EligibleAmt = 0
									END								
							END
							
						-- update PRDT with the remaining amount 
						UPDATE dbo.bPRDT SET Amount = @AmtToUpdate, EligibleAmt = @EligibleAmt 
						FROM dbo.bPRDT d
						JOIN #EmployeePreTaxDedns e ON e.PRCo=d.PRCo AND e.PRGroup=d.PRGroup AND e.PREndDate=d.PREndDate AND
								e.Employee=d.Employee AND e.PaySeq=d.PaySeq AND e.DLCode=d.EDLCode
						WHERE d.PRCo=@prco AND d.PRGroup=@prgroup AND d.PREndDate=@prenddate AND d.Employee=@employee AND 
							d.PaySeq=@payseq AND d.EDLType = 'D' AND e.PreTaxGroup=@PreTaxGroup AND d.EDLCode = @PreTaxDLCode
						END
				END -- End Remaining Amt
			END -- End Apply Limit amounts within this Deduction Group
			
			ELSE -- CHS 10/28/2011	- B-0630
			BEGIN

					-- update PRDT with zero for the catchup DL Code
					UPDATE dbo.bPRDT SET Amount = 0, EligibleAmt = 0
					FROM dbo.bPRDT d
					JOIN #EmployeePreTaxDedns e ON e.PRCo=d.PRCo AND e.PRGroup=d.PRGroup AND e.PREndDate=d.PREndDate AND
							e.Employee=d.Employee AND e.PaySeq=d.PaySeq AND e.DLCode=d.EDLCode
					WHERE d.PRCo=@prco AND d.PRGroup=@prgroup AND d.PREndDate=@prenddate AND d.Employee=@employee AND 
						d.PaySeq=@payseq AND d.EDLType = 'D' AND e.PreTaxGroup=@PreTaxGroup AND PreTaxCatchUpYN = 'Y'
						
			END

			GOTO NEXT_DednGroup
		END_DednGroup:
			IF @OpenDedGroup = 1
			BEGIN
				CLOSE bcDedGroup
    			DEALLOCATE bcDedGroup
    			SELECT @OpenDedGroup = 0
			END
		END --Apply limits from PR Deduction Groups	

		-- Update to #EmployeePreTaxDedns with the basis amt (SubjectAmt) and ded amt (Either Amount or OverAmt) from bPRDT.
		-- PRDT was updated with the deduction amounts in the cursor process above and the amount adjusted in bPRDT for limits if needed.  
		UPDATE #EmployeePreTaxDedns SET  
			BasisAmt = SubjectAmt,
			DednAmt = CASE d.UseOver WHEN 'Y' THEN d.OverAmt ELSE d.Amount END
		FROM dbo.bPRDT d
		JOIN #EmployeePreTaxDedns e ON e.PRCo=d.PRCo AND e.PRGroup=d.PRGroup AND e.PREndDate=d.PREndDate AND
				e.Employee=d.Employee AND e.PaySeq=d.PaySeq AND e.DLCode=d.EDLCode
		WHERE d.PRCo=@prco AND d.PRGroup=@prgroup AND d.PREndDate=@prenddate AND d.Employee=@employee AND 
			d.PaySeq=@payseq AND d.EDLType = 'D' 
			
	/* END PRE-TAX DEDUCTION PROCESSING */
	----------------------------------------------------------------------------------------------------------

	-- Redo calcs for Payback
	Payback_Recalculate:

	/* Calculate: Fed(US/CA/AU), State, Province, Local, Craft Accums, Craft(d/l), Insurance(d/l), Empl(d/l) */
	
		if @country in ('US','AU') --USA & Australia fed/state taxes
			begin
    		-- process Federal dedns and liabs
    		exec @rcode = bspPRProcessFed @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
            		@limitmth, @stddays, @bonus, @posttoall, @country, @fedtax output, @fedbasis output, @errmsg output
    		if @rcode <> 0 goto bspexit
    		
    		-- process Tax and Unemployment State dedns and liabs
			exec @rcode = bspPRProcessState @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
				@limitmth, @stddays, @bonus, @posttoall, @fedtax, @fedbasis, @errmsg output
    		if @rcode <> 0 goto bspexit
			end

		if @country = 'CA' --Canada fed/state taxes
			begin
    		-- process Federal dedns and liabs
    		exec @rcode = bspPRProcessFedCA @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
            		@limitmth, @stddays, @bonus, @posttoall, @fedtax output, @fedbasis output, @A output, 
					@PP output, @maxCPP output, @EI output, @maxEI output, @capstock output, @HD output, @errmsg output
    		if @rcode <> 0 goto bspexit

    		-- process Tax and Unemployment State dedns and liabs
			exec @rcode = bspPRProcessProvinceCA @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
				@limitmth, @stddays, @bonus, @posttoall, @A, @PP, @maxCPP, @EI, @maxEI, @capstock, @HD, @errmsg output
    		if @rcode <> 0 goto bspexit
			end

    	-- process Local dedns and liabs
        exec @rcode = bspPRProcessLocal @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
      		@limitmth, @stddays, @bonus, @posttoall, @fedtax, @fedbasis, @errmsg output
    	if @rcode <> 0 goto bspexit
    
        -- update posted and addon earnings to Craft report tables
        exec @rcode = bspPRProcessCraftAccums @prco, @prgroup, @prenddate, @employee, @payseq, @errmsg output
    	if @rcode <> 0 goto bspexit

        -- process Craft/Class dedns and liabs
        exec @rcode = bspPRProcessCraft @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
            @limitmth, @stddays, @bonus, @posttoall, @errmsg output
    	if @rcode <> 0 goto bspexit
        

        -- proccess Insurance dedns and liabs
        exec @rcode = bspPRProcessIns @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
            @limitmth, @stddays, @bonus, @posttoall, @errmsg output
    	if @rcode <> 0 goto bspexit


    	-- process Employee dedns and liabs
        exec @rcode = bspPRProcessEmpl @prco, @prgroup, @prenddate, @employee, @payseq, @ppds, --issue 20562
            @limitmth, @stddays, @bonus, @posttoall, @errmsg output
    	if @rcode <> 0 goto bspexit
        
	/* End: Calculate */
        
	----------------------------------------------------------------------------------------------
	/* Refresh AP info for manualy added PRDT entries -- cleared when processing begins (#17284)*/
    	declare bcDLVendor cursor for
    	select t.EDLType, t.EDLCode, l.VendorGroup, l.Vendor, l.Description
    	from dbo.bPRDT t with (nolock)
    	join dbo.bPRDL l with (nolock) on l.PRCo = t.PRCo and l.DLCode = t.EDLCode
    	where t.PRCo = @prco and t.PRGroup = @prgroup and t.PREndDate = @prenddate and t.Employee = @employee
    		and t.PaySeq = @payseq and t.EDLType in ('D','L') and t.UseOver = 'Y' and t.Vendor is null 
    		and l.AutoAP = 'Y'
   		union --issue 20559 include earnings
    	select 'E', t.EDLCode, c.VendorGroup, c.Vendor, c.Description
    	from dbo.bPRDT t with (nolock)
    	join dbo.bPREC c with (nolock) on c.PRCo = t.PRCo and c.EarnCode = t.EDLCode
    	where t.PRCo = @prco and t.PRGroup = @prgroup and t.PREndDate = @prenddate and t.Employee = @employee
    		and t.PaySeq = @payseq and t.EDLType = 'E' and t.UseOver = 'Y' and t.Vendor is null 
    		and c.AutoAP = 'Y'
    
    	open bcDLVendor
    	select @openDLVendor = 1
    
    	-- loop through Employee Pay Seq Detail to update auto AP info
    	next_DLVendor:
    		fetch next from bcDLVendor into @edltype, @edlcode, @edlvendorgroup, @edlvendor, @edldesc
    
    		if @@fetch_status = -1 goto end_DLVendor
    		if @@fetch_status <> 0 goto next_DLVendor
    
    		select @edvendorgroup = null, @edvendor = null, @apdesc = null
    
   		if @edltype <> 'E'
   			begin
   	 		-- check for Employee override 
   	 		select @edvendorgroup = VendorGroup, @edvendor = Vendor, @apdesc = APDesc
   	 		from dbo.bPRED with (nolock)
   	 		where PRCo = @prco and Employee = @employee and DLCode = @edlcode 
   			end
    	
    		-- update Employee Detail
    		update dbo.bPRDT
    		set VendorGroup = isnull(@edvendorgroup,@edlvendorgroup), Vendor = isnull(@edvendor,@edlvendor),
    			APDesc = isnull(@apdesc,@edldesc)	-- #19909 - use DL description if no Employee override
    		where PRCo = @prco and PRGroup = @prgroup and PREndDate = @prenddate and Employee = @employee
    			and PaySeq = @payseq and EDLType = @edltype and EDLCode = @edlcode
    		if @@rowcount <> 1
    			begin
    			select @errmsg = 'Unable to update auto AP info in Employee Sequence Control!', @rcode = 1
    		   	goto bspexit
    		   	end
    		goto next_DLVendor
    
    	end_DLVendor:	-- finished with auto AP updates
    		close bcDLVendor
    		deallocate bcDLVendor
    		select @openDLVendor = 0
    	
    /* End: Refresh AP info for manualy added PRDT entries */

	----------------------------------------------------------------------------------------
	/* Arrears Payback processing - with timecards */
	EXEC @rcode = vspPRProcessArrearsPayback @prco, @prgroup, @prenddate, @employee, @payseq, 
											 @PaybackRecalculate, 
											 @PaybackRecalculate OUTPUT, @errmsg OUTPUT	
	IF @rcode <> 0 GOTO bspexit
	
	IF @PaybackRecalculate = 'Y' GOTO Payback_Recalculate -- @PaybackRecalculate = 'Y'					
	-- Otherwise, Reset flag for next employee --
	SELECT @PaybackRecalculate = 'N'--, @EFTRecalculate = 'N'
    -----------------------------------------------------------------------------------------	
    					  					
	-- unlock Employee Pay Sequence
	UPDATE dbo.bPRSQ
	SET Processed = 'Y'
	WHERE PRCo = @prco 
	  AND PRGroup = @prgroup 
	  AND PREndDate = @prenddate 
	  AND Employee = @employee 
	  AND PaySeq = @payseq
	IF @@rowcount <> 1
	BEGIN
		SELECT @errmsg = 'Unable to update Employee Sequence Control ''processed'' flag!', @rcode = 1
		GOTO bspexit
	END
    
GOTO next_EmployeeSeq

end_EmployeeSeq:
CLOSE bcEmployeeSeq
DEALLOCATE bcEmployeeSeq
SELECT @openEmployeeSeq = 0
----------------------------------------------------------------------------------------------------------
/************ End EMPLOYEE-SEQUENCE: Master cursor ******************************************************/
----------------------------------------------------------------------------------------------------------
    		
	--------------------------------------------------------------------------------------------
	/*	If we removed all entries from PRSQ therefore removing pay period,					  */
	/*	make sure to clear all entries from PRArrears as well(also updates LifeToDate in PRED)*/
	--------------------------------------------------------------------------------------------
	IF NOT EXISTS (SELECT * FROM dbo.bPRSQ 
				   WHERE PRCo = @prco
					 AND PRGroup = @prgroup
					 And PREndDate = @prenddate)
	BEGIN		
		DELETE FROM dbo.vPRArrears 
		WHERE PRCo = @prco
		  AND PRGroup = @prgroup
		  And PREndDate = @prenddate
	END
     
    bspexit:
    	if @openAddon = 1
    		begin
    		close bcAddon
    		deallocate bcAddon
    		end
    	if @openEarning = 1
    		begin
    		close bcEarning
    		deallocate bcEarning
    		end
    	if @openDLVendor = 1
    		begin
    		close bcDLVendor
    		deallocate bcDLVendor
    		end
    	if @openEmployeeSeq = 1
    		begin
    		close bcEmployeeSeq
    		deallocate bcEmployeeSeq
    		end
		IF @OpenPreTaxProcessing = 1
			BEGIN
				CLOSE bcPreTaxProcessing
    			DEALLOCATE bcPreTaxProcessing
    			SELECT @OpenPreTaxProcessing = 0
			END
		IF @OpenDedGroup = 1
			BEGIN
				CLOSE bcDedGroup
    			DEALLOCATE bcDedGroup
    			SELECT @OpenDedGroup = 0
			END
		IF @OpenDLCodes = 1
				BEGIN
					CLOSE bcDLCodes
    				DEALLOCATE bcDLCodes
    				SELECT @OpenDLCodes = 0
				END
		IF @OpenCraftCalcPrep = 1
				BEGIN
					CLOSE bcCraftCalcPrep
    				DEALLOCATE bcCraftCalcPrep
    				SELECT @OpenCraftCalcPrep = 0
				END

		IF (OBJECT_ID('tempdb..#EmployeePreTaxDedns') IS NOT NULL)
		DROP TABLE #EmployeePreTaxDedns;
    
    	return @rcode
GO
PRINT N'Refreshing [dbo].[vrvPRLocalEITWithholding]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRLocalEITWithholding]'
GO
PRINT N'Refreshing [dbo].[POILAcctChangeBatch]'
GO
EXEC sp_refreshview N'[dbo].[POILAcctChangeBatch]'
GO
PRINT N'Refreshing [dbo].[PMJCProjects]'
GO
EXEC sp_refreshview N'[dbo].[PMJCProjects]'
GO
PRINT N'Refreshing [dbo].[viFact_MSSales]'
GO
EXEC sp_refreshview N'[dbo].[viFact_MSSales]'
GO
PRINT N'Refreshing [dbo].[SMStandardTaskLabor]'
GO
EXEC sp_refreshview N'[dbo].[SMStandardTaskLabor]'
GO
PRINT N'Refreshing [dbo].[brvGLFSP2]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSP2]'
GO
PRINT N'Refreshing [dbo].[vrvPROSSSchedules]'
GO
EXEC sp_refreshview N'[dbo].[vrvPROSSSchedules]'
GO
PRINT N'Refreshing [dbo].[VADDFSUsersAndGroups]'
GO
EXEC sp_refreshview N'[dbo].[VADDFSUsersAndGroups]'
GO
PRINT N'Refreshing [dbo].[viFact_PMCompliance]'
GO
EXEC sp_refreshview N'[dbo].[viFact_PMCompliance]'
GO
PRINT N'Refreshing [dbo].[SMStandardTaskMaterial]'
GO
EXEC sp_refreshview N'[dbo].[SMStandardTaskMaterial]'
GO
PRINT N'Refreshing [dbo].[APLBGrid]'
GO
EXEC sp_refreshview N'[dbo].[APLBGrid]'
GO
PRINT N'Refreshing [dbo].[brvGLFSP3]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSP3]'
GO
PRINT N'Altering [dbo].[bspPRRMInit]'
GO
/****** Object:  Stored Procedure dbo.bspPRRMInit    Script Date: 8/28/99 9:35:39 AM ******/
  
  ALTER          procedure [dbo].[bspPRRMInit]
  /***********************************************************
   * CREATED BY: GG 11/11/98
   * MODIFIED By : GG 12/21/98 - updated for 1999 tax routines
   *              EN 12/07/99 - updated for 2000 tax routines
   *              GG 12/08/99 - update bPRRM with current tax procedures, added NY Disability
   *              EN 12/27/99 - update routine name for Michigan, Vermont, and Massachusetts
   *              GG 05/02/00 - fix bPRRM update - limit to a single 'like' entry
   *              EN 5/30/00 - fixed to look up routine names in sysobjects rather than have them hardcoded and have to keep updating this bsp
   *              EN 9/13/00 - added NY Worker's Comp update
   *              EN 12/28/00 - fixed to use today's date as last update date
   *              EN 8/21/01 - issue 14405
   *              EN 9/10/01 - issue 13564 - add feature for calculating Earned Income Credit
   *				EN 4/19/02 - issue 16832 - add Philadelphia city tax to the init list
   *				EN 10/9/02 - issue 18877 change double quotes to single
   *				EN 9/15/03 - issue 21186 add Benefit based on day of week routine (bspPRDailyBen)
   *				EN 2/10/04 - issue 23613 add init code for bspPRORM??
   *				EN 8/03/04 issue 24545  add init for bspPRExemptRateOfGross
   *				EN 7/05/05 issue 29207  remove code to init NY WC routine (bspPRNYI)
   *				EN 9/5/06 issue 122062  added init for bspPRKentonKYC06
   *				EN 10/5/07 issue 119634  removed code to init Multnomah county tax
   *				EN 6/6/08 #127015  add initialization for Canadian tax routines and use HQCO_DefaultCountry to 
   *							determine which set of routines to init
   *				EN 6/17/08 #127270  add initialization for Australia PAYG tax routine
   *				EN 3/13/2009 #127888 add init for Australia ROSG, Allowance and AllowanceRDO routines
   *				EN 8/10/09 - #133605 add init for AUS Superannuation Guarantee routine
   *				EN 2/15/2010 #136039 add init for AUS RDO Accrual routine and rename ROSG routine to RateOfGros
   *										and split AllowRDO routine to AllowRDO36 and AllowRDO38
   *				EN 2/19/2010 #132653 add init for AUS AmtPerDay, OTMealAllow, OTCribAllow, and RPHwkend routines
   *				EN 3/09/2010 #136099 add init for Virgin Island tax routine
   *				CHS 10/14/2010 #139417 added Guam tax routine
   *				EN 4/18/2011 D-01575 #143739  [AUS] Added routine AllowRDO (bspPR_AU_AllowWithRDOFactor)
   *				CHS 05/12/2010 #142867 added Saipan tax routine
   *				KK/EN 06/09/2011 TK-05849 Added ROSG and AmtPerDay to CA list
   *				EN 5/22/2012 B-09715/TK-15008 Removed code to replace proc name on RateOfGros routine and removed
   *												old moldy code to replace ROG routine with RateOfGros routine because
   *												that is soooo passe
   *				EN 5/22/2012 B-09715/TK-15008 Removed code to replace proc name on Allowance routine
   *				EN 11/27/2012 D-05383/#146657 added code to init new routine 'Addl Med' (vspPRMedicareSurcharge)
   *				DAN SO 03/18/2013 - User Story 39860:Task 42416: Add AU ETP Tax routines
   *				EN 03/28/2013 Story 39859/Task 42411 - Add AU ETP tax routine for Marginal computation
   *				EN 4/5/2013 Story 44310 / Task 45407  Correct proc name used for Marginal computation
   *
   * USAGE:
   * Initializes and updates the PR Routine Master with default information
   * for all Viewpoint supplied tax routines.
   *
   *  INPUT PARAMETERS
   *   @prco - company
   *
   * OUTPUT PARAMETERS
   *   @msg      error message if error occurs
   *
   * RETURN VALUE
   *   0         success
   *   1         Failure
   *****************************************************/
  	(@prco bCompany = null, @msg varchar(60) output)
  as
  set nocount on
  
  declare @rcode int, @date bDate, @cnt int, @currentname sysname, @country varchar(2)
  
  select @rcode = 0, @date = convert(varchar,getdate(),101)	-- today's date used as last update date
  
  -- validate PR Company
  if @prco is null
  	begin
  	select @msg = 'Missing PR Company #.  Cannot initialize Routines.', @rcode = 1
  	goto bspexit
  	end
  
  if not exists(select * from dbo.bPRCO with (nolock) where PRCo = @prco)
  	begin
  	select @msg = 'Invalid PR Company #.  Cannot initialize Routines!', @rcode = 1
  	goto bspexit
  	end

  -- get country the company resides in  
  select @country = DefaultCountry from dbo.bHQCO with (nolock) where HQCo = @prco

  -- default routine set based on the country
  if @country = 'US'
  begin
	  -- Alabama State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRALT%' and name not like 'bspPRALT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRALT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRALT%'
	  if @cnt = 0	  -- add most current routine
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AL Tax', 'Alabama Income Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1     -- update with current routine if only one entry exists
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRALT%'
	  
	  -- Arkansas State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRART%' and name not like 'bspPRART9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRART%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRART%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AR Tax', 'Arkansas Income Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRART%'
	  
	  -- Arizona State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRAZT%' and name not like 'bspPRAZT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRAZT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRAZT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AZ Tax', 'Arizona Income Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRAZT%'
	  
	  -- California State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRCAT%' and name not like 'bspPRCAT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRCAT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRCAT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'CA Tax', 'California Income Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRCAT%'
	  
	  -- Colorado Occupational Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRCOO%' and name not like 'bspPRCOO9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRCOO%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRCOO%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'CO OP Tax', 'Colorado Occup Priv Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRCOO%'
	  
	  -- Colorado State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRCOT%' and name not like 'bspPRCOT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRCOT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRCOT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'CO Tax', 'Colorado Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRCOT%'
	  
	  -- Connecticut State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRCTT%' and name not like 'bspPRCTT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRCTT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRCTT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'CT Tax', 'Connecticut Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRCTT%'
	  
	  -- District of Columbia Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRDCT%' and name not like 'bspPRDCT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRDCT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRDCT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'DC Tax', 'District of Columbia Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRDCT%'
	  
	  -- Delaware State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRDET%' and name not like 'bspPRDET9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRDET%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRDET%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'DE Tax', 'Delaware Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRDET%'

	  -- Federal Income Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRFWT%[^old]' and name not like 'bspPRFWT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRFWT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRFWT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'FED Tax', 'Federal Income Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
	  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
	  where PRCo = @prco and ProcName like 'bspPRFWT%'
	  
	  -- Georgia State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRGAT%' and name not like 'bspPRGAT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRGAT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRGAT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'GA Tax', 'Georgia Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRGAT%'
	  
	  -- Hawaii State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRHIT%' and name not like 'bspPRHIT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRHIT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRHIT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'HI Tax', 'Hawaii Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date         -- most current Hawaii tax proc
		  where PRCo = @prco and ProcName like 'bspPRHIT%'
	  
	  -- Iowa State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRIAT%' and name not like 'bspPRIAT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRIAT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRIAT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'IA Tax', 'Iowa Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRIAT%'
	  
	  -- Idaho State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRIDT%' and name not like 'bspPRIDT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRIDT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRIDT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'ID Tax', 'Idaho Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRIDT%'
	  
	  -- Illinois State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRILT%' and name not like 'bspPRILT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRILT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRILT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'IL Tax', 'Illinois Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRILT%'
	  
	  -- Indiana County Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRINC%' and name not like 'bspPRINC9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRINC%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRINC%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'INCnty Tax', 'Indiana County Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRINC%'
	  
	  -- Indiana State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRINT%' and name not like 'bspPRINT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRINT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRINT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'IN Tax', 'Indiana Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRINT%'
	  
	  -- Kansas State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRKST%' and name not like 'bspPRKST9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRKST%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRKST%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'KS Tax', 'Kansas Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRKST%'
	  
	  -- Kentucky State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRKYT%' and name not like 'bspPRKYT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRKYT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRKYT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'KY Tax', 'Kentucky Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRKYT%'

	  -- Kenton County, Kentucky State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRKentonKYC%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRKentonKYC%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'KenKY Tax', 'Kenton County, Kentucky Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRKentonKYC%'
	  
	  -- Louisiana State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRLAT%' and name not like 'bspPRLAT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRLAT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRLAT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'LA Tax', 'Louisiana Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRLAT%'
	  
	  -- Massachusetts State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMAT%' and name not like 'bspPRMAT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMAT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMAT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MA Tax', 'Massachusetts Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMAT%'
	  
	  
	  -- Maryland State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMDT%' and name not like 'bspPRMDT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMDT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMDT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MD Tax', 'Maryland Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMDT%'
	  
	  -- Maine State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMET%' and name not like 'bspPRMET9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMET%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMET%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'ME Tax', 'Maine Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMET%'
	  
	  -- Michigan City Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMIC%' and name not like 'bspPRMIC9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMIC%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMIC%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MICity Tax', 'Michigan City Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMIC%'
	  
	  -- Michigan State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMIT%' and name not like 'bspPRMIT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMIT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMIT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MI Tax', 'Michigan Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMIT%'
	  
	  -- Minnesota State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMNT%' and name not like 'bspPRMNT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMNT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMNT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MN Tax', 'Minnesota Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMNT%'
	  
	  -- Missouri State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMOT%' and name not like 'bspPRMOT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMOT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMOT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MO Tax', 'Missouri Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMOT%'
	  
	  -- Mississippi State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMST%' and name not like 'bspPRMST9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMST%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMST%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MS Tax', 'Mississipi Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMST%'
	  
	  -- Montana State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRMTT%' and name not like 'bspPRMTT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMTT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMTT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MT Tax', 'Montana Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMTT%'
	  
	  -- North Carolina State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNCT%' and name not like 'bspPRNCT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNCT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNCT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NC Tax', 'North Carolina Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNCT%'
	  
	  -- North Dakota State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNDT%' and name not like 'bspPRNDT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNDT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNDT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'ND Tax', 'North Dakota Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNDT%'
	  
	  -- Nebraska State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNET%' and name not like 'bspPRNET9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNET%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNET%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NE Tax', 'Nebraska Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNET%'
	  
	  -- New Jersey State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNJT%' and name not like 'bspPRNJT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNJT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNJT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NJ Tax', 'New Jersey Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNJT%'
	  
	  -- New Mexico State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNMT%' and name not like 'bspPRNMT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNMT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNMT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NM Tax', 'New Mexico Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNMT%'
	  
	  -- New York City Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNYC%' and name not like 'bspPRNYC9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNYC%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNYC%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NYCity Tax', 'New York City Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNYC%'
	  
	  -- New York State Disability (liability)
	  select @currentname = max(name) from sysobjects where name like 'bspPRNYD%' and name not like 'bspPRNYD9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNYD%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNYD%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NYDis Tax', 'New York Disability Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNYD%'
	  
	  -- New York State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNYT%' and name not like 'bspPRNYT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNYT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNYT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NY Tax', 'New York Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNYT%'
	  
	  -- Yonkers City Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRNYY%' and name not like 'bspPRNYY9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRNYY%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNYY%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NYY Tax', 'Yonkers City Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRNYY%'
	  
	  ---- New York Worker's Compensation
	  --select @currentname = max(name) from sysobjects where name like 'bspPRNYI%'
	  --select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRNYI%'
	  --if @cnt = 0
	  --	insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
	  --	values (@prco, 'NY WC', 'New York Worker''s Compensation', @currentname, @date, 0, 0, 0, 0)
	  --if @cnt = 1
	  --    update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
	  --    where PRCo = @prco and ProcName like 'bspPRNYI%'
	  
	  -- Ohio State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPROHT%' and name not like 'bspPROHT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPROHT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPROHT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OH Tax', 'Ohio Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPROHT%'
	  
	  -- Oklahoma State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPROKT%' and name not like 'bspPROKT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPROKT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPROKT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OK Tax', 'Oklahoma Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPROKT%'
	  
	  -- Oregon State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRORT%' and name not like 'bspPRORT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRORT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRORT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OR Tax', 'Oregon Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRORT%'
	  
	  -- Ohio School District Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPROST%' and name not like 'bspPROST9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPROST%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPROST%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OHSch Tax', 'Ohio School District Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPROST%'
	  
	  -- Philadelphia City Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRPHC%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRPHC%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'PHCity Tax', 'Philadelphia City Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRPHC%'
	  
	  -- Puerto Rico Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRPRT%' and name not like 'bspPRPRT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRPRT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRPRT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'PR Tax', 'Puerto Rico Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRPRT%'
	  
	  -- Rhode Island State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRRIT%' and name not like 'bspPRRIT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRRIT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRRIT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'RI Tax', 'Rhode Island Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRRIT%'
	  
	  -- South Carolina State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRSCT%' and name not like 'bspPRSCT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRSCT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRSCT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'SC Tax', 'South Carolina Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRSCT%'
	  
	  -- Utah State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRUTT%' and name not like 'bspPRUTT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRUTT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRUTT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'UT Tax', 'Utah Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRUTT%'
	  
	  -- Virginia State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRVAT%' and name not like 'bspPRVAT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRVAT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRVAT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'VA Tax', 'Virginia Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRVAT%'
	  
	  -- Vermont State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRVTT%' and name not like 'bspPRVTT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRVTT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRVTT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'VT Tax', 'Vermont Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRVTT%'
	  
	  -- #136099 Virgin Islands Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRVIT%' and name not like 'bspPRVIT%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRVIT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRVIT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'VI Tax', 'Virgin Islands Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRVIT%'
	  
	  	  -- #139417 Guam Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRGUT%' and name not like 'bspPRGUT%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRGUT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRGUT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'GU Tax', 'Guam Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRGUT%'
		  
		-- #142867  
	  select @currentname = max(name) from sysobjects where name like 'bspPRMPT%' and name not like 'bspPRMPT%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRMPT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRMPT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MP Tax', 'Saipan Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRMPT%'		  
		  
	  -- Wisconsin State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRWIT%' and name not like 'bspPRWIT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRWIT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRWIT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'WI Tax', 'Wisconsin Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update  dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRWIT%'
	  
	  -- West Virginia State Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPRWVT%' and name not like 'bspPRWVT9%'
	  if @currentname is null select @currentname = max(name) from sysobjects where name like 'bspPRWVT%'
	  select @cnt = count(*) from  dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRWVT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'WV Tax', 'West Virginia Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPRWVT%'
	  
	  -- EIC  - issue 13564 - add feature for calculating Earned Income Credit
	  select @currentname = max(name) from sysobjects where name like 'bspPREIC%'
	  
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPREIC%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'EIC', 'Earned Income Credit', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPREIC%'

	  -- D-05383/#146657 Additional Medicare Surcharge
	  SELECT @currentname = MAX(name) FROM sysobjects WHERE name LIKE 'vspPRMedicareSurcharge%'
	  
	  IF NOT EXISTS (SELECT * FROM dbo.bPRRM WHERE PRCo = @prco AND ProcName LIKE 'vspPRMedicareSurcharge%')
	  BEGIN
		  INSERT dbo.bPRRM	(PRCo,			Routine,		[Description],	
							 ProcName,		LastUpdated,	MiscAmt1,	MiscAmt2,	MiscAmt3,	MiscAmt4)
		  VALUES			(@prco,			'Addl Med',		'Additional Medicare Surcharge',
							 @currentname,	@date,			0,			0,			0,			0)
	  END
	  ELSE
	  BEGIN
		  UPDATE dbo.bPRRM 
		  SET ProcName = @currentname, LastUpdated = @date
		  WHERE PRCo = @prco AND ProcName LIKE 'bspPRMedicareSurcharge%'
	  END
	  
  end

  if @country = 'CA' --Canada
  begin
	  -- Federal Income Tax
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_FWT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_FWT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'FED Tax', 'Federal Income Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
	  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
	  where PRCo = @prco and ProcName like 'bspPR_CA_FWT%'

	  -- Alberta
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_ABT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_ABT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AB Tax', 'Alberta Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update  dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_ABT%'

	  -- British Columbia
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_BCT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_BCT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'BC Tax', 'British Columbia Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_BCT%'

	  -- Manitoba
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_MBT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_MBT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'MB Tax', 'Manitoba Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_MBT%'

	  -- New Brunswick
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_NBT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_NBT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NB Tax', 'New Brunswick Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_NBT%'

	  -- Newfoundland and Labrador
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_NLT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_NLT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NL Tax', 'Newfoundland/Labrador Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_NLT%'

	  -- Nova Scotia
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_NST%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_NST%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NS Tax', 'Nova Scotia Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_NST%'

	  -- Northwest Territories
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_NTT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_NTT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NT Tax', 'Northwest Territories Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_NTT%'

	  -- Nunavut
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_NUT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_NUT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'NU Tax', 'Nunavut Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_NUT%'

	  -- Ontario
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_ONT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_ONT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'ON Tax', 'Ontario Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_ONT%'

	  -- Prince Edward Island
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_PET%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_PET%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'PE Tax', 'Prince Edward Island Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_PET%'

	  -- Saskatchewan
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_SKT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_SKT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'SK Tax', 'Saskatchewan Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_SKT%'

	  -- Yukon
	  select @currentname = max(name) from sysobjects where name like 'bspPR_CA_YTT%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_CA_YTT%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'YT Tax', 'Yukon Tax', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_CA_YTT%'

	  -- Canada Pension Plan
	  select @currentname = max(name) from sysobjects where name = 'bspPRCPP'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'CPP'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'CPP', 'Canada Pension Plan', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and Routine = 'CPP'
		  
	  -- Rate of Subject Gross
	  if exists (select * from dbo.bPRRM with (nolock) where PRCo=@prco and Routine = 'ROSG')
		delete from dbo.bPRRM where PRCo=@prco and Routine = 'ROSG'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'RateOfGros'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'RateOfGros', 'Earn: Rate of Subject Gross', 'bspPR_CA_ROSG', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_CA_ROSG', LastUpdated = @date
		  where PRCo = @prco and Routine = 'RateOfGros'
		  
	  -- Amount Per Day
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'AmtPerDay'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AmtPerDay', 'Earn: Amount Per Day', 'bspPR_CA_AmtPerDay', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_CA_AmtPerDay', LastUpdated = @date
		  where PRCo = @prco and Routine = 'AmtPerDay'
  end

  if @country = 'AU' --Australia
  begin
	  -- PAYG (Pay As You Go)
	  select @currentname = max(name) from sysobjects where name like 'bspPR_AU_PAYG%'
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPR_AU_PAYG%'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'PAYG Tax', 'Dedn: Pay As You Go', @currentname, @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
		  where PRCo = @prco and ProcName like 'bspPR_AU_PAYG%'

	  -- Allowance
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'Allowance'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'Allowance', 'Earn: Allowance', 'bspPR_AU_Allowance', @date, 0, 0, 0, 0)

	  -- Allowance With RDO Factor
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'AllowRDO'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AllowRDO', 'Earn: RDO factored Allowance', 'bspPR_AU_AllowWithRDOFactor', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_AllowWithRDOFactor', LastUpdated = @date
		  where PRCo = @prco and Routine = 'AllowRDO'


	  -- Allowance with RDO factor adjustment for 36 hour work week
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'AllowRDO36'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AllowRDO36', 'Earn: RDO factord 36 day allow', 'bspPR_AU_AllowRDO36', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_AllowRDO36', LastUpdated = @date
		  where PRCo = @prco and Routine = 'AllowRDO36'

	  -- Allowance with RDO factor adjustment for 38 hour work week
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'AllowRDO38'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AllowRDO38', 'Earn: RDO factord 38 day allow', 'bspPR_AU_AllowRDO38', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_AllowRDO38', LastUpdated = @date
		  where PRCo = @prco and Routine = 'AllowRDO38'

	  -- Rate of Subject Gross
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'RateOfGros'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'RateOfGros', 'Earn: Rate of Subject Gross', 'bspPR_AU_ROSG', @date, 0, 0, 0, 0)

	  -- Superannuation
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'SuperMin'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'SuperMin', 'Liab: Superannuation', 'bspPR_AU_SuperWithMin', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_SuperWithMin', LastUpdated = @date
		  where PRCo = @prco and Routine = 'SuperMin'

	  -- #136039 RDO Accrual
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'RDOAccrual'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'RDOAccrual', 'Earn: RDO Accrual', 'bspPR_AU_RDOAccrual', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_RDOAccrual', LastUpdated = @date
		  where PRCo = @prco and Routine = 'RDOAccrual'

	  -- #132653 Amount Per Day
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'AmtPerDay'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'AmtPerDay', 'Earn: Amount Per Day', 'bspPR_AU_AmtPerDay', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_AmtPerDay', LastUpdated = @date
		  where PRCo = @prco and Routine = 'AmtPerDay'

	  -- #132653 OT Meal Allowance
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'OTMeal'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OTMeal', 'Earn: Overtime Meal Allowance', 'bspPR_AU_OTMealAllow', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_OTMealAllow', LastUpdated = @date
		  where PRCo = @prco and Routine = 'OTMeal'

	  -- #132653 OT Crib Allowance
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'OTCrib'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OTCrib', 'Earn: Overtime Crib Allowance', 'bspPR_AU_OTCribAllow', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_OTCribAllow', LastUpdated = @date
		  where PRCo = @prco and Routine = 'OTCrib'
		
	  -- #132653 OT Meal/Rest/Crib Allowance
	  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'OTCribWknd'
	  if @cnt = 0
  		insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  		values (@prco, 'OTCribWknd', 'Earn: Overtime Meal/Rest/Crib', 'bspPR_AU_OTWeekendCrib', @date, 0, 0, 0, 0)
	  if @cnt = 1
		  update dbo.bPRRM set ProcName = 'bspPR_AU_OTWeekendCrib', LastUpdated = @date
		  where PRCo = @prco and Routine = 'OTCribWknd'


	  ----------------------------------------------------------
	  -- User Story 39860:Task 42416: Add AU ETP Tax routines --
	  ----------------------------------------------------------
		-- DEATH --
		SELECT @cnt = COUNT(*) FROM dbo.bPRRM WITH (NOLOCK) WHERE PRCo = @prco and Routine = 'ETPDeath'
		IF @cnt = 0
  			INSERT dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  			VALUES (@prco, 'ETPDeath', 'AU ETP Death Tax routine', 'vspPR_AU_Death', @date, 0, 0, 0, 0)
		IF @cnt = 1
		  UPDATE dbo.bPRRM set ProcName = 'vspPR_AU_Death', LastUpdated = @date
		  WHERE PRCo = @prco and Routine = 'ETPDeath'

		-- INVALIDITY --
		SELECT @cnt = COUNT(*) FROM dbo.bPRRM WITH (NOLOCK) WHERE PRCo = @prco and Routine = 'ETPInvalid'
		IF @cnt = 0
  			INSERT dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  			VALUES (@prco, 'ETPInvalid', 'AU ETP Invalidity Tax routine', 'vspPR_AU_Invalidity', @date, 0, 0, 0, 0)
		IF @cnt = 1
		  UPDATE dbo.bPRRM set ProcName = 'vspPR_AU_Invalidity', LastUpdated = @date
		  WHERE PRCo = @prco and Routine = 'ETPInvalid'

		-- REDUNDANCY --
		SELECT @cnt = COUNT(*) FROM dbo.bPRRM WITH (NOLOCK) WHERE PRCo = @prco and Routine = 'ETPRedunda'
		IF @cnt = 0
  			INSERT dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  			VALUES (@prco, 'ETPRedunda', 'AU ETP Redundancy Tax routine', 'vspPR_AU_Redundancy', @date, 0, 0, 0, 0)
		IF @cnt = 1
		  UPDATE dbo.bPRRM set ProcName = 'vspPR_AU_Redundancy', LastUpdated = @date
		  WHERE PRCo = @prco and Routine = 'ETPRedunda'

		-- STANDARD --
		SELECT @cnt = COUNT(*) FROM dbo.bPRRM WITH (NOLOCK) WHERE PRCo = @prco and Routine = 'ETPStandar'
		IF @cnt = 0
  			INSERT dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  			VALUES (@prco, 'ETPStandar', 'AU ETP Standard Tax routine', 'vspPR_AU_Standard', @date, 0, 0, 0, 0)
		IF @cnt = 1
		  UPDATE dbo.bPRRM set ProcName = 'vspPR_AU_Standard', LastUpdated = @date
		  WHERE PRCo = @prco and Routine = 'ETPStandar'

		-- UNFAIR --
		SELECT @cnt = COUNT(*) FROM dbo.bPRRM WITH (NOLOCK) WHERE PRCo = @prco and Routine = 'ETPUnfair'
		IF @cnt = 0
  			INSERT dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  			VALUES (@prco, 'ETPUnfair', 'AU ETP Unfair Tax routine', 'vspPR_AU_Unfair', @date, 0, 0, 0, 0)
		IF @cnt = 1
		  UPDATE dbo.bPRRM set ProcName = 'vspPR_AU_Unfair', LastUpdated = @date
		  WHERE PRCo = @prco and Routine = 'ETPUnfair'

		-- MARGINAL --
		SELECT @cnt = COUNT(*) FROM dbo.bPRRM WITH (NOLOCK) WHERE PRCo = @prco and Routine = 'ETPMargina'
		IF @cnt = 0
  			INSERT dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  			VALUES (@prco, 'ETPMargina', 'AU ETP Marginal Tax routine', 'vspPR_AU_Marginal_PAYG', @date, 0, 0, 0, 0)
		IF @cnt = 1
		  UPDATE dbo.bPRRM set ProcName = 'vspPR_AU_Marginal_PAYG', LastUpdated = @date
		  WHERE PRCo = @prco and Routine = 'ETPMargina'

  end
	  
  -- Exempt Rate of Gross
  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and Routine = 'ExemptROG'
  if @cnt = 0
  	insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  	values (@prco, 'ExemptROG', 'Exempt Rate Of Gross', 'bspPRExemptRateOfGross', @date, 0, 0, 0, 0)
  if @cnt = 1
      update dbo.bPRRM set Description = 'Exempt Rate Of Gross', ProcName = 'bspPRExemptRateOfGross', LastUpdated = @date
      where PRCo = @prco and Routine = 'ExemptROG'
  
  -- Benefit based on day of week
  select @currentname = max(name) from sysobjects where name like 'bspPRDailyBen%'
  select @cnt = count(*) from dbo.bPRRM with (nolock) where PRCo = @prco and ProcName like 'bspPRDailyBen%'
  if @cnt = 0
  	insert dbo.bPRRM(PRCo, Routine, Description, ProcName, LastUpdated, MiscAmt1, MiscAmt2, MiscAmt3, MiscAmt4)
  	values (@prco, 'Daily Ben', 'Benefit based on day of week', @currentname, @date, 0, 0, 0, 0)
  if @cnt = 1
      update dbo.bPRRM set ProcName = @currentname, LastUpdated = @date
      where PRCo = @prco and ProcName like 'bspPRDailyBen%'
  
  



  bspexit:
  	return @rcode

GO
PRINT N'Refreshing [dbo].[vrvPROTSchedules]'
GO
EXEC sp_refreshview N'[dbo].[vrvPROTSchedules]'
GO
PRINT N'Refreshing [dbo].[viFact_PMDocuments]'
GO
EXEC sp_refreshview N'[dbo].[viFact_PMDocuments]'
GO
PRINT N'Refreshing [dbo].[PMFM1]'
GO
EXEC sp_refreshview N'[dbo].[PMFM1]'
GO
PRINT N'Refreshing [dbo].[HRBIMAIN]'
GO
EXEC sp_refreshview N'[dbo].[HRBIMAIN]'
GO
PRINT N'Refreshing [dbo].[APLBPONotes]'
GO
EXEC sp_refreshview N'[dbo].[APLBPONotes]'
GO
PRINT N'Refreshing [dbo].[brvGLFSPart1]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSPart1]'
GO
PRINT N'Altering [dbo].[bspVAWDNotifier]'
GO
ALTER PROCEDURE [dbo].[bspVAWDNotifier]
		/***********************************************************************
		*  Created by: 	JM 08/23/02
		*
		*  Altered by: 	TV 10/29/02 - Cleanup
		*              	TV 01/17/03 issue 20408. Changed Convert(varchar(3),@InputValue) to Convert(varchar(50),@InputValue)
		*              	TV 05/17/03 20408. Checks param being passed in to see if it is numeric.
		*              	TV 10/15/03 22710. Correct insert statment
   		*				TV - 23061 added isnulls	
   		*				RT 04/27/04 - issue 24326, retrieve servername and fromaddress and pass to bspXP_SendMail.
   		*				MV 08/07/07 - #119594 - increased size of emailto,cc,bcc fields in bWDJB to 512
		*				CC 11/12/07 - #121258 - added trim to remove instance name and '\' if SMTP server not set
		*				CC 11/12/07 - #120619 - moved location of identity column definition for the select clause, remarked out the code to set @startpos
		*				CC 03/03/08 - #120840 - SProc re-write: additional error handling, loop removals, set based parameter replacements,
		*										use Viewpoint vMailQueue instead of bspXP_SendMail, unique temp table names, 
		*										allow for 1 email per result set, allow for grouping of emails to send 1 email per group of results
		*				CC 05/30/08 - #128451 - Wrapped line and footer with ISNULL for cases where no data is present.
		*				CC 06/09/08 - #127893 - Corrected issue with JobLine trimming the string correctly.
		*				CC 06/16/08 - #128689 - Corrected unclosed quote in the grouped where clause.
		*				CC 06/30/08 - #128847 - Added check for null job parameters and return an error if they exist.
		*				CC 09/30/08 - #130032 - Change WDJB update to use FirstRun and LastRun as datetime columns
		*				CC 11/03/08 - #130757 - Changed number of characters to trim because of SQL 2005 RTM error with LEN
		*				CC 01/26/09 - #131796 - Added check to verify grouping variables were populated, if not go straight to building the line query
		*				CC 01/28/09 - #129920 - Added ability to send event type notifications
		*				CC 07/01/09 - #132804 - Corrected single quote and beginning/end constant handling in consolidated emails (line query section)
		*				JV 09/01/09 - #135323 - Fixed the number of charcters to trim by using RTRIM. Related to issue #130757
		*				JV 11/24/09 - #132804 - Wrapped job email line with isnull
		*				RM 01/27/10 - #136686 - Changed the way the Seq column is added and updated.
		*				HH 10/02/12 - #TK-18072 - Fixed Parameter Value for replacement in Email Body(header)
		*				HH 10/18/12 - #TK-18459 - added support for VAInquiries
		*				DK 10/24/12 - #TK-18072 - Add support for Test Email option
		*				HH 11/12/12 - #TK-18867 - added support for RTF/HTML formatted emails
		*				HH 02/28/13 - #TK-148109- added To, CC, BCC, Subject to consolidation group validation list
		*				HH 03/01/13 - #TK-148108- removed quote handling on WDJP.InputValue
		*				HH 03/06/13 - #TK-148109- renamed Seq column 
		*				HH 04/01/13 - #TFS-45389- removed where clause in 'build rest of the column list' and introduced @WFNFGrouping table which cleans
		*										  data from WFNFGrouping if Subject is included and also Subject line contains other fields that are present 
		*										  in WFNFGrouping already --> duplicate columns in processing @tempDataTableName temp table.
		*			
		* Usage: Fires notifier email if select statement for Job finds qualifying data. 
		*
		***********************************************************************/
		@JobName VARCHAR(150), 
		@ExecuteBySQLJob TINYINT = 1,			-- 0 - Not run as a SQL Job (ie via Test Email or Send Email buttons); 1 - Run as SQL Job
		@SendToTestEmail VARCHAR(3000) = NULL
		WITH EXECUTE AS 'viewpointcs'
		
		AS  


		SET NOCOUNT ON
		DECLARE @ErrorMessage VARCHAR(MAX)
	BEGIN TRY    	        
		--get from address for email notification  
		DECLARE @FromAddress VARCHAR(255)
   		SELECT @FromAddress = ISNULL([Value], 'Notifier')
   		FROM WDSettings
   		WHERE Setting = 'FromAddress'
   	
		-- Get QueryName
		DECLARE @QueryName				VARCHAR(150) 
				,@QueryType				INT
				,@IsConsolidated		bYN 
				,@JobEmailTo			VARCHAR(3000)
				,@JobEmailCC			VARCHAR(3000) 
				,@JobEmailBCC			VARCHAR(3000) 
				,@JobEmailSubject		VARCHAR(3000) 
				,@JobEmailBody			VARCHAR(MAX)
				,@JobEmailBodyHtml		VARCHAR(MAX)
				,@JobEmailLine			VARCHAR(MAX)
				,@JobEmailFooter		VARCHAR(MAX)
				,@IsHTML				bYN


		SELECT	@QueryName				= QueryName
				,@QueryType				= QueryType
				,@IsConsolidated		= IsConsolidated
       			,@JobEmailTo			= CASE WHEN ISNULL(@SendToTestEmail,'') <> '' THEN @SendToTestEmail 
       											ELSE ISNULL(EmailTo,'')
       									  END 
				,@JobEmailCC			= CASE WHEN ISNULL(@SendToTestEmail,'') <> '' THEN ''
												ELSE ISNULL(EmailCC,'')
										  END
				,@JobEmailBCC			= CASE WHEN ISNULL(@SendToTestEmail,'') <> '' THEN ''
												ELSE ISNULL(BCC,'')
										  END 
				,@JobEmailSubject		= ISNULL(EmailSubject,'')
				,@JobEmailBody			= ISNULL(EmailBody,'')
				,@JobEmailBodyHtml		= ISNULL(EmailBodyHtml,'')
				,@JobEmailLine			= EmailLine
				,@JobEmailFooter		= EmailFooter
				,@IsHTML				= CASE	
												WHEN EmailFormat = 1 THEN 'Y'
												ELSE 'N'
											END
   		FROM [bWDJB]
		WHERE [JobName] = @JobName;

		IF (ISNULL(@QueryName,'') = '')
			RAISERROR('Invalid Query Name specified on the job', 16, 1);
		
		IF (@QueryType not in (0,1))
			RAISERROR('Invalid Query Type specified on the job', 16, 1);			

		IF (ISNULL(@JobEmailTo,'') = '' AND ISNULL(@SendToTestEmail,'') = '')
			RAISERROR('Missing recipient. Please enter email address in ''To'' field.' , 16, 1);

		-- Handling Consolidation Groups in table variable @WFNFGrouping if grouping field is in both Subject line and grouping: 
		-- remove field from grouping otherwise the processing temp table (@tempDataTableName) will have duplicate column names
		DECLARE @WFNFGrouping TABLE 
		(
			KeyID int,
			JobName varchar(150),
			GroupBy varchar(100) 
		)
		IF EXISTS (SELECT 1 FROM WFNFGrouping where JobName = @JobName and GroupBy = 'Subject') 
		BEGIN
			;WITH EmailSubjectGrouping AS
			(
				   SELECT	g.KeyID
							,g.JobName
							,g.GroupBy
							,j.EmailSubject
							,CASE
									WHEN j.EmailSubject like '%\[' + REPLACE(REPLACE(g.GroupBy, '[', ''), ']', '') + '\]%' ESCAPE '\' AND g.GroupBy <> 'Subject' THEN 'Y'
									ELSE 'N'
							END AS GroupInSubjectLine
				   FROM WFNFGrouping g
				   INNER JOIN WDJob j on g.JobName = j.JobName
				   WHERE g.JobName = @JobName
			)
			INSERT INTO @WFNFGrouping (KeyID, JobName, GroupBy)
			SELECT cte.KeyID, cte.JobName, cte.GroupBy
			FROM EmailSubjectGrouping cte
			WHERE cte.GroupInSubjectLine = 'N'
		END
		ELSE
		BEGIN
			INSERT INTO @WFNFGrouping (KeyID, JobName, GroupBy)
			SELECT KeyID, JobName, GroupBy
			FROM WFNFGrouping
			WHERE JobName = @JobName
		END

		-- Parsing parts for RTF/HTML formatted emails
		IF @IsHTML = 'Y'
		BEGIN
			DECLARE @TableHtml varchar(max)
			DECLARE @TableStart int
			DECLARE @TableEnd int

			DECLARE @HeaderHtml varchar(max)
			DECLARE @HeaderStart int
			DECLARE @HeaderEnd int

			DECLARE @DetailHtml varchar(max)
			DECLARE @DetailStart int
			DECLARE @DetailEnd int
			
			DECLARE @FrontPart varchar(max)
			DECLARE @FrontStart int
			DECLARE @FrontEnd int

			DECLARE @BackPart varchar(max)
			DECLARE @BackStart int
			DECLARE @BackEnd int

			SELECT @TableStart = PATINDEX ( '%<table%' , @JobEmailBodyHtml )
			SELECT @TableEnd = PATINDEX ( '%</table>%' , @JobEmailBodyHtml ) + len('</table>')
			SELECT @TableHtml = SUBSTRING ( @JobEmailBodyHtml ,@TableStart , @TableEnd - @TableStart )

			IF (SELECT HeaderIsVisible FROM WDJBTableLayout WHERE JobName = @JobName ) = 'Y'
			BEGIN
				SELECT @HeaderStart = PATINDEX ( '%<tr%' , @TableHtml )
				SELECT @HeaderEnd = PATINDEX ( '%</tr>%' , @TableHtml ) + len('</tr>')
				SELECT @HeaderHtml = SUBSTRING ( @TableHtml ,@HeaderStart , @HeaderEnd - @HeaderStart )

				SELECT @DetailHtml = SUBSTRING ( @TableHtml ,@HeaderEnd, len(@TableHtml) )
				SELECT @DetailStart = PATINDEX ( '%<tr%' , @DetailHtml )
				SELECT @DetailEnd = PATINDEX ( '%</tr>%' , @DetailHtml ) + len('</tr>')
				SELECT @DetailHtml = SUBSTRING ( @DetailHtml ,@DetailStart , @DetailEnd - @DetailStart )
			END
			ELSE
			BEGIN
				SELECT @DetailHtml = @TableHtml
				SELECT @DetailStart = PATINDEX ( '%<tr%' , @TableHtml )
				SELECT @DetailEnd = PATINDEX ( '%</tr>%' , @TableHtml ) + len('</tr>')
				SELECT @DetailHtml = SUBSTRING ( @DetailHtml ,@DetailStart , @DetailEnd - @DetailStart )
			END
			
		
			IF (SELECT HeaderIsVisible FROM WDJBTableLayout WHERE JobName = @JobName ) = 'Y'
			-- with header row
			BEGIN
				SELECT @FrontStart = 0
				SELECT @FrontEnd = PATINDEX ( '%</tr>%' , @JobEmailBodyHtml ) + len('</tr>')
				SELECT @FrontPart = SUBSTRING(@JobEmailBodyHtml, @FrontStart, @FrontEnd)
			END
			ELSE 
			-- without header row
			BEGIN
				SELECT @FrontStart = 0
				SELECT @FrontEnd = PATINDEX ( '%<tr>%' , @JobEmailBodyHtml )
				SELECT @FrontPart = SUBSTRING(@JobEmailBodyHtml, @FrontStart, @FrontEnd)
			END

			SELECT @BackStart = PATINDEX('%</table>%', @JobEmailBodyHtml)
			SELECT @BackEnd = len(@JobEmailBodyHtml)
			SELECT @BackPart = SUBSTRING(@JobEmailBodyHtml, @BackStart, @BackEnd)

			IF @IsConsolidated = 'Y'
			BEGIN
				SET @JobEmailBody = @FrontPart
				SET @JobEmailLine = @DetailHtml
				SET @JobEmailFooter	= @BackPart
			END
			ELSE
			BEGIN
				SET @JobEmailBody = @JobEmailBodyHtml
			END

		END
		-- End Parsing parts for RTF/HTML formatted emails

		-- Get Query text 
		DECLARE		@SelectClause			NVARCHAR(MAX)
					,@FromWhereClause		NVARCHAR(MAX)
					,@IsQueryEventBased		bYN

		-- WF Notifier Queries		
		IF @QueryType = 0
		BEGIN	
			SELECT	@SelectClause = ISNULL(SelectClause,'') 
					,@FromWhereClause = ISNULL(FromWhereClause,'')
					,@IsQueryEventBased = IsEventQuery
			FROM [bWDQY]
			WHERE [QueryName] = @QueryName;
		

			IF ISNULL(@IsQueryEventBased,'N') = 'Y'
				IF NOT EXISTS (SELECT TOP 1 1 FROM WDQF WHERE QueryName = @QueryName AND IsKeyField = 'Y')
					SET @IsQueryEventBased = 'N'

			IF @SelectClause = ''
			BEGIN
				SET @ErrorMessage = 'Blank ''Select Clause'' found in the query '''  + @QueryName + '''.';
				RAISERROR(@ErrorMessage, 16, 1);
			END

			IF @FromWhereClause = ''
			BEGIN
				SET @ErrorMessage = 'Blank ''FromWhere clause'' found in the query '''  + @QueryName + '''.';
				RAISERROR(@ErrorMessage, 16, 1);
			END
	       
			IF EXISTS (SELECT TOP 1 1 FROM WDJP WHERE JobName = @JobName AND InputValue IS NULL)
			BEGIN
				SET @ErrorMessage = 'Missing values in parameters for job '''  + @JobName + '''.  Please assign values to job parameters.';
				RAISERROR(@ErrorMessage, 16, 1);
			END

			-- Embed Identity column in Select Clause if not event based
			--IF @IsQueryEventBased = 'N'
			--SELECT @SelectClause = @SelectClause + ' ,IDENTITY (int, 1, 1) AS Seq '

			-- Replace params in @FromWhereClause with Input Values from WDJP 
			-- need to order by [Param] Desc (longest string) since sql replace is NOT whole word
			--SELECT @FromWhereClause = REPLACE(@FromWhereClause, [Param], QUOTENAME(REPLACE(InputValue,'''',''),'''')) FROM WDJP WHERE JobName = @JobName ORDER BY [Param] Desc
			SELECT @FromWhereClause = REPLACE(@FromWhereClause, [Param], InputValue) FROM WDJP WHERE JobName = @JobName ORDER BY [Param] Desc
		END	
		-- VA Inquiries
		ELSE
		BEGIN 
			SELECT	@SelectClause = ISNULL(Query,'') 
					,@FromWhereClause = ''
					,@IsQueryEventBased = (SELECT MAX(IsNotifierKeyField) FROM VPGridColumns WHERE QueryName = @QueryName)
			FROM VPGridQueries
			WHERE [QueryName] = @QueryName;
		
			IF ISNULL(@IsQueryEventBased,'N') = 'Y'
				IF NOT EXISTS (SELECT TOP 1 1 FROM VPGridColumns WHERE QueryName = @QueryName AND IsNotifierKeyField = 'Y')
					SET @IsQueryEventBased = 'N'

			IF @SelectClause = ''
			BEGIN
				SET @ErrorMessage = 'Blank ''Select Clause'' found in the query '''  + @QueryName + '''.';
				RAISERROR(@ErrorMessage, 16, 1);
			END

			IF EXISTS (SELECT TOP 1 1 FROM WDJP WHERE JobName = @JobName AND InputValue IS NULL)
			BEGIN
				SET @ErrorMessage = 'Missing values in parameters for job '''  + @JobName + '''.  Please assign values to job parameters.';
				RAISERROR(@ErrorMessage, 16, 1);
			END

			-- Embed Identity column in Select Clause if not event based
			--IF @IsQueryEventBased = 'N'
			--SELECT @SelectClause = @SelectClause + ' ,IDENTITY (int, 1, 1) AS Seq '

			DECLARE @VAInquiryQueryType INT;
			SELECT @VAInquiryQueryType = QueryType 
			FROM VPGridQueries 
			WHERE QueryName = @QueryName;
			
			-- create and stuff select statement for VA Inquiry type 'view'
			IF @VAInquiryQueryType = 1
			BEGIN
				SELECT @SelectClause =
					'SELECT' + STUFF
					(
						(
							SELECT ', ' + '['+ColumnName+']'
							FROM VPGridColumns C
							WHERE C.QueryName = Q.QueryName
							ORDER BY DefaultOrder
							FOR XML PATH('')
						), 1, 1, ''
					) 
					+ ' FROM '
					+ Q.Query 
					+ ISNULL(' WHERE ' + STUFF
					(
						(
							SELECT ' ' + ISNULL('['+P.ColumnName+']','') + ' ' + ISNULL(P.Comparison,'') + ' ' + ISNULL(P.ParameterName,'') + ' ' + ISNULL(P.Operator,'')
							FROM VPGridQueryParameters P
							WHERE P.QueryName = Q.QueryName
							ORDER BY P.Seq
							FOR XML PATH(''), ROOT('Query'), TYPE 
						).value('/Query[1]','VARCHAR(MAX)'), 1, 1, ''
					), '')
				FROM	VPGridQueries Q
				WHERE	QueryName = @QueryName;

				--Remove last and/or
				IF EXISTS(SELECT 1 FROM VPGridQueryParameters WHERE QueryName = @QueryName )
					SET @SelectClause = CASE WHEN (RIGHT(@SelectClause,3) IN ('AND', ' OR'))THEN LEFT(@SelectClause, LEN(@SelectClause)-3) END;

			END 
		
			-- Replace params in @SelectClause with Input Values from WDJP
			-- need to order by [Param] Desc (longest string) since sql replace is NOT whole word
			--SELECT @SelectClause = REPLACE(@SelectClause, [Param], QUOTENAME(REPLACE(InputValue,'''',''),'''')) FROM WDJP WHERE JobName = @JobName ORDER BY [Param] Desc
			SELECT @SelectClause = REPLACE(@SelectClause, [Param], InputValue) FROM WDJP WHERE JobName = @JobName ORDER BY [Param] Desc
		END


		-- create temp. @tempDataTableName table ---------------------
		DECLARE @tempDataTableName VARCHAR(40), @sql NVARCHAR(MAX);
		SET @tempDataTableName = 'tmp-' + CONVERT(VARCHAR(36),NEWID());

		IF @QueryType = 0
		BEGIN
			SET @sql = @SelectClause + ' INTO [' + @tempDataTableName + '] ' + @FromWhereClause;
			EXEC sp_executesql @sql;
		END
		ELSE IF @QueryType = 1
		BEGIN
			DECLARE @CreateTmpTable varchar(max)
			SET @CreateTmpTable = 
					'CREATE TABLE '+ '['+@tempDataTableName+']' +' (' + STUFF
					(
						(
							SELECT ', ' + '['+ColumnName+']' + ' VARCHAR(MAX)'
							FROM VPGridColumns C
							WHERE QueryName = @QueryName
							ORDER BY DefaultOrder
							FOR XML PATH('')
						), 1, 1, ''
					) + ' ) ' 
	
			SET @sql = @CreateTmpTable + ' INSERT INTO ' + '['+@tempDataTableName+']' +' EXEC sp_executesql N' + ''''+REPLACE(@SelectClause, '''', '''''')+''''
			EXEC sp_executesql @sql;
		END

		--------
		IF (@@error <> 0)
			RAISERROR('Cannot create temporary data table. Please check your query and its parameters.', 16, 1);


		-- If query is event based add hash column to table, purge old results
		IF @IsQueryEventBased = 'Y'
		BEGIN
			--Get hash columns
			DECLARE @HashKeyColumns		VARCHAR(MAX);
			SET @HashKeyColumns = 'CAST(HASHBYTES(N''MD5'', CONVERT(NVARCHAR(MAX), ';
			
			-- WF Notifier Query
			IF @QueryType = 0
			BEGIN 
				SELECT @HashKeyColumns = @HashKeyColumns + 'ISNULL(' + EMailField + ', '''')) + CONVERT(NVARCHAR(MAX), '
				FROM bWDQF
				WHERE	QueryName = @QueryName
						AND IsKeyField = 'Y';
			END
			-- VA Inquiry
			ELSE IF @QueryType = 1
			BEGIN 
				SELECT @HashKeyColumns = @HashKeyColumns + 'ISNULL(' + '[' + ColumnName + ']' + ', '''')) + CONVERT(NVARCHAR(MAX), '
				FROM VPGridColumns
				WHERE	QueryName = @QueryName
						AND IsNotifierKeyField = 'Y';
			END
			
			SELECT @HashKeyColumns = LEFT(@HashKeyColumns, LEN(@HashKeyColumns) - 25) + ') AS UNIQUEIDENTIFIER)';
					
			--Add hash column to temp table
			SET @sql = 'ALTER TABLE [' + @tempDataTableName + '] ADD KeyHash UNIQUEIDENTIFIER NULL;'					
			EXEC sp_executesql @sql
			
			--Populate hash column
			SET @sql = 'UPDATE [' + @tempDataTableName + '] SET KeyHash = ' + @HashKeyColumns + ';'			
			EXEC sp_executesql @sql
			
			--Purge old results
			SET @sql = 'DELETE vWFSentNotifications
			FROM vWFSentNotifications s
			LEFT OUTER JOIN [' + @tempDataTableName + '] t ON s.KeyHash = t.KeyHash
			WHERE t.KeyHash IS NULL AND s.JobName = ''' + @JobName + ''''						
			EXEC sp_executesql @sql
			
			--Delete any previously sent items from the temp table
			SET @sql = 'DELETE [' + @tempDataTableName + '] 
			FROM [' + @tempDataTableName + '] t
			INNER JOIN vWFSentNotifications s ON t.KeyHash = s.KeyHash
			WHERE s.JobName = ''' + @JobName + ''''						
			EXEC sp_executesql @sql
			
		END

		--Add sequence column to temp table
		SET @sql = 'ALTER TABLE [' + @tempDataTableName + '] ADD SeqForTmpTable int null;'
		EXEC sp_executesql @sql

		--Add sequence column to temp table
		SET @sql = 'WITH t AS (select SeqForTmpTable, ROW_NUMBER() OVER(Order By SeqForTmpTable) RowNum FROM [' + @tempDataTableName + ']) UPDATE t SET SeqForTmpTable=RowNum;'
		EXEC sp_executesql @sql
	

		--extract number of records in @tempDataTableName
		DECLARE @NumRows int
		SET @sql = 'SELECT @NumRows = ISNULL(MAX(SeqForTmpTable),0) FROM [' + @tempDataTableName + ']'
		EXEC sp_executesql @sql, N'@NumRows int OUTPUT', @NumRows = @NumRows OUTPUT;
		IF (@@error <> 0)
			RAISERROR('Cannot retrieve number of rows from temporary data table. Please check your query and its parameters.', 16, 1);

		-- Leave if no data in result set
		IF @NumRows = 0 
			GOTO Notifier_Exit
				
		--declare and initialize variables for pivot table     
		DECLARE @ColumnList					NVARCHAR(MAX), 
				@EmailFields				NVARCHAR(MAX), 
				@CTE						NVARCHAR(MAX)

		SELECT @ColumnList = '', @EmailFields = '', @CTE = ''

		-- WF Notifier Query
		IF @QueryType = 0
		BEGIN
			--build column and field list
			SELECT @ColumnList = @ColumnList + 'ISNULL(CAST(' + TableColumn + ' AS VARCHAR(MAX)),'''') AS ' + EMailField + ', ',
			@EmailFields = @EmailFields + EMailField + ', '
			FROM bWDQF WHERE QueryName = @QueryName
		END
		-- VA Inquiry
		ELSE IF @QueryType =1
		BEGIN
			--build column and field list
			SELECT @ColumnList = @ColumnList + 'ISNULL(CAST(' + '['+ColumnName+']' + ' AS VARCHAR(MAX)),'''') AS ' + '['+ColumnName+']' + ', ',
			@EmailFields = @EmailFields + '['+ColumnName+']' + ', '
			FROM VPGridColumns WHERE QueryName = @QueryName
		END
		
		-- #135323 - changed #130757 hack to using RTRIM to remove spaces instead of calculating with the spaces.

		--trim trailing comma
		SET @ColumnList = LEFT(@ColumnList, LEN(RTRIM(@ColumnList)) - 1)
		SET @EmailFields = LEFT(@EmailFields, LEN(RTRIM(@EmailFields)) - 1)

		--Create holding pivot table
		CREATE TABLE #ReplaceVal (col VARCHAR(MAX), val VARCHAR(MAX))

		--build pivot statment
		SET @CTE = 'WITH CTE AS ( SELECT ' + @ColumnList + ' FROM [' + @tempDataTableName + '] WHERE SeqForTmpTable = @RowNum  ) INSERT INTO #ReplaceVal SELECT col, val FROM CTE UNPIVOT(val FOR col IN(' + @EmailFields + ')) AS U'
		
		SET @sql = 'SELECT @CurrentRecord = KeyHash FROM [' + @tempDataTableName + '] WHERE SeqForTmpTable = @RowNum'
								
        IF @IsConsolidated = 'N'
		BEGIN
			--email variables	
			DECLARE @EmailTo VARCHAR(3000), @EmailCC VARCHAR(3000), @EmailBCC VARCHAR(3000), @EmailSubject VARCHAR(3000), @EmailBody VARCHAR(MAX)
		
			--counter variable
			DECLARE	 @RowNum int
					,@CurrentRecord UNIQUEIDENTIFIER
					
					
			SET @RowNum = 1
			WHILE @RowNum <= @NumRows
       		BEGIN
       			--Get email template for this iteration
				SELECT	@EmailTo = @JobEmailTo, 
						@EmailCC = @JobEmailCC, 
						@EmailBCC = @JobEmailBCC,
						@EmailSubject = @JobEmailSubject,
						@EmailBody = @JobEmailBody
							
       			-- Make sure #ReplaceVal is empty (truncate for minimal logging)
       			TRUNCATE TABLE #ReplaceVal
	
				--use sp_executesql to execute pivot for the current row
				EXEC sp_executesql @CTE, N'@RowNum int', @RowNum

            	-- Replace [field name] with its value in all email parameters: To, CC, BCC, Subject, Body
				SELECT @EmailTo = REPLACE(@EmailTo, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @EmailCC = REPLACE(@EmailCC, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @EmailBCC = REPLACE(@EmailBCC, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @EmailSubject = REPLACE(@EmailSubject, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @EmailBody = REPLACE(@EmailBody,  '[' + col + ']', val) FROM #ReplaceVal;
       
    	   		-- Send email 
        	   IF ISNULL(@EmailTo, '') <> ''
        			BEGIN
						IF @IsQueryEventBased = 'N'
							EXEC [dbo].[vspMailQueueInsert] @To = @EmailTo, @CC = @EmailCC, @BCC = @EmailBCC, @From = @FromAddress, @Subject = @EmailSubject, @Body = @EmailBody, @Source = N'Notifier', @IsHTML = @IsHTML						
						ELSE --Query is Event based
							BEGIN
								EXEC sp_executesql @sql, N'@RowNum int, @CurrentRecord UNIQUEIDENTIFIER OUTPUT', @RowNum = @RowNum, @CurrentRecord = @CurrentRecord OUTPUT;

								EXEC [dbo].[vspMailQueueInsert] @To = @EmailTo, @CC = @EmailCC, @BCC = @EmailBCC, @From = @FromAddress, @Subject = @EmailSubject, @Body = @EmailBody, @Source = N'Notifier', @IsHTML = @IsHTML						
								
								INSERT INTO vWFSentNotifications (KeyHash, JobName) 
									VALUES (@CurrentRecord, @JobName)
							END
					END
				-- Set RowNum
	       		SELECT @RowNum = @RowNum + 1
    	   	END 
		END -- End IsConsolidated = 'N'
		ELSE
		BEGIN
			DECLARE @GroupColumnList NVARCHAR(MAX), @GroupEmailFields NVARCHAR(MAX), 
					@tempGroupTableName NVARCHAR(40), @NumGroupRows int, @GroupWhere NVARCHAR(MAX),
					@WithBrackets NVARCHAR(MAX), @WithoutBrackets NVARCHAR(MAX);
			IF EXISTS(SELECT * FROM @WFNFGrouping WHERE JobName = @JobName)
			BEGIN
			-----------------------------------Build Groups---------------------------------------------------
			--build grouping query
				--check if To, CC, BCC, Subject are in column list and if so check if they have [ in them
					--if [ exists in a given element add it to the column list
				SELECT @GroupColumnList = '', @GroupEmailFields = '', @WithBrackets = '', @WithoutBrackets = '', @GroupWhere = ''
				IF EXISTS (SELECT * FROM @WFNFGrouping WHERE GroupBy = 'To' AND JobName = @JobName)
		   			WHILE CHARINDEX('[', @JobEmailTo) <> 0
					BEGIN

						SELECT @WithBrackets = SUBSTRING(@JobEmailTo, CHARINDEX('[', @JobEmailTo), CHARINDEX(']', @JobEmailTo) - CHARINDEX('[', @JobEmailTo)+1),
							   @WithoutBrackets = SUBSTRING(@JobEmailTo, CHARINDEX('[', @JobEmailTo)+1, CHARINDEX(']', @JobEmailTo)-(CHARINDEX('[', @JobEmailTo)+1))

						SELECT @GroupColumnList = @GroupColumnList + 'ISNULL(CAST(' + @WithBrackets + ' AS VARCHAR(MAX)),'''') AS ' + @WithBrackets + ', ',
							   @GroupEmailFields = @GroupEmailFields + @WithBrackets + ', ',
							   @GroupWhere = @GroupWhere + @WithoutBrackets + ' = ''' + @WithBrackets + ''' AND '

						SELECT @JobEmailTo = REPLACE(@JobEmailTo, @WithBrackets, '')
					END

				IF EXISTS (SELECT * FROM @WFNFGrouping WHERE GroupBy = 'CC' AND JobName = @JobName)
			   		WHILE CHARINDEX('[', @JobEmailCC) <> 0
					BEGIN

						SELECT @WithBrackets = SUBSTRING(@JobEmailCC, CHARINDEX('[', @JobEmailCC), CHARINDEX(']', @JobEmailCC) - CHARINDEX('[', @JobEmailCC)+1),
							   @WithoutBrackets = SUBSTRING(@JobEmailCC, CHARINDEX('[', @JobEmailCC)+1, CHARINDEX(']', @JobEmailCC)-(CHARINDEX('[', @JobEmailCC)+1))

						SELECT @GroupColumnList = @GroupColumnList + 'ISNULL(CAST(' + @WithBrackets + ' AS VARCHAR(MAX)),'''') AS ' + @WithBrackets + ', ',
							   @GroupEmailFields = @GroupEmailFields + @WithBrackets + ', ',
							   @GroupWhere = @GroupWhere + @WithoutBrackets + ' = ''' + @WithBrackets + ''' AND '

						SELECT @JobEmailCC = REPLACE(@JobEmailCC, @WithBrackets, '')
					END

				IF EXISTS (SELECT * FROM @WFNFGrouping WHERE GroupBy = 'BCC' AND JobName = @JobName)
			   		WHILE CHARINDEX('[', @JobEmailBCC) <> 0
					BEGIN

						SELECT @WithBrackets = SUBSTRING(@JobEmailBCC, CHARINDEX('[', @JobEmailBCC), CHARINDEX(']', @JobEmailBCC) - CHARINDEX('[', @JobEmailBCC)+1),
							   @WithoutBrackets = SUBSTRING(@JobEmailBCC, CHARINDEX('[', @JobEmailBCC)+1, CHARINDEX(']', @JobEmailBCC)-(CHARINDEX('[', @JobEmailBCC)+1))

						SELECT @GroupColumnList = @GroupColumnList + 'ISNULL(CAST(' + @WithBrackets + ' AS VARCHAR(MAX)),'''') AS ' + @WithBrackets + ', ',
							   @GroupEmailFields = @GroupEmailFields + @WithBrackets + ', ',
							   @GroupWhere = @GroupWhere + @WithoutBrackets + ' = ''' + @WithBrackets + ''' AND '

						SELECT @JobEmailBCC = REPLACE(@JobEmailBCC, @WithBrackets, '')
					END

				IF EXISTS (SELECT * FROM @WFNFGrouping WHERE GroupBy = 'Subject' AND JobName = @JobName)
			   		WHILE CHARINDEX('[', @JobEmailSubject) <> 0
					BEGIN
						SELECT @WithBrackets = SUBSTRING(@JobEmailSubject, CHARINDEX('[', @JobEmailSubject), CHARINDEX(']', @JobEmailSubject) - CHARINDEX('[', @JobEmailSubject)+1),
							   @WithoutBrackets = SUBSTRING(@JobEmailSubject, CHARINDEX('[', @JobEmailSubject)+1, CHARINDEX(']', @JobEmailSubject)-(CHARINDEX('[', @JobEmailSubject)+1))

						SELECT @GroupColumnList = @GroupColumnList + 'ISNULL(CAST(' + @WithBrackets + ' AS VARCHAR(MAX)),'''') AS ' + @WithBrackets + ', ',
							   @GroupEmailFields = @GroupEmailFields + @WithBrackets + ', ',
							   @GroupWhere = @GroupWhere + @WithoutBrackets + ' = ''' + @WithBrackets + ''' AND '

						SELECT @JobEmailSubject = REPLACE(@JobEmailSubject, @WithBrackets, '')
					END	
		
				--check if consolidation grouping is valid
				DECLARE @InvalidGrouping VARCHAR(MAX)
				SELECT @InvalidGrouping = 'Invalid Consolidation Grouping. Please remove: '
				-- WF Query
				IF(@QueryType = 0)
				BEGIN
					SELECT @InvalidGrouping = COALESCE(@InvalidGrouping+ CHAR(13) + CHAR(10) ,'') + GroupBy 
					FROM @WFNFGrouping 
					WHERE JobName = @JobName AND GroupBy NOT IN(	SELECT EMailField 
																	FROM WDQF 
																	WHERE QueryName = @QueryName)
					
					IF	EXISTS(SELECT 1 FROM @WFNFGrouping WHERE JobName = @JobName
															AND GroupBy NOT IN(	SELECT EMailField 
																				FROM WDQF 
																				WHERE QueryName = @QueryName 
																				UNION ALL 
																				SELECT 'To'
																				UNION ALL
																				SELECT 'CC'
																				UNION ALL
																				SELECT 'BCC'
																				UNION ALL
																				SELECT 'Subject' ))
						RAISERROR(@InvalidGrouping, 16, 1)
				END
				-- VA Inquiry
				ELSE
				BEGIN
					SELECT @InvalidGrouping = COALESCE(@InvalidGrouping+ CHAR(13) + CHAR(10) ,'') + GroupBy 
					FROM @WFNFGrouping 
					WHERE JobName = @JobName AND GroupBy NOT IN(	SELECT QuoteName(ColumnName) 
																	FROM VPGridColumns 
																	WHERE QueryName = @QueryName)
									
					IF	EXISTS(SELECT 1 FROM @WFNFGrouping WHERE JobName = @JobName
															AND GroupBy NOT IN(	SELECT QuoteName(ColumnName) 
																				FROM VPGridColumns 
																				WHERE QueryName = @QueryName
																				UNION ALL 
																				SELECT 'To'
																				UNION ALL
																				SELECT 'CC'
																				UNION ALL
																				SELECT 'BCC'
																				UNION ALL
																				SELECT 'Subject' ))
						RAISERROR(@InvalidGrouping, 16, 1)
				END

				--build rest of the column list
				SELECT @GroupColumnList = @GroupColumnList + 'ISNULL(CAST(' + GroupBy + ' AS VARCHAR(MAX)),'''') AS ' + GroupBy + ', ',
					   @GroupEmailFields = @GroupEmailFields + GroupBy + ', ',
					   @GroupWhere = @GroupWhere + SUBSTRING(GroupBy, CHARINDEX('[', GroupBy)+1, CHARINDEX(']', GroupBy)-(CHARINDEX('[', GroupBy)+1)) + ' = ''' + SUBSTRING(GroupBy, CHARINDEX('[', GroupBy), CHARINDEX(']', GroupBy)) + ''' AND '
				FROM @WFNFGrouping WHERE GroupBy NOT IN ('To', 'CC', 'BCC', 'Subject') AND JobName = @JobName

				--(131796) If the column list, email fields, or where clause were not populated
				--exit the rest of this block
				IF LEN(@GroupColumnList) < 6 OR LEN(@GroupEmailFields) < 1 OR LEN(@GroupWhere) < 1
					GOTO Build_Line_Query

				--trim trailing comma
				SET @GroupColumnList = LEFT(@GroupColumnList, LEN(RTRIM(@GroupColumnList)) - 1)
				SET @GroupEmailFields = LEFT(@GroupEmailFields, LEN(RTRIM(@GroupEmailFields)) - 1)
				
				--trim trailing AND from the where replacement
				SET @GroupWhere = LEFT(@GroupWhere, LEN(@GroupWhere) - 4)
				
				--generate new group temp table name
				SET @tempGroupTableName = 'tmp-' + CONVERT(VARCHAR(36),NEWID());
			
				--final query looks like: select distinct (column list) into [newtemptable] from [temptable]
				SET @sql = 'SELECT DISTINCT ' + @GroupColumnList + ' INTO ' + QUOTENAME(@tempGroupTableName) + ' FROM ' + QUOTENAME(@tempDataTableName);


				EXEC (@sql);
				IF (@@error <> 0)
					RAISERROR('Cannot create temporary group table. Please check your query and its parameters.', 16, 1);

				SET @sql = 'ALTER TABLE [' + @tempGroupTableName + '] ADD [SeqForTmpTable] int NOT NULL IDENTITY(1,1)';
				EXEC (@sql);

				--extract number of records in @tempGroupTableName
				SET @sql = 'SELECT @NumGroupRows = ISNULL(MAX(SeqForTmpTable),0) FROM ' + QUOTENAME(@tempGroupTableName) 
				EXEC sp_executesql @sql, N'@NumGroupRows int OUTPUT', @NumGroupRows = @NumGroupRows OUTPUT;
				IF (@@error <> 0)
					RAISERROR('Cannot retrieve row number from temporary group table. Please check your query and its parameters.', 16, 1);

				-- Leave if no data in result set (nothing to group by)
				IF @NumGroupRows = 0 
					RAISERROR('No records in temp group table, nothing to group by. Please check your query and its parameters.', 16, 1);
			END

			--------------------------------------------------------------------------------------------------------------------------					
Build_Line_Query:
			----------------------------build line query-----------------------------------
			DECLARE @LineQuery NVARCHAR(MAX)
			IF @JobEmailLine IS NOT NULL AND RTRIM(LTRIM(@JobEmailLine)) <> ''
			BEGIN
			SELECT @JobEmailLine = REPLACE(@JobEmailLine, '''', '''''');

					IF CHARINDEX('[', @JobEmailLine) <> 0 AND CHARINDEX(']', @JobEmailLine) <> 0
					BEGIN
						DECLARE	  @FirstPartOfJobLine	VARCHAR(MAX)
								, @LastPartOfJobLine	VARCHAR(MAX);

								  --for the first part, take everything up to the first '[', not including the '['
						SELECT	  @FirstPartOfJobLine = SUBSTRING(@JobEmailLine, 1, CHARINDEX('[', @JobEmailLine) - 1)
								  --for the last part, take everything from the last ']' to the end, not including the ']'
								, @LastPartOfJobLine = REVERSE(LEFT(REVERSE(@JobEmailLine), CHARINDEX(']',REVERSE(@JobEmailLine))-1))
								;

						--update the line to have everything from the first '[' to the end
						SET @JobEmailLine = SUBSTRING(@JobEmailLine, CHARINDEX('[', @JobEmailLine), LEN(@JobEmailLine));

						--update the line to have everything from the last ']' to the begining
						SET @JobEmailLine = REVERSE(SUBSTRING(REVERSE(@JobEmailLine), CHARINDEX(']',REVERSE(@JobEmailLine)), LEN(@JobEmailLine)));

						-- WF Notifier Query
						IF @QueryType = 0
						BEGIN
							SELECT @JobEmailLine = REPLACE(@JobEmailLine, EMailField,''' + ISNULL(CAST(' + TableColumn + ' AS VARCHAR(MAX)),'''') + ''')
							FROM bWDQF WHERE QueryName = @QueryName;
						END
						-- VA Inquiry
						ELSE IF @QueryType = 1
						BEGIN
							SELECT @JobEmailLine = REPLACE(@JobEmailLine, '['+ColumnName+']',''' + ISNULL(CAST(' + '['+ColumnName+']' + ' AS VARCHAR(MAX)),'''') + ''')
							FROM VPGridColumns WHERE QueryName = @QueryName;
						END

						--add + to left hand side
						SET @JobEmailLine = '+ ''' + @JobEmailLine;
							 
						--handle left hand side to prepare it for combination with the first part of the line
						IF LEFT(LTRIM(@JobEmailLine), 2) = ''''
							SET @JobEmailLine = SUBSTRING(@JobEmailLine, 3, LEN(@JobEmailLine));

						--handle right hand side to prepare it for combination with the last part of the line
						IF RIGHT(@JobEmailLine, 3) =  '+ '''
							SET @JobEmailLine = SUBSTRING(@JobEmailLine, 1, LEN(@JobEmailLine)-3);
						ELSE --add closing quote to the right side
							SET @JobEmailLine = @JobEmailLine + '''';

						--combine the first part, the replaced values, and last part of the line for insertion into @LineQuery
						SET @JobEmailLine = ' + ''' + @FirstPartOfJobLine + ''' ' + @JobEmailLine + ' + ''' + @LastPartOfJobLine + ''' ';

						SELECT @LineQuery = 'DECLARE @BodyLine VARCHAR(MAX)
											 SELECT @BodyLine = ''''
											 SELECT @BodyLine = @BodyLine ' + @JobEmailLine + ' + CHAR(13) + CHAR(10) FROM ' + QUOTENAME(@tempDataTableName) +
											'; INSERT INTO #tmpMessages ([BodyLine]) VALUES (@BodyLine);';
					END
					ELSE
						SELECT @LineQuery = 'INSERT INTO #tmpMessages ([BodyLine]) VALUES (''' + @JobEmailLine + ''');';
										
			END
			ELSE
				SELECT @LineQuery = 'INSERT INTO #tmpMessages ([BodyLine]) VALUES ('''');';

			-------------------------------------------------------------------------------

			--build message holding table
			CREATE TABLE #tmpMessages(
									  KeyID int IDENTITY(1,1),
									  [To] VARCHAR(3000) NULL,
									  CC VARCHAR(3000) NULL,
									  BCC VARCHAR(3000) NULL,
									  [From] VARCHAR(3000) NULL,
									  [Subject] VARCHAR(3000) NULL,
									  BodyHeader VARCHAR(MAX) NULL,
									  BodyLine VARCHAR(MAX) NULL,
									  BodyFooter VARCHAR(MAX) NULL,
									  Source VARCHAR(30) NULL
									  )

			DECLARE @Newline VARCHAR(2)
			SET @Newline = CHAR(13) + CHAR(10)

			--see if grouping table was created
			IF @tempGroupTableName IS NULL
			BEGIN 
				--temp table not created, no groupings, send 1 email
       			-- Make sure #ReplaceVal is empty (truncate for minimal logging)
       			TRUNCATE TABLE #ReplaceVal

				--execute pivot for the first row
				SET @RowNum = 1
				EXEC sp_executesql @CTE, N'@RowNum int', @RowNum

            	-- Replace [field name] with its value in all email parameters: To, CC, BCC, Subject, Body(header), Footer
				-- Use the Job variables because they will not be re-used in this procedure
				SELECT @JobEmailTo = REPLACE(@JobEmailTo, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @JobEmailCC = REPLACE(@JobEmailCC, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @JobEmailBCC = REPLACE(@JobEmailBCC, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @JobEmailSubject = REPLACE(@JobEmailSubject, '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @JobEmailBody = REPLACE(@JobEmailBody,  '[' + col + ']', val) FROM #ReplaceVal;
				SELECT @JobEmailFooter = REPLACE(@JobEmailFooter,  '[' + col + ']', val) FROM #ReplaceVal;

				--insert message body into holding table
				EXEC(@LineQuery);
				DECLARE @NewRecord int
				SELECT @NewRecord = MAX(KeyID) FROM #tmpMessages

				UPDATE #tmpMessages SET [To] = @JobEmailTo, CC = @JobEmailCC, BCC = @JobEmailBCC, 
										[From] = @FromAddress, [Subject] = @JobEmailSubject, BodyHeader = @JobEmailBody, 
										BodyFooter = @JobEmailFooter, Source = 'Notifier'
								    WHERE KeyID = @NewRecord
			END --END @tempGroupTableName IS NULL
			ELSE 
			BEGIN
			--Groupings exist, send multiple messages
			----------------Setup for grouping -----------------------------
			--reset RowNum
			SET @RowNum = 1

			--extract number of records in grouping table
			SET @sql = 'SELECT @NumRows = ISNULL(MAX(SeqForTmpTable),0) FROM ' + QUOTENAME(@tempGroupTableName)
			EXEC sp_executesql @sql, N'@NumRows int OUTPUT', @NumRows = @NumRows OUTPUT;

			IF (@@error <> 0)
				RAISERROR('Cannot retrieve row number from temporary group table. Please check your query and its parameters.', 16, 1);

			DECLARE @WherePredicate NVARCHAR(MAX), @GroupingCTE NVARCHAR(MAX), @NewRec int, @EmailFooter NVARCHAR(MAX)
			--Create holding pivot table for the grouping criteria
			CREATE TABLE #Groups (col VARCHAR(MAX), val VARCHAR(MAX));
			
			--create pivot for the grouping
			SET @GroupingCTE = 'WITH CTE AS ( SELECT ' + @GroupColumnList + ' FROM ' + QUOTENAME(@tempGroupTableName) + ' WHERE SeqForTmpTable = @RowNum  ) INSERT INTO #Groups SELECT col, val FROM CTE UNPIVOT(val FOR col IN(' + @GroupEmailFields + ')) AS U'			

			--repopulate template variables because of destructive replace during group building
			SELECT	@JobEmailTo =	CASE 
										WHEN ISNULL(@SendToTestEmail,'') <> '' THEN @SendToTestEmail 
										ELSE ISNULL(EmailTo,'')
									END, 
					@JobEmailCC =	CASE 
										WHEN ISNULL(@SendToTestEmail,'') <> '' THEN ''
										ELSE ISNULL(EmailCC,'')
									END,
					@JobEmailBCC =	CASE 
										WHEN ISNULL(@SendToTestEmail,'') <> '' THEN ''
										ELSE ISNULL(BCC,'')
									END, 
					@JobEmailSubject = ISNULL(EmailSubject,'')
   			FROM [bWDJB]
			WHERE [JobName] = @JobName;
			----------------------------------------------------------------

			--loop through groupings
			WHILE @RowNum <= @NumRows
       			BEGIN
					-- clear temp tables
       				TRUNCATE TABLE #ReplaceVal
       				TRUNCATE TABLE #Groups					

       				--Get email template for this iteration
					SELECT	@EmailTo = @JobEmailTo, 
							@EmailCC = @JobEmailCC, 
							@EmailBCC = @JobEmailBCC,
							@EmailSubject = @JobEmailSubject,
							@EmailBody = @JobEmailBody,
							@EmailFooter = @JobEmailFooter,
							@WherePredicate = @GroupWhere

					--execute grouping pivot
					EXEC sp_executesql @GroupingCTE, N'@RowNum int', @RowNum

					--build where clause
					SELECT @WherePredicate = REPLACE(@WherePredicate, QUOTENAME(col), REPLACE(val,'''','''''')) FROM #Groups;
					
					SET @LineQuery = 'DECLARE @BodyLine VARCHAR(MAX)
								 SELECT @BodyLine = ''''
								 SELECT @BodyLine = @BodyLine ' + ISNULL(@JobEmailLine, '') + ' + CHAR(13) + CHAR(10) FROM ' + QUOTENAME(@tempDataTableName) +
								' WHERE '+ @WherePredicate +'; '+'
								INSERT INTO #tmpMessages ([BodyLine]) VALUES (@BodyLine);'
					
					--insert message body into holding table
					EXEC sp_executesql @LineQuery;

					SELECT @NewRec = MAX(KeyID) FROM #tmpMessages					

					--build replacement value pivot statment
					SET @CTE = 'WITH CTE AS (SELECT TOP 1 ' + @ColumnList + ' FROM ' + QUOTENAME(@tempDataTableName) + ' WHERE ' + @WherePredicate + ') INSERT INTO #ReplaceVal SELECT col, val FROM CTE UNPIVOT(val FOR col IN(' + @EmailFields + ')) AS U'			

					EXEC sp_executesql @CTE

					--insert parameter values
					INSERT INTO #ReplaceVal SELECT [Param], InputValue FROM WDJP WHERE JobName = @JobName;

            		-- Replace [field name] with its value in all email parameters: To, CC, BCC, Subject, Body(header), Footer
					SELECT @EmailTo = REPLACE(@EmailTo, '[' + col + ']', val) FROM #ReplaceVal;
					SELECT @EmailCC = REPLACE(@EmailCC, '[' + col + ']', val) FROM #ReplaceVal;
					SELECT @EmailBCC = REPLACE(@EmailBCC, '[' + col + ']', val) FROM #ReplaceVal;
					SELECT @EmailSubject = REPLACE(@EmailSubject, '[' + col + ']', val) FROM #ReplaceVal;
					SELECT @EmailBody = REPLACE(@EmailBody,  '[' + col + ']', val) FROM #ReplaceVal;
					SELECT @EmailFooter = REPLACE(@EmailFooter,  '[' + col + ']', val) FROM #ReplaceVal;
					
					-- Replace @Parameters with its value in Body(header)
					SELECT @EmailBody = REPLACE(@EmailBody,  col, val) FROM #ReplaceVal WHERE col LIKE '@%';

					--pre-queue email in #tmpMessages	
					UPDATE #tmpMessages SET [To] = @EmailTo, CC = @EmailCC, BCC = @EmailBCC, 
											[From] = @FromAddress, [Subject] = @EmailSubject, BodyHeader = @EmailBody, 
											BodyFooter = @EmailFooter, Source = 'Notifier'
									    WHERE KeyID = @NewRec
	
					SET @RowNum = @RowNum + 1
				END--End while loop
				
				-- Remove messages that do not contain information
				DELETE FROM #tmpMessages where LTRIM(RTRIM(ISNULL(BodyLine,''))) = ''
			END

  	   		-- Send email 
  	   		INSERT INTO vMailQueue ([To], CC, BCC, [From], [Subject], Body, Source, IsHTML)
			SELECT [To], CC, BCC, [From], [Subject], ISNULL(BodyHeader,'') + @Newline + ISNULL(BodyLine,'') + @Newline + ISNULL(BodyFooter,''), Source, @IsHTML
			FROM #tmpMessages WHERE [To] IS NOT NULL

			IF @IsQueryEventBased = 'Y'
			BEGIN			
				SELECT @sql = 'INSERT INTO vWFSentNotifications (JobName, KeyHash)
								SELECT ''' + @JobName + ''', KeyHash 
								FROM ' + QUOTENAME(@tempDataTableName)						
								
				EXEC sp_executesql @sql
			END
			
			DROP TABLE #tmpMessages

		END -- End IsConsolidated ='N' Else block

		SET @ErrorMessage = NULL;
END TRY
BEGIN CATCH

		IF (OBJECT_ID('tempdb..#ReplaceVal') IS NOT NULL)
			DROP TABLE #ReplaceVal;

		IF (OBJECT_ID('tempdb..#tmpMessages') IS NOT NULL)
			DROP TABLE #tmpMessages;

		IF (OBJECT_ID('tempdb..#Groups') IS NOT NULL)
			DROP TABLE #Groups;

		IF (OBJECT_ID(@tempDataTableName) IS NOT NULL)
			BEGIN
				SET @sql = 'DROP TABLE ' + QUOTENAME(@tempDataTableName) ;
				EXEC (@sql);
			END

		IF (OBJECT_ID(@tempGroupTableName) IS NOT NULL)
			BEGIN
				SET @sql = 'DROP TABLE ' + QUOTENAME(@tempGroupTableName);
				EXEC (@sql);
			END

		IF @ExecuteBySQLJob = 1
		BEGIN
			SET @ErrorMessage = 
				'Job: ' + ISNULL(@JobName, 'n/a') + CHAR(13) + CHAR(10) +
				'Query: ' + ISNULL(@QueryName,'n/a') + CHAR(13) + CHAR(10) +
				'Error: ' + ISNULL(ERROR_MESSAGE(), 'n/a') + CHAR(13) + CHAR(10) +
				'Line: ' + ISNULL(CONVERT(varchar(5),ERROR_LINE()), 'n/a') + CHAR(13) + CHAR(10) + 
				'Query String:' + ISNULL('<<' + @sql + '>>', 'none') ;
		END
		ELSE
		BEGIN
			SET @ErrorMessage = ERROR_MESSAGE() + CHAR(13) + CHAR(10)
		END
		
		RAISERROR(@ErrorMessage, 16, 1); 

END CATCH

Notifier_Exit:
	IF @ExecuteBySQLJob = 1
	BEGIN
		-- no need to update the Last Run details when testing. 
		-- Because the actual run of this proc is done via Remote Helper, it should be run as viewpointcs, if not skip it. 
		DECLARE @JobLastRun VARCHAR(10)
		--Get last job run
		SELECT @JobLastRun = CONVERT(varchar(10), CASE WHEN NULLIF([last_run_date],0) IS NULL THEN GETDATE() ELSE CONVERT(datetime,CONVERT(VARCHAR(10),[last_run_date])) END, 101)
		FROM msdb.dbo.sysjobsteps
		
		WHERE [step_name] = @JobName;

		--Update WDJB with First/Last Run information
		UPDATE [bWDJB] SET 
			[FirstRun] = CASE WHEN [FirstRun] IS NULL THEN @JobLastRun ELSE [FirstRun] END,
			[LastRun] = @JobLastRun
		WHERE
			[JobName] = @JobName;
	END 
	
		IF (OBJECT_ID('tempdb..#ReplaceVal') IS NOT NULL)
			DROP TABLE #ReplaceVal;

		IF (OBJECT_ID('tempdb..#tmpMessages') IS NOT NULL)
			DROP TABLE #tmpMessages;

		IF (OBJECT_ID('tempdb..#Groups') IS NOT NULL)
			DROP TABLE #Groups;

		IF (OBJECT_ID(@tempDataTableName) IS NOT NULL)
			BEGIN
				SET @sql = 'DROP TABLE ' + QUOTENAME(@tempDataTableName);
				EXEC (@sql);
			END

		IF (OBJECT_ID(@tempGroupTableName) IS NOT NULL)
			BEGIN
				SET @sql = 'DROP TABLE ' + QUOTENAME(@tempGroupTableName);
				EXEC (@sql);
			END
GO
PRINT N'Refreshing [dbo].[vrvPRPAYGCountETPPaymentSummaries]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPAYGCountETPPaymentSummaries]'
GO
PRINT N'Refreshing [dbo].[viFact_PMPendChangeOrders]'
GO
EXEC sp_refreshview N'[dbo].[viFact_PMPendChangeOrders]'
GO
PRINT N'Refreshing [dbo].[PMFMArch]'
GO
EXEC sp_refreshview N'[dbo].[PMFMArch]'
GO
PRINT N'Refreshing [dbo].[HRChart]'
GO
EXEC sp_refreshview N'[dbo].[HRChart]'
GO
PRINT N'Altering [dbo].[PMSCOTotal]'
GO



/****************************/
ALTER view [dbo].[PMSCOTotal] as
/*****************************
* Created By:	GF 03/11/2011 TK-02577
* Modified By:	GF 04/15/2011 TK-04281
*				GF 11/23/2011 TK-10291 exclude VAT tax type
*				GPT/NH 09/06/12 TK-17499 Sum the PMSL Original Amount in the SL Total Original Amount.
*				AJW	04/26/2012 reverting prior mod change because it causes problems with 
*					SubCOs if SubCO is assigned a PCO not fully approved yet
*
* Displays SCO Totals (PMSubcontractCO), Original (SLIT), Current (SLCD, SLIT, PMSL),
* and Tax SL amounts in PMSubcontractCO (PMSL)
*
********************************/

SELECT TOP 100 PERCENT
		b.KeyID AS SCOKeyID,
		a.KeyID AS SLKeyID,
		b.SLCo,
		b.SL,
		b.SubCO,

		CAST(ISNULL(SUM(SLTOTAL.SLTotalOrig), 0) + ISNULL(SUM(SLTOTAL.SLTotalOrigTax), 0) -- + ISNULL(SUM(PMSL.PMSLOriginalAmt), 0) 	
																			AS NUMERIC(18,2)) AS SLTotalOriginal,
		CAST(ISNULL(SUM(SLTOTAL.SLTotalOrigTax), 0)		AS NUMERIC(18,2)) AS SLTotalOrigTax,
		
		CAST(ISNULL(SUM(SLPRIOR.SLPriorAmt), 0) + ISNULL(SUM(SLPRIOR.SLPriorTaxAmt), 0)		AS NUMERIC(18,2)) AS SLAmtPrior,
		CAST(ISNULL(SUM(SLPRIOR.SLPriorTaxAmt), 0)	AS NUMERIC(18,2))	AS SLTaxPrior,
		
		---- THE pm VALUES ARE RETRIEVED FROM A TABLE FUNCTION THAT RETURNS CURRENT SCO,
		---- PREVIOUS APPROVED CHANGE ORDERS, AND PENDING CHANGE ORDERS
		CAST(ISNULL(SUM(PMSL.PMSLCurrentAmt), 0)	AS NUMERIC(18,2))	AS PMSLAmtCurrent,
		CAST(ISNULL(SUM(PMSL.PMSLCurrentTaxAmt), 0)	AS NUMERIC(18,2))	AS PMSLTaxCurrent,
		CAST(ISNULL(SUM(PMSL.PMSLPrevApprAmt), 0)		AS NUMERIC(18,2)) AS PMSLAmtPrior,
		CAST(ISNULL(SUM(PMSL.PMSLPrevApprTaxAmt), 0)	AS NUMERIC(18,2)) AS PMSLTaxPrior,
		CAST(ISNULL(SUM(PMSL.PMSLPendingAmt), 0)		AS NUMERIC(18,2)) AS PMSLAmtPriorPending,
		CAST(ISNULL(SUM(PMSL.PMSLPendingTaxAmt),0)		AS NUMERIC(18,2)) AS PMSLTaxPriorPending,
		
		CAST(ISNULL(SUM(SLPRIOR.SLPriorAmt), 0) + ISNULL(SUM(SLPRIOR.SLPriorTaxAmt), 0) + ISNULL(SUM(PMSL.PMSLPrevApprAmt), 0) AS NUMERIC(18,2)) AS SubCOPrevious
				
FROM dbo.PMSubcontractCO b
JOIN dbo.bSLHD a ON a.SLCo=b.SLCo AND a.SL=b.SL
				
	---- SL SUBCONTRACT AMOUNTS
    OUTER APPLY (SELECT  SLTotalOrig    = ISNULL(SUM(CASE WHEN e.ItemType IN (1,4) THEN e.OrigCost ELSE 0 END), 0),
						 ----TK-10291
                         SLTotalOrigTax = ISNULL(SUM(CASE WHEN e.ItemType IN (1,4) AND e.TaxType = 1 THEN e.OrigTax ELSE 0 END) , 0)
                  FROM   dbo.bSLIT e
                  WHERE  e.SLCo = a.SLCo
                         AND e.SL = a.SL
                         AND e.ItemType <> 3
                  GROUP BY  e.SLCo,
                            e.SL
                ) SLTOTAL

	---- SL PRIOR CHANGE AMOUNTS
    OUTER APPLY ( SELECT SLPriorAmt    = ISNULL(SUM(f.ChangeCurCost), 0),
						 ----TK-10291
						 SLPriorTaxAmt = ISNULL(SUM(CASE WHEN g.TaxType = 1 THEN f.ChgToTax ELSE 0 END), 0)
                  FROM   dbo.bSLCD f
                  INNER JOIN dbo.bSLIT g ON g.SLCo=f.SLCo AND g.SL=f.SL AND g.SLItem=f.SLItem
                  WHERE  f.SLCo = a.SLCo
                         AND f.SL = a.SL
                         AND f.SLChangeOrder IS NOT NULL
                         AND f.SLChangeOrder < b.SubCO
                  GROUP BY  f.SLCo,
                            f.SL
                ) SLPRIOR


	----- TABLE FUNCTION APPLIED FOR PM SUCONTRACT CHANGE AMOUNTS
	CROSS APPLY dbo.vfPMSLSubcontractCOAmounts(b.SLCo, b.SL, b.SubCO) PMSL



GROUP BY  b.SLCo,
          b.SL,
          b.SubCO,
          b.KeyID,
          a.KeyID
          
ORDER BY  b.SLCo, b.SL, b.SubCO





















GO
PRINT N'Refreshing [dbo].[vrvPRPAYGCountPaymentSummaries]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPAYGCountPaymentSummaries]'
GO
PRINT N'Refreshing [dbo].[POJC]'
GO
EXEC sp_refreshview N'[dbo].[POJC]'
GO
PRINT N'Refreshing [dbo].[PMFMInsp]'
GO
EXEC sp_refreshview N'[dbo].[PMFMInsp]'
GO
PRINT N'Refreshing [dbo].[HRPCEmp]'
GO
EXEC sp_refreshview N'[dbo].[HRPCEmp]'
GO
PRINT N'Refreshing [dbo].[JBAR]'
GO
EXEC sp_refreshview N'[dbo].[JBAR]'
GO
PRINT N'Refreshing [dbo].[POJM]'
GO
EXEC sp_refreshview N'[dbo].[POJM]'
GO
PRINT N'Refreshing [dbo].[PMFMRel]'
GO
EXEC sp_refreshview N'[dbo].[PMFMRel]'
GO
PRINT N'Refreshing [dbo].[SMTechnicianPreferred]'
GO
EXEC sp_refreshview N'[dbo].[SMTechnicianPreferred]'
GO
PRINT N'Refreshing [dbo].[HRRMHRDP]'
GO
EXEC sp_refreshview N'[dbo].[HRRMHRDP]'
GO
PRINT N'Refreshing [dbo].[brvGLFSSum]'
GO
EXEC sp_refreshview N'[dbo].[brvGLFSSum]'
GO
PRINT N'Refreshing [dbo].[vrvPRPAYGEmployerATOSuperItems]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPAYGEmployerATOSuperItems]'
GO
PRINT N'Refreshing [dbo].[PMFMReq]'
GO
EXEC sp_refreshview N'[dbo].[PMFMReq]'
GO
PRINT N'Refreshing [dbo].[brvHQATTrans]'
GO
EXEC sp_refreshview N'[dbo].[brvHQATTrans]'
GO
PRINT N'Creating trigger [dbo].[vtvSLClaimItem_Audit_Insert] on [dbo].[vSLClaimItem]'
GO
CREATE TRIGGER dbo.vtvSLClaimItem_Audit_Insert ON dbo.vSLClaimItem
 AFTER INSERT
 NOT FOR REPLICATION AS
 SET NOCOUNT ON 
 -- generated by vspAuditTriggersCreate

 BEGIN TRY 

-- log additions to the ApproveAmount column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ApproveAmount' , 
								NULL , 
								ApproveAmount , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ApproveRetPct column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ApproveRetPct' , 
								NULL , 
								ApproveRetPct , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ApproveRetention column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ApproveRetention' , 
								NULL , 
								ApproveRetention , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ApproveUnits column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ApproveUnits' , 
								NULL , 
								ApproveUnits , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ClaimAmount column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ClaimAmount' , 
								NULL , 
								ClaimAmount , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ClaimNo column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ClaimNo' , 
								NULL , 
								ClaimNo , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ClaimToDateAmt column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ClaimToDateAmt' , 
								NULL , 
								ClaimToDateAmt , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ClaimToDateUnits column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ClaimToDateUnits' , 
								NULL , 
								ClaimToDateUnits , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the ClaimUnits column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'ClaimUnits' , 
								NULL , 
								ClaimUnits , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the CurCost column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'CurCost' , 
								NULL , 
								CurCost , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the CurUnitCost column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'CurUnitCost' , 
								NULL , 
								CurUnitCost , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the CurUnits column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'CurUnits' , 
								NULL , 
								CurUnits , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the Description column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'Description' , 
								NULL , 
								Description , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the SL column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'SL' , 
								NULL , 
								SL , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the SLCo column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'SLCo' , 
								NULL , 
								SLCo , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the SLItem column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'SLItem' , 
								NULL , 
								SLItem , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the TaxAmount column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'TaxAmount' , 
								NULL , 
								TaxAmount , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the TaxCode column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'TaxCode' , 
								NULL , 
								TaxCode , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the TaxGroup column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'TaxGroup' , 
								NULL , 
								TaxGroup , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the TaxType column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'TaxType' , 
								NULL , 
								TaxType , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								

-- log additions to the UM column
							INSERT dbo.bHQMA (	
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
							
							SELECT 
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								ISNULL(inserted.SLCo, '') , 
								'A' , 
								'UM' , 
								NULL , 
								UM , 
								GETDATE() , 
								SUSER_SNAME()
							FROM inserted
								


 END TRY 
 BEGIN CATCH 
   DECLARE	@ErrorMessage	NVARCHAR(4000), 
				@ErrorSeverity	INT; 

   SELECT	@ErrorMessage = 'Error '+ ISNULL(ERROR_MESSAGE(),'') +' in [dbo].[dbo.vtvSLClaimItem_Audit_Insert] trigger', 
				@ErrorSeverity = ERROR_SEVERITY(); 

   RAISERROR(@ErrorMessage, @ErrorSeverity, 1 ) 
 END CATCH 
GO
EXEC sp_settriggerorder N'[dbo].[vtvSLClaimItem_Audit_Insert]', 'last', 'insert', null
GO
PRINT N'Refreshing [dbo].[vrvPRPAYGFBTDateRange]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPAYGFBTDateRange]'
GO
PRINT N'Altering [dbo].[vrptPRPAYGPaymentDetails]'
GO

/***************************************************************************************
Copyright 2013 Viewpoint Construction Software. All rights reserved.
Purpose:
	Extract payment detail for the PAYG payroll summary of 
	individual earnings, deduction, and liability codes 
	to the payroll end date level.
	
Created:	CWirtz	06/22/11
Modified:	DML		03/21/13 Modified to include ETP items. 
			JayR	05/17/13 Removed copyright symbol as it prevents database compares.
			CUC		05/21/13 Removed ETP items.
 
***************************************************************************************/

/***************************************************************************************

Test Harness
DECLARE	@return_value int

EXEC	@return_value = [dbo].[vrptPRPAYGPaymentDetails]
		@PRCo = 141,
		@TaxYear = N'2011',
		@Employee = 0

SELECT	'Return Value' = @return_value

GO

***************************************************************************************/

ALTER  PROCEDURE [dbo].[vrptPRPAYGPaymentDetails]
         (@PRCo bCompany = null
         ,@TaxYear char(4) = null
         ,@Employee bEmployee =null)

AS      
         
DECLARE @BegEmp bEmployee			--Calculated
DECLARE @EndEmp bEmployee			--Calculated

DECLARE @TaxYearInt smallint

SET @TaxYearInt = CAST (@TaxYear AS smallint)

PRINT @TaxYearInt


--SET employee selection range.  A parameter value of 0 returns all employees. 
--Otherwise, the specific employee is only selected
If @Employee = 0  
BEGIN
	SET	@BegEmp = 0
	SET	@EndEmp = 999999

END
ELSE
BEGIN
	SET	@BegEmp = @Employee
	SET	@EndEmp = @Employee
END;


        
-- Extract all payments for each employee.  In subsequent steps, this data 
--will be used to determine the first time an employee was paid in a given tax year.
WITH PAYGTaxYear(PRCo, Employee, PaidDate,PaidMth,TaxYear)
AS
(
SELECT 
	 PRDT.PRCo
	,PRDT.Employee
	,PRSQ.PaidDate
	,PRSQ.PaidMth
	,@TaxYear
FROM 
		PRSQ PRSQ (NOLOCK)
		INNER JOIN dbo.PRDT PRDT (NOLOCK) 
			ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
				AND PRSQ.PREndDate = PRDT.PREndDate AND PRDT.Employee=PRSQ.Employee
				AND PRSQ.PaySeq = PRDT.PaySeq 
				
WHERE 
		@PRCo = PRDT.PRCo
		AND PRDT.Employee BETWEEN @BegEmp AND @EndEmp
		AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PRSQ.PaidMth) BETWEEN 7 and 12) 
							THEN DATEPART(yyyy,PRSQ.PaidMth) + 1 ELSE DATEPART(yyyy,PRSQ.PaidMth)  END
		AND PRSQ.PaidDate IS NOT NULL
)
,
-- Generate the first paid date for each employee in the fiscal tax year.
PAYGFirstPaidDateInTaxYear

AS
(
	SELECT 
	PRCo, TaxYear, Employee, MIN(PaidDate) as PaidDate, MIN(PaidMth ) as FirstPaidMth
	FROM PAYGTaxYear 
	GROUP BY PRCo, TaxYear, Employee
)
,
-- Read all employee payments for the first month they were paid in a specific tax year.
-- These payments will be compared with the employee's accumulations for the corresponding 
-- month and any differences will be preloaded(plugged) data from another system or process.
-- NOTE: This data is aggregated to the same level as the employee's accumulations in table PREA
PREASplitMth
AS
(
SELECT PRDT.PRCo,PRDT.Employee,PRDT.EDLType,PRDT.EDLCode
	,SUM(PRDT.Hours) AS Hours
	,SUM(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) AS Amount
	,SUM(PRDT.SubjectAmt) AS SubjectAmt
	,SUM(PRDT.EligibleAmt) AS EligibleAmt
	,f.FirstPaidMth
FROM PAYGFirstPaidDateInTaxYear f
	INNER JOIN dbo.PRSQ PRSQ (nolock) 
		ON f.PRCo = PRSQ.PRCo AND f.Employee= PRSQ.Employee AND f.FirstPaidMth = PRSQ.PaidMth 
	INNER JOIN PRDT PRDT (nolock) 
		ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup AND PRDT.Employee=PRSQ.Employee
			AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 
GROUP BY PRDT.PRCo,PRDT.Employee,PRDT.EDLType,PRDT.EDLCode,f.FirstPaidMth
)


,
-- Determine any preloaded data when it is also the same month the employee was first paid.
PREAPreLoadedForSplitMonth
AS
(
SELECT PREA.PRCo,PREA.Employee,PREA.Mth,PREA.EDLType,PREA.EDLCode
	,(ISNULL(PREA.Hours,0) -  ISNULL(g.Hours,0)) AS Hours
	,(ISNULL(PREA.Amount,0) -  ISNULL(g.Amount,0)) AS Amount
	,(ISNULL(PREA.SubjectAmt,0) -  ISNULL(g.SubjectAmt,0)) AS SubjectAmt
	,(ISNULL(PREA.EligibleAmt,0) -  ISNULL(g.EligibleAmt,0)) AS EligibleAmt
	,g.FirstPaidMth
FROM PREA
	LEFT OUTER JOIN PREASplitMth g
		ON PREA.PRCo = g.PRCo AND PREA.Employee = g.Employee
			AND PREA.Mth = g.FirstPaidMth 
			AND PREA.EDLType = g.EDLType
			AND PREA.EDLCode = g.EDLCode
WHERE
		@PRCo = PREA.PRCo
		AND PREA.Employee BETWEEN @BegEmp AND @EndEmp
		AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PREA.Mth) BETWEEN 7 and 12) 
							THEN DATEPART(yyyy,PREA.Mth) + 1 ELSE DATEPART(yyyy,PREA.Mth)  END
		AND PREA.Mth = g.FirstPaidMth					

)
-- Create table with all preloaded data
,
PREAAllPreloadedData
AS
(
SELECT	 PREA.PRCo,PREA.Employee,PREA.Mth,PREA.EDLType,PREA.EDLCode
		,PREA.Hours,PREA.Amount,PREA.SubjectAmt,PREA.EligibleAmt, f.FirstPaidMth
FROM PREA 
LEFT OUTER JOIN PAYGFirstPaidDateInTaxYear f
		ON f.PRCo = PREA.PRCo AND f.Employee= PREA.Employee-- AND f.PaidMth = PRSQ.PaidMth 
WHERE
		@PRCo = PREA.PRCo
		AND PREA.Employee BETWEEN @BegEmp AND @EndEmp
		AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PREA.Mth) BETWEEN 7 and 12) 
							THEN DATEPART(yyyy,PREA.Mth) + 1 ELSE DATEPART(yyyy,PREA.Mth)  END
		AND PREA.Mth < f.FirstPaidMth		
		
		AND
		NOT(PREA.Hours = 0 AND PREA.Amount = 0 AND PREA.SubjectAmt = 0 AND PREA.EligibleAmt= 0)

UNION ALL

SELECT	PRCo,Employee,Mth,EDLType,EDLCode,Hours,Amount,SubjectAmt,EligibleAmt,FirstPaidMth
FROM PREAPreLoadedForSplitMonth h
WHERE 
		NOT(Hours = 0 AND Amount = 0 AND SubjectAmt = 0 AND EligibleAmt= 0)

		
)
,
--PreLoadedData	1=Data was not preloaded in PREA
--PreLoadedData	2=Data was preloaded in PREA by Balance Forward Process

--Extract PAYG employee data at the detail level

PRAUEmployeeItemAmountsExt 
(	 SortValue, PreLoadedData, UnionSetOrdinal, RecType, PRCo, TaxYear, Employee, BeginDate, EndDate, SummarySeq
	,ItemCode, TotalAmount, EDLType, EDLCode, EDLDescription ,SubjectAmt, EligibleAmt
	,EDLAmount, LSAType, PREndDate, PaidDate, PaidMth ,ItemOrder, FBTBeginDate	, FBTEndDate
	,ItemDescription, AFGAmount
)	
AS
--Select all employee items (deductions, liabilities and earnings codes) used in PAYG Summary reports
(


--PRAUEmployeeItemAmounts
--Select all employee items (deductions, liabilities and earnings codes) used in PAYG Summary reports
SELECT 
	 1 AS SortValue
	,1 AS PreLoadedData
	,1 AS UnionSetOrdinal
	,'PRAUEmployeeItemAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,f.EDLType,f.EDLCode
	,(CASE WHEN PRDT.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,PRDT.SubjectAmt 
	,PRDT.EligibleAmt
	,(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) AS EDLAmount
	,(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) AS LSAType
	,PRSQ.PREndDate
	,PRSQ.PaidDate
	,PRSQ.PaidMth
	,PRAUItems.ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,PRAUItems.ItemDescription
	,NULL AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRAUEmployeeItemAmounts e
	INNER JOIN vrvPRPAYGEmployerATOSuperItems f
			ON e.PRCo = f.PRCo AND e.TaxYear = f.TaxYear AND e.ItemCode = f.ItemCode
	INNER JOIN PRDT PRDT (nolock)
		ON e.PRCo = PRDT.PRCo AND e.Employee = PRDT.Employee AND f.EDLType = PRDT.EDLType AND f.EDLCode = PRDT.EDLCode
	INNER JOIN dbo.PRSQ PRSQ (nolock) 
		ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
			AND PRSQ.PREndDate = PRDT.PREndDate AND PRDT.Employee=PRSQ.Employee AND PRSQ.PaySeq = PRDT.PaySeq 
	INNER JOIN PRAUItems PRAUItems (nolock)
		ON PRAUItems.ItemCode = f.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
												OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode AND PRDT.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = PRDT.PRCo AND PRDL.DLCode = PRDT.EDLCode AND PRDT.EDLType<>'E'
				
WHERE		PRSQ.PaidDate BETWEEN e.BeginDate AND e.EndDate
			AND e.ItemCode NOT IN ('GR','FBT')
			AND PRSQ.CMRef IS NOT NULL
			AND @PRCo = PRDT.PRCo
			AND PRDT.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PRSQ.PaidMth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,PRSQ.PaidMth) + 1 ELSE DATEPART(yyyy,PRSQ.PaidMth)  END
			AND PRSQ.PaidDate IS NOT NULL
UNION ALL
--For FBT Reporting period is from April 1st through March 31st of the following year.
--This is different from the normal tax year of July 1st through the June 30th.
SELECT 
	 1 AS SortValue
	,1 AS PreLoadedData
	,2 AS UnionSetOrdinal
	,'PRAUEmployeeItemAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,f.EDLType
	,f.EDLCode
	,(CASE WHEN PRDT.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,PRDT.SubjectAmt 
	,PRDT.EligibleAmt
	,(CASE WHEN PRDT.UseOver = 'Y' THEN (CASE WHEN PRDT.EDLType='D' THEN (PRDT.OverAmt  * -1) ELSE PRDT.OverAmt  END) 
		ELSE (CASE WHEN PRDT.EDLType='D' THEN (PRDT.Amount * -1) ELSE PRDT.Amount END) END) AS EDLAmount
	,(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) AS LSAType
	,PRSQ.PREndDate
	,PRSQ.PaidDate
	,PRSQ.PaidMth
	,PRAUItems.ItemOrder
	,g.FBTBeginDate
	,g.FBTEndDate
	,PRAUItems.ItemDescription
	,NULL AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRAUEmployeeItemAmounts e
	INNER JOIN vrvPRPAYGEmployerATOSuperItems f
			ON e.PRCo = f.PRCo AND e.TaxYear = f.TaxYear AND e.ItemCode = f.ItemCode
	INNER JOIN PRDT PRDT (nolock)
		ON e.PRCo = PRDT.PRCo AND e.Employee = PRDT.Employee AND f.EDLType = PRDT.EDLType AND f.EDLCode = PRDT.EDLCode
	INNER JOIN dbo.PRSQ PRSQ (nolock) 
		ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
			AND PRSQ.PREndDate = PRDT.PREndDate AND PRDT.Employee=PRSQ.Employee AND PRSQ.PaySeq = PRDT.PaySeq 
	INNER JOIN PRAUItems PRAUItems (nolock)
		ON PRAUItems.ItemCode = f.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
												OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))
	LEFT OUTER JOIN vrvPRPAYGFBTDateRange g
			ON e.PRCo = g.PRCo AND e.TaxYear = g.TaxYear AND e.ItemCode = g.ItemCode 
				AND e.SummarySeq = g.SummarySeq AND e.Employee = g.Employee
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode AND PRDT.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = PRDT.PRCo AND PRDL.DLCode = PRDT.EDLCode AND PRDT.EDLType<>'E'		
		
WHERE		PRSQ.PaidDate BETWEEN  g.FBTBeginDate AND g.FBTEndDate  --NOTE: This is FBT reporting range and not Summary Seq Range
			AND e.ItemCode ='FBT'
			AND PRSQ.CMRef IS NOT NULL
			AND @PRCo = PRDT.PRCo
			AND PRDT.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PRSQ.PaidMth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,PRSQ.PaidMth) + 1 ELSE DATEPART(yyyy,PRSQ.PaidMth)  END
			AND PRSQ.PaidDate IS NOT NULL

UNION ALL
--PRAUEmployeeMiscItemAmounts
---- Select all employee miscellanous items (allowances, union/professional and workplace giving) used in PAYG Summary reports
SELECT 
	 2 AS SortValue
	,1 AS PreLoadedData
	,3 AS UnionSetOrdinal
	,'PRAUEmployeeMiscItemAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,f.EDLType
	,f.EDLCode
	,(CASE WHEN PRDT.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,PRDT.SubjectAmt 
	,PRDT.EligibleAmt
	,(CASE WHEN PRDT.UseOver = 'Y' THEN PRDT.OverAmt ELSE PRDT.Amount END) AS EDLAmount
	,NULL AS LSAType
	,PRSQ.PREndDate,PRSQ.PaidDate,PRSQ.PaidMth
	,PRAUItems.ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,PRAUItems.ItemDescription	
	
	,(SELECT SUM(Amount) 	
		FROM PRAUEmployeeMiscItemAmounts h
		WHERE e.PRCo=h.PRCo AND e.TaxYear=h.TaxYear AND e.Employee=h.Employee AND e.SummarySeq=h.SummarySeq AND e.ItemCode=h.ItemCode
		GROUP BY 	h.PRCo,h.TaxYear,h.Employee,h.SummarySeq,h.ItemCode ) AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRAUEmployeeMiscItemAmounts e
	INNER JOIN PRAUEmployerMiscItems f
		ON e.PRCo = f.PRCo AND e.TaxYear = f.TaxYear AND e.ItemCode = f.ItemCode AND f.EDLType = e.EDLType AND f.EDLCode = e.EDLCode
	INNER JOIN PRDT PRDT (nolock)
		ON e.PRCo = PRDT.PRCo AND e.Employee = PRDT.Employee AND f.EDLType = PRDT.EDLType AND f.EDLCode = PRDT.EDLCode
	INNER JOIN dbo.PRSQ PRSQ (nolock) 
		ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup 
			AND PRSQ.PREndDate = PRDT.PREndDate AND PRDT.Employee=PRSQ.Employee AND PRSQ.PaySeq = PRDT.PaySeq 
	INNER JOIN PRAUItems PRAUItems (nolock)
		ON PRAUItems.ItemCode = f.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
												OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = PRDT.PRCo AND PREC.EarnCode = PRDT.EDLCode AND PRDT.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = PRDT.PRCo AND PRDL.DLCode = PRDT.EDLCode AND PRDT.EDLType<>'E'		
		
WHERE		PRSQ.PaidDate BETWEEN e.BeginDate AND e.EndDate
			AND PRSQ.CMRef IS NOT NULL
			AND @PRCo = PRDT.PRCo
			AND PRDT.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PRSQ.PaidMth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,PRSQ.PaidMth) + 1 ELSE DATEPART(yyyy,PRSQ.PaidMth)  END
			AND PRSQ.PaidDate IS NOT NULL


--Gross Payments
UNION ALL
SELECT
 	 1 AS SortValue
	,1 AS PreLoadedData
	,4 AS UnionSetOrdinal
	,'GrossAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,PRDT.EDLType
	,PRDT.EDLCode
	,(CASE WHEN PRDT.EDLType='E' THEN PREC.Description ELSE PRDLBasis.Description END) AS EDLDescription
	,PRDT.SubjectAmt  
	,PRDT.EligibleAmt
--NOTE:Pretax deductions are not included in gross payments
	,(CASE WHEN PRDT.UseOver = 'Y' THEN (CASE WHEN PRDLBasis.PreTax='Y' THEN (PRDT.OverAmt  * -1) ELSE PRDT.OverAmt  END) 
			ELSE (CASE WHEN PRDLBasis.PreTax='Y' THEN (PRDT.Amount * -1) ELSE PRDT.Amount END) END) AS EDLAmount
	,NULL AS LSAType
	,PRSQ.PREndDate
	,PRSQ.PaidDate
	,PRSQ.PaidMth
	,PRAUItems.ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,PRAUItems.ItemDescription
	,NULL  AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRDB PRDB
INNER JOIN PRDL PRDL
	ON PRDB.PRCo = PRDL.PRCo and PRDB.DLCode = PRDL.DLCode 
LEFT JOIN PRDL PRDLBasis
	ON PRDB.PRCo = PRDLBasis.PRCo and PRDB.EDLCode = PRDLBasis.DLCode  AND PRDB.EDLType = 'D'

LEFT JOIN PREC PREC
	ON PRDB.PRCo = PREC.PRCo and PRDB.EDLCode = PREC.EarnCode 
INNER JOIN PRDT PRDT
	ON PRDB.PRCo = PRDT.PRCo and PRDB.EDLCode = PRDT.EDLCode and PRDT.EDLType=PRDB.EDLType
INNER JOIN dbo.PRSQ PRSQ (nolock) 
	ON PRSQ.PRCo = PRDT.PRCo AND PRSQ.PRGroup = PRDT.PRGroup AND PRDT.Employee=PRSQ.Employee
		AND PRSQ.PREndDate = PRDT.PREndDate AND PRSQ.PaySeq = PRDT.PaySeq 		
INNER JOIN PRAUEmployeeItemAmounts e
	ON e.PRCo = PRDT.PRCo AND e.Employee = PRDT.Employee AND e.ItemCode='GR'
INNER JOIN PRAUItems PRAUItems (nolock)
	ON PRAUItems.ItemCode = e.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
											OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))	
WHERE PRDB.PRCo=PRDT.PRCo 
AND PRDL.ATOCategory='T'
--Criterion below (at present) effectively excludes from Gross Payments any payment under an earncode whose ATOCategory is 'AT' or 'LSE'
AND ISNULL(PREC.ATOCategory,'') NOT IN (SELECT ATOCategory FROM PRAUItemsATOCategories WHERE ItemCode='GR' AND ATOCategory <>'T')
--Criterion below excludes from Gross Payments any payment under an earncode whose ATOCategory appears in list
AND ISNULL(PREC.ATOCategory,'') NOT IN ('ETP','ETPR','ETPV','ETPU','ETPD','LSAT','LSAR','LSB')
AND PRSQ.PaidDate BETWEEN    e.BeginDate AND e.EndDate
			AND @PRCo = PRDT.PRCo
			AND PRDT.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,PRSQ.PaidMth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,PRSQ.PaidMth) + 1 ELSE DATEPART(yyyy,PRSQ.PaidMth)  END
			AND PRSQ.PaidDate IS NOT NULL

UNION ALL

--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

SELECT 
	 1 AS SortValue
	,2 AS PreLoadedData		--Loaded by Balance Forward Process
	,5 AS UnionSetOrdinal
	,'PRAUEmployeeItemAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,f.EDLType,f.EDLCode
	,(CASE WHEN i.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,i.SubjectAmt 
	,i.EligibleAmt
	,i.Amount AS EDLAmount
	,(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) AS LSAType
	,i.Mth AS PREndDate		--For preloaded data Set PREndDate,PaidDate and PaidMth to month 
	,i.Mth AS PaidDate		--the data was preloaded for
	,i.Mth AS PaidMth
	,PRAUItems.ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,PRAUItems.ItemDescription
	,NULL AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRAUEmployeeItemAmounts e
	INNER JOIN vrvPRPAYGEmployerATOSuperItems f
			ON e.PRCo = f.PRCo AND e.TaxYear = f.TaxYear AND e.ItemCode = f.ItemCode		
	INNER JOIN PREAAllPreloadedData i
			ON e.PRCo = i.PRCo AND e.Employee = i.Employee AND f.EDLType = i.EDLType AND f.EDLCode = i.EDLCode
	INNER JOIN PRAUItems PRAUItems (nolock)
		ON PRAUItems.ItemCode = f.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
												OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = i.PRCo AND PREC.EarnCode = i.EDLCode AND i.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = i.PRCo AND PRDL.DLCode = i.EDLCode AND i.EDLType<>'E'
		
				
WHERE		i.Mth BETWEEN e.BeginDate AND e.EndDate
			AND e.ItemCode NOT IN ('GR','FBT')
--			AND PRSQ.CMRef IS NOT NULL
			AND @PRCo = i.PRCo
			AND i.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,i.Mth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,i.Mth) + 1 ELSE DATEPART(yyyy,i.Mth)  END
--			AND PRSQ.PaidDate IS NOT NULL


UNION ALL
--For FBT Reporting period is from April 1st through March 31st of the following year.
--This is different from the normal tax year of July 1st through the June 30th.
SELECT 
	 1 AS SortValue
	,2 AS PreLoadedData		--Loaded by Balance Forward Process
	,6 AS UnionSetOrdinal
	,'PRAUEmployeeItemAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,f.EDLType
	,f.EDLCode
	,(CASE WHEN i.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,i.SubjectAmt 
	,i.EligibleAmt
	,(CASE WHEN i.EDLType='D' THEN (i.Amount * -1) ELSE i.Amount END) AS EDLAmount
--	,(CASE WHEN PRDT.UseOver = 'Y' THEN (CASE WHEN PRDT.EDLType='D' THEN (PRDT.OverAmt  * -1) ELSE PRDT.OverAmt  END) 
--		ELSE (CASE WHEN PRDT.EDLType='D' THEN (PRDT.Amount * -1) ELSE PRDT.Amount END) END) AS EDLAmount
	,(CASE PREC.ATOCategory WHEN 'LSAT' THEN 'T' WHEN 'LSAR' THEN 'R' ELSE NULL END) AS LSAType
	,i.Mth AS PREndDate		--For preloaded data Set PREndDate,PaidDate and PaidMth to month 
	,i.Mth AS PaidDate		--the data was preloaded for
	,i.Mth AS PaidMth
	,PRAUItems.ItemOrder
	,g.FBTBeginDate
	,g.FBTEndDate
	,PRAUItems.ItemDescription
	,NULL AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRAUEmployeeItemAmounts e
	INNER JOIN vrvPRPAYGEmployerATOSuperItems f
			ON e.PRCo = f.PRCo AND e.TaxYear = f.TaxYear AND e.ItemCode = f.ItemCode
	INNER JOIN PREAAllPreloadedData i
			ON e.PRCo = i.PRCo AND e.Employee = i.Employee AND f.EDLType = i.EDLType AND f.EDLCode = i.EDLCode
	INNER JOIN PRAUItems PRAUItems (nolock)
		ON PRAUItems.ItemCode = f.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
												OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))
	LEFT OUTER JOIN vrvPRPAYGFBTDateRange g
			ON e.PRCo = g.PRCo AND e.TaxYear = g.TaxYear AND e.ItemCode = g.ItemCode 
				AND e.SummarySeq = g.SummarySeq AND e.Employee = g.Employee
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = i.PRCo AND PREC.EarnCode = i.EDLCode AND i.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = i.PRCo AND PRDL.DLCode = i.EDLCode AND i.EDLType<>'E'
		
WHERE		i.Mth BETWEEN  g.FBTBeginDate AND g.FBTEndDate  --NOTE: This is FBT reporting range and not Summary Seq Range
			AND e.ItemCode ='FBT'
--			AND PRSQ.CMRef IS NOT NULL
			AND @PRCo = i.PRCo
			AND i.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,i.Mth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,i.Mth) + 1 ELSE DATEPART(yyyy,i.Mth)  END
--			AND PRSQ.PaidDate IS NOT NULL


UNION ALL
--PRAUEmployeeMiscItemAmounts
---- Select all employee miscellanous items (allowances, union/professional and workplace giving) used in PAYG Summary reports
SELECT 
	 2 AS SortValue
	,2 AS PreLoadedData		--Loaded by Balance Forward Process
	,7 AS UnionSetOrdinal
	,'PRAUEmployeeMiscItemAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,f.EDLType
	,f.EDLCode
	,(CASE WHEN i.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,i.SubjectAmt 
	,i.EligibleAmt
	,i.Amount AS EDLAmount
	,NULL AS LSAType
	,i.Mth AS PREndDate		--For preloaded data Set PREndDate,PaidDate and PaidMth to month 
	,i.Mth AS PaidDate		--the data was preloaded for
	,i.Mth AS PaidMth	,PRAUItems.ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,PRAUItems.ItemDescription	
	
	,(SELECT SUM(Amount) 	
		FROM PRAUEmployeeMiscItemAmounts h
		WHERE e.PRCo=h.PRCo AND e.TaxYear=h.TaxYear AND e.Employee=h.Employee AND e.SummarySeq=h.SummarySeq AND e.ItemCode=h.ItemCode
		GROUP BY 	h.PRCo,h.TaxYear,h.Employee,h.SummarySeq,h.ItemCode ) AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRAUEmployeeMiscItemAmounts e
	INNER JOIN PRAUEmployerMiscItems f
		ON e.PRCo = f.PRCo AND e.TaxYear = f.TaxYear AND e.ItemCode = f.ItemCode AND f.EDLType = e.EDLType AND f.EDLCode = e.EDLCode
	INNER JOIN PREAAllPreloadedData i
			ON e.PRCo = i.PRCo AND e.Employee = i.Employee AND f.EDLType = i.EDLType AND f.EDLCode = i.EDLCode
	INNER JOIN PRAUItems PRAUItems (nolock)
		ON PRAUItems.ItemCode = f.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
												OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = i.PRCo AND PREC.EarnCode = i.EDLCode AND i.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = i.PRCo AND PRDL.DLCode = i.EDLCode AND i.EDLType<>'E'
		
WHERE		i.Mth BETWEEN e.BeginDate AND e.EndDate
			--AND PRSQ.CMRef IS NOT NULL
			AND @PRCo = i.PRCo
			AND i.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,i.Mth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,i.Mth) + 1 ELSE DATEPART(yyyy,i.Mth)  END
--			AND PRSQ.PaidDate IS NOT NULL



--Gross Payments
UNION ALL
SELECT
 	 1 AS SortValue
	,2 AS PreLoadedData		--Loaded by Balance Forward Process
	,8 AS UnionSetOrdinal
	,'GrossAmounts' AS RecType
	,e.PRCo
	,e.TaxYear
	,e.Employee
	,e.BeginDate
	,e.EndDate
	,e.SummarySeq
	,e.ItemCode
	,e.Amount AS TotalAmount
	,i.EDLType
	,i.EDLCode
	,(CASE WHEN i.EDLType='E' THEN PREC.Description ELSE PRDLBasis.Description END) AS EDLDescription
	,i.SubjectAmt  
	,i.EligibleAmt
--NOTE:Pretax deductions are not included in gross payments
	,(CASE WHEN PRDLBasis.PreTax='Y' THEN (i.Amount * -1) ELSE i.Amount END)  AS EDLAmount
	,NULL AS LSAType
	,i.Mth AS PREndDate		--For preloaded data Set PREndDate,PaidDate and PaidMth to month 
	,i.Mth AS PaidDate		--the data was preloaded for
	,i.Mth AS PaidMth
	,PRAUItems.ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,PRAUItems.ItemDescription
	,NULL  AS AFGAmount  --AFG Allowances Fees & Giving
	
FROM PRDB PRDB
INNER JOIN PRDL PRDL
	ON PRDB.PRCo = PRDL.PRCo and PRDB.DLCode = PRDL.DLCode 
LEFT JOIN PRDL PRDLBasis
	ON PRDB.PRCo = PRDLBasis.PRCo and PRDB.EDLCode = PRDLBasis.DLCode  AND PRDB.EDLType = 'D'

LEFT JOIN PREC PREC
	ON PRDB.PRCo = PREC.PRCo and PRDB.EDLCode = PREC.EarnCode 

INNER JOIN PREAAllPreloadedData i
		ON PRDB.PRCo = i.PRCo AND PRDB.EDLType = i.EDLType AND PRDB.EDLCode = i.EDLCode
	
INNER JOIN PRAUEmployeeItemAmounts e
	ON e.PRCo = i.PRCo AND e.Employee = i.Employee AND e.ItemCode='GR'
INNER JOIN PRAUItems PRAUItems (nolock)
	ON PRAUItems.ItemCode = e.ItemCode AND(( e.TaxYear >= BeginTaxYear AND EndTaxYear IS NULL)
											OR (e.TaxYear BETWEEN BeginTaxYear AND EndTaxYear))	
WHERE PRDB.PRCo=i.PRCo 
AND PRDL.ATOCategory='T'
--Criterion below (at present) effectively excludes from Gross Payments any payment under an earncode whose ATOCategory is 'AT' or 'LSE'
AND ISNULL(PREC.ATOCategory,'') NOT IN (SELECT ATOCategory FROM PRAUItemsATOCategories WHERE ItemCode='GR' AND ATOCategory <>'T')
--Criterion below excludes from Gross Payments any payment under an earncode whose ATOCategory appears in list
AND ISNULL(PREC.ATOCategory,'') NOT IN ('ETP','ETPR','ETPV','ETPU','ETPD','LSAT','LSAR','LSB')
AND i.Mth BETWEEN    e.BeginDate AND e.EndDate
			AND @PRCo = i.PRCo
			AND i.Employee BETWEEN @BegEmp AND @EndEmp
			AND  @TaxYearInt = CASE WHEN(DATEPART(mm,i.Mth) BETWEEN 7 and 12) 
								THEN DATEPART(yyyy,i.Mth) + 1 ELSE DATEPART(yyyy,i.Mth)  END
--			AND PRSQ.PaidDate IS NOT NULL


--@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
/*

UNION All


SELECT
	 3 AS SortValue
	,2 AS PreLoadedData
	,'PREAPreLoad' AS RecType
	,i.PRCo
	,@TaxYear AS TaxYear
	,i.Employee
	,NULL AS BeginDate
	,NULL AS EndDate
	,NULL AS SummarySeq
	,NULL AS ItemCode
	,NULL AS TotalAmount
	,i.EDLType
	,i.EDLCode
	,(CASE WHEN i.EDLType='E' THEN PREC.Description ELSE PRDL.Description END) AS EDLDescription
	,i.SubjectAmt 
	,i.EligibleAmt
	,i.Amount
	,NULL AS LSAType
	,NULL AS PREndDate
	,NULL AS PaidDate
	,i.Mth AS PaidMth
	,NULL AS ItemOrder
	,NULL AS FBTBeginDate
	,NULL AS FBTEndDate
	,NULL AS ItemDescription
	,NULL AS AFGAmount  --AFG Allowances Fees & Giving
FROM
PREAAllPreloadedData i
	LEFT OUTER JOIN PREC PREC(nolock)		
		ON PREC.PRCo = i.PRCo AND PREC.EarnCode = i.EDLCode AND i.EDLType='E'
	LEFT OUTER JOIN PRDL PRDL(nolock)		
		ON PRDL.PRCo = i.PRCo AND PRDL.DLCode = i.EDLCode AND i.EDLType<>'E'
*/
)
,
--Extract Employee's name and the company name
PRAUPayrollSummary
AS
(
SELECT 	 
	 j.SortValue, j.PreLoadedData, j.UnionSetOrdinal, j.RecType, j.PRCo, j.TaxYear, j.Employee, j.BeginDate, j.EndDate, j.SummarySeq
	,j.ItemCode, j.TotalAmount, j.EDLType, j.EDLCode, j.EDLDescription , j.SubjectAmt, j.EligibleAmt
	,j.EDLAmount, j.LSAType, j.PREndDate, j.PaidDate, j.PaidMth , j.ItemOrder, j.FBTBeginDate, j.FBTEndDate
	,j.ItemDescription, j.AFGAmount
	,PRAUEmployees.Surname
	,PRAUEmployees.GivenName
	,HQCO.Name

FROM PRAUEmployeeItemAmountsExt j
	LEFT OUTER JOIN PRAUEmployees PRAUEmployees (NOLOCK)
		ON j.PRCo = PRAUEmployees.PRCo AND j.TaxYear = PRAUEmployees.TaxYear AND j.Employee = PRAUEmployees.Employee
	LEFT OUTER JOIN HQCO HQCO (NOLOCK)
		ON j.PRCo = HQCO.HQCo
		



)


SELECT 
 	 SortValue, PreLoadedData, UnionSetOrdinal, RecType, PRCo, TaxYear, Employee, BeginDate, EndDate, SummarySeq
	,ItemCode, TotalAmount, EDLType, EDLCode, EDLDescription, SubjectAmt, EligibleAmt
	,EDLAmount, LSAType, PREndDate, PaidDate, PaidMth, ItemOrder, FBTBeginDate, FBTEndDate
	,ItemDescription, AFGAmount, Surname, GivenName, Name
FROM PRAUPayrollSummary



--SELECT * FROM PAYGFirstPaidDateInTaxYear
--SELECT * FROM PREAPreLoaded
--SELECT * from PREASplitMth

--SELECT * FROM PREABackoutPaidData
--SELECT * FROM PREAAllPreloadedData
--SELECT * FROM PRAUEmployeeItemAmountsExt









GO
PRINT N'Refreshing [dbo].[PMFMResp]'
GO
EXEC sp_refreshview N'[dbo].[PMFMResp]'
GO
PRINT N'Refreshing [dbo].[brvHQBC]'
GO
EXEC sp_refreshview N'[dbo].[brvHQBC]'
GO
PRINT N'Creating trigger [dbo].[vtvSLClaimItem_Audit_Update] on [dbo].[vSLClaimItem]'
GO
CREATE TRIGGER dbo.vtvSLClaimItem_Audit_Update ON dbo.vSLClaimItem
 AFTER UPDATE 
 NOT FOR REPLICATION AS 
 SET NOCOUNT ON 
 -- generated by vspAuditTriggersCreate

 BEGIN TRY 

							IF UPDATE([ApproveAmount])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ApproveAmount' , 								CONVERT(VARCHAR(MAX), deleted.[ApproveAmount]) , 								CONVERT(VARCHAR(MAX), inserted.[ApproveAmount]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ApproveAmount] <> deleted.[ApproveAmount]) OR (inserted.[ApproveAmount] IS NULL AND deleted.[ApproveAmount] IS NOT NULL) OR (inserted.[ApproveAmount] IS NOT NULL AND deleted.[ApproveAmount] IS NULL))
								

							END 

							IF UPDATE([ApproveRetPct])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ApproveRetPct' , 								CONVERT(VARCHAR(MAX), deleted.[ApproveRetPct]) , 								CONVERT(VARCHAR(MAX), inserted.[ApproveRetPct]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ApproveRetPct] <> deleted.[ApproveRetPct]) OR (inserted.[ApproveRetPct] IS NULL AND deleted.[ApproveRetPct] IS NOT NULL) OR (inserted.[ApproveRetPct] IS NOT NULL AND deleted.[ApproveRetPct] IS NULL))
								

							END 

							IF UPDATE([ApproveRetention])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ApproveRetention' , 								CONVERT(VARCHAR(MAX), deleted.[ApproveRetention]) , 								CONVERT(VARCHAR(MAX), inserted.[ApproveRetention]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ApproveRetention] <> deleted.[ApproveRetention]) OR (inserted.[ApproveRetention] IS NULL AND deleted.[ApproveRetention] IS NOT NULL) OR (inserted.[ApproveRetention] IS NOT NULL AND deleted.[ApproveRetention] IS NULL))
								

							END 

							IF UPDATE([ApproveUnits])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ApproveUnits' , 								CONVERT(VARCHAR(MAX), deleted.[ApproveUnits]) , 								CONVERT(VARCHAR(MAX), inserted.[ApproveUnits]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ApproveUnits] <> deleted.[ApproveUnits]) OR (inserted.[ApproveUnits] IS NULL AND deleted.[ApproveUnits] IS NOT NULL) OR (inserted.[ApproveUnits] IS NOT NULL AND deleted.[ApproveUnits] IS NULL))
								

							END 

							IF UPDATE([ClaimAmount])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ClaimAmount' , 								CONVERT(VARCHAR(MAX), deleted.[ClaimAmount]) , 								CONVERT(VARCHAR(MAX), inserted.[ClaimAmount]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ClaimAmount] <> deleted.[ClaimAmount]) OR (inserted.[ClaimAmount] IS NULL AND deleted.[ClaimAmount] IS NOT NULL) OR (inserted.[ClaimAmount] IS NOT NULL AND deleted.[ClaimAmount] IS NULL))
								

							END 

							IF UPDATE([ClaimNo])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ClaimNo' , 								CONVERT(VARCHAR(MAX), deleted.[ClaimNo]) , 								CONVERT(VARCHAR(MAX), inserted.[ClaimNo]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ClaimNo] <> deleted.[ClaimNo]) OR (inserted.[ClaimNo] IS NULL AND deleted.[ClaimNo] IS NOT NULL) OR (inserted.[ClaimNo] IS NOT NULL AND deleted.[ClaimNo] IS NULL))
								

							END 

							IF UPDATE([ClaimToDateAmt])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ClaimToDateAmt' , 								CONVERT(VARCHAR(MAX), deleted.[ClaimToDateAmt]) , 								CONVERT(VARCHAR(MAX), inserted.[ClaimToDateAmt]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ClaimToDateAmt] <> deleted.[ClaimToDateAmt]) OR (inserted.[ClaimToDateAmt] IS NULL AND deleted.[ClaimToDateAmt] IS NOT NULL) OR (inserted.[ClaimToDateAmt] IS NOT NULL AND deleted.[ClaimToDateAmt] IS NULL))
								

							END 

							IF UPDATE([ClaimToDateUnits])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ClaimToDateUnits' , 								CONVERT(VARCHAR(MAX), deleted.[ClaimToDateUnits]) , 								CONVERT(VARCHAR(MAX), inserted.[ClaimToDateUnits]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ClaimToDateUnits] <> deleted.[ClaimToDateUnits]) OR (inserted.[ClaimToDateUnits] IS NULL AND deleted.[ClaimToDateUnits] IS NOT NULL) OR (inserted.[ClaimToDateUnits] IS NOT NULL AND deleted.[ClaimToDateUnits] IS NULL))
								

							END 

							IF UPDATE([ClaimUnits])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'ClaimUnits' , 								CONVERT(VARCHAR(MAX), deleted.[ClaimUnits]) , 								CONVERT(VARCHAR(MAX), inserted.[ClaimUnits]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[ClaimUnits] <> deleted.[ClaimUnits]) OR (inserted.[ClaimUnits] IS NULL AND deleted.[ClaimUnits] IS NOT NULL) OR (inserted.[ClaimUnits] IS NOT NULL AND deleted.[ClaimUnits] IS NULL))
								

							END 

							IF UPDATE([CurCost])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'CurCost' , 								CONVERT(VARCHAR(MAX), deleted.[CurCost]) , 								CONVERT(VARCHAR(MAX), inserted.[CurCost]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[CurCost] <> deleted.[CurCost]) OR (inserted.[CurCost] IS NULL AND deleted.[CurCost] IS NOT NULL) OR (inserted.[CurCost] IS NOT NULL AND deleted.[CurCost] IS NULL))
								

							END 

							IF UPDATE([CurUnitCost])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'CurUnitCost' , 								CONVERT(VARCHAR(MAX), deleted.[CurUnitCost]) , 								CONVERT(VARCHAR(MAX), inserted.[CurUnitCost]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[CurUnitCost] <> deleted.[CurUnitCost]) OR (inserted.[CurUnitCost] IS NULL AND deleted.[CurUnitCost] IS NOT NULL) OR (inserted.[CurUnitCost] IS NOT NULL AND deleted.[CurUnitCost] IS NULL))
								

							END 

							IF UPDATE([CurUnits])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'CurUnits' , 								CONVERT(VARCHAR(MAX), deleted.[CurUnits]) , 								CONVERT(VARCHAR(MAX), inserted.[CurUnits]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[CurUnits] <> deleted.[CurUnits]) OR (inserted.[CurUnits] IS NULL AND deleted.[CurUnits] IS NOT NULL) OR (inserted.[CurUnits] IS NOT NULL AND deleted.[CurUnits] IS NULL))
								

							END 

							IF UPDATE([Description])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'Description' , 								CONVERT(VARCHAR(MAX), deleted.[Description]) , 								CONVERT(VARCHAR(MAX), inserted.[Description]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[Description] <> deleted.[Description]) OR (inserted.[Description] IS NULL AND deleted.[Description] IS NOT NULL) OR (inserted.[Description] IS NOT NULL AND deleted.[Description] IS NULL))
								

							END 

							IF UPDATE([SL])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'SL' , 								CONVERT(VARCHAR(MAX), deleted.[SL]) , 								CONVERT(VARCHAR(MAX), inserted.[SL]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[SL] <> deleted.[SL]) OR (inserted.[SL] IS NULL AND deleted.[SL] IS NOT NULL) OR (inserted.[SL] IS NOT NULL AND deleted.[SL] IS NULL))
								

							END 

							IF UPDATE([SLCo])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'SLCo' , 								CONVERT(VARCHAR(MAX), deleted.[SLCo]) , 								CONVERT(VARCHAR(MAX), inserted.[SLCo]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[SLCo] <> deleted.[SLCo]) OR (inserted.[SLCo] IS NULL AND deleted.[SLCo] IS NOT NULL) OR (inserted.[SLCo] IS NOT NULL AND deleted.[SLCo] IS NULL))
								

							END 

							IF UPDATE([SLItem])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'SLItem' , 								CONVERT(VARCHAR(MAX), deleted.[SLItem]) , 								CONVERT(VARCHAR(MAX), inserted.[SLItem]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[SLItem] <> deleted.[SLItem]) OR (inserted.[SLItem] IS NULL AND deleted.[SLItem] IS NOT NULL) OR (inserted.[SLItem] IS NOT NULL AND deleted.[SLItem] IS NULL))
								

							END 

							IF UPDATE([TaxAmount])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'TaxAmount' , 								CONVERT(VARCHAR(MAX), deleted.[TaxAmount]) , 								CONVERT(VARCHAR(MAX), inserted.[TaxAmount]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[TaxAmount] <> deleted.[TaxAmount]) OR (inserted.[TaxAmount] IS NULL AND deleted.[TaxAmount] IS NOT NULL) OR (inserted.[TaxAmount] IS NOT NULL AND deleted.[TaxAmount] IS NULL))
								

							END 

							IF UPDATE([TaxCode])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'TaxCode' , 								CONVERT(VARCHAR(MAX), deleted.[TaxCode]) , 								CONVERT(VARCHAR(MAX), inserted.[TaxCode]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[TaxCode] <> deleted.[TaxCode]) OR (inserted.[TaxCode] IS NULL AND deleted.[TaxCode] IS NOT NULL) OR (inserted.[TaxCode] IS NOT NULL AND deleted.[TaxCode] IS NULL))
								

							END 

							IF UPDATE([TaxGroup])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'TaxGroup' , 								CONVERT(VARCHAR(MAX), deleted.[TaxGroup]) , 								CONVERT(VARCHAR(MAX), inserted.[TaxGroup]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[TaxGroup] <> deleted.[TaxGroup]) OR (inserted.[TaxGroup] IS NULL AND deleted.[TaxGroup] IS NOT NULL) OR (inserted.[TaxGroup] IS NOT NULL AND deleted.[TaxGroup] IS NULL))
								

							END 

							IF UPDATE([TaxType])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'TaxType' , 								CONVERT(VARCHAR(MAX), deleted.[TaxType]) , 								CONVERT(VARCHAR(MAX), inserted.[TaxType]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[TaxType] <> deleted.[TaxType]) OR (inserted.[TaxType] IS NULL AND deleted.[TaxType] IS NOT NULL) OR (inserted.[TaxType] IS NOT NULL AND deleted.[TaxType] IS NULL))
								

							END 

							IF UPDATE([UM])
							BEGIN
							INSERT dbo.bHQMA (	TableName, 
																	KeyString, 
																	Co, 
																	RecType, 
																	FieldName, 
																	OldValue, 
																	NewValue, 
																	DateTime, 
																	UserName)
								
								SELECT 							'vSLClaimItem' , 								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(inserted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(inserted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(inserted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(inserted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 								inserted.SLCo , 								'C' , 								'UM' , 								CONVERT(VARCHAR(MAX), deleted.[UM]) , 								CONVERT(VARCHAR(MAX), inserted.[UM]) , 								GETDATE() , 								SUSER_SNAME()
							FROM inserted
								INNER JOIN deleted
									ON  inserted.[KeyID] = deleted.[KeyID] 
									AND ((inserted.[UM] <> deleted.[UM]) OR (inserted.[UM] IS NULL AND deleted.[UM] IS NOT NULL) OR (inserted.[UM] IS NOT NULL AND deleted.[UM] IS NULL))
								

							END 



 END TRY 
 BEGIN CATCH 
   DECLARE	@ErrorMessage	NVARCHAR(4000), 
				@ErrorSeverity	INT; 

   SELECT	@ErrorMessage = 'Error '+ ISNULL(ERROR_MESSAGE(),'') +' in [dbo].[dbo.vtvSLClaimItem_Audit_Update] trigger', 
				@ErrorSeverity = ERROR_SEVERITY(); 

   RAISERROR(@ErrorMessage, @ErrorSeverity, 1 ) 
 END CATCH 
GO
EXEC sp_settriggerorder N'[dbo].[vtvSLClaimItem_Audit_Update]', 'last', 'update', null
GO
PRINT N'Creating [dbo].[vspAPAUATOAmendedDateVal]'
GO



CREATE procedure [dbo].[vspAPAUATOAmendedDateVal]
/************************************************************
* CREATED BY:	GF 04/08/2013 AP ATO Processing Enhancement
* MODIFIED By:		
*								
*								
*
* USAGE:
* Validate Amended date for the Tax Year entered in APAUATOEFileGenerate.
* There must be at least one creditor/payee with the amended date.
*
* INPUT PARAMETERS
* @APCo			AP Co
* @TaxYear		Year to validate
* @AmendedDate	AmendedDate
*
*
* OUTPUT PARAMETERS
*   @errmsg     if something went wrong
* RETURN VALUE
*   0   success
*   1   fail
************************************************************/
(@APCo bCompany = NULL, 
 @TaxYear SMALLINT = NULL,
 @AmendedDate bDate = NULL,
 @msg VARCHAR(255) OUTPUT)
AS
SET NOCOUNT ON

DECLARE @rcode INT

SELECT @rcode = 0

IF @TaxYear IS NULL
	BEGIN
	SET @msg = 'Missing Tax Year!'
	RETURN 1
	END

IF @APCo IS NULL
	BEGIN
	SET @msg = 'Missing AP Company!'
	RETURN 1
	END

IF @AmendedDate IS NULL
	BEGIN
	SET @msg = 'Missing Amended Date!'
	RETURN 1
	END


IF NOT EXISTS (SELECT 1 FROM dbo.APAUPayeeTaxPaymentATO WHERE APCo = @APCo
					AND TaxYear = @TaxYear
					AND AmendedDate = @AmendedDate)
	BEGIN
	SET @msg = 'No creditors have the amended date assigned!'
	RETURN 1
	END
   

RETURN 0


GO
PRINT N'Refreshing [dbo].[HRADMAIN]'
GO
EXEC sp_refreshview N'[dbo].[HRADMAIN]'
GO
PRINT N'Refreshing [dbo].[vrvPRPayPeriod]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPayPeriod]'
GO
PRINT N'Refreshing [dbo].[PMFMSend]'
GO
EXEC sp_refreshview N'[dbo].[PMFMSend]'
GO
PRINT N'Refreshing [dbo].[SMTripWithStatuses]'
GO
EXEC sp_refreshview N'[dbo].[SMTripWithStatuses]'
GO
PRINT N'Refreshing [dbo].[MSHaulCodeNoCompany]'
GO
EXEC sp_refreshview N'[dbo].[MSHaulCodeNoCompany]'
GO
PRINT N'Refreshing [dbo].[INIBwMO]'
GO
EXEC sp_refreshview N'[dbo].[INIBwMO]'
GO
PRINT N'Refreshing [dbo].[JBCC]'
GO
EXEC sp_refreshview N'[dbo].[JBCC]'
GO
PRINT N'Refreshing [dbo].[brvHRAccident]'
GO
EXEC sp_refreshview N'[dbo].[brvHRAccident]'
GO
PRINT N'Creating trigger [dbo].[vtvSLClaimItem_Audit_Delete] on [dbo].[vSLClaimItem]'
GO
CREATE TRIGGER dbo.vtvSLClaimItem_Audit_Delete ON dbo.vSLClaimItem
 AFTER DELETE
 NOT FOR REPLICATION AS
 SET NOCOUNT ON 
 -- generated by vspAuditCreateAuditTriggers

 BEGIN TRY 

							INSERT dbo.HQMA (
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
								
							SELECT
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(deleted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(deleted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(deleted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(deleted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								deleted.SLCo , 
								'D' , 
								'ClaimNo' , 
								CONVERT(VARCHAR(MAX), deleted.[ClaimNo]) , 								NULL , 
								GETDATE() , 
								SUSER_SNAME()
							FROM deleted
								
							INSERT dbo.HQMA (
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
								
							SELECT
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(deleted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(deleted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(deleted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(deleted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								deleted.SLCo , 
								'D' , 
								'SL' , 
								CONVERT(VARCHAR(MAX), deleted.[SL]) , 								NULL , 
								GETDATE() , 
								SUSER_SNAME()
							FROM deleted
								
							INSERT dbo.HQMA (
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
								
							SELECT
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(deleted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(deleted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(deleted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(deleted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								deleted.SLCo , 
								'D' , 
								'SLCo' , 
								CONVERT(VARCHAR(MAX), deleted.[SLCo]) , 								NULL , 
								GETDATE() , 
								SUSER_SNAME()
							FROM deleted
								
							INSERT dbo.HQMA (
													TableName, 
													KeyString, 
													Co, 
													RecType, 
													FieldName, 
													OldValue, 
													NewValue, 
													DateTime, 
													UserName)
								
							SELECT
								'vSLClaimItem' , 
								'<KeyString ClaimNo = "' + REPLACE(CAST(ISNULL(deleted.[ClaimNo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SL = "' + REPLACE(CAST(ISNULL(deleted.[SL],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLCo = "' + REPLACE(CAST(ISNULL(deleted.[SLCo],'') AS VARCHAR(MAX)),'"', '&quot;') + '" SLItem = "' + REPLACE(CAST(ISNULL(deleted.[SLItem],'') AS VARCHAR(MAX)),'"', '&quot;') + '" />' , 
								deleted.SLCo , 
								'D' , 
								'SLItem' , 
								CONVERT(VARCHAR(MAX), deleted.[SLItem]) , 								NULL , 
								GETDATE() , 
								SUSER_SNAME()
							FROM deleted
								

							
 END TRY 
 BEGIN CATCH 
   DECLARE	@ErrorMessage	NVARCHAR(4000), 
				@ErrorSeverity	INT; 

   SELECT	@ErrorMessage = 'Error '+ ISNULL(ERROR_MESSAGE(),'') +' in [dbo].[dbo.vtvSLClaimItem_Audit_Delete] trigger', 
				@ErrorSeverity = ERROR_SEVERITY(); 

   RAISERROR(@ErrorMessage, @ErrorSeverity, 1 ) 
 END CATCH 
GO
EXEC sp_settriggerorder N'[dbo].[vtvSLClaimItem_Audit_Delete]', 'last', 'delete', null
GO
PRINT N'Creating [dbo].[vspAPAUATOClearAmendedEFile]'
GO



CREATE PROC [dbo].[vspAPAUATOClearAmendedEFile]
/********************************************************/
-- CREATED BY:	GF 03/14/2013 AP ATO enhancement
-- MODIFIED BY:  
--
-- USAGE:
--	Set the Amended Date in APAUPayeeTaxPaymentATO to NULL
--	for all Creditor for the specified APCo/TaxYear.
--
-- INPUT PARAMETERS:
--	@APCo		AP Company
--	@TaxYear	Tax Year to affect in ATO Creditor taxable payments
--
--
-- OUTPUT PARAMETERS:
--	@Message	error message if failure, message specifying # of records cleared if success
--
-- RETURN VALUE:
-- 	0 	    success
--	1 		failure
--
/**********************************************************/
(
 @APCo bCompany, 
 @TaxYear char(4), 
 @Message VARCHAR(4000) = NULL OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON

	-- Check Parameters
	IF @APCo IS NULL
		BEGIN
		SET @Message = 'Missing AP Company!'
		RETURN 1
		END

	IF @TaxYear IS NULL
		BEGIN
		SET @Message = 'Missing Tax Year!'
		RETURN 1
		END


---- update Creditor table setting amended flag to 'N' and amended date to null
BEGIN TRY

	---- start a transaction, commit after fully processed
    BEGIN TRANSACTION;

	UPDATE dbo.APAUPayeeTaxPaymentATO
		SET AmendedDate = NULL
	WHERE APCo = @APCo AND TaxYear = @TaxYear AND AmendedDate IS NOT NULL

	SELECT @Message = 'Cleared ' + CONVERT(varchar,@@ROWCOUNT) + ' amended records.'

		---- insert for Creditor payments has completed. commit transaction
	COMMIT TRANSACTION;

END TRY
BEGIN CATCH
    -- Test XACT_STATE:
        -- If 1, the transaction is committable.
        -- If -1, the transaction is uncommittable and should 
        --     be rolled back.
        -- XACT_STATE = 0 means that there is no transaction and
        --     a commit or rollback operation would generate an error.
	IF XACT_STATE() <> 0
		BEGIN
		ROLLBACK TRANSACTION
		SET @Message = CAST(ERROR_MESSAGE() AS VARCHAR(200))
		RAISERROR (@Message, 15, 1)
		RETURN 1
		END
END CATCH


RETURN 0


END
GO
PRINT N'Refreshing [dbo].[vrvPRPayStubByEmployee]'
GO
EXEC sp_refreshview N'[dbo].[vrvPRPayStubByEmployee]'
GO
PRINT N'Refreshing [dbo].[PMFMSub]'
GO
EXEC sp_refreshview N'[dbo].[PMFMSub]'
GO
PRINT N'Refreshing [dbo].[DDFLc]'
GO
EXEC sp_refreshview N'[dbo].[DDFLc]'
GO
PRINT N'Refreshing [dbo].[SMType]'
GO
EXEC sp_refreshview N'[dbo].[SMType]'
GO
PRINT N'Refreshing [dbo].[JBILTotal]'
GO
EXEC sp_refreshview N'[dbo].[JBILTotal]'
GO
PRINT N'Refreshing [dbo].[brvINAllocInventory]'
GO
EXEC sp_refreshview N'[dbo].[brvINAllocInventory]'
GO
PRINT N'Creating [dbo].[vfAPAUATOAddressGet]'
GO




-- =============================================
-- Author:		Gil Fox Tfs-00000 AP ATO EFile Address values meeting aussie specifications.
-- Create date: 06/13/2013
-- Description:	The function will be called from the vspAPAUATOExportGet stored procedure
-- to return address values (Address, Address2, City, State, PostalCode, Country)
-- meeting the efile specifications.
--
-- Address fields returned: Address, Address2, City, State, PostalCode, Country
--
-- 1. When address is empty, then all address fields are empty except Postal Code which will be 0000
-- 2. State must be one of the 6 AU states or 'OTH'.
-- 3. Postal Code:
--		a. When country is not AU then postal code is 9999.
--		b. When between range of 0001 and 9998 then use.
--		c. Otherwise 0000.
-- 4. When the country is 'AU' then AUSTRALIA.
--
-- =============================================
CREATE FUNCTION [dbo].[vfAPAUATOAddressGet]
(
	  @Address			VARCHAR(60)
	 ,@Address2			VARCHAR(60)
	 ,@City				VARCHAR(30)
	 ,@State			VARCHAR(4)
	 ,@PostalCode		VARCHAR(12)
	 ,@Country			VARCHAR(2)
)

RETURNS @ReportAddress TABLE (
								 [Address]		VARCHAR(60)
								 ,[Address2]	VARCHAR(60)
								 ,[City]		VARCHAR(30)
								 ,[State]		VARCHAR(4)
								 ,[PostalCode]	VARCHAR(12)
								 ,[Country] 	VARCHAR(20)
							    )

AS
BEGIN


	---- if the address is empty then we will return all address fields as empty
	IF ISNULL(LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@Address,'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')), '') = ''
		BEGIN
		INSERT INTO @ReportAddress ([Address], [Address2], [City], [State], [PostalCode], [Country]) 
		VALUES ( '', '', '', '', '0000', '')
		END
 
	ELSE

		BEGIN
		INSERT INTO @ReportAddress ([Address], [Address2], [City], [State], [PostalCode], [Country])
		VALUES (
				LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@Address,'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')),
				LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@Address2,'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')),
				LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@City,'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')),

				CASE WHEN @State NOT IN ('ACT', 'NSW', 'NT', 'QLD', 'SA', 'TAS', 'VIC', 'WA')
						THEN 'OTH'
						ELSE @State
						END, ----state

				CASE WHEN ISNULL(@Country, 'AU') <> 'AU' THEN '9999'
						WHEN ISNUMERIC(ISNULL(@PostalCode, '')) = 0
								THEN '0000'
						WHEN LEN(LTRIM(RTRIM(ISNULL(@PostalCode, '')))) <> 4
								THEN '0000'
						WHEN ISNULL(@PostalCode, '') BETWEEN '0001' AND '9998'
								THEN @PostalCode
						ELSE '0000'
						END, ----postal code
                 
				CASE WHEN ISNULL(@Country, 'AU') = 'AU' THEN 'AUSTRALIA'
						ELSE ISNULL(@Country, '')
						END ----country
				)       

		END
	
		  
	RETURN
END
GO
PRINT N'Creating [dbo].[vspAPAUATOExportGet]'
GO






CREATE	PROC [dbo].[vspAPAUATOExportGet]
/************************************
* Created By:	GF 04/09/2013 AP ATO Taxable Payment Enhancement
* Modified By:	GF 06/13/2013 TFS-52766 return BSB, Account # from APVM and format address fields
*
*
* This procedure is called form the AP ATO Export Process and returns
* supplier/payer - creditor/payee information to be reported in the E file process.
*
* INPUT PARAMETERS
*   @APCo		AP Company
*   @TaxYear	Tax Year
*	@AmendedDate	ATO Amended Date or null
*
***********************************/
(@APCo bCompany = NULL,
 @TaxYear SMALLINT = NULL,
 @AmendedDate bDate = NULL)

AS
SET NOCOUNT ON

DECLARE @rcode INT

SET @rcode = 0
	
DECLARE  @FileDate smalldatetime

SET @FileDate = dbo.vfDateOnly()
	
IF ISNULL(@AmendedDate,'') = '' SET @AmendedDate = NULL

---- get supplier/payer information
SELECT  Payer.TaxYear,
		ISNULL(Payer.ABN, '00000000000') AS [ABN],
		ISNULL(Payer.BranchNo, '001') AS [BranchNo],
		Payer.CompanyName, 	Payer.ContactName, Payer.ContactPhone,
		Payer.SignatureOfAuthPerson,
		Payer.ReportDate, @FileDate AS [FileDate],

		----TFS-52766
		ISNULL(PayerAddress.[Address], '')		AS [Address],
		ISNULL(PayerAddress.[Address2], '')		AS [Address2],
		ISNULL(PayerAddress.[City], '')			AS [City],
		ISNULL(PayerAddress.[State], '')		AS [State],
		ISNULL(PayerAddress.[PostalCode], '')	AS [PostalCode],
		ISNULL(PayerAddress.[Country], '')		AS [Country]

		--LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(Payer.[Address],'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')) AS [Address],
		--LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(Payer.[Address2],'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')) AS [Address2],
		--LTRIM(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(Payer.[City],'      ',' '),'     ',' '),'    ',' '),'   ',' '),'  ',' ')) AS [City],
		--CASE WHEN Payer.[State] NOT IN ('ACT', 'NSW', 'NT', 'QLD', 'SA', 'TAS', 'VIC', 'WA') THEN 'OTH' ELSE Payer.[State] END AS [State],

		------TFS-52766
		--CASE WHEN ISNULL(Payer.Country, HQCO.DefaultCountry) <> 'AU' THEN '9999'
		--	ELSE
		--		CASE WHEN ISNULL(Payer.[Address], '') = '' THEN '0000'
		--		WHEN ISNULL(Payer.[PostalCode], '') BETWEEN '0001' AND '9998' THEN Payer.[PostalCode]
		--		ELSE '0000' END
		--	END AS [PostalCode],
		----CASE WHEN ISNULL(Payer.Country, HQCO.DefaultCountry) = 'AU' THEN Payer.[PostalCode] ELSE '9999' END AS [PostalCode],

		--CASE WHEN ISNULL(Payer.Country, HQCO.DefaultCountry) = 'AU' THEN 'AUSTRALIA' ELSE ISNULL(Payer.Country, HQCO.DefaultCountry) END AS [Country],


FROM dbo.vAPAUPayerTaxPaymentATO Payer
INNER JOIN dbo.bHQCO HQCO ON HQCO.HQCo = Payer.APCo

---- TFS-52766 TABLE FUNCTION APPLIED FOR Creditor address values
CROSS APPLY dbo.vfAPAUATOAddressGet(Payer.[Address], Payer.[Address2], Payer.[City], Payer.[State],
				Payer.[PostalCode], ISNULL(Payer.[Country], HQCO.[DefaultCountry])) PayerAddress

WHERE Payer.APCo = @APCo
	AND Payer.TaxYear = @TaxYear



---- get creditor/payee information
SELECT  Creditor.VendorGroup, Creditor.Vendor, Creditor.PayeeName,
		ISNULL(Creditor.AusBusNbr, '00000000000') AS [AusBusNbr],
		Creditor.AmendedDate, Creditor.Phone,
		CAST(ROUND(ABS(Creditor.TotalNoABNTax), 0, 1) AS DECIMAL (11,0)) AS [TotalNoABNTax],
		CAST(ROUND(ABS(Creditor.TotalGST), 0, 1)	  AS DECIMAL (11,0)) AS [TotalGST],
		CAST(ROUND(ABS(Creditor.TotalPaid), 0, 1)	  AS DECIMAL (11,0)) AS [TotalPaid],
		CASE WHEN @AmendedDate IS NOT NULL THEN 'A' ELSE 'O' END AS [AmendmentIndicator],
		----TFS-52766
		APVM.AUVendorBSB AS [AUVendorBSB],
		APVM.AUVendorAccountNumber AS [AUVendorAccountNumber],

		ISNULL(CreditorAddress.[Address], '')	AS [Address],
		ISNULL(CreditorAddress.[Address2], '')	AS [Address2],
		ISNULL(CreditorAddress.[City], '')		AS [City],
		ISNULL(CreditorAddress.[State], '')		AS [State],
		ISNULL(CreditorAddress.[PostalCode], '')	AS [PostalCode],
		ISNULL(CreditorAddress.[Country], '')		AS [Country]

FROM dbo.vAPAUPayeeTaxPaymentATO Creditor
INNER JOIN dbo.bHQCO HQCO ON HQCO.HQCo = Creditor.APCo
LEFT JOIN dbo.bAPVM APVM ON APVM.VendorGroup = Creditor.VendorGroup AND APVM.Vendor = Creditor.Vendor

---- TFS-52766 TABLE FUNCTION APPLIED FOR Creditor address values
CROSS APPLY dbo.vfAPAUATOAddressGet(Creditor.[Address], Creditor.[Address2], Creditor.[City], Creditor.[State],
				Creditor.[PostalCode], ISNULL(Creditor.[Country], HQCO.[DefaultCountry])) CreditorAddress



WHERE Creditor.APCo = @APCo
	AND Creditor.TaxYear = @TaxYear
	AND CASE WHEN @AmendedDate IS NOT NULL AND Creditor.AmendedDate = @AmendedDate THEN 0
			 WHEN @AmendedDate IS NOT NULL AND Creditor.AmendedDate <> @AmendedDate THEN 1
			 ELSE 0
			 END = 0





return @rcode







GO
PRINT N'Refreshing [dbo].[vrvRPRTLink]'
GO
EXEC sp_refreshview N'[dbo].[vrvRPRTLink]'
GO
PRINT N'Refreshing [dbo].[PORBGrid]'
GO
EXEC sp_refreshview N'[dbo].[PORBGrid]'
GO
PRINT N'Refreshing [dbo].[PMFMTest]'
GO
EXEC sp_refreshview N'[dbo].[PMFMTest]'
GO
PRINT N'Refreshing [dbo].[APPBChkPrnt]'
GO
EXEC sp_refreshview N'[dbo].[APPBChkPrnt]'
GO
PRINT N'Refreshing [dbo].[brvINDistinctINMI]'
GO
EXEC sp_refreshview N'[dbo].[brvINDistinctINMI]'
GO
PRINT N'Refreshing [dbo].[PRPretaxEDLLookup]'
GO
EXEC sp_refreshview N'[dbo].[PRPretaxEDLLookup]'
GO
PRINT N'Creating [dbo].[vspAPAUATOPayeeTaxPaymentsInit]'
GO






CREATE  procedure [dbo].[vspAPAUATOPayeeTaxPaymentsInit]
/******************************************************
* CREATED BY:	GF 02/26/2013 TFS-42329
* MODIFIED By:	GF 06/10/2013 TFS-52548 deduct discount taken from paid amount
*
* Usage: Calculates Paid Amounts from APTD/APTH for creditors (vendors).
*		 Inserts Creditor information and amounts into vAPAUPayeeTaxPaymentATO table.
*		 Called from APAUPayerTaxPaymentATO form.	
*
*
* Input params:
*
* @APCo			AP Company
* @Taxyear		Reporting Tax Year
* @Overwrite	Flag to indicate if replacing or adding to tax payments.
*			'Y' - all creditor tax payments will be overwritten.
*			'N' - only creditors not already in tax payment table will be added.
*
* Output params:
* @Msg		Code description or error message
*
* Return code:
*	0 = success, 1 = failure
*******************************************************/
(@APCo bCompany = NULL
 ,@TaxYear CHAR(4) = NULL
 ,@Overwrite CHAR(1) = 'Y'
 ,@Msg VARCHAR(255) OUTPUT)
AS
SET NOCOUNT ON

DECLARE @rcode INT, @BeginMth bMonth, @EndMth bMonth, @ValidYear DATETIME,
		@VendorGroup bGroup


SET @rcode = 0
IF @Overwrite IS NULL SET @Overwrite = 'Y'


IF @APCo IS NULL
	BEGIN
	SET @Msg='Missing AP Company!'
	SET @rcode=1
	GOTO vspexit
	END

IF @TaxYear IS NULL
	BEGIN
	SET @Msg='Missing Tax Year!'
	SET @rcode=1
	GOTO vspexit
	END

---- valid year?
SET @ValidYear = CONVERT(DATETIME, '01/01/' + CONVERT(CHAR(4), @TaxYear), 101)
IF ISDATE(@ValidYear) = 0
	BEGIN
 	--SELECT @msg = 'Invalid Tax Year!'
	SET @rcode = 1
	GOTO vspexit
	END  

----validate tax year is not closed
IF EXISTS(SELECT 1 FROM dbo.vAPAUPayerTaxPaymentATO WHERE APCo  =@APCo AND TaxYear = @TaxYear AND TaxYearClosed = 'Y')
	BEGIN
	SET @Msg = 'Cannot initialize tax payments. The tax year is closed.'
	SET @rcode = 1
	GOTO vspexit
	END  

---- get vendor group from HQCo
SELECT @VendorGroup = h.VendorGroup
FROM dbo.APCO c WITH (NOLOCK)
JOIN dbo.HQCO h WITH (NOLOCK) ON h.HQCo = c.APCo
WHERE c.APCo = @APCo
IF @@ROWCOUNT = 0
	BEGIN
	SET @Msg = 'Error retrieving Vendor Group for AP Company.'  
	SET @rcode = 1
	GOTO vspexit
	END

---- create a begin month and end month for the tax year
SET @BeginMth = CONVERT(DATETIME, '07/01/' + CONVERT(CHAR(4),  @TaxYear - 1), 101)
SET @EndMth   = CONVERT(DATETIME, '06/01/' + CONVERT(CHAR(4), @TaxYear), 101)


---- initialize tax payments
BEGIN TRY
	---- start a transaction, commit after fully processed
    BEGIN TRANSACTION;
  
	---- when overwrite flag = 'Y' then first delete existing rows Creditor tax payments
	IF @Overwrite = 'Y'
		BEGIN
		DELETE FROM dbo.vAPAUPayeeTaxPaymentATO WHERE APCo = @APCo AND TaxYear = @TaxYear   
		END

	---- insert a record for each creditor (vendor) that has received payment in the tax year.
	---- the APTH.V1099YN flag is used to validate invoices that are reportable for the creditor.
	INSERT INTO dbo.vAPAUPayeeTaxPaymentATO
	        (
				APCo, TaxYear, VendorGroup, Vendor, PayeeName, AusBusNbr, [Address],
				[Address2], City, [State], PostalCode, [Country], Phone, TotalNoABNTax, TotalGST, TotalPaid,
				AmendedDate
	        )
	SELECT  @APCo, @TaxYear, @VendorGroup, APVM.Vendor, APVM.Name, APVM.AusBusNbr,
			CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Address] ELSE APVM.[Address] END,
			CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Address2] ELSE APVM.[Address2] END,
			CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[City]	   ELSE APVM.[City]    END,
			CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[State]   ELSE APVM.[State]   END,
			CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]     ELSE APVM.[Zip]     END,
			CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Country] ELSE ISNULL(APVM.Country, HQCO.DefaultCountry) END,
			APVM.Phone, 0, ISNULL(TotalTaxAmt, 0), ISNULL(AmtPaidInYear, 0), NULL
	FROM dbo.bAPVM APVM
	INNER JOIN dbo.bHQCO HQCO ON HQCO.HQCo = @APCo
	LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = APVM.VendorGroup AND APAA.Vendor = APVM.Vendor AND APAA.AddressSeq = APVM.V1099AddressSeq
			CROSS APPLY  
			(
			----TFS-52548
			SELECT  SUM(ISNULL(APTD.Amount, 0)) - SUM(ISNULL(APTD.DiscTaken,0)) AmtPaidInYear
				   ,SUM(ISNULL(APTD.TotTaxAmount, 0)) TotalTaxAmt
			 FROM dbo.bAPTD APTD WITH (NOLOCK)
			 INNER JOIN dbo.bAPTH APTH ON APTH.APCo = APTD.APCo AND APTH.Mth = APTD.Mth AND APTH.APTrans = APTD.APTrans
			 WHERE APTD.APCo = @APCo
				AND APTD.Status = 3
				AND APTD.PaidMth BETWEEN @BeginMth AND @EndMth
				AND APTH.Mth = APTD.Mth 
				AND APTH.APTrans = APTD.APTrans
				AND APTH.V1099YN = 'Y'
				AND APTH.VendorGroup = APVM.VendorGroup
				AND APTH.Vendor = APVM.Vendor
			 HAVING SUM(ISNULL(APTD.Amount, 0)) <> 0
			 ) APTD

	WHERE APVM.VendorGroup = @VendorGroup
		AND NOT EXISTS(SELECT 1 FROM dbo.vAPAUPayeeTaxPaymentATO
						WHERE APCo = @APCo
							AND TaxYear = @TaxYear
							AND VendorGroup = APVM.VendorGroup
							AND Vendor = APVM.Vendor)


	---- insert for Creditor payments has completed. commit transaction
	COMMIT TRANSACTION;


END TRY
BEGIN CATCH
    -- Test XACT_STATE:
        -- If 1, the transaction is committable.
        -- If -1, the transaction is uncommittable and should 
        --     be rolled back.
        -- XACT_STATE = 0 means that there is no transaction and
        --     a commit or rollback operation would generate an error.
	IF XACT_STATE() <> 0
		BEGIN
		ROLLBACK TRANSACTION
		SET @Msg = CAST(ERROR_MESSAGE() AS VARCHAR(200)) 
		SET @rcode = 1
		END
END CATCH




			
vspexit:
	RETURN @rcode





GO
PRINT N'Refreshing [dbo].[HRAITypeR]'
GO
EXEC sp_refreshview N'[dbo].[HRAITypeR]'
GO
PRINT N'Refreshing [dbo].[vrvRPV6Upgrade]'
GO
EXEC sp_refreshview N'[dbo].[vrvRPV6Upgrade]'
GO
PRINT N'Refreshing [dbo].[SMWIPTransferBatch]'
GO
EXEC sp_refreshview N'[dbo].[SMWIPTransferBatch]'
GO
PRINT N'Refreshing [dbo].[JCCHPMItems]'
GO
EXEC sp_refreshview N'[dbo].[JCCHPMItems]'
GO
PRINT N'Refreshing [dbo].[brvINMA_MatlCategory]'
GO
EXEC sp_refreshview N'[dbo].[brvINMA_MatlCategory]'
GO
PRINT N'Creating [dbo].[vspAPAUATOPayerTaxYearVal]'
GO



CREATE procedure [dbo].[vspAPAUATOPayerTaxYearVal]
/************************************************************
* CREATED BY:	GF 03/18/2013 AP ATO Processing Enhancement
* MODIFIED By:		
*								
*								
*
* USAGE:
* Validate Tax Year entered for APAUATOEFileGenerate.  Must be a valid Tax Year in APAUPayerTaxPaymentATO.
*
* INPUT PARAMETERS
* @APCo       AP Co
* @TaxYear    Year to validate
*
* OUTPUT PARAMETERS
* @AmendedDate Tax Year last amended date for default
* @errmsg     if something went wrong
* RETURN VALUE
*   0   success
*   1   fail
************************************************************/
(@APCo bCompany = NULL, 
 @TaxYear SMALLINT = NULL,
 @AmendedDate bDate = NULL OUTPUT,
 @msg VARCHAR(255) OUTPUT)
AS
SET NOCOUNT ON

DECLARE @rcode INT

SELECT @rcode = 0

IF @TaxYear IS NULL
	BEGIN
	SET @msg = 'Missing Tax Year!'
	RETURN 1
	END

IF @APCo IS NULL
	BEGIN
	SET @msg = 'Missing AP Company!'
	RETURN 1
	END

IF NOT EXISTS (SELECT 1 FROM dbo.APAUPayerTaxPaymentATO WHERE APCo = @APCo and TaxYear = @TaxYear)
	BEGIN
	SET @msg = 'Tax Year is not set up in ATO Processing!'
	RETURN 1
	END
   
---- get last amended date if there is one
SELECT @AmendedDate = MAX(AmendedDate)
FROM dbo.APAUPayeeTaxPaymentATO
WHERE APCo = @APCo
	AND TaxYear = @TaxYear


RETURN 0


GO
PRINT N'Refreshing [dbo].[vrvSLClaimPaymentSchedule]'
GO
EXEC sp_refreshview N'[dbo].[vrvSLClaimPaymentSchedule]'
GO
PRINT N'Refreshing [dbo].[DDFSUsers]'
GO
EXEC sp_refreshview N'[dbo].[DDFSUsers]'
GO
PRINT N'Refreshing [dbo].[JBER]'
GO
EXEC sp_refreshview N'[dbo].[JBER]'
GO
PRINT N'Refreshing [dbo].[brvINMTCat]'
GO
EXEC sp_refreshview N'[dbo].[brvINMTCat]'
GO
PRINT N'Refreshing [dbo].[APT5]'
GO
EXEC sp_refreshview N'[dbo].[APT5]'
GO
PRINT N'Altering [dbo].[vspAPT5018PRINT]'
GO

ALTER         proc [dbo].[vspAPT5018PRINT]      
    /************************************      
    * Created: MV 12/14/09 - #133633      
    * Modified: MV 06/18/12 - TK15758 restrict Amended refiling by bAPVM.V1099YN = 'Y' (vendor is still subject to T5)       
    *      - TK-16658 select T5ParterFINm, T5SocInsNbr and T5FirstName from APVM for Types O, C and All  
	*	   - TK-16454 07/30/2012 DML :: added v.Type 'C' to @reporttype = 'A' = DML
	*	   - TK-16445 07/30/2012 DML :: added column 'CalcdNo' to combine Corporation / Partnership / Individual IDs
	*		 GF 04/22/2013 TFS-47480 use APVM.V1099AddressSeq for vendor address if there is one.
	*
    * Report SP to print Canadian T5018      
    *      
    ***********************************/      
    (@co bCompany, @perenddate bDate, @reporttype char(1))      
        
   as      
   set nocount on      
        
 if @reporttype = 'A' --Amended refiling      
  begin      
  select isnull(c.Name,'')'HQName',isnull(c.Address,'') 'HQAddress', isnull(c.City,'') 'HQCity', isnull(c.State,'') 'HQState',      
   isnull(c.Country,'') 'HQCountry', isnull(c.Zip,'') 'HQPostal', isnull(c.FedTaxId,'') 'HQBusNbr',isnull(v.Name,'') 'VMName',  
   ----TFS-47400
     		CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Address]  ELSE v.[Address]	END AS [VMAddress],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[City]	 ELSE v.[City]		END AS [VMCity],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[State]    ELSE v.[State]		END AS [VMState],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]      ELSE v.[Zip]		END AS [VMPostal],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Country]  ELSE v.Country		END AS [VMCountry],   
   --isnull(v.Address,'') 'VMAddress', isnull(v.City,'') 'VMCity', isnull(v.State,'') 'VMState', isnull(v.Zip,'') 'VMPostal',      
   --isnull(v.Country,'') 'VMCountry', 
   isnull(v.T5BusTypeCode,'') 'VMBusTypeCode', isnull(v.T5BusinessNbr,'') 'VMBusinessNbr',      
   isnull(v.T5PartnerFIN,'') 'VMPartnerFIN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', isnull(v.T5FirstName,'') 'VMFirstName',      
   isnull(v.T5MiddleInit,'') 'VMMiddleInit', isnull(v.T5LastName,'') 'VMLastName', isnull(t.OrigAmount,'0') 'OrigAmount',      
   isnull(t.Amount,'0') 'AmendedAmount', isnull(t.Type,'') 'T5Type', isnull(t.RefilingYN, 'N') 'RefilingYN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', 'CalcdNo' = case (v.T5BusTypeCode)  
   	when 'C' then v.T5BusinessNbr 
	when 'P' then v.T5PartnerFIN 
	when 'I' then v.T5SocInsNbr 
	else '' 
	end     
  From dbo.APT5 t (nolock)      
	join dbo.HQCO c (nolock) on c.HQCo=t.APCo      
	join dbo.APVM v (nolock) on c.VendorGroup=v.VendorGroup and t.Vendor=v.Vendor  
	----TFS-47480
	LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = v.VendorGroup AND APAA.Vendor = v.Vendor AND APAA.AddressSeq = v.V1099AddressSeq
    where t.APCo=@co and @perenddate=t.PeriodEndDate and t.RefilingYN='Y' and t.Type in ('A','C') AND v.V1099YN = 'Y'      
  end      
    
 if @reporttype = 'O' --Original refiling      
  begin       
  select isnull(c.Name,'')'HQName',isnull(c.Address,'') 'HQAddress', isnull(c.City,'') 'HQCity', isnull(c.State,'') 'HQState',      
   isnull(c.Country,'') 'HQCountry', isnull(c.Zip,'') 'HQPostal', isnull(c.FedTaxId,'') 'HQBusNbr',isnull(v.Name,'') 'VMName',
   ----TFS-47400
     		CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Address]  ELSE v.[Address]	END AS [VMAddress],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[City]	 ELSE v.[City]		END AS [VMCity],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[State]    ELSE v.[State]		END AS [VMState],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]      ELSE v.[Zip]		END AS [VMPostal],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Country]  ELSE v.Country		END AS [VMCountry],   
   ----isnull(v.Address,'') 'VMAddress', isnull(v.City,'') 'VMCity', isnull(v.State,'') 'VMState', isnull(v.Zip,'') 'VMPostal',      
   ----isnull(v.Country,'') 'VMCountry',
   isnull(v.T5BusTypeCode,'') 'VMBusTypeCode', isnull(v.T5BusinessNbr,'') 'VMBusinessNbr',   
   isnull(v.T5PartnerFIN,'') 'VMPartnerFIN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', isnull(v.T5FirstName,'') 'VMFirstName',      
   isnull(v.T5MiddleInit,'') 'VMMiddleInit', isnull(v.T5LastName,'') 'VMLastName', isnull(t.OrigAmount,'0') 'OrigAmount',      
   isnull(t.Amount,'0') 'AmendedAmount', isnull(t.Type,'') 'T5Type', isnull(t.RefilingYN, 'N') 'RefilingYN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', 'CalcdNo' = case (v.T5BusTypeCode)  
   	when 'C' then v.T5BusinessNbr 
	when 'P' then v.T5PartnerFIN 
	when 'I' then v.T5SocInsNbr 
	else '' 
	end      
  From dbo.APT5 t (nolock)  
	join dbo.HQCO c (nolock) on c.HQCo=t.APCo      
	join dbo.APVM v (nolock) on c.VendorGroup=v.VendorGroup and t.Vendor=v.Vendor
	----TFS-47480
	LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = v.VendorGroup AND APAA.Vendor = v.Vendor AND APAA.AddressSeq = v.V1099AddressSeq
  where t.APCo=@co and @perenddate=t.PeriodEndDate and t.RefilingYN='N' and t.Type='O'      
  end      
    
 if @reporttype = 'C' --Cancelled refiling      
  begin      
  select isnull(c.Name,'')'HQName',isnull(c.Address,'') 'HQAddress', isnull(c.City,'') 'HQCity', isnull(c.State,'') 'HQState',      
   isnull(c.Country,'') 'HQCountry', isnull(c.Zip,'') 'HQPostal', isnull(c.FedTaxId,'') 'HQBusNbr',isnull(v.Name,'') 'VMName',  
   ----TFS-47400
     		CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Address]  ELSE v.[Address]	END AS [VMAddress],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[City]	 ELSE v.[City]		END AS [VMCity],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[State]    ELSE v.[State]		END AS [VMState],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]      ELSE v.[Zip]		END AS [VMPostal],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Country]  ELSE v.Country		END AS [VMCountry],   
   --isnull(v.Address,'') 'VMAddress', isnull(v.City,'') 'VMCity', isnull(v.State,'') 'VMState', isnull(v.Zip,'') 'VMPostal',      
   --isnull(v.Country,'') 'VMCountry',
   isnull(v.T5BusTypeCode,'') 'VMBusTypeCode', isnull(v.T5BusinessNbr,'') 'VMBusinessNbr',  
   isnull(v.T5PartnerFIN,'') 'VMPartnerFIN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', isnull(v.T5FirstName,'') 'VMFirstName',      
   isnull(v.T5MiddleInit,'') 'VMMiddleInit', isnull(v.T5LastName,'') 'VMLastName', isnull(t.OrigAmount,'0') 'OrigAmount',      
   isnull(t.Amount,'0') 'AmendedAmount', isnull(t.Type,'') 'T5Type', isnull(t.RefilingYN, 'N') 'RefilingYN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', 'CalcdNo' = case (v.T5BusTypeCode)  
   	when 'C' then v.T5BusinessNbr 
	when 'P' then v.T5PartnerFIN 
	when 'I' then v.T5SocInsNbr 
	else '' 
	end      
  From dbo.APT5 t (nolock)      
	join dbo.HQCO c (nolock) on c.HQCo=t.APCo      
	join dbo.APVM v (nolock) on c.VendorGroup=v.VendorGroup and t.Vendor=v.Vendor
	----TFS-47480
	LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = v.VendorGroup AND APAA.Vendor = v.Vendor AND APAA.AddressSeq = v.V1099AddressSeq   
  where t.APCo=@co and @perenddate=t.PeriodEndDate and t.RefilingYN='Y' and t.Type='C'      
  end      
    
   if @reporttype = 'S' --All (S)lips      
  begin       
  select isnull(c.Name,'')'HQName',isnull(c.Address,'') 'HQAddress', isnull(c.City,'') 'HQCity', isnull(c.State,'') 'HQState',      
   isnull(c.Country,'') 'HQCountry', isnull(c.Zip,'') 'HQPostal', isnull(c.FedTaxId,'') 'HQBusNbr',isnull(v.Name,'') 'VMName',   
   ----TFS-47400
     		CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Address]  ELSE v.[Address]	END AS [VMAddress],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[City]	 ELSE v.[City]		END AS [VMCity],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[State]    ELSE v.[State]		END AS [VMState],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]      ELSE v.[Zip]		END AS [VMPostal],
			CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Country]  ELSE v.Country		END AS [VMCountry], 
   ----isnull(v.Address,'') 'VMAddress', isnull(v.City,'') 'VMCity', isnull(v.State,'') 'VMState', isnull(v.Zip,'') 'VMPostal',      
   ----isnull(v.Country,'') 'VMCountry', 
   isnull(v.T5BusTypeCode,'') 'VMBusTypeCode', isnull(v.T5BusinessNbr,'') 'VMBusinessNbr',  
   isnull(v.T5PartnerFIN,'') 'VMPartnerFIN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', isnull(v.T5FirstName,'') 'VMFirstName',      
   isnull(v.T5MiddleInit,'') 'VMMiddleInit', isnull(v.T5LastName,'') 'VMLastName', isnull(t.OrigAmount,'0') 'OrigAmount',      
   isnull(t.Amount,'0') 'AmendedAmount', isnull(t.Type,'') 'T5Type', isnull(t.RefilingYN, 'N') 'RefilingYN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', 'CalcdNo' = case (v.T5BusTypeCode)  
   	when 'C' then v.T5BusinessNbr 
	when 'P' then v.T5PartnerFIN 
	when 'I' then v.T5SocInsNbr 
	else '' 
	end      
  From dbo.APT5 t (nolock)      
	join dbo.HQCO c (nolock) on c.HQCo=t.APCo      
	join dbo.APVM v (nolock) on c.VendorGroup=v.VendorGroup and t.Vendor=v.Vendor
	----TFS-47480
	LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = v.VendorGroup AND APAA.Vendor = v.Vendor AND APAA.AddressSeq = v.V1099AddressSeq   
  where t.APCo=@co and @perenddate=t.PeriodEndDate       
  end      
    
	
	  
 return       
      
      
      
      
  
GO
PRINT N'Refreshing [dbo].[vrvSLSubContractStatus]'
GO
EXEC sp_refreshview N'[dbo].[vrvSLSubContractStatus]'
GO
PRINT N'Refreshing [dbo].[JCContractOverride]'
GO
EXEC sp_refreshview N'[dbo].[JCContractOverride]'
GO
PRINT N'Refreshing [dbo].[brvINPlantSummary]'
GO
EXEC sp_refreshview N'[dbo].[brvINPlantSummary]'
GO
PRINT N'Altering [dbo].[vspAPT5018XML]'
GO

ALTER            proc [dbo].[vspAPT5018XML]
    /************************************
    * Created: MV 06/23/09 - #27230 
    * Modified:	MV 06/18/12 - TK15758 restrict Amended refiling by bAPVM.V1099YN = 'Y' (vendor is still subject to T5)  
	*			GF 04/22/2013 TFS-47480 use APVM.V1099AddressSeq for vendor address if there is one.  
	*
    * This SP is called from form APT5018 to return a list of vendor info
    *
    ***********************************/
    (@co bCompany, @vendorgroup bGroup, @perenddate bDate, @reporttype char(1))
  
   as
   set nocount on
  
	if @reporttype = 'A' --Amended refiling
		begin
		select isnull(c.Name,'')'HQName',isnull(c.Address,'') 'HQAddress', isnull(c.City,'') 'HQCity', isnull(c.State,'') 'HQState',
			isnull(c.Country,'') 'HQCountry', isnull(c.Zip,'') 'HQPostal', isnull(c.FedTaxId,'') 'HQBusNbr',isnull(v.Name,'') 'VMName',
		    ----TFS-47400
     				CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Address]  ELSE v.[Address]	END AS [VMAddress],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[City]	 ELSE v.[City]		END AS [VMCity],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[State]    ELSE v.[State]		END AS [VMState],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]      ELSE v.[Zip]		END AS [VMPostal],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Country]  ELSE v.Country		END AS [VMCountry], 
			--isnull(v.Address,'') 'VMAddress', isnull(v.City,'') 'VMCity', isnull(v.State,'') 'VMState', isnull(v.Zip,'') 'VMPostal',
			--isnull(v.Country,'') 'VMCountry',
			isnull(v.T5BusTypeCode,'') 'VMBusTypeCode', isnull(v.T5BusinessNbr,'') 'VMBusinessNbr',
			isnull(v.T5PartnerFIN,'') 'VMPartnerFIN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', isnull(v.T5FirstName,'') 'VMFirstName',
			isnull(v.T5MiddleInit,'') 'VMMiddleInit', isnull(v.T5LastName,'') 'VMLastName', isnull(t.Amount,'0') 'T5Amount', isnull(t.Type,'') 'T5Type'
		From dbo.bAPT5 t (nolock)
		join dbo.bAPVM v (nolock) on t.VendorGroup=v.VendorGroup and t.Vendor=v.Vendor
		join dbo.bHQCO c (nolock) on c.HQCo=t.APCo
		----TFS-47480
		LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = v.VendorGroup AND APAA.Vendor = v.Vendor AND APAA.AddressSeq = v.V1099AddressSeq
		where t.APCo=@co and @perenddate=t.PeriodEndDate and t.VendorGroup=@vendorgroup and t.RefilingYN='Y' AND v.V1099YN = 'Y' 
		end
	else
		begin	--Original filing
		select isnull(c.Name,'')'HQName',isnull(c.Address,'') 'HQAddress', isnull(c.City,'') 'HQCity', isnull(c.State,'') 'HQState',
			isnull(c.Country,'') 'HQCountry', isnull(c.Zip,'') 'HQPostal', isnull(c.FedTaxId,'') 'HQBusNbr',isnull(v.Name,'') 'VMName',
		    ----TFS-47400
     				CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Address]  ELSE v.[Address]	END AS [VMAddress],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[City]	 ELSE v.[City]		END AS [VMCity],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[State]    ELSE v.[State]		END AS [VMState],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]      ELSE v.[Zip]		END AS [VMPostal],
					CASE WHEN v.V1099AddressSeq IS NOT NULL THEN APAA.[Country]  ELSE v.Country		END AS [VMCountry], 
			--isnull(v.Address,'') 'VMAddress', isnull(v.City,'') 'VMCity', isnull(v.State,'') 'VMState', isnull(v.Zip,'') 'VMPostal',
			--isnull(v.Country,'') 'VMCountry', 
			isnull(v.T5BusTypeCode,'') 'VMBusTypeCode', isnull(v.T5BusinessNbr,'') 'VMBusinessNbr',
			isnull(v.T5PartnerFIN,'') 'VMPartnerFIN', isnull(v.T5SocInsNbr,'') 'VMSocInsNbr', isnull(v.T5FirstName,'') 'VMFirstName',
			isnull(v.T5MiddleInit,'') 'VMMiddleInit', isnull(v.T5LastName,'') 'VMLastName', isnull(t.OrigAmount,'0') 'T5Amount', isnull(t.Type,'') 'T5Type'
		From dbo.bAPT5 t (nolock)
		join dbo.bAPVM v (nolock) on t.VendorGroup=v.VendorGroup and t.Vendor=v.Vendor
		join dbo.bHQCO c (nolock) on c.HQCo=t.APCo
		----TFS-47480
		LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = v.VendorGroup AND APAA.Vendor = v.Vendor AND APAA.AddressSeq = v.V1099AddressSeq
		where t.APCo=@co and @perenddate=t.PeriodEndDate and t.VendorGroup=@vendorgroup and t.RefilingYN='N'
		end

   

	return 








GO
PRINT N'Refreshing [dbo].[vrvSLTexturaSubconComplianceExport]'
GO
EXEC sp_refreshview N'[dbo].[vrvSLTexturaSubconComplianceExport]'
GO
PRINT N'Refreshing [dbo].[JCContractOverrideCost]'
GO
EXEC sp_refreshview N'[dbo].[JCContractOverrideCost]'
GO
PRINT N'Refreshing [dbo].[brvJBJCChangeOrders]'
GO
EXEC sp_refreshview N'[dbo].[brvJBJCChangeOrders]'
GO
PRINT N'Creating [dbo].[vspAPTaxableCreditorVal]'
GO





CREATE proc [dbo].[vspAPTaxableCreditorVal]
/****************************************************************************
* CREATED BY:	GF 02/13/2013 TFS-41052 AP Taxable Payment Reporting Enhancement
* MODIFIED BY:	GF 06/10/2013 TFS-52548 discount taken deduct from amount paid in year
*
*
* USAGE:
* Validates the Creditor from the AP Taxable Payment Reporting form / AP ATO Payee
* Taxable Payment form and returns vendor information from AP Vendor Master.
* Also retrieves tax year paid gst, total paid, and no abn tax totals.
*
*
* INPUT PARAMETERS:
* @APCo					AP Company
* @TaxYear				AP Reporting Tax Year
* @VendorGroup			AP Vendor Group
* @Creditor				AP Creditor to validate sort name or number
*
*
* OUTPUT PARAMETERS:
* @CreditorOut			Vendor Number
* @PayeeName			Vendor Name
* @Phone				Vendor Phone
* @Address				Vendor Address
* @City					Vendor City
* @State				Vendor State
* @ZipCode				Vendor Zip Code
* @Country				Vendor Country
* @AusBusNbr			Vendor Australia Business No.
* @V1099YN				Subject to Tax restriction
* @TotalPaid			Total Paid to vendor (includes GST)
* @TotalGST				Total GST Paid
* @NoABNTax				Non ABN Tax Amount
* @TotalATOPaid			Total ato paid
* @TotalATOGST			total gst paid
* @CreditorRecordsExist	flag to indicate payee records exist for creditor
* @AmendedRecordsExist	flag to indicate payee amended records exist for creditor
* @Address2				Vendor Address 2
*
*
*
* RETURN VALUE:
* 	0 	    Success
*	1 & message Failure
*
*****************************************************************************/
(@APCo bCompany = NULL
 ,@TaxYear SMALLINT = NULL
 ,@VendorGroup bGroup = NULL
 ,@Creditor VARCHAR(15) = NULL
 ,@CreditorOut bVendor = NULL OUTPUT
 ,@PayeeName VARCHAR(60) = NULL OUTPUT
 ,@Phone VARCHAR(15) = NULL OUTPUT
 ,@Address VARCHAR(60) = NULL OUTPUT
 ,@City VARCHAR(60) = NULL OUTPUT
 ,@State VARCHAR(4) = NULL OUTPUT
 ,@ZipCode VARCHAR(12) = NULL OUTPUT
 ,@Country VARCHAR(2) = NULL OUTPUT
 ,@AUBusNbr VARCHAR(20) = NULL OUTPUT
 ,@V1099YN CHAR(1) = 'N' OUTPUT
 ,@TotalPaid bDollar = 0 OUTPUT
 ,@TotalGST bDollar = 0 OUTPUT
 ,@NoABNTax bDollar = 0 OUTPUT
 ,@TotalATOPaid bDollar = 0 OUTPUT
 ,@TotalATOGST bDollar = 0 OUTPUT
 ,@CreditorRecordsExist VARCHAR(1) = 'N' OUTPUT
 ,@AmendedRecordsExist VARCHAR(1) = 'N' OUTPUT
 ,@Address2 VARCHAR(60) = NULL OUTPUT
 ,@Msg VARCHAR(255) OUTPUT
 )
AS
SET NOCOUNT ON

DECLARE @rcode INT, @BeginMth DATETIME, @EndMth DATETIME,
		@ValidYear DATETIME, @DefaultCountry VARCHAR(2), @V1099AddressSeq TINYINT

SET @rcode = 0
SET @TotalPaid = 0
SET @TotalGST = 0
SET @NoABNTax = 0
SET @CreditorRecordsExist = 'N'
SET @AmendedRecordsExist = 'N'

---- get vendor group from HQCo
SELECT @VendorGroup = ISNULL(@VendorGroup, h.VendorGroup)
		,@DefaultCountry = h.DefaultCountry
FROM dbo.APCO c WITH (NOLOCK)
JOIN dbo.HQCO h WITH (NOLOCK) ON h.HQCo = c.APCo
WHERE c.APCo = @APCo
IF @@ROWCOUNT = 0
	BEGIN
	SET @Msg = 'Error retrieving Vendor Group for AP Company.'  
	SET @rcode = 1
	GOTO vspexit
	END
 

---- If @Creditor is numeric then try to find Creditor number
IF dbo.bfIsInteger(@Creditor) = 1 AND LEN(@Creditor) < 7
	BEGIN
	SELECT	@CreditorOut = v.Vendor, @Msg = v.Name,
			@Address = v.[Address],	@Address2 = v.[Address2], @City = v.City,	@State = v.[State], 
			@ZipCode = v.Zip, @Country = ISNULL(v.Country, ISNULL(@DefaultCountry,'')),
			@V1099YN = v.V1099YN, @AUBusNbr = v.AusBusNbr,
			@PayeeName = v.Name, @Phone = v.Phone,
			@V1099AddressSeq = v.V1099AddressSeq
	FROM dbo.APVM v (NOLOCK)
	WHERE v.VendorGroup = @VendorGroup
		AND v.Vendor = CONVERT(int, CONVERT(float, @Creditor))
	END

---- if not numeric or not found try to find as Sort Name
IF @CreditorOut IS NULL
	BEGIN
	SELECT	@CreditorOut = v.Vendor, @Msg = v.Name,
			@Address = v.[Address],	@Address2 = v.[Address2], @City = v.City,	@State = v.[State], 
			@ZipCode = v.Zip, @Country = ISNULL(v.Country, ISNULL(@DefaultCountry,'')),
			@V1099YN = v.V1099YN, @AUBusNbr = v.AusBusNbr,
			@PayeeName = v.Name, @Phone = v.Phone,
			@V1099AddressSeq = v.V1099AddressSeq
	FROM dbo.APVM v (NOLOCK)
	WHERE v.VendorGroup = @VendorGroup
		AND v.SortName = UPPER(@Creditor)
	ORDER BY v.SortName
    
	---- if not found,  try to find closest
	IF @@ROWCOUNT = 0 
		BEGIN	
		SET ROWCOUNT 1
		SELECT	@CreditorOut = v.Vendor, @Msg = v.Name,
				@Address = v.[Address],	@Address2 = v.[Address2], @City = v.City,	@State = v.[State], 
				@ZipCode = v.Zip, @Country = ISNULL(v.Country, ISNULL(@DefaultCountry,'')),
				@V1099YN = v.V1099YN, @AUBusNbr = v.AusBusNbr,
				@PayeeName = v.Name, @Phone = v.Phone,
				@V1099AddressSeq = v.V1099AddressSeq
		FROM dbo.APVM v (NOLOCK) 
		WHERE	v.VendorGroup = @VendorGroup
			AND v.SortName LIKE UPPER(@Creditor) + '%'
		ORDER BY v.SortName
		IF @@ROWCOUNT = 0
			BEGIN
			SELECT @Msg = 'Not a valid Creditor.'
			RETURN 1
			END
		END
	END

---- if we have a V1099 Address Sequence use to get creditor address
IF @V1099AddressSeq IS NOT NULL
	BEGIN
	SELECT @Address = APAA.[Address], @Address2 = APAA.[Address2], @City = APAA.[City],
			@State = APAA.[State], @ZipCode = APAA.[Zip], 
			@Country = ISNULL(APAA.Country, ISNULL(@DefaultCountry,''))
	FROM dbo.bAPAA APAA
	WHERE APAA.VendorGroup = @VendorGroup
		AND APAA.Vendor = @CreditorOut
		AND APAA.AddressSeq = @V1099AddressSeq
	END

---- tax year must not be null
IF @TaxYear IS NULL
	BEGIN
	--SET @Msg = 'Missing Tax Year!'
	--SET @rcode = 1
	GOTO vspexit
	END
    
---- valid year?
SET @ValidYear = CONVERT(DATETIME, '01/01/' + CONVERT(CHAR(4), @TaxYear), 101)
IF ISDATE(@ValidYear) = 0
	BEGIN
 --	SET @Msg = 'Invalid Tax Year!'
	--SET @rcode = 1
	GOTO vspexit
	END  

---- check if records exist for creditor
IF EXISTS(SELECT 1 FROM dbo.vAPAUPayeeTaxPaymentATO WHERE APCo = @APCo	AND TaxYear = @TaxYear
					AND VendorGroup = @VendorGroup AND Vendor = @CreditorOut)
	BEGIN
	SET @CreditorRecordsExist = 'Y'
	END

---- check if amended records exist for creditor
IF EXISTS(SELECT 1 FROM dbo.vAPAUPayeeTaxPaymentATO WHERE APCo = @APCo	AND TaxYear = @TaxYear
					AND VendorGroup = @VendorGroup AND Vendor = @CreditorOut AND AmendedDate IS NOT NULL)
	BEGIN
	SET @AmendedRecordsExist = 'Y'
	END
    
---- create a begin month and end month for the tax year
SET @BeginMth = CONVERT(DATETIME, '07/01/' + CONVERT(CHAR(4),  @TaxYear - 1), 101)
SET @EndMth = CONVERT(DATETIME, '06/01/' + CONVERT(CHAR(4), @TaxYear), 101)

---- get creditor total paid and total GST paid
----TFS-52548
SELECT @TotalPaid = SUM(ISNULL(APTD.Amount, 0)) - SUM(ISNULL(APTD.DiscTaken, 0))
	  ,@TotalGST  = SUM(ISNULL(APTD.TotTaxAmount, 0))
FROM dbo.bAPTD APTD WITH (NOLOCK)
INNER JOIN dbo.bAPTH APTH ON APTH.APCo=APTD.APCo AND APTH.Mth=APTD.Mth AND APTH.APTrans=APTD.APTrans
WHERE APTD.APCo = @APCo
	AND APTD.Status = 3
	AND APTD.PaidMth BETWEEN @BeginMth AND @EndMth
	AND APTH.Vendor = @CreditorOut
	AND APTH.InUseBatchId IS NULL
HAVING SUM(ISNULL(APTD.Amount, 0)) <> 0

---- get creditor total paid and total GST paid for invoices where V1099YN = 'Y'
----TFS-52548
SELECT @TotalATOPaid = SUM(ISNULL(APTD.Amount, 0)) - SUM(ISNULL(APTD.DiscTaken, 0))
	  ,@TotalATOGST  = SUM(ISNULL(APTD.TotTaxAmount, 0))
FROM dbo.bAPTD APTD WITH (NOLOCK)
INNER JOIN dbo.bAPTH APTH ON APTH.APCo=APTD.APCo AND APTH.Mth=APTD.Mth AND APTH.APTrans=APTD.APTrans
WHERE APTD.APCo = @APCo
	AND APTD.Status = 3
	AND APTD.PaidMth BETWEEN @BeginMth AND @EndMth
	AND APTH.Vendor = @CreditorOut
	AND APTH.V1099YN = 'Y'
	AND APTH.InUseBatchId IS NULL
HAVING SUM(ISNULL(APTD.Amount, 0)) <> 0



vspexit:
	return @rcode





GO
PRINT N'Refreshing [dbo].[vrvSLTexturaSubcontractExport]'
GO
EXEC sp_refreshview N'[dbo].[vrvSLTexturaSubcontractExport]'
GO
PRINT N'Refreshing [dbo].[EMSMLastReadDate]'
GO
EXEC sp_refreshview N'[dbo].[EMSMLastReadDate]'
GO
PRINT N'Refreshing [dbo].[DDFormRelated]'
GO
EXEC sp_refreshview N'[dbo].[DDFormRelated]'
GO
PRINT N'Refreshing [dbo].[JCFutureJCCO]'
GO
EXEC sp_refreshview N'[dbo].[JCFutureJCCO]'
GO
PRINT N'Refreshing [dbo].[brvJBPrevRetainUtil]'
GO
EXEC sp_refreshview N'[dbo].[brvJBPrevRetainUtil]'
GO
PRINT N'Creating [dbo].[vspAPTaxablePaymentGridFill]'
GO




CREATE proc [dbo].[vspAPTaxablePaymentGridFill]
/****************************************************************************
* CREATED BY:	GF 02/13/2013 TFS-41052 AP Taxable Payment Reporting Enhancement
* MODIFIED BY:	GF 06/10/2013 TFS-52548 discount taken deduct from amount paid
*
*
* USAGE:
* Fills grid with available AP Invoices that can be updated with the AP Invoice
* header reportable flag. APTH.V1099YN ?
*
*
* INPUT PARAMETERS:
* @APCo					AP Company
* @TaxYear				AP Reporting Tax Year
* @Creditor				AP Vendor restriction
* @ShowSubjectToTax		Subject to Tax restriction
*						'Y' - V1099YN = 'Y'
*						'N' - V1099YN = 'Y' OR 'N'
*
*
* OUTPUT PARAMETERS:
*	See Select statement below
*
* RETURN VALUE:
* 	0 	    Success
*	1 & message Failure
*
*****************************************************************************/
(@APCo bCompany = NULL,
 @TaxYear SMALLINT = NULL, 
 @Creditor bVendor = NULL,
 @ShowSubjectToTax CHAR(1) = 'N'
 )
AS
SET NOCOUNT ON

DECLARE @rcode INT, @BeginMth DATETIME, @EndMth DATETIME, @ValidYear DATETIME,
		@Style INT

SET @rcode = 0
SET @Style = 101

----assume all if missing show subject to tax option
IF @ShowSubjectToTax IS NULL SET @ShowSubjectToTax = 'N'


---- get date display style from HQ Company
SELECT @Style = CASE HQCO.ReportDateFormat WHEN 1 THEN 101
										   WHEN 2 THEN 103
										   WHEN 3 THEN 111
										   ELSE 101
										   END
FROM dbo.HQCO HQCO WHERE HQCO.HQCo = @APCo


---- tax year must not be null
IF @TaxYear IS NULL
	BEGIN
	--SELECT @msg = 'Missing Tax Year!'
	SET @rcode = 1
	GOTO vspexit
	END
    
---- valid year?
SET @ValidYear = CONVERT(DATETIME, '01/01/' + CONVERT(CHAR(4), @TaxYear), 101)
IF ISDATE(@ValidYear) = 0
	BEGIN
 	--SELECT @msg = 'Invalid Tax Year!'
	SET @rcode = 1
	GOTO vspexit
	END  

---- create a begin month and end month for the tax year
SET @BeginMth = CONVERT(DATETIME, '07/01/' + CONVERT(CHAR(4),  @TaxYear - 1), 101)
SET @EndMth   = CONVERT(DATETIME, '06/01/' + CONVERT(CHAR(4), @TaxYear), 101)

---- create result set to fill grid for with inovices that have been paid with the tax year
SELECT   APTH.KeyID			AS [KeyID]
		,APTH.V1099YN		AS [Reportable]
		,APTH.V1099YN		AS [V1099YN]
		,CAST(CAST(DATEPART(mm, APTH.Mth) AS VARCHAR(2)) + '/' + CAST(DATEPART(yyyy, APTH.Mth) AS VARCHAR(4)) AS VARCHAR) AS [ExpMth]
		,APTH.APTrans		AS [APTrans]
		,APTH.APRef			AS [APRef]
		,APTH.[Description] AS [Description]
		,CONVERT(VARCHAR(20), APTH.InvDate, @Style) AS [InvDate]
		,APTH.InvTotal		AS [InvTotal]
		,ISNULL(InvRetention,0)	AS [InvRetention]
		,AmtPaidInYear		AS [AmtPaidInYear]
		,TotalTaxAmt		AS [TotalTaxAmt]
from dbo.APTH APTH WITH (NOLOCK)
	OUTER APPLY
		(
		 SELECT  SUM(ISNULL(APTL.Retainage, 0)) InvRetention
		 FROM dbo.bAPTL APTL WITH (NOLOCK)
		 WHERE APTH.APCo = APTL.APCo 
		 AND APTH.Mth = APTL.Mth 
		 AND APTH.APTrans = APTL.APTrans
		 ) APTL
	CROSS APPLY  
	    (
		 ----TFS-52548
		 SELECT  SUM(ISNULL(APTD.Amount, 0)) - SUM(ISNULL(APTD.DiscTaken, 0)) AmtPaidInYear
			   ,SUM(ISNULL(APTD.TotTaxAmount, 0)) TotalTaxAmt
		 FROM dbo.bAPTD APTD WITH (NOLOCK)
		 WHERE APTH.APCo = APTD.APCo 
		 AND APTH.Mth = APTD.Mth 
		 AND APTH.APTrans = APTD.APTrans
		 AND APTD.Status = 3
		 AND APTD.PaidMth BETWEEN @BeginMth AND @EndMth
		 HAVING SUM(ISNULL(APTD.Amount, 0)) <> 0
		 ) APTD
WHERE APTH.APCo = @APCo
	AND APTH.Vendor = ISNULL(@Creditor, APTH.Vendor)
	AND (@ShowSubjectToTax = 'N'
		OR (@ShowSubjectToTax = 'Y' AND APTH.V1099YN = 'Y'))
	AND APTH.InUseBatchId IS NULL
ORDER BY APTH.APCo, APTH.Mth, APTH.APTrans



	
vspexit:
	return @rcode




GO
PRINT N'Refreshing [dbo].[HRATbyHRRef]'
GO
EXEC sp_refreshview N'[dbo].[HRATbyHRRef]'
GO
PRINT N'Refreshing [dbo].[vrvSMAgreementPriceTaxTotal]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMAgreementPriceTaxTotal]'
GO
PRINT N'Refreshing [dbo].[EMSMLastReadDateEndOdo]'
GO
EXEC sp_refreshview N'[dbo].[EMSMLastReadDateEndOdo]'
GO
PRINT N'Refreshing [dbo].[JCFutureRevenueCO]'
GO
EXEC sp_refreshview N'[dbo].[JCFutureRevenueCO]'
GO
PRINT N'Refreshing [dbo].[udCustomerDefaults]'
GO
EXEC sp_refreshview N'[dbo].[udCustomerDefaults]'
GO
PRINT N'Refreshing [dbo].[APRH]'
GO
EXEC sp_refreshview N'[dbo].[APRH]'
GO
PRINT N'Refreshing [dbo].[JBIDGrid]'
GO
EXEC sp_refreshview N'[dbo].[JBIDGrid]'
GO
PRINT N'Refreshing [dbo].[brvJBRetainageException]'
GO
EXEC sp_refreshview N'[dbo].[brvJBRetainageException]'
GO
PRINT N'Refreshing [dbo].[PRRM]'
GO
EXEC sp_refreshview N'[dbo].[PRRM]'
GO
PRINT N'Creating [dbo].[vspAPTaxablePaymentUpdate]'
GO





CREATE proc [dbo].[vspAPTaxablePaymentUpdate]
/****************************************************************************
* CREATED BY:	GF 03/14/2013 TFS-43705 AP ATO enhancement
* MODIFIED BY:	GF 06/11/2013 TFS-52548 add history if vendor/creditor does not exist yet part of discount taken deduct from amount paid
*
*
*
* USAGE:
* updates APTH V1099YN flag and the tax year payment history payee amounts for the creditor (vendor).
* Called from the AP Taxable Payments Reporting Update process form.
*
* The update process form allows the user to check or uncheck the V1099YN flag.
* If there is an existing payee record for the creditor, then the Total Paid and Total GST
* will be updated with the invoice amounts.
* When flag is 'Y', then adding too
* When flag is 'N', then deducting from.
*
*
* INPUT PARAMETERS:
* @APCo					AP Company
* @TaxYear				Tax Year to update payee record for creditor when exists
* @VendorGroup			AP Vendor Group
* @Creditor				AP Creditor to update taxable payment
* @APTH_KeyId			APTH Record id to be updated. Also identifies vendor to update in history
* @Reportable			Value of V1099YN flag to update, can be either 'Y' or 'N'
* @TotalPaid			Amount paid in year
* @TotalGST				GST paid in year
*
*
* OUTPUT PARAMETERS:
*
* RETURN VALUE:
* 	0 	    Success
*	1 & message Failure
*
*****************************************************************************/
(@APCo			bCompany = NULL
,@TaxYear		SMALLINT = NULL
,@VendorGroup	bGroup	 = NULL
,@Creditor		bVendor	 = NULL
,@APTH_KeyId	BIGINt  = NULL
,@Reportable	CHAR(1) = 'Y'
,@TotalPaid		bDollar = 0
,@TotalGST		bDollar = 0
,@Msg			VARCHAR(255) OUTPUT
 )
AS
SET NOCOUNT ON

DECLARE @rcode INT, @ValidYear DATETIME, @BeginMth bMonth, @EndMth bMonth

SET @rcode = 0

---- tax year must not be null
IF @TaxYear IS NULL
	BEGIN
	SET @Msg = 'Missing Tax Year!'
	SET @rcode = 1
	GOTO vspexit
	END
    
---- valid year?
SET @ValidYear = CONVERT(DATETIME, '01/01/' + CONVERT(CHAR(4), @TaxYear), 101)
IF ISDATE(@ValidYear) = 0
	BEGIN
 	SET @Msg = 'Invalid Tax Year!'
	SET @rcode = 1
	GOTO vspexit
	END  

---- check Reportable flag
IF @Reportable IS NULL
	BEGIN
 	SET @Msg = 'Missing Invoice Reportable Flag!'
	SET @rcode = 1
	GOTO vspexit
	END 

---- make sure tax year is not closed
IF EXISTS(SELECT 1 FROM dbo.vAPAUPayerTaxPaymentATO WHERE APCo = @APCo AND TaxYear = @TaxYear AND TaxYearClosed = 'Y')
	BEGIN
    SET @Msg = 'Tax Year has been closed. Updates not allowed!'
	SET @rcode = 1
	GOTO vspexit
	END
    
---- update APTH.V1099YN flag
UPDATE dbo.bAPTH SET V1099YN = @Reportable
WHERE KeyID = @APTH_KeyId
IF @@ROWCOUNT = 0
	BEGIN
    SET @Msg = 'Error occurred updating APTH Reporting Flag!'
	SET @rcode = 1
	GOTO vspexit
	END


---- if we have an AP ATO Payee record for the tax year and creditor then update
IF EXISTS(SELECT 1 FROM dbo.vAPAUPayeeTaxPaymentATO WHERE APCo = @APCo
					AND TaxYear = @TaxYear
					AND VendorGroup = @VendorGroup
					AND Vendor = @Creditor)
	BEGIN
	UPDATE dbo.vAPAUPayeeTaxPaymentATO
			SET  TotalPaid = CASE WHEN @Reportable = 'Y'
								  THEN TotalPaid + @TotalPaid
								  ELSE TotalPaid - @TotalPaid
								  END
				,TotalGST = CASE WHEN @Reportable = 'Y'
								  THEN TotalGST + @TotalGST
								  ELSE TotalGST - @TotalGST
								  END
	WHERE APCo = @APCo
		AND TaxYear = @TaxYear
		AND VendorGroup = @VendorGroup
		AND Vendor = @Creditor
	END
ELSE
	BEGIN
  
	---- create a begin month and end month for the tax year
	SET @BeginMth = CONVERT(DATETIME, '07/01/' + CONVERT(CHAR(4),  @TaxYear - 1), 101)
	SET @EndMth   = CONVERT(DATETIME, '06/01/' + CONVERT(CHAR(4), @TaxYear), 101)  


	---- if tax year exists but no creditor then add to history  
	IF EXISTS(SELECT 1 FROM dbo.vAPAUPayerTaxPaymentATO WHERE APCo = @APCo AND TaxYear = @TaxYear)
		BEGIN
		IF NOT EXISTS(SELECT 1 FROM dbo.vAPAUPayeeTaxPaymentATO WHERE APCo = @APCo
							AND TaxYear = @TaxYear
							AND VendorGroup = @VendorGroup
							AND Vendor = @Creditor)
			BEGIN
			---- insert a record for each creditor (vendor) that has received payment in the tax year.
			---- the APTH.V1099YN flag is used to validate invoices that are reportable for the creditor.
			INSERT INTO dbo.vAPAUPayeeTaxPaymentATO
					(
						APCo, TaxYear, VendorGroup, Vendor, PayeeName, AusBusNbr, [Address],
						[Address2], City, [State], PostalCode, [Country], Phone, TotalNoABNTax, TotalGST, TotalPaid,
						AmendedDate
					)
			SELECT  @APCo, @TaxYear, @VendorGroup, @Creditor, APVM.Name, APVM.AusBusNbr,
					CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Address] ELSE APVM.[Address] END,
					CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Address2] ELSE APVM.[Address2] END,
					CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[City]	   ELSE APVM.[City]    END,
					CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[State]   ELSE APVM.[State]   END,
					CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Zip]     ELSE APVM.[Zip]     END,
					CASE WHEN APVM.V1099AddressSeq IS NOT NULL THEN APAA.[Country] ELSE ISNULL(APVM.Country, HQCO.DefaultCountry) END,
					APVM.Phone, 0, ISNULL(TotalTaxAmt, 0), ISNULL(AmtPaidInYear, 0), NULL
			FROM dbo.bAPVM APVM
			INNER JOIN dbo.bHQCO HQCO ON HQCO.HQCo = @APCo
			LEFT JOIN dbo.bAPAA APAA ON APAA.VendorGroup = APVM.VendorGroup AND APAA.Vendor = APVM.Vendor AND APAA.AddressSeq = APVM.V1099AddressSeq
					CROSS APPLY  
					(
					----TFS-52548
					SELECT  SUM(ISNULL(APTD.Amount, 0)) - SUM(ISNULL(APTD.DiscTaken,0)) AmtPaidInYear
						   ,SUM(ISNULL(APTD.TotTaxAmount, 0)) TotalTaxAmt
					 FROM dbo.bAPTD APTD WITH (NOLOCK)
					 INNER JOIN dbo.bAPTH APTH ON APTH.APCo = APTD.APCo AND APTH.Mth = APTD.Mth AND APTH.APTrans = APTD.APTrans
					 WHERE APTD.APCo = @APCo
						AND APTD.Status = 3
						AND APTD.PaidMth BETWEEN @BeginMth AND @EndMth
						AND APTH.Mth = APTD.Mth 
						AND APTH.APTrans = APTD.APTrans
						AND APTH.V1099YN = 'Y'
						AND APTH.VendorGroup = @VendorGroup
						AND APTH.Vendor = @Creditor
					 HAVING SUM(ISNULL(APTD.Amount, 0)) <> 0
					 ) APTD

			WHERE APVM.VendorGroup = @VendorGroup
				AND APVM.Vendor = @Creditor
				AND NOT EXISTS(SELECT 1 FROM dbo.vAPAUPayeeTaxPaymentATO
								WHERE APCo = @APCo
									AND TaxYear = @TaxYear
									AND VendorGroup = @VendorGroup
									AND Vendor = @Creditor)
			END
		END          
	END  



	
vspexit:
	return @rcode





GO
PRINT N'Refreshing [dbo].[vrvSMContactList]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMContactList]'
GO
PRINT N'Refreshing [dbo].[EMSMMaxReadingDateEndOdo]'
GO
EXEC sp_refreshview N'[dbo].[EMSMMaxReadingDateEndOdo]'
GO
PRINT N'Refreshing [dbo].[JCIPForJCIR]'
GO
EXEC sp_refreshview N'[dbo].[JCIPForJCIR]'
GO
PRINT N'Refreshing [dbo].[brvJBTaxRate]'
GO
EXEC sp_refreshview N'[dbo].[brvJBTaxRate]'
GO
PRINT N'Creating [dbo].[vspAPTaxableTaxYearVal]'
GO





CREATE proc [dbo].[vspAPTaxableTaxYearVal]
/****************************************************************************
* CREATED BY:	GF 03/12/2013 TFS-00000 AP Taxable Payment Reporting Enhancement
* MODIFIED BY:
*
*
* USAGE:
* Validates the Tax Year from the AP Taxable Payment Reporting form and returns 
* ATO tax year information if set up in AP Payer/Payee ATO tables.
*
*
* INPUT PARAMETERS:
* @APCo					AP Company
* @TaxYear				AP Reporting Tax Year
*
*
* OUTPUT PARAMETERS:
* @TaxYearClosed			Tax Year Closed Flag
*
*
*
* RETURN VALUE:
* 	0 	    Success		no error returned to form, always 0
*
*****************************************************************************/
(@APCo bCompany = NULL
 ,@TaxYear SMALLINT = NULL
 ,@TaxYearClosed VARCHAR(1) = 'N' OUTPUT
 ,@Msg VARCHAR(255) OUTPUT
 )
AS
SET NOCOUNT ON

DECLARE @rcode INT

SET @rcode = 0
SET @TaxYearClosed = 'N'

---- check if tax year is closed
IF EXISTS(SELECT 1 FROM dbo.vAPAUPayerTaxPaymentATO WHERE APCo = @APCo AND TaxYear = @TaxYear
					AND TaxYearClosed = 'Y')
	BEGIN
	SET @TaxYearClosed = 'Y'
	END







vspexit:
	return @rcode





GO
PRINT N'Refreshing [dbo].[vrvSMOpenPurchaseOrder]'
GO
EXEC sp_refreshview N'[dbo].[vrvSMOpenPurchaseOrder]'
GO
PRINT N'Refreshing [dbo].[PMIMMaster]'
GO
EXEC sp_refreshview N'[dbo].[PMIMMaster]'
GO
PRINT N'Refreshing [dbo].[JCIRForJCCP]'
GO
EXEC sp_refreshview N'[dbo].[JCIRForJCCP]'
GO
PRINT N'Refreshing [dbo].[APRLGrid]'
GO
EXEC sp_refreshview N'[dbo].[APRLGrid]'
GO
PRINT N'Refreshing [dbo].[brvJBTemplateInfo]'
GO
EXEC sp_refreshview N'[dbo].[brvJBTemplateInfo]'
GO
PRINT N'Altering [dbo].[vspEMACProcess]'
GO

ALTER      proc [dbo].[vspEMACProcess]
/*************************************
* CREATED BY: AE   4/16/99
* Re-Write BY TerryLis 12/18/07 for VP6.1 Issue 120566
* MODIFIED By: DAN SO - 05/08/08 - Issue: 128084 - Default UM 'LS' when inserting into bEMBF
*				TRL Issue 129249 07/31/08 Fixed error converting EMEM ud field for Alloc amt/rate
*				TRL Issue 131067 01/12/08 Fixed negative rounding issue when/if alloc is ran twice
*				TRL Issue 134913 added "and @EMAHamtrateflag<>'C'"
*				TRL Issue 136527  added rounding code distribution code
*				AMR 01/17/11 - #142350, making case insensitive by removing unused vars and renaming same named variables-  
*				GF 08/23/2012 TK-17328 check allocated vs basis rounding problem for variable 'ud' only with basis column
*				GF 03/18/2013 TFS-44145 148251 error in rounding correction for ud column that is amount and basis
*				GF 04/10/2013 TFS-46839 fix for EMEM.ReplCost and variable allocation.
*
*
* USAGE:
 * used by EMACRUN to process an allocation
 *
 * Pass in :
 *	EMCo, Mth, BatchId, AllocationCode, AllocationDate, Equip, Dept, Categ, Amt, Rate
 *      BeginDate, EndDate, GetBasis, Reversal, Basis
 *
 * NOTE:  If MthDateFlag is M then Begin and End Date are not used
 *
 * Returns
 *	BasisAmount, Error message and return code
 *
 * Error returns no rows
*******************************/
(@emco bCompany, 
@mth bMonth, 
@batchid bBatchID, 
@alloccode smallint, 
@actualdate bDate,
@equipment bEquip, 
@department bDept, 
@category varchar(10), 
@allocamt bDollar, 
@allocrate bRate, 
@begindate bDate, 
@enddate bDate,
@reversal tinyint =0,
@getbasis tinyint=0,
@basis bDollar output, 
@errmsg varchar(255) = null output)

as

set nocount on
    
declare @rcode int, 
/*HQ Group info*/
@matlgroup bGroup,
@emgroup bGroup,
/*EMAH Allocation info*/
@EMAHselectcategory varchar(1), 
@EMAHselectdepartment varchar(1), 
@EMAHselectequipment varchar(1),
@EMAHallocbasis varchar(1),
@EMAHamtrateflag varchar(1), 
@EMAHbasiscolumn varchar(30),
@EMAHamtcolumn varchar(30), 
@EMAHratecolumn varchar(30), 
@EMAHmthdateflag varchar(1), 
@EMAHcostcode bCostCode, 
@EMAHcosttype bEMCType, 
@EMAHdebitacct bGLAcct, 
@EMAHcreditacct bGLAcct,
@EMAHglco bCompany, 
/*Cost allocation variables*/
@AllocType int,  
@CCode bCostCode, 
@CType bEMCType, 
/*Used for select string for cursor, 
converts @emco parameter to string*/
@VEMCo varchar(3),
/*Return amt from cursor select statements 
for 'V' Allocation typs*/
@variablebasis numeric(12, 2),
--#142350 - renaming @Equipment
@Equip bEquip, 

/*Used all through procedure*/
@alloctotal bDollar, 
@BasisInsert numeric(12, 2), 
@batchseq int,
--#142350 - renaming @Department
@Dept bDept,
@Description bDesc, 
@EMCoInsert bCompany, 
@EquipInsert bEquip, 
@numrows int, 

@opencursor tinyint,  
@addemco bCompany, 
@addequip bJob, 
@addallocamt bDollar,

@status tinyint,
@TestEquip bEquip,
@Type char(1),
@CompOfEquip bEquip,
@ComponentTypeCode varchar(10),
@Component bEquip,

@opencursor2 tinyint,
@costemco bCompany,
@costequip bJob,
@costccode bCostCode,
@costctype bEMCType,
@costBasisInsert numeric(12, 2),
@sql varchar(100),

@alloctoadjust bDollar
    
create table #EquipTable (EMCo tinyint not null,
	Equip varchar(20) not null,
    Basis numeric(12, 2) not null,
    AllocAmt numeric(12, 2) not null,
    AllocRate numeric(8, 6) null,
    Dept varchar(10),--not null, TV 07/12/2005 - issue 29254 - Allow Deptartment to be Null.
    Categ varchar(10),
	EMGroup tinyint not null)--not null)
    
CREATE UNIQUE INDEX bitmpProjInit ON #EquipTable (EMCo, Equip)

create table #BaseTable (EMCo tinyint not null,
	Equip varchar(20) not null,
	RevCode varchar(10) null,
	Basis numeric(12, 2) not null,
	EMGroup tinyint not null)
    
create table #CostTable (EMCo tinyint not null,
	Equipment varchar(20) not null,
   	CCode varchar(10) not null,
   	CType tinyint not null,
   	BasisInsert numeric(12, 2) not null)
    
select @VEMCo = convert(varchar(3),@emco),  @alloctoadjust = 0, @rcode = 0

/* Get MatlGroup, EMGroup*/
select @matlgroup = MatlGroup , @emgroup = EMGroup from dbo.HQCO with (nolock) where HQCo = @emco
  
/* Validate Batch info */
exec @rcode = bspHQBatchProcessVal @emco, @mth, @batchid, 'EMAlloc', 'EMBF', @errmsg output, @status output
    
if @rcode <> 0
begin
	select '@errmsg= ' + isnull(convert(varchar(20),@errmsg),'')
    select @errmsg = @errmsg, @rcode = 1
    goto vspexit
end

if @status <> 0
begin
	select @errmsg = 'Invalid Batch status!', @rcode = 1
	goto vspexit
end

/*Start by getting information about the allocation code */
select @EMAHselectequipment=SelectEquip, @EMAHselectdepartment=SelectDept, @EMAHselectcategory = SelectCatgy,
	@EMAHallocbasis=AllocBasis, @EMAHamtrateflag=AmtRateFlag, @EMAHbasiscolumn = BasisCol,
    @EMAHamtcolumn=EquipAmtCol, @EMAHratecolumn=EquipRateCol, @EMAHmthdateflag=MthDateFlag,
    @EMAHcostcode=CostCode, @EMAHcosttype=CostType, @EMAHglco=GLCo,
    @EMAHdebitacct=GLDebitAcct, @EMAHcreditacct=GLCreditAcct, @Description=Description
from dbo.EMAH with (nolock)
where EMCo=@emco and AllocCode=@alloccode
if @@rowcount <> 1
begin
	select @errmsg = 'Invalid Allocation code!', @rcode = 1
	goto vspexit
end

if @EMAHamtcolumn is null and @allocamt is null and @EMAHamtrateflag = 'A' and @EMAHallocbasis <> 'V'
begin
	select @errmsg = 'Missing allocation amount or equipment column, cannot create!', @rcode = 1
	goto vspexit
end

if @EMAHratecolumn is null and @allocrate is null and @EMAHamtrateflag = 'R' and @EMAHallocbasis <> 'V'
begin
	select @errmsg = 'Missing allocation rate or equipment column, cannot create!', @rcode = 1
	goto vspexit
end

--Retrieve Equipment to allocations
/* Cannot be Inactive since this is validated at form level  - Issue 16224 */
If @EMAHselectequipment ='E' and @EMAHselectdepartment ='D' and @EMAHselectcategory ='C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM  with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment IN (select Equipment from dbo.EMAE with (nolock) where EMCo=@emco and AllocCode = @alloccode)
	and	EMEM.Department IN(select Department from dbo.EMAD with (nolock) where EMCo=@emco and AllocCode = @alloccode)
	and	EMEM.Category IN (select Category from dbo.EMAG with (nolock) where EMCo=@emco and AllocCode = @alloccode)
end

If @EMAHselectequipment ='E' and @EMAHselectdepartment ='D' and @EMAHselectcategory <>'C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM  with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment IN(select Equipment from dbo.EMAE with (nolock) where EMCo=@emco and AllocCode = @alloccode)
	and	EMEM.Department IN (select Department from dbo.EMAD with (nolock) where EMCo=@emco and AllocCode = @alloccode)
	and	EMEM.Category = case  @EMAHselectcategory when  'A' then EMEM.Category
												  when  'P' then @category end 	
end

If @EMAHselectequipment ='E' and @EMAHselectdepartment <>'D' and @EMAHselectcategory ='C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM  with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment IN (select Equipment from dbo.EMAE with (nolock) where EMCo=@emco and AllocCode = @alloccode)
	and	EMEM.Department = case  @EMAHselectdepartment when 'A' then EMEM.Department
													  when  'P' then @department end
	and	EMEM.Category IN(select Category from dbo.EMAG with (nolock) where EMCo=@emco and AllocCode = @alloccode)
end

If @EMAHselectequipment ='E' and @EMAHselectdepartment <>'D' and @EMAHselectcategory <>'C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM  with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment IN (select Equipment from dbo.EMAE with (nolock) where EMCo=@emco and AllocCode = @alloccode)
	and	EMEM.Department = case  @EMAHselectdepartment when 'A' then EMEM.Department
													  when  'P' then @department end
	and	EMEM.Category = case  @EMAHselectcategory when  'A' then EMEM.Category
												  when  'P' then @category end 	
end

If @EMAHselectequipment <>'E' and @EMAHselectdepartment ='D' and @EMAHselectcategory <>'C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM  with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment = case @EMAHselectequipment when  'A' then EMEM.Equipment
												  when  'P' then  @equipment end
	and	EMEM.Department IN (select Department from dbo.EMAD with (nolock) where EMCo=@emco and AllocCode = @alloccode)					  
	and	EMEM.Category = case  @EMAHselectcategory when  'A' then EMEM.Category
												  when  'P' then @category end 	
end

If @EMAHselectequipment <>'E' and @EMAHselectdepartment ='D' and @EMAHselectcategory ='C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM  with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment = case @EMAHselectequipment when  'A' then EMEM.Equipment
								 				  when  'P' then  @equipment end
	and	EMEM.Department IN (select Department from dbo.EMAD with (nolock) where EMCo=@emco and AllocCode = @alloccode)					  
	and	EMEM.Category IN (select Category from dbo.EMAG with (nolock) where EMCo=@emco and AllocCode = @alloccode)
end

If @EMAHselectequipment <>'E' and @EMAHselectdepartment <>'D' and @EMAHselectcategory ='C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
	and	EMEM.Equipment = case @EMAHselectequipment when  'A' then EMEM.Equipment
								 				  when  'P' then  @equipment end
	and	EMEM.Department = case  @EMAHselectdepartment when 'A' then EMEM.Department
					  								  when  'P' then @department end
	and	EMEM.Category In(select Category from dbo.EMAG with (nolock) where EMCo=@emco and AllocCode = @alloccode)
end

If @EMAHselectequipment <>'E' and @EMAHselectdepartment <>'D' and @EMAHselectcategory <>'C'
begin
	insert into #EquipTable(EMCo, Equip, Basis, AllocAmt, Dept, Categ, EMGroup)
	select EMEM.EMCo,EMEM.Equipment,0,0,EMEM.Department,EMEM.Category, @emgroup
	From dbo.EMEM with(nolock)
	Where EMEM.EMCo=@emco and EMEM.Status <> 'I' 
		and	EMEM.Equipment = case @EMAHselectequipment when  'A' then EMEM.Equipment
								 				  when  'P' then  @equipment end
	and	EMEM.Department = case  @EMAHselectdepartment when 'A' then EMEM.Department
					  								  when  'P' then @department end
	and	EMEM.Category = case  @EMAHselectcategory when  'A' then EMEM.Category
												  when  'P' then @category end
end
--Exit Procedure if no equipment has been selected
select @numrows = count(*) from #EquipTable
if @numrows=0
begin
   	select @errmsg = 'No Equipment selected for allocation!', @rcode=1
	goto vspexit
end

------------------------------------------------------------------------
/* Calculate the basis amounts */
select '@EMAHallocbasis= ' + isnull(convert(varchar(20),@EMAHallocbasis),'')
if @EMAHallocbasis = 'R' or @EMAHallocbasis = 'H' or @EMAHallocbasis = 'V'
BEGIN
	--1. Varaible Allocations
	if @EMAHallocbasis = 'V'
	begin
		--1.  Cycle through temp table #EquipTable through while statement
		--	  Can't include temp table in cursor, update statement 
		--2.  get amount from specified field in EMAH (EM Allocations)
		--3.  Create cursor to get amount for equipment and update information into the base table
		--4.  Add record to #BaseTable tht holds Revenue Code and basis mount
		select @Equip = min(Equip) from #EquipTable
    	while IsNull(@Equip,'') <> ''
    	begin
			select @variablebasis = 0
    		--select '@Equip= ' + @Equip --convert(varchar(20),@Equip)
    		if IsNull(@EMAHbasiscolumn,'') <> ''
    		begin
    			--Creating Cursor
    			declare @strcursor varchar(500)
    			select @strcursor = 'declare EM_cursor cursor global for select ' + isnull(@EMAHbasiscolumn,'') + ' from dbo.EMEM with(nolock) where EMCo = ' + isnull(@VEMCo,'') + ' and Equipment = '''+ isnull(@Equip,'') + ''''
    			--run cursor
    			exec (@strcursor)
    			open EM_cursor
    			fetch next from EM_cursor into @variablebasis
    			--@variablebasis amount from specified in EMEM
    			close EM_cursor
    			deallocate EM_cursor
    		end 
    		if IsNull(@Equip,'')<> '' and IsNull(@variablebasis,0) <> 0
			begin
				--Update Base table only if amount field is greater than zero
    			insert into #BaseTable(EMCo, Equip, RevCode, Basis, EMGroup) 
				select @emco, @Equip, 0, @variablebasis, @emgroup
			end
    		select @Equip = min(Equip) from #EquipTable where Equip > @Equip
    	end --while @Equip is not null
    	goto joinit
    end -- if @allocbasis = 'V'
    
	--All allocations, either by Month or Date Range	
	If @EMAHmthdateflag = 'M'
		begin
			--By Month
			insert into #BaseTable(EMCo, Equip, RevCode, Basis, EMGroup) 
    			select d.EMCo, d.Equipment, d.RevCode,
			'Basis'= CASE @EMAHallocbasis WHEN 'R' THEN sum(d.Dollars)
					                  WHEN 'H' THEN sum(d.TimeUnits) END,
			@emgroup
	    	from dbo.EMRD d with (nolock) 
			join #EquipTable t on d.EMCo=t.EMCo and d.Equipment=t.Equip and d.EMGroup=t.EMGroup
			join dbo.EMAV v with(nolock) on v.EMCo=d.EMCo and v.EMGroup=d.EMGroup and v.RevCode=d.RevCode
			--where d.RevCode in (select RevCode from dbo.EMAV c with (nolock) where c.EMCo=@emco and c.AllocCode=@alloccode and c.EMGroup=@emgroup)
			--and d.Mth=@mth
			--group by d.EMCo, d.Equipment, d.RevCode
			where  d.EMCo=@emco and d.EMGroup=@emgroup and v.AllocCode = @alloccode and d.Mth=@mth
			group by d.EMCo,d.Equipment,d.RevCode
		end
	else
		begin
			--By Date Range
			insert into #BaseTable(EMCo, Equip, RevCode, Basis, EMGroup)
			select d.EMCo, d.Equipment, d.RevCode,
			'Basis'= case @EMAHallocbasis WHEN 'R' THEN sum(d.Dollars)
									  WHEN 'H' THEN sum(d.TimeUnits) END,
			@emgroup
			from dbo.EMRD d with (nolock) 
			join #EquipTable t on d.EMCo=t.EMCo and d.Equipment=t.Equip and d.EMGroup=t.EMGroup
			join dbo.EMAV v with(nolock) on v.EMCo=d.EMCo and v.EMGroup=d.EMGroup and  v.RevCode=d.RevCode
			--where d.RevCode in (select RevCode from dbo.EMAV c with (nolock) where c.EMCo=@emco and c.AllocCode=@alloccode and c.EMGroup=@emgroup)
			where d.EMCo=@emco and d.EMGroup=@emgroup and v.AllocCode = @alloccode and d.ActualDate >= @begindate and d.ActualDate <=@enddate 
			group by d.EMCo, d.Equipment, d.RevCode
		end
	
	--Hourly Allocations up Revenue Codes	
 	if @EMAHallocbasis = 'H'
	begin
	   	update #BaseTable Set Basis = (x.Basis * y.HrsPerTimeUM) 
		from #BaseTable x
		Inner Join dbo.EMRC y with(nolock)on x.EMGroup=y.EMGroup and x.RevCode=y.RevCode
	end
    
	joinit:
    select @TestEquip = min(Equip) from #BaseTable
    while @TestEquip is not null
    begin
		--Get basis amount from #BaseTable
		select @basis = sum(Basis) 
		from #BaseTable j 
		where j.EMCo = @emco and j.Equip = @TestEquip
		--Update basis in #EquipTable from Base Table
    	update #EquipTable 
		Set Basis=@basis 
		from #EquipTable t, #BaseTable b 
		where b.EMCo=t.EMCo and b.Equip=t.Equip and t.Equip = @TestEquip
    	
		select @TestEquip = min(Equip) from #BaseTable where Equip > @TestEquip
    end --while @TestEquip is not null
    ----------------------------------------------------------
	--Override Allocation rate from EMACProcess form 
	--if amount exists in EMEM
	--Issue 129249 fix
    if IsNull(@EMAHratecolumn,'') <> ''
    begin
		select @Equip = min(Equip) from #EquipTable
    	while @Equip is not null
    	begin
    		select @Equip =  + isnull(convert(varchar(20),@Equip),'')
    		exec('declare EM_cursor cursor global for select ' + @EMAHratecolumn + ' from dbo.EMEM with(nolock) where EMCo = ' + @VEMCo + ' and Equipment = ''' + @Equip + '''')
    		open EM_cursor
    		fetch next from EM_cursor into @allocrate
    		close EM_cursor
    		deallocate EM_cursor

    		update #EquipTable 
			Set AllocRate = isnull(@allocrate,0) 
			from #EquipTable 
			where EMCo = @emco and Equip = @Equip

    		select @Equip = min(Equip) from #EquipTable where Equip > @Equip

    	end --while @Equip is not null
    end -- if @EMAHratecolumn is not null
    ---------------------------------------------------------------------
	--Override Allocation amount from EMACProcess form 
	--if amount exists in EMEM
	--Issue 129249 fix
    if IsNull(@EMAHamtcolumn,'') <> ''
    begin
    	select @Equip = min(Equip) from #EquipTable
    	while @Equip is not null
    	begin
    		select @Equip=  + isnull(convert(varchar(20),@Equip),'')
    		exec('declare EM_cursor cursor global for select ' + @EMAHamtcolumn + ' from dbo.EMEM with(nolock) where EMCo = ' + @VEMCo + ' and Equipment = ''' + @Equip + '''')
    		open EM_cursor
    		fetch next from EM_cursor into @allocamt
    		close EM_cursor
    		deallocate EM_cursor
    		
			if IsNull(@allocamt,0) <> 0
			begin
				update #EquipTable 
				Set AllocAmt = isnull(@allocamt,0) 
				from #EquipTable
				 where EMCo = @emco and Equip = @Equip
    		end

			select @Equip = min(Equip) from #EquipTable where Equip > @Equip
    	end --while @Equip is not null
    end --if @EMAHamtcolumn is not null
    
    select @basis = sum(Basis) from #EquipTable
    select '@basis = ' + isnull(convert(varchar(20),@basis),'')
    --drop table #BaseTable
    
    if @getbasis=1
    begin
		select @errmsg = 'Basis returned.', @rcode=0
    	goto vspexit
    end
    	
    if @basis = 0
    begin
		select @errmsg = 'Basis is 0, cannot create Allocations!', @rcode=1
    	goto vspexit
    end
    	
    /* once basis has been calculated then we can calculate the allocation based on Type */
    if @EMAHamtrateflag = 'A'
	begin
		if IsNull(@allocamt,0)<> 0
		begin
			update #EquipTable
			set AllocAmt =(Basis / (select sum(Basis) from #EquipTable)) * @allocamt
		end
	end

	--if @EMAHamtrateflag='C'
	    --update #EquipTable set AllocAmt = (Basis / (select sum(Basis) from #EquipTable)) * AllocAmt

    if @EMAHamtrateflag = 'R' 
	begin 
		update #EquipTable 
		set AllocAmt = Basis * @allocrate 
	end
    if @EMAHamtrateflag = 'T'
	begin 
		update #EquipTable 
		set AllocAmt = Basis * isnull(AllocRate,0) 
	end

/* now each row in #EquipTable should coorespond to a Batch Entry */
donecalculating:
	/*Issue 131076
	if we're allocating an amount, and not using a column in JCJM check and
	make sure that we allocated the full amount
	if there is a rounding descrepency we add it to the last item
	If amount remaining to allocate, adjust last batch seq with difference. for non-user memo amounts only*/
	--134913 added "and @EMAHamtrateflag<>'C'"
	if @EMAHamtcolumn is not null  and @EMAHamtrateflag<>'C'
	begin
		select @alloctoadjust = IsNull(@allocamt,0) - sum(Basis) from #EquipTable

		if @alloctoadjust <> 0 
		begin
			update Top (1) #EquipTable
			set AllocAmt = IsNull(AllocAmt,0) + @alloctoadjust
		end
	end
    declare bcEMBF cursor local fast_forward for 
	select EMCo, Equip, AllocAmt from #EquipTable
  
    open bcEMBF
    select @opencursor = 1
    
	goto NextEquipRec
	NextEquipRec:
	
	fetch next from bcEMBF into @addemco, @addequip, @addallocamt
	if @@fetch_status <> 0
	begin
			goto EndNextEquipRec 
	end

    select @batchseq = isnull(max(BatchSeq),0) 
	from dbo.EMBF with (nolock) 
	where Co=@emco and Mth=@mth and BatchId=@batchid
    
	select @alloctotal = 0

   	/* create an entry in EMBF for each entry in temp table */
   	/* since batches are unique we can just use a counter to get the seq number */
	--if @addallocamt > 0  Do not have to be positive, only have to be not 0
   	if IsNull(@addallocamt,0) <> 0
   	begin
   		set @batchseq = @batchseq + 1
   		select @EMAHdebitacct=GLDebitAcct from dbo.EMAH with (nolock) where EMCo=@emco and AllocCode=@alloccode
   		if @EMAHdebitacct is null
   		begin
			select @CompOfEquip = null
			--Gets Department of Component
   			select @CompOfEquip=CompOfEquip, @Dept=Department
   			from dbo.EMEM with (nolock) where EMCo = @addemco and Equipment=@addequip
   			if isnull(@CompOfEquip,'') <> ''
			begin
   				select @Dept = Department from dbo.EMEM with (nolock) 
   				where EMCo = @addemco and Equipment=@CompOfEquip
   			end
			--EM Department and Cost Type Override 
			select @EMAHdebitacct = GLAcct 
			from dbo.EMDO with (nolock) 
			where EMCo = @emco and isnull(Department,'') = isnull(@Dept,'') and CostCode = @EMAHcostcode and EMGroup = @emgroup
   			if @EMAHdebitacct is null
			begin
   				select @EMAHdebitacct = GLAcct from dbo.EMDG with (nolock) 
   				where EMCo = @emco and isnull(Department,'') = isnull(@Dept,'') and EMGroup = @emgroup and CostType = @EMAHcosttype
			end

			--Error out if there is no debit GLAccount
	    	if @EMAHdebitacct is null
			begin
    			select @errmsg = 'Missing GLTransAcct for EM Department: ' + convert(varchar(30),isnull(@Dept,''))
   				+ ' Cost Code: ' + convert(varchar(10),isnull(@EMAHcostcode,''))
   				+ ' Cost Type: ' + convert(varchar(10),isnull(@EMAHcosttype,'')),@rcode = 1
    			goto vspexit
    		end 
		end --if @EMAHdebitacct is null
 
	   	if @EMAHmthdateflag = 'M'
			begin
    			update dbo.EMAH 
				set LastPosted = @actualdate, LastMonth = @mth, LastBeginDate = null, LastEndDate = null,
    			PrevPosted = LastPosted,PrevMonth = LastMonth,PrevBeginDate = LastBeginDate,PrevEndDate = LastEndDate
    			where EMCo=@emco and AllocCode=@alloccode
			end
    	else
			begin
    			update dbo.EMAH 
				set LastPosted = @actualdate, LastBeginDate = @begindate, LastEndDate = @enddate, LastMonth = null,
    			PrevPosted = LastPosted,PrevMonth = LastMonth,PrevBeginDate = LastBeginDate,PrevEndDate = LastEndDate
    			where EMCo=@emco and AllocCode=@alloccode

			end	

    	insert into dbo.EMBF(Co, Mth, BatchId, BatchSeq, Source, Equipment, BatchTransType, EMTransType,  EMGroup, CostCode, EMCostType, 
    	ActualDate, Description, GLCo, GLTransAcct, GLOffsetAcct, ReversalStatus,MatlGroup,  UM, Units, Dollars, AllocCode)
    	values(@addemco, @mth, @batchid, @batchseq, 'EMAlloc', @addequip, 'A', 'Alloc', @emgroup, @EMAHcostcode, @EMAHcosttype, @actualdate, 
    	@Description, @EMAHglco, @EMAHdebitacct, @EMAHcreditacct, @reversal, @matlgroup, 'LS', 0, isnull(@addallocamt,0), @alloccode)

    	select @alloctotal = @alloctotal + @addallocamt
    end --if @addallocamt <> 0
      goto NextEquipRec
	
	
	EndNextEquipRec:
		if @opencursor = 1
    	begin
    		close bcEMBF
    		deallocate bcEMBF
    		select @opencursor = 0
    	end
	  
    select @rcode=0
END -- @EMAHallocbasis = 'H' or 'R' or 'V'
------------------------------------------------------
--/*allocation based on amount distributed by Cost */    
if @EMAHallocbasis = 'C'
BEGIN
	--Allocation Type 1-4 are for Date Range
	if @EMAHcostcode is Null and @EMAHcosttype is Null
    	select @AllocType = 1


    if @EMAHcostcode is not  Null and @EMAHcosttype is Null
    	select @AllocType = 2
    if @EMAHcostcode is  Null and @EMAHcosttype is not Null
    	select @AllocType = 3
    if @EMAHcostcode is not Null and @EMAHcosttype is not Null
    	select @AllocType = 4

	--Allocation Type 5-8 are by Month
    if @EMAHmthdateflag = 'M' 
		-- @AllocType(6) = @AllocType(2) + 4
		select @AllocType = @AllocType + 4

	--EMAH.Cosde and EMAH.CostType are null by Date Range
    if @AllocType = 1
    begin
    	select @batchseq = isnull(max(BatchSeq),0) 
		from dbo.EMBF with (nolock) 
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment) 
		from dbo.EMCD j with (nolock)
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup = t.EMGroup
    	where j.EMCo = @emco and j.EMGroup = @emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate
    	while @Equip is not null
    	begin
    		select @CCode = min(CostCode) 
			from dbo.EMCD with (nolock) 
			where EMCo = @emco and Equipment = @Equip and EMGroup = @emgroup and ActualDate >=@begindate and ActualDate <= @enddate
    		while @CCode is not null
    		begin
    			select @CType = min(j.EMCostType) 
				from dbo.EMCD j with (nolock) 
				Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
				where j.EMCo = @emco and j.Equipment = @Equip and j.CostCode = @CCode and c.AllocCode = @alloccode 
				and j.EMGroup = @emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate 
				while @CType is not null
    			begin
    				select @EMCoInsert = EMCo, @EquipInsert = Equipment, @BasisInsert = sum(Dollars) 
					from dbo.EMCD with (nolock)
    				where EMCo = @emco and Equipment = @Equip and EMGroup = @emgroup and CostCode = @CCode 
					and EMCostType = @CType and ActualDate >=@begindate and ActualDate <= @enddate
    				Group By EMCo, Equipment
    				if @@rowcount = 0 
					begin
						goto skip1
					end

    				select @alloctotal = @alloctotal + @BasisInsert
    				/*if @getbasis=1
    					select @alloctotal = @alloctotal + @BasisInsert
    				else 
    				select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    				insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert) 
					values(@EMCoInsert, @EquipInsert, @CCode, @CType, @BasisInsert)
				skip1:
    				select 'CType=' + isnull(CONVERT(varchar(12),@CType),'')

    				select @CType = min(j.EMCostType) 
					from dbo.EMCD j with (nolock) 
					Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
					where j.EMCo = @emco and j.Equipment = @Equip and j.EMGroup = @emgroup and j.CostCode = @CCode and c.AllocCode = @alloccode 
					and j.ActualDate >=@begindate and j.ActualDate <= @enddate AND j.EMCostType > @CType
    			end  --while @CType is not null

    			select 'CCode=' + isnull(CONVERT(varchar(12),@CCode),'')

    			select @CCode = min(CostCode)
				from dbo.EMCD with (nolock) 
				where EMCo = @emco and Equipment = @Equip and EMGroup = @emgroup and ActualDate >=@begindate 
				and ActualDate <= @enddate AND CostCode > @CCode
    		end --while @CCode is not null

    		select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')

    		select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock) 
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    		where j.EMCo = @emco and j.EMGroup = @emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate 
			and j.Equipment > @Equip
    	end --while @Equip is not null
    	if @getbasis=1
    	begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
		goto donecalculating2
    end --if @AllocType = 1
    
	--EMAH.CostCode is not Null and EMAH.CostType is Null  by Date Range
    if @AllocType = 2
    begin
    	select @batchseq = isnull(max(BatchSeq),0) 
		from dbo.EMBF with (nolock) 
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment)
		from dbo.EMCD j with (nolock) 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    	where j.EMCo = @emco and j.EMGroup = @emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate
    	while @Equip is not null
    	begin
    		select @CType = min(j.EMCostType) 
			from dbo.EMCD j with (nolock) 
			Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
			where j.EMCo = @emco and j.Equipment = @Equip and c.AllocCode = @alloccode  and j.EMGroup = @emgroup
			and j.ActualDate >=@begindate and j.ActualDate <= @enddate 
			while @CType is not null
    		begin
				select @EMCoInsert = EMCo, @EquipInsert = Equipment, @BasisInsert = sum(Dollars) 
				from dbo.EMCD with (nolock) 
    			where EMCo = @emco and Equipment = @Equip and EMGroup = @emgroup and EMCostType = @CType
				and ActualDate >=@begindate and ActualDate <= @enddate
    			Group By EMCo, Equipment
    			if @@rowcount = 0 
				begin
					goto skip2
				end
    			select @alloctotal = @alloctotal + @BasisInsert
    			/*if @getbasis=1
    				select @alloctotal = @alloctotal + @BasisInsert
    			else 
    			select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    			insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert) 
				values(@EMCoInsert, @EquipInsert, @EMAHcostcode, @CType, @BasisInsert)
			skip2:
    			select 'CType=' + isnull(CONVERT(varchar(12),@CType),'')

    			select @CType = min(j.EMCostType) 
				from dbo.EMCD j with (nolock)
				Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
				where j.EMCo = @emco and j.Equipment = @Equip and c.AllocCode = @alloccode and j.EMGroup = @emgroup
				and j.ActualDate >=@begindate and j.ActualDate <= @enddate 	AND j.EMCostType > @CType
    		end  --while @CType is not null
    		
			select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')
    		
			select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock) 
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    		where j.EMCo = @emco and j.EMGroup = @emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate 
			and j.Equipment > @Equip
    	end --while @Equip is not null
		if @getbasis=1
    	begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
		goto donecalculating2
    end --if @AllocType = 2
    
	--EMAH.CostCode is  Null and EMAH.CostType is not Null by Date Range
    if @AllocType = 3
    begin
    	select @batchseq = isnull(max(BatchSeq),0)
		from dbo.EMBF with (nolock) 
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment)
		from dbo.EMCD j with (nolock) 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    	where j.EMCo = @emco and j.EMGroup = @emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate
    	while @Equip is not null
    	begin
    		select @CCode = min(CostCode) 
			from dbo.EMCD with (nolock) 
			where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and ActualDate >=@begindate and ActualDate <= @enddate
    		while @CCode is not null
    		begin
    			select @EMCoInsert = j.EMCo, @EquipInsert = j.Equipment, @BasisInsert = sum(Dollars) 
				from dbo.EMCD j with (nolock) 
				Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    			where j.EMCo = @emco and j.Equipment = @Equip and j.CostCode = @CCode and j.EMGroup=@emgroup and c.AllocCode=@alloccode 
				and ActualDate >=@begindate and ActualDate <= @enddate
				Group By j.EMCo, j.Equipment
    			if @@rowcount = 0 
				begin
					goto skip3
				end
    			select @alloctotal = @alloctotal + @BasisInsert
    			/*if @getbasis=1
    				select @alloctotal = @alloctotal + @BasisInsert
    			else 
    				select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    			select 'EquipInsert=' + isnull(CONVERT(varchar(12),@EquipInsert),'')
    			select 'CCode=' + isnull(CONVERT(varchar(12),@CCode),'')
    			select 'CostType=' + isnull(CONVERT(varchar(12),@EMAHcosttype),'')
    			select 'BasisInsert=' + isnull(CONVERT(varchar(12),@BasisInsert),'')
    			insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert)
    			values(@EMCoInsert, @EquipInsert, @CCode, @EMAHcosttype, @BasisInsert)
			skip3:
    			select @CCode = min(CostCode)
				from dbo.EMCD with (nolock) 
    			where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and ActualDate >=@begindate and ActualDate <= @enddate 
				AND CostCode > @CCode
    		end --while @CCode is not null
    		
			select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock) 
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    		where j.EMCo = @emco and j.EMGroup=@emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate and j.Equipment > @Equip
    	end --while @Equip is not null
    
    	if @getbasis=1
    	begin
			select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
    	goto donecalculating2
    end --if @AllocType = 3
    
	--EMAH.CostCode is not Null and EMAH.CostType is not Null  by Date Range
    if @AllocType = 4
    begin
    	select @batchseq = isnull(max(BatchSeq),0)
		from dbo.EMBF with (nolock)
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment)
    	from dbo.EMCD j 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
		where j.EMCo = @emco and j.EMGroup=@emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate
    	while @Equip is not null
    	begin
    		select @EMCoInsert = j.EMCo, @EquipInsert = j.Equipment, @BasisInsert = sum(Dollars) 
			from dbo.EMCD j with (nolock) 
			Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    		where j.EMCo = @emco and j.Equipment = @Equip and j.EMGroup=@emgroup and c.AllocCode=@alloccode 
			and ActualDate >= @begindate and ActualDate <= @enddate
			Group By j.EMCo, j.Equipment
    		if @@rowcount = 0 
			begin 
				goto skip4
			end
			select @alloctotal = @alloctotal + @BasisInsert
    		/*if @getbasis=1
    			select @alloctotal = @alloctotal + @BasisInsert
    		else 
    			select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    		insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert) 
			values(@EMCoInsert, @EquipInsert, @EMAHcostcode, @EMAHcosttype, @BasisInsert)
		skip4:
    		select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')

    		select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock)
			Join #EquipTable t on j.EMCo=t.EMCo and j.EMGroup =t.EMGroup and j.Equipment=t.Equip
    		where j.EMCo = @emco and j.EMGroup=@emgroup and j.ActualDate >=@begindate and j.ActualDate <= @enddate and j.Equipment > @Equip
    	end --while @Equip is not null
    	if @getbasis=1
    	begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
    	goto donecalculating2
    end --if @AllocType = 4
    
	--EMAH.Cosde and EMAH.CostType are null by Month
    if @AllocType = 5
    begin
    	select @batchseq = isnull(max(BatchSeq),0) 
		from dbo.EMBF with (nolock) 
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment)
		from dbo.EMCD j with (nolock) 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    	where j.EMCo = @emco and j.EMGroup=@emgroup and j.Mth=@mth
    	while @Equip is not null
    	begin
    		select @CCode = min(CostCode) 
			from dbo.EMCD with (nolock) 
			where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and Mth=@mth
    		while @CCode is not null
    		begin
    			select @CType = min(j.EMCostType) 
				from dbo.EMCD j with (nolock) 
				Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    			where j.EMCo = @emco and j.Equipment = @Equip and j.EMGroup=@emgroup and c.AllocCode=@alloccode and j.CostCode = @CCode 
				and j.Mth=@mth 
    			while @CType is not null
    			begin
    				select @EMCoInsert = EMCo, @EquipInsert = Equipment, @BasisInsert = sum(Dollars) 
					from dbo.EMCD with (nolock) 
    				where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and CostCode = @CCode 
					and EMCostType = @CType and Mth=@mth
					Group By EMCo, Equipment
    				if @@rowcount = 0 
					begin 
						goto skip5
					end
    				select @alloctotal = @alloctotal + @BasisInsert
    				/*if @getbasis=1
    					select @alloctotal = @alloctotal + @BasisInsert
    				else 
    				select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    				insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert) 
					values(@EMCoInsert, @EquipInsert, @CCode, @CType, @BasisInsert)
				skip5:
    				select 'CType=' + isnull(CONVERT(varchar(12),@CType),'')
    				
					select @CType = min(j.EMCostType)
					from dbo.EMCD j with (nolock) 
					Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    				where j.EMCo = @emco and j.Equipment = @Equip and j.CostCode = @CCode and j.Mth=@mth AND 
					j.EMGroup=@emgroup and c.AllocCode=@alloccode AND j.EMCostType > @CType
    			end  --while @CType is not null
    			select 'CCode=' + isnull(CONVERT(varchar(12),@CCode),'')

    			select @CCode = min(CostCode)
				from dbo.EMCD with (nolock) 
				where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and Mth=@mth aND CostCode > @CCode
    		end --while @CCode is not null
    		select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')

    		select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock) 
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    		where j.EMCo = @emco and j.Mth=@mth and j.Equipment > @Equip
		end --while @Equip is not null
		if @getbasis=1
		begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
		end
		goto donecalculating2
    end --if @AllocType = 5
    
	--EMAH.CostCode is not Null and EMAH.CostType is Null by Month
    if @AllocType = 6
    begin
    	select @batchseq = isnull(max(BatchSeq),0)
		from dbo.EMBF with (nolock) 
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment) 
		from dbo.EMCD j with (nolock) 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip  and j.EMGroup=t.EMGroup
		where j.EMCo = @emco and j.EMGroup=@emgroup and j.Mth=@mth
    	while @Equip is not null
    	begin
    		select @CType = min(j.EMCostType)
			from dbo.EMCD j with (nolock) 
			Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    		where j.EMCo = @emco and j.Equipment = @Equip and j.Mth=@mth  and j.EMGroup=@emgroup and c.AllocCode=@alloccode
    		while @CType is not null
    		begin
    			select @EMCoInsert = EMCo, @EquipInsert = Equipment, @BasisInsert = sum(Dollars) 
				from dbo.EMCD with (nolock) 
    			where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and EMCostType = @CType and Mth=@mth
    			Group By EMCo, Equipment
    			if @@rowcount = 0 
				begin 
					goto skip6
				end
    			select @alloctotal = @alloctotal + @BasisInsert
    			/*if @getbasis=1
    				select @alloctotal = @alloctotal + @BasisInsert
    			else 
    				select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    			insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert) 
				values(@EMCoInsert, @EquipInsert, @EMAHcostcode, @CType, @BasisInsert)
			skip6:
    			select 'CType=' + isnull(CONVERT(varchar(12),@CType),'')
    			
				select @CType = min(j.EMCostType) 
				from dbo.EMCD j with (nolock) 
				Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
				where j.EMCo = @emco and j.Equipment = @Equip and j.Mth=@mth AND j.EMGroup=@emgroup and c.AllocCode=@alloccode
				and j.EMCostType > @CType
    		end  --while @CType is not null
    		select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')

    		select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock) 
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
    		where j.EMCo = @emco and j.Mth=@mth and j.EMGroup=@emgroup and j.Equipment > @Equip
    	end --while @Equip is not null
    	if @getbasis=1
    	begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
    	goto donecalculating2
    end --if @AllocType = 6
    
	--EMAH.CostCode is  Null and EMAH.CostType is not Null by Month
    if @AllocType = 7
    begin
    	select @batchseq = isnull(max(BatchSeq),0) 
		from dbo.EMBF with (nolock)
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment)
		from dbo.EMCD j with (nolock) 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
		where j.EMCo = @emco and j.EMGroup=@emgroup and j.Mth=@mth
    	while @Equip is not null
    	begin
    		select @CCode = min(CostCode) 
			from dbo.EMCD with (nolock) 
			where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and Mth=@mth
    		while @CCode is not null
    		begin
    			select @EMCoInsert = j.EMCo, @EquipInsert = j.Equipment, @BasisInsert = sum(Dollars) 
				from dbo.EMCD j with (nolock) 
				Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    			where j.EMCo = @emco and j.Equipment = @Equip and j.CostCode = @CCode 
				and Mth=@mth and j.EMGroup=@emgroup and c.AllocCode=@alloccode
    			Group By j.EMCo, j.Equipment
    			if @@rowcount = 0 
				begin
					goto skip7
				end
				select @alloctotal = @alloctotal + @BasisInsert
    			/*if @getbasis=1
    				select @alloctotal = @alloctotal + @BasisInsert
    			else 
    				select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    			insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert) 
				values(@EMCoInsert, @EquipInsert, @CCode, @EMAHcosttype, @BasisInsert)
			skip7:
    			select 'CCode=' + isnull(CONVERT(varchar(12),@CCode),'')
    		
				select @CCode = min(CostCode) 
				from dbo.EMCD with (nolock) 
				where EMCo = @emco and Equipment = @Equip and EMGroup=@emgroup and Mth=@mth AND CostCode > @CCode
    		end --while @CCode is not null
    		select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')

    		select @Equip = min(j.Equipment) 
			from dbo.EMCD j with (nolock) 
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.Equipment=t.Equip
    		where j.EMCo = @emco and j.EMGroup=@emgroup and j.Mth=@mth and j.Equipment > @Equip
    	end --while @Equip is not null
    	if @getbasis=1
    	begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
    	goto donecalculating2
    end --if @AllocType = 7
    
	--EMAH.CostCode is not Null and EMAH.CostType is not Null by Month
    if @AllocType = 8
    begin
    	select @batchseq = isnull(max(BatchSeq),0)
		from dbo.EMBF with (nolock) 
		where Co=@emco and Mth=@mth and BatchId=@batchid

    	select @alloctotal = 0

    	select @Equip = min(j.Equipment)
		from dbo.EMCD j with (nolock) 
		Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
		where j.EMCo = @emco and j.EMGroup=@emgroup and j.Mth=@mth
    	while @Equip is not null
    	begin
    		select @EMCoInsert = j.EMCo, @EquipInsert = j.Equipment, @BasisInsert = sum(Dollars) 
			from dbo.EMCD j with (nolock) 
			Inner Join dbo.EMAT c with(nolock)on c.EMCo=j.EMCo and c.EMGroup=j.EMGroup and c.CostType = j.EMCostType
    		where j.EMCo = @emco and j.Equipment = @Equip and j.EMGroup=@emgroup and c.AllocCode=@alloccode and Mth=@mth
    		Group By j.EMCo, j.Equipment
    		if @@rowcount = 0
			begin
				 goto skip8
			end
    		select @alloctotal = @alloctotal + @BasisInsert
    		/*if @getbasis=1
    			select @alloctotal = @alloctotal + @BasisInsert
    		else 
    			select @alloctotal = @alloctotal + abs(@BasisInsert)*/
    		insert into #CostTable(EMCo, Equipment, CCode, CType, BasisInsert)
			values(@EMCoInsert, @Equip, @EMAHcostcode, @EMAHcosttype, @BasisInsert)

	skip8:

    		select 'Equipment=' + isnull(CONVERT(varchar(12),@Equip),'')

    		select @Equip = min(j.Equipment)
			from dbo.EMCD j with (nolock)
			Join #EquipTable t on j.EMCo=t.EMCo and j.Equipment=t.Equip and j.EMGroup=t.EMGroup
			where j.EMCo = @emco and j.EMGroup=@emgroup and j.Mth=@mth and j.Equipment > @Equip
    	end --while @Equip is not null
    	if @getbasis=1
    	begin
    		select @basis = @alloctotal
    		select @errmsg = 'Basis returned.', @rcode=0
    		goto vspexit
    	end
    	goto donecalculating2
    end --if @AllocType = 8

/* now each row in #CostTable should coorespond to a Batch Entry */    
donecalculating2:
	/*Issue 131076
	if we're allocating an amount, and not using a column in JCJM check and
	make sure that we allocated the full amount
	if there is a rounding descrepency we add it to the last item
	If amount remaining to allocate, adjust last batch seq with difference. for non-user memo amounts only*/
	--134913 added "and @EMAHamtrateflag<>'C'"
	if @EMAHamtcolumn is not null  and @EMAHamtrateflag<>'C'
	begin
		If @allocamt is not null
		begin
			select @alloctoadjust = @allocamt - sum(BasisInsert) from #CostTable

			if @alloctoadjust <> 0 
			begin
				update Top (1) #CostTable 
				set BasisInsert =  IsNull(BasisInsert,0) + @alloctoadjust
			end
		end
	end
	declare bcEMBF2 cursor local fast_forward for
	select EMCo, Equipment, CCode, CType, BasisInsert from #CostTable

    open bcEMBF2
    select @opencursor2 = 1

	goto NextCostRec
	NextCostRec:

	fetch next from bcEMBF2 into @costemco, @costequip, @costccode, @costctype, @costBasisInsert 

	if @@fetch_status <> 0
	begin
			goto EndNextCostRec
	end
	
	select @batchseq = isnull(max(BatchSeq),0) 
	from dbo.EMBF with (nolock) where Co=@emco and Mth=@mth and BatchId=@batchid

    if @alloctotal  = 0
    begin
    	select @errmsg = 'Basis is 0, cannot create Allocations!', @rcode=1
    	goto vspexit
    end
     
	/* create an entry in EMBF for each entry in temp table */
	/* since batches are unique we can just use a counter to get the seq number */
   	if isnull(@costBasisInsert,0) <> 0
   	begin
   		select @VEMCo = @costemco
   		if @EMAHratecolumn is not null
   		begin
   			exec('declare EM_cursor cursor global for select ' + @EMAHratecolumn + ' from dbo.EMEM with(nolock) where EMCo = ' + @VEMCo + ' and Equipment = ''' + @costequip + '''')
   			open EM_cursor
   			fetch next from EM_cursor into @allocrate
   			close EM_cursor
   			deallocate EM_cursor
   		end --if @EMAHratecolumn is not null
   		if @EMAHamtcolumn is not null
   		begin
   			exec('declare EM_cursor cursor global for select ' + @EMAHamtcolumn + ' from dbo.EMEM  with(nolock) where EMCo = ' + @VEMCo + ' and Equipment = ''' + @costequip + '''')
   			open EM_cursor
   			fetch next from EM_cursor into @allocamt
   			close EM_cursor
   			deallocate EM_cursor
   		end --if @EMAHamtcolumn is not null
    
		/* once basis has been calculated then we can calculate the allocation based on Type */
 		if @EMAHamtrateflag = 'A'
		begin
   			select @costBasisInsert = case when @costBasisInsert < 0 then ((abs(@costBasisInsert) / @alloctotal) * @allocamt) * -1 else ((abs(@costBasisInsert) / @alloctotal) * @allocamt) end
		end
    	if @EMAHamtrateflag = 'C'
		begin
    		select @costBasisInsert = @allocamt
		end
    	if @EMAHamtrateflag = 'R' or @EMAHamtrateflag = 'T'
		begin
    		select @costBasisInsert = @costBasisInsert * @allocrate
		End

    	select @batchseq = @batchseq + 1

		select @EMAHdebitacct=GLDebitAcct 
		from dbo.EMAH with (nolock) 
		where EMCo=@emco and AllocCode=@alloccode
		if @EMAHdebitacct is null
   		begin
   			select @Dept = Department from dbo.EMEM with (nolock) 
  			where EMCo = @costemco and Equipment = @costequip
	    	
			select @EMAHdebitacct = GLAcct from dbo.EMDO with (nolock) 
   			where EMCo = @emco and isnull(Department,'') = isnull(@Dept,'') 
			and CostCode = @costccode and EMGroup = @emgroup

	    	if @EMAHdebitacct is null
			begin
    			select @EMAHdebitacct = GLAcct from dbo.EMDG with (nolock) 
   				where EMCo = @emco and isnull(Department,'') = isnull(@Dept,'') 
				and EMGroup = @emgroup and CostType = @costctype
			end
	
   			if @EMAHdebitacct is null
			begin
				select @errmsg = 'Missing GLTransAcct for EMDepartment ' + isnull(convert(varchar(30),@Dept),'')
								+ ' Cost Type ' + isnull(convert(varchar(10),@EMAHcosttype),''),@rcode = 1
				goto vspexit
			end
    	end --if @EMAHdebitacct is null
    
    	if @EMAHmthdateflag = 'M'
			begin
    			update dbo.EMAH 
				set LastPosted = @actualdate, LastMonth = @mth, LastBeginDate = null, LastEndDate = null,
    			PrevPosted = LastPosted,PrevMonth = LastMonth,PrevBeginDate = LastBeginDate,PrevEndDate = LastEndDate
    			where EMCo=@emco and AllocCode=@alloccode
			end
    	else
			begin
    			update dbo.EMAH 
				set LastPosted = @actualdate, LastBeginDate = @begindate, LastEndDate = @enddate, LastMonth = null,
    			PrevPosted = LastPosted,PrevMonth = LastMonth,PrevBeginDate = LastBeginDate,PrevEndDate = LastEndDate
    			where EMCo=@emco and AllocCode=@alloccode
			end

   		insert into dbo.EMBF(Co,Mth,BatchId,BatchSeq,Source,Equipment,BatchTransType,EMTransType,EMGroup,CostCode,EMCostType,ActualDate,
		Description,GLCo,GLTransAcct,GLOffsetAcct, ReversalStatus,MatlGroup, UM, Units, Dollars,AllocCode)
    	values(@costemco,@mth,@batchid,@batchseq,'EMAlloc',@costequip,'A','Alloc',@emgroup,@costccode,@costctype,@actualdate,
		@Description,@EMAHglco,@EMAHdebitacct,@EMAHcreditacct,@reversal,@matlgroup,'LS',0,isnull(@costBasisInsert,0),@alloccode)
	end 
	goto NextCostRec
  
    
	EndNextCostRec:
		if @opencursor2 = 1
    		begin
    			close bcEMBF2
    			deallocate bcEMBF2
    			select @opencursor2 = 0
    		end
    	--136527
	if @allocamt is not null  and @EMAHamtrateflag='A'
	begin
		select @alloctoadjust = @allocamt - sum(Dollars) from dbo.EMBF 
		where Co=@costemco and Mth=@mth and @batchid=BatchId and Source='EMAlloc' and AllocCode=@alloccode
		and ActualDate = @actualdate
		
		if @alloctoadjust <> 0 
			begin
				update Top (1) dbo.EMBF 
				set Dollars =  IsNull(Dollars,0) + @alloctoadjust 
				where Co=@costemco and Mth=@mth and @batchid=BatchId and Source='EMAlloc' and AllocCode=@alloccode
				and ActualDate = @actualdate
			end
		end
	   	select @rcode=0
END--if @EMAHallocbasis = 'C'


vspexit:
    	if @opencursor = 1
		begin
	    	close bcEMBF
    		deallocate bcEMBF
    		select @opencursor = 0
    	end
       	drop table #EquipTable
    
    	if @opencursor2 = 1
    	begin
    		close bcEMBF2
    		deallocate bcEMBF2
    		select @opencursor2 = 0
    	end
	   	drop table #CostTable

return @rcode

GO
PRINT N'Refreshing [dbo].[JCJPDescGet]'
GO
EXEC sp_refreshview N'[dbo].[JCJPDescGet]'
GO
PRINT N'Refreshing [dbo].[APRLTotals]'
GO
EXEC sp_refreshview N'[dbo].[APRLTotals]'
GO
PRINT N'Refreshing [dbo].[brvJCACO]'
GO
EXEC sp_refreshview N'[dbo].[brvJCACO]'
GO
PRINT N'Altering [dbo].[vspHQCOInfoGetVal]'
GO

ALTER     PROCEDURE [dbo].[vspHQCOInfoGetVal]
/************************************************************
* CREATED:		CHS 12/14/2010
* MODIFIED:		CHS 03/10/2010
*				GF 04/18/2013 TFS-47445 added country as output parameter for AP ATO
* 
* USAGE:
*   Returns the HQCO table
*	
* INPUT PARAMETERS
*	HQCO
* 
* OUTPUT PARAMETERS
*   
* RETURN VALUE
*   
************************************************************/
(@TaxYear varchar(4), @hqco bCompany, @CoName varchar(60) output, @Address varchar(60) output, 
	@Address2 varchar(60) output, @City varchar(30) output, @State varchar(4) output, 
	@Zip varchar(12) output, @FedTaxId varchar(20) output, @Phone bPhone output
	----TFS-47445
	,@Country VARCHAR(2) OUTPUT
	,@msg varchar(60) output)

  	AS
  	SET NOCOUNT ON
  	
  	DECLARE @rcode int
  	SELECT @rcode = 0
  	
IF LEN(ISNULL(@TaxYear, '')) NOT IN (0,4)
  	BEGIN
	SELECT @msg = 'Invalid Tax Year entered!', @rcode = 1
	RETURN @rcode
	END
	
IF ISNUMERIC(@TaxYear) = 0
  	BEGIN
	SELECT @msg = 'Invalid Tax Year entered!', @rcode = 1
	RETURN @rcode
	END
	
IF SUBSTRING(@TaxYear, 1, 1) not in ('1','2','3','4','5','6','7','8','9')
  	BEGIN
	SELECT @msg = 'Invalid Tax Year entered!', @rcode = 1
	RETURN @rcode
	END
	
IF SUBSTRING(@TaxYear, 2, 1) not in ('1','2','3','4','5','6','7','8','9','0')
	BEGIN
	SELECT @msg = 'Invalid Tax Year entered!', @rcode = 1
	RETURN @rcode
	END

IF SUBSTRING(@TaxYear, 3, 1) not in ('1','2','3','4','5','6','7','8','9','0')
	BEGIN
	SELECT @msg = 'Invalid Tax Year entered!', @rcode = 1
	RETURN @rcode
	END

IF SUBSTRING(@TaxYear, 4, 1) not in ('1','2','3','4','5','6','7','8','9','0')
	BEGIN
	SELECT @msg = 'Invalid Tax Year entered!', @rcode = 1
	RETURN @rcode
	END
  	  	  	
  	
IF @hqco IS NULL
	BEGIN
	SELECT @msg = 'Missing HQ Company', @rcode = 1
	RETURN @rcode
	END

SELECT @CoName = Name, @Address = Address, @Address2 = Address2, @City= City,  @State = State,
	@Zip = Zip, @FedTaxId = FedTaxId, @Phone = Phone
	----TFS-47445
	,@Country = ISNULL(Country, DefaultCountry)

FROM HQCO
WHERE HQCo = @hqco

GO
PRINT N'Refreshing [dbo].[PMJCJMItems]'
GO
EXEC sp_refreshview N'[dbo].[PMJCJMItems]'
GO
PRINT N'Refreshing [dbo].[JCJPPM1]'
GO
EXEC sp_refreshview N'[dbo].[JCJPPM1]'
GO
PRINT N'Refreshing [dbo].[PRSD]'
GO
EXEC sp_refreshview N'[dbo].[PRSD]'
GO
PRINT N'Altering [dbo].[vspIMUploadAPDB]'
GO
ALTER             proc [dbo].[vspIMUploadAPDB]
   	
   /***********************************************************
    * CREATED BY: MV   08/25/09
    * MODIFIED By :	MV	05/25/10 - #136500 - added param 'N' to bspProcessPartialPayment for '@ApplyCurrTaxRateYN' 
    *				GF 08/15/2010 - issue #135813 change for subcontract expanded
	*				MV 02/07/2011 - #142713 - validate AmountToPay against Invoice amount.
	*				ECV 05/25/11 - TK-05443 - Add SMPayType parameter to bspAPPayTypeGet
	*				MV 03/21/13 - TFS 44601 - validate input parameters specific to retainage/non-retg payments
	*				MV 04/15/2013 - TFS 47145 - Corrected where clause for open to pay select 
    *
    * USAGE: called from vspIMUploadHeaderDetailTextura. It
	*	creates bAPDB records for bAPTB and bAPPB records 
	*	created by vspIMUPloadHeaderDetailTextura.  Or for
	*	retainage, it creates bAPTBs and bAPDBs as necessary
	*	for released retainage.
    *
    * INPUT PARAMETERS
    *   VendorGroup   vendorgroup associated with the vendor
    *   Vendor	    Vendor
    *	AddressSeq    sequence # for the vendor address
    *	
    * OUTPUT PARAMETERS
    *	@msg   		error message
    *
    * RETURN VALUE
    *   0         success
    *   1         Failure
    *****************************************************/ 
   (@co bCompany,		@batchmth bDate,	@batchid int,		@batchseq int,		@ExpMth bDate,		@APTrans bTrans,
	@APRef varchar(15),	@InvDate bDate,		@RetainageFlag bYN,	@AmtToPay bDollar,	@SL varchar(30),	@TexturaYN bYN,
	@errmsg varchar(200) output)
	 
   AS
   SET NOCOUNT ON
   
   DECLARE	@rcode int,				@RetPayType int,		@ReleasedAmt bDollar,	@vendor bVendor,
			@vendorgroup bGroup,	@opencursorAPTD int,	@APTDMth bDate,			@APTDAPTrans bTrans,
			@APTDAPRef varchar(15), @APTDInvDate bDate,		@APTDLine int,			@APTDSeq int,
			@APTDAmt bDollar,		@APTDDesc varchar(30),	@AmtLeftToPay bDollar,	@AmtToSplit bDollar,
			@GrossAmt bDollar,		@Description bDesc,		@AmtOpenToPay bDollar

   
   SELECT @rcode = 0, @opencursorAPTD = 0,@AmtLeftToPay = 0, @AmtToSplit = 0, @GrossAmt = 0, @AmtOpenToPay = 0
   
   IF @RetainageFlag IS NULL
		BEGIN
		SELECT @RetainageFlag = 'N'
		END

   IF @co IS NULL
   	BEGIN
   	SELECT @errmsg = 'Missing AP Company!', @rcode = 1
   	GOTO bspexit
   	END
   
   IF @batchmth IS NULL
   	BEGIN
   	SELECT @errmsg = 'Missing Batch Mth!', @rcode = 1
   	GOTO bspexit
   	END
   
   IF @batchid IS NULL
   	BEGIN
   	SELECT @errmsg = 'Missing Batch Seq!', @rcode = 1
   	GOTO bspexit
   	END

	IF @InvDate IS NULL
   	BEGIN
   	SELECT @errmsg = 'Missing Inv Date!', @rcode = 1
   	GOTO bspexit
   	END

	IF @AmtToPay IS NULL
   	BEGIN
   	SELECT @errmsg = 'Missing Amount!', @rcode = 1
   	GOTO bspexit
   	END
	
	--validaton specific to non retainage payments
	IF @RetainageFlag <> 'R'
	BEGIN
		IF @ExpMth IS NULL
   			BEGIN
   			SELECT @errmsg = 'Missing Exp Mth!', @rcode = 1
   			GOTO bspexit
   			END

		IF @APTrans IS NULL
   		BEGIN
   			SELECT @errmsg = 'Missing AP Trans!', @rcode = 1
   			GOTO bspexit
   		END

		IF @APRef IS NULL
   		BEGIN
   			SELECT @errmsg = 'Missing AP Ref!', @rcode = 1
   			GOTO bspexit
   		END
	END

	--validate specific to Textura retainage payments
	IF isnull(@TexturaYN,'N') = 'Y'
	BEGIN
		IF @SL IS NULL and @RetainageFlag = 'R'
		BEGIN
		SELECT @errmsg = 'Missing SL!', @rcode = 1
		GOTO bspexit
		END
	END
	
	--get default retainage pay type 
	EXEC @rcode = dbo.bspAPPayTypeGet @co, null, null, null,null,null,
    	@RetPayType output, null,null,null, @errmsg output

	-- get vendor group and vendor
	SELECT @vendor=Vendor, @vendorgroup = VendorGroup 
	FROM dbo.APPB (nolock) 
	WHERE Co=@co and Mth=@batchmth and BatchId=@batchid and BatchSeq=@batchseq
 
--	 Regular Invoices - Non Retainage 
	IF ISNULL(@RetainageFlag, 'N') = 'N'
	BEGIN
		-- make sure the bAPTB record exists  
		IF NOT EXISTS (SELECT * 
						FROM
						dbo.APTB (nolock) WHERE
						Co=@co and Mth=@batchmth and BatchId=@batchid and
						BatchSeq=@batchseq and ExpMth=@ExpMth and APTrans=@APTrans and APRef=@APRef)
		BEGIN
			SELECT @errmsg = 'APTB payment transaction record does not exist for ExpMth: ' + convert(varchar(8),@ExpMth,1) +
				' APTrans: ' + convert(varchar(4),@APTrans) 
			SELECT @rcode = 1
			GOTO bspexit
		END

		--	 make sure APTD exists - 
	   IF NOT EXISTS (SELECT * 
						FROM dbo.APTD d (nolock) 
						JOIN dbo.APTH h (nolock) on d.APCo=h.APCo and d.Mth=h.Mth and d.APTrans=h.APTrans 
						WHERE d.APCo=@co and d.Mth=@ExpMth and d.APTrans=@APTrans and h.APRef = @APRef) 
		BEGIN
			SELECT @errmsg = 'APTD payment transaction detail does not exist for Mth: ' + convert(varchar(8),@ExpMth,1) +
				' APTrans: ' + convert(varchar(4),@APTrans) + ' APRef: ' + @APRef 
			SELECT @rcode = 1
			GOTO bspexit
		END

		--validate open to pay against amount to pay
		IF ISNULL(@TexturaYN,'N') ='N'
		BEGIN
			SELECT @AmtOpenToPay = SUM(d.Amount - d.DiscTaken)
			FROM dbo.APTD d (NOLOCK) 
			JOIN dbo.APTH h (NOLOCK) ON d.APCo=h.APCo AND d.Mth=h.Mth AND d.APTrans=h.APTrans 
			WHERE d.APCo=@co AND d.Mth=@ExpMth AND d.APTrans=@APTrans AND h.APRef = @APRef AND d.Status=1
			-- Amount open to pay exceeds the import check amount.
			IF @AmtOpenToPay < @AmtToPay
			BEGIN
				SELECT @errmsg = 'Check amount exceeds open to pay for Mth: ' + CONVERT(VARCHAR(8),@ExpMth,1) +
					' APTrans: ' + CONVERT(varchar(4),@APTrans) + ' APRef: ' + @APRef 
				SELECT @rcode = 1
				GOTO bspexit
			END
			-- Amount open to pay is less than the import check amount.
			IF @AmtOpenToPay > @AmtToPay
			BEGIN
				SELECT @errmsg = 'Check amount is less than amount open to pay for Mth: ' + CONVERT(VARCHAR(8),@ExpMth,1) +
					' APTrans: ' + CONVERT(VARCHAR(4),@APTrans) + ' APRef: ' + @APRef 
				SELECT @rcode = 1
				GOTO bspexit
			END
		END
		ELSE
		BEGIN
			SELECT @AmtOpenToPay = SUM(d.Amount - d.DiscTaken)
			FROM dbo.APTD d (NOLOCK) 
			JOIN dbo.APTH h (NOLOCK) ON d.APCo=h.APCo AND d.Mth=h.Mth AND d.APTrans=h.APTrans 
			WHERE d.APCo=@co AND d.Mth=@ExpMth AND d.APTrans=@APTrans AND h.APRef = @APRef 
				AND d.Status=1 
				AND 
					((d.PayCategory IS NULL AND d.PayType <> @RetPayType )
					OR 
						(
							d.PayCategory IS NOT NULL AND d.PayType <> 
																(
																	SELECT RetPayType 
																	FROM dbo.APPC c 
																	WHERE c.APCo = @co AND c.PayCategory = d.PayCategory
																)
						))
			-- Amount open to pay exceeds the import check amount.
			IF @AmtOpenToPay < @AmtToPay
			BEGIN
				SELECT @errmsg = 'Check amount exceeds open to pay for Mth: ' + CONVERT(VARCHAR(8),@ExpMth,1) +
					' APTrans: ' + CONVERT(varchar(4),@APTrans) + ' APRef: ' + @APRef 
				SELECT @rcode = 1
				GOTO bspexit
			END
			-- Amount open to pay is less than the import check amount.
			IF @AmtOpenToPay > @AmtToPay
			BEGIN
				SELECT @errmsg = 'Check amount is less than amount open to pay for Mth: ' + CONVERT(VARCHAR(8),@ExpMth,1) +
					' APTrans: ' + CONVERT(VARCHAR(4),@APTrans) + ' APRef: ' + @APRef 
				SELECT @rcode = 1
				GOTO bspexit
			END
		END

		--	 Create bAPDB recs 
		IF ISNULL(@TexturaYN,'N') ='N'
		BEGIN
			INSERT INTO dbo.APDB (
					Co,                            
					Mth,                           
					BatchId,                       
					BatchSeq,                      
					ExpMth,                        
					APTrans,                       
					APLine,                        
					APSeq,                         
					PayType,                       
					Amount,                        
					DiscTaken,                     
					PayCategory,                   
					TotTaxAmount)
				SELECT @co,@batchmth,@batchid,@batchseq,@ExpMth,@APTrans,d.APLine,d.APSeq,d.PayType,d.Amount,d.DiscTaken,d.PayCategory,d.TotTaxAmount
				FROM dbo.APTD d join dbo.APTH h on d.APCo=h.APCo and d.Mth=h.Mth and d.APTrans=h.APTrans 
				WHERE d.APCo=@co and d.Mth=@ExpMth and d.APTrans=@APTrans and h.APRef = @APRef and d.Status=1 
				
				IF @@rowcount = 0
					BEGIN
						SELECT @errmsg = 'APDB payment transaction detail was not created for Mth: ' + convert(varchar(8),@ExpMth,1) +
							' APTrans: ' + convert(varchar(4),@APTrans) + ' APRef: ' + @APRef + '.'
						SELECT @rcode = 1
						GOTO bspexit
					END
				ELSE
					BEGIN
						-- update APTB with gross, description
						SELECT @GrossAmt = sum(Amount) FROM dbo.APTD WHERE APCo = @co and Mth = @ExpMth and APTrans = @APTrans
						SELECT @Description 
						FROM dbo.APTH 
						WHERE APCo = @co and Mth = @ExpMth and APTrans = @APTrans
						UPDATE dbo.APTB set Gross = @GrossAmt, Description=@Description
					   FROM dbo.APTB WHERE Co = @co and Mth = @batchmth and BatchId = @batchid
					   and BatchSeq = @batchseq and ExpMth = @ExpMth and APTrans = @APTrans
					END
		END				
		ELSE
		BEGIN
			insert into dbo.APDB (
				Co,                            
				Mth,                           
				BatchId,                       
				BatchSeq,                      
				ExpMth,                        
				APTrans,                       
				APLine,                        
				APSeq,                         
				PayType,                       
				Amount,                        
				DiscTaken,                     
				PayCategory,                   
				TotTaxAmount)
			SELECT @co,@batchmth,@batchid,@batchseq,@ExpMth,@APTrans,d.APLine,d.APSeq,d.PayType,d.Amount,d.DiscTaken,d.PayCategory,d.TotTaxAmount
			FROM dbo.APTD d join dbo.APTH h on d.APCo=h.APCo and d.Mth=h.Mth and d.APTrans=h.APTrans 
			WHERE d.APCo=@co and d.Mth=@ExpMth and d.APTrans=@APTrans and h.APRef = @APRef and d.Status=1
			AND 
					((d.PayCategory IS NULL AND d.PayType <> @RetPayType )
					OR 
						(
							d.PayCategory IS NOT NULL AND d.PayType <> 
																(
																	SELECT RetPayType 
																	FROM dbo.APPC c 
																	WHERE c.APCo = @co AND c.PayCategory = d.PayCategory
																)
						)) 
			IF @@rowcount = 0
				BEGIN
				SELECT @errmsg = 'APDB payment transaction detail was not created for Mth: ' + convert(varchar(8),@ExpMth,1) +
					' APTrans: ' + convert(varchar(4),@APTrans) + ' APRef: ' + @APRef + '.'
				SELECT @rcode = 1
				GOTO bspexit
				END
			ELSE
				BEGIN
					-- update APTB with gross, description
					SELECT @GrossAmt = sum(Amount) FROM dbo.APTD WHERE APCo = @co and Mth = @ExpMth and APTrans = @APTrans
					SELECT @Description FROM dbo.APTH WHERE APCo = @co and Mth = @ExpMth and APTrans = @APTrans
					UPDATE dbo.APTB set Gross = @GrossAmt, Description=@Description
					FROM dbo.APTB WHERE Co = @co and Mth = @batchmth and BatchId = @batchid
					and BatchSeq = @batchseq and ExpMth = @ExpMth and APTrans = @APTrans
				END
		END	
	END 

	-- Released retainage payments - This should be Textura only
	IF @RetainageFlag = 'R' and @TexturaYN = 'Y'
	BEGIN
	-- validate that there is enough released retainage for what is being paid
	SELECT @ReleasedAmt = sum(d.Amount) 
	FROM dbo.APTD d (nolock) 
	JOIN dbo.APTL l (nolock) on d.APCo=l.APCo and d.Mth=l.Mth and d.APTrans=l.APTrans and d.APLine=l.APLine
	JOIN dbo.APTH h (nolock) on d.APCo=h.APCo and d.Mth=h.Mth and d.APTrans=h.APTrans
	WHERE d.APCo=@co and h.VendorGroup=@vendorgroup	and h.Vendor=@vendor and l.LineType=7 and l.SL=@SL 
	AND 
			((d.PayCategory IS NULL AND d.PayType=@RetPayType )
			OR 
				(
					d.PayCategory IS NOT NULL AND d.PayType = 
														(
															SELECT RetPayType 
															FROM dbo.APPC c 
															WHERE c.APCo = @co AND c.PayCategory = d.PayCategory
														)
				)) 
	
	AND d.Status=1
	IF @ReleasedAmt < @AmtToPay
	BEGIN
		SELECT @errmsg = 'Retainage paid exceeds released retainage for Mth: ' + convert(varchar(8),@ExpMth,1) +
			' APTrans: ' + convert(varchar(4),@APTrans) + ' SL: ' + @SL + '.'
		SELECT @rcode = 1
		GOTO bspexit
	END

	--create a cursor to spin through released retainage for this SL
	DECLARE bcAPTDr cursor local fast_forward for
   	SELECT l.Mth,l.APTrans,h.APRef,h.InvDate,l.Description, l.APLine,d.APSeq,d.Amount
	FROM dbo.APTD d (nolock) 
	JOIN dbo.APTL l (nolock) on d.APCo=l.APCo and d.Mth=l.Mth and d.APTrans=l.APTrans and d.APLine=l.APLine
	JOIN dbo.APTH h (nolock) on d.APCo=h.APCo and d.Mth=h.Mth and d.APTrans=h.APTrans
	WHERE d.APCo=@co and h.VendorGroup=@vendorgroup	and h.Vendor=@vendor and l.LineType=7 
		and l.SL=@SL and 
			((d.PayCategory IS NULL AND d.PayType=@RetPayType )
			OR 
				(
					d.PayCategory IS NOT NULL AND d.PayType = 
														(
															SELECT RetPayType 
															FROM dbo.APPC c 
															WHERE c.APCo = @co AND c.PayCategory = d.PayCategory
														)
				))
		and d.Status=1
	ORDER BY d.Mth
   
   	-- open cursor
   	OPEN bcAPTDr
   	SELECT @opencursorAPTD = 1
   
   	APDB_loop:	-- process each APTD
   		FETCH NEXT FROM bcAPTDr into @APTDMth,@APTDAPTrans,@APTDAPRef,@APTDInvDate,@APTDDesc,@APTDLine,@APTDSeq,@APTDAmt 
   
   		IF @@fetch_status <> 0 GOTO APTD_end
		-- If there is still retainage to pay continue processing
		IF @AmtLeftToPay < @AmtToPay 
		BEGIN
			-- Insert APTB if needed
			IF NOT EXISTS (
							SELECT * 
							FROM dbo.APTB 
							WHERE Co=@co and Mth=@batchmth and BatchId=@batchid and BatchSeq=@batchseq
							AND ExpMth=@APTDMth and APTrans=@APTDAPTrans and APRef=@APTDAPRef
						   )
			BEGIN
				INSERT INTO dbo.APTB(
				Co,                            
				Mth,                           
				BatchId,                       
				BatchSeq,                      
				ExpMth,                        
				APTrans,                       
				APRef,                         
				Description,                   
				InvDate,                       
				Gross,                         
				Retainage,                     
				PrevPaid,                      
				PrevDisc,                      
				Balance,                       
				DiscTaken)
			SELECT @co,@batchmth,@batchid,@batchseq,@APTDMth,@APTDAPTrans,@APTDAPRef,@APTDDesc,@APTDInvDate,0,0,0,0,0,0
			IF @@ROWCOUNT = 0
				BEGIN
				SELECT @errmsg = 'APTB transaction payment rec was not created for ExpMth: ' + convert(varchar(8),@APTDMth,1) +
				' APTrans: ' + convert(varchar(4),@APTDAPTrans) + ' SL: ' + @SL + '.'
				SELECT @rcode = 1
				GOTO APTD_end
				END
			END 

			-- insert APDB 
			IF NOT EXISTS (SELECT * 
							FROM dbo.APDB 
							WHERE Co=@co and Mth=@batchmth and BatchId=@batchid and BatchSeq=@batchseq
							and ExpMth=@APTDMth and APTrans=@APTDAPTrans and APLine=@APTDLine and APSeq=@APTDSeq)
			BEGIN	
			-- split APTD if Amount is more than what is left to pay on retainage
			if @APTDAmt > (@AmtToPay - @AmtLeftToPay)
--			@APTDAmt >   (@AmtToPay - @AmtLeftToPay)
--			   150   > 100 (500     -    400)			
--			Seq 2 = 100 
--			Seq 3 =  50
--			Send over $50
			-- split APTD retainage payment
			BEGIN
				SELECT @AmtToSplit = @APTDAmt - (@AmtToPay - @AmtLeftToPay)
				EXEC @rcode = bspAPProcessPartialPayments @co, @APTDMth, @APTDAPTrans,@APTDLine, @APTDSeq,
				   @AmtToSplit, null, 'N', null,'Y', null, 'Y', 'N', @errmsg output
				IF @rcode <> 0
				BEGIN
					SELECT @errmsg = @errmsg + ' - APTD payment split was not made for Mth: ' + convert(varchar(8),@APTDMth,1) +
					' APTrans: ' + convert(varchar(4),@APTDAPTrans) + ' SL: ' + @SL + '.'
					SELECT @rcode = 1
					GOTO APTD_end
				END
				ELSE
					--set APTD Amount - Amount minus what was split out
					SELECT @APTDAmt = @APTDAmt - @AmtToSplit
			END

			-- Insert APDB	
			INSERT INTO dbo.APDB (
				Co,                            
				Mth,                           
				BatchId,                       
				BatchSeq,                      
				ExpMth,                        
				APTrans,                       
				APLine,                        
				APSeq,                         
				PayType,                       
				Amount,                        
				DiscTaken,                     
				PayCategory,                   
				TotTaxAmount)
			SELECT @co,@batchmth,@batchid,@batchseq,@APTDMth,@APTDAPTrans,@APTDLine,@APTDSeq,PayType,@APTDAmt,DiscTaken,PayCategory,TotTaxAmount
			FROM dbo.APTD 
			WHERE APCo=@co and Mth=@APTDMth and APTrans=@APTDAPTrans and APLine=@APTDLine and APSeq=@APTDSeq
			IF @@ROWCOUNT = 0
			BEGIN
				SELECT @errmsg = 'APDB payment transaction detail was not created for ExpMth: ' + convert(varchar(8),@APTDMth,1) +
					' APTrans: ' + convert(varchar(4),@APTDAPTrans) + ' SL: ' + @SL + '.'
				SELECT @rcode = 1
				GOTO APTD_end
			END
			ELSE
			BEGIN
				SELECT @AmtLeftToPay = @AmtLeftToPay + @APTDAmt
				-- update APTB with gross, description
				SELECT @GrossAmt = sum(Amount) 
				FROM dbo.APTD 
				WHERE APCo = @co and Mth = @APTDMth and APTrans = @APTDAPTrans

				SELECT @Description 
				FROM dbo.APTH 
				WHERE APCo = @co and Mth = @APTDMth and APTrans = @APTDAPTrans

				UPDATE dbo.APTB set Gross = @GrossAmt, Description=@Description
				FROM dbo.APTB 
				WHERE Co = @co and Mth = @batchmth and BatchId = @batchid
				   and BatchSeq = @batchseq and ExpMth = @APTDMth and APTrans = @APTDAPTrans
			END 
		END	
		END
		GOTO APDB_loop

		APTD_end:	
       	CLOSE bcAPTDr
           deallocate bcAPTDr
   		SELECT @opencursorAPTD = 0

	END

   
   bspexit:
   	RETURN @rcode


GO
PRINT N'Refreshing [dbo].[SMWorkOrderContactDefault]'
GO
EXEC sp_refreshview N'[dbo].[SMWorkOrderContactDefault]'
GO
PRINT N'Refreshing [dbo].[JCOHTotals]'
GO
EXEC sp_refreshview N'[dbo].[JCOHTotals]'
GO
PRINT N'Refreshing [dbo].[brvJCCMDet]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCMDet]'
GO
PRINT N'Altering [dbo].[vspIMUploadHeaderDetailPay]'
GO
ALTER   procedure [dbo].[vspIMUploadHeaderDetailPay]
     
     /**************************************************
      *
      *  Created By:	MV 08/19/09
      *  Modified By:	MV 11/23/09 - #130949 @ExpMthID, @APTransID,@InvDateID 
	  *					MV 12/08/09 - #130949 @INMWinsert
	  *					GF 06/25/2010 - issue #135813 expanded SL to varchar(30)
	  *					MV 02/14/11 - #142713
	  *					MV 03/21/13 - TFS 44601 - If Textura retg payment, bypass non-retg coding
	  *					MV 04/17/13 - TFS 47145 - Get Textura retg Flag before processing APTBs
      *
      *USAGE:
      *
      * Upload data from IMWE to APPB,APTB tables.  Designed 
      * for Textura AP Payment imports. Creates third payment 
	  * table records - APDB.  Handles retainage imported payments
	  * separately.  Looks for released retainage and creates APTBs 
	  * and APDBs.   
      *
      *INPUT PARAMETERS
      *    Company, ImportId, Template, Errmsg
      *
      *RETURN PARAMETERS
      *    Error Message
      *
      *None
      *
      *************************************************/
     
     
       (@importid varchar(20) = null, @template varchar(30) = null, @errmsg varchar(500) = null output)
     
     AS
	 SET NOCOUNT ON
     
     /* Store current state for ANSI_WARNINGS to restore at end. */
     DECLARE @ANSIWARN int
     SELECT @ANSIWARN = 0
     IF @@OPTIONS & 8 > 0
     	SELECT @ANSIWARN = 1
     SET ANSI_WARNINGS OFF
     
     
     --Locals
     DECLARE @ident int, @detailident int, @headrecseq int, @detailrecseq int, 
     @columnlist varchar(max), @valuelist varchar(max), @rcode int, 
     @detailcollist varchar(max), @detailvallist varchar(max),
     @detailinsert varchar(max), @headerinsert varchar(max),@headerkeyident int, 
     @detailkeyident int, @headerkeycol int, @detailkeycol int, @quote int, 
     @importcolumn varchar(30), @importvalue varchar(max), @coltype varchar(20),
     @headform varchar(30), @detailform varchar(30), @headerr int, @detailerr int,
     @deletestmt varchar(8000), @errcode int, @errdesc varchar(255), @ErrorMessage varchar(2048),
     @firstform varchar(30), @secondform varchar(30), @rectypecount int, @batchyn char(1), 
     @headtable varchar(10), @detailtable varchar(10), @headrectype varchar(10), 
     @detailrectype varchar(10), @batchid bBatchID, @batchmth varchar(25), @batchseq int,
     @batchlock varchar(max), @batchunlock varchar(max), @maxbatchid int, @sql varchar(max),
     @updateIMBC varchar(max), @imbccount int, @rc int, @retainageident int, @retainageYN bYN,
     @IMWMinsert varchar(max), @intrans int, @quoteloc int, @hcstatus int, @dcstatus int,
     @DetailCursorOpen int, @HeaderCursorOpen int,@TexturaYN bYN,@apdbrcode int,

	--APDB variables
	@ExpMth			bDate,			@APTrans		bTrans,		@APRef			varchar(15),
	@AmtToPay		bDollar,		@RetainageFlag	bYN,		@InvDate		bDate,
	@SL				VARCHAR(30),	@HeaderCMCo		bCompany,	@HeaderCMAcct	bCMAcct,
	@HeaderCMRef	bCMRef,		

	-- ID --
	@CoID		int, @MthID				int, @ExpMthID			int, @APTransID		int,   
	@InvDateID	int, @RetainageFlagID	int, @AmtToPayID		int, @APRefID		int,
	@SLID		int, @HeaderCMCoID		int, @HeaderCMAcctID	int, @HeaderCMRefID	int
     

     DECLARE @coident int, @co bCompany, @form varchar(30), @batchassign_errmsg varchar(8000)
     
     --the ascii code for a single quote
     SELECT @quote = 39
     
     --initialize the error code
     SELECT @rcode = 0, @ident = -1, @headrecseq = -1, @headerr = 0, @DetailCursorOpen = 0, @HeaderCursorOpen = 0, @apdbrcode = 0
     
     SELECT @rectypecount = count(ImportTemplate) FROM IMTR with (nolock) WHERE ImportTemplate = @template
     
     --we should only have 2 record types but we don't know which one is header or which one is detail
     IF @rectypecount = 2
     BEGIN
     	SELECT @headrectype = min(RecordType) FROM IMTR with (nolock) WHERE ImportTemplate = @template
     	SELECT @firstform = Form FROM IMTR with (nolock) WHERE ImportTemplate = @template and RecordType = @headrectype 
     	SELECT @detailrectype = RecordType FROM IMTR with (nolock) WHERE ImportTemplate = @template and RecordType > @headrectype
     	SELECT @secondform = Form FROM IMTR with (nolock) WHERE ImportTemplate = @template and RecordType = @detailrectype
     END
    -- set Textura flag 
	IF @template = 'AP Pay Txt'
	BEGIN
		SELECT @TexturaYN = 'Y'
	END
	ELSE
		BEGIN
		SELECT @TexturaYN = 'N'
		END

     SELECT @headform = Form, @batchyn = BatchYN FROM DDUF with (nolock) WHERE Form = @firstform 
     IF @batchyn = 'N'
     BEGIN
     	SELECT @headform = Form, @batchyn = BatchYN 
		FROM dbo.DDUF with (nolock) 
		WHERE Form = @secondform 
   		SELECT @headrectype = RecordType 
		FROM dbo.IMTR with (nolock) 
		WHERE ImportTemplate = @template and Form = @headform
   
     	IF @batchyn = 'N'
     	--we got an error here.  Bump out of procedure.
     	BEGIN
     		SELECT @errmsg = 'Unable to get upload form information', @rcode = 1
     		INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message)
     		VALUES (@importid, @template, @firstform, @headrecseq, @errmsg)
     		GOTO bspexit
     	END
     	ELSE
			BEGIN
     			SELECT @detailform = Form 
				FROM dbo.DDUF 
				WHERE Form = @firstform 
   			-- correct the record types.
   				SELECT @detailrectype = RecordType FROM IMTR with (nolock) WHERE ImportTemplate = @template and Form = @detailform
   			END
		END
     ELSE
     	SELECT @detailform = Form 
		FROM dbo.DDUF with (nolock) 
		WHERE Form = @secondform 
     
		SELECT @headtable = ViewName 
		FROM dbo.vDDFH with (nolock) 
		WHERE Form = @headform
     
     IF @headtable = ''
     BEGIN
     	SELECT @errmsg = 'Unable to get Header table information', @rcode = 1
     	INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message)
     	VALUES (@importid, @template, @firstform, @headrecseq, @errmsg)
     	GOTO bspexit
     END
     
     SELECT @detailtable = ViewName 
	 FROM dbo.vDDFH 
	 WHERE Form = @detailform
     
     IF @detailtable = ''
     BEGIN
     	SELECT @errmsg = 'Unable to get Detail table information', @rcode = 1
     	INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message)
     	VALUES (@importid, @template, @firstform, @headrecseq, @errmsg)
     	GOTO bspexit
     END
     
     --Get the identifier for the company.  This should be the first identifier.
     SELECT @coident = min(Identifier)
     FROM IMWE with (nolock)
     WHERE ImportTemplate = @template and RecordType = @headrectype 
     and ImportId = @importid	
     --new company stuff
     
     --call bspIMBatchAssign to spin through IMWE and assign the batches.
     EXEC @rc = bspIMBatchAssign @importid, @template, @headrectype, @headform, @coident, @batchassign_errmsg output
     IF @rc <> 0
     BEGIN
     	SELECT @errmsg = 'Unable to assign batch.  ' + @batchassign_errmsg
     	SELECT @rcode = 1
     	goto bspexit
     END
     
     --Get the key column identifier
   	SELECT @headerkeyident = a.Identifier
   	FROM dbo.IMTD a with (nolock) 
	JOIN dbo.DDUD b with (nolock) on a.Identifier = b.Identifier
   	WHERE a.ImportTemplate=@template AND b.ColumnName = 'RecKey'
   		and a.RecordType = @headrectype and b.Form = @headform
   
     DECLARE HeaderCursor CURSOR FOR
     SELECT DISTINCT IMWE.RecordSeq FROM 
     IMWE with (nolock) left outer join DDUD with (nolock) on 
     	IMWE.Form = DDUD.Form and 
     	DDUD.TableName = @headtable and 
     	DDUD.Identifier = IMWE.Identifier 
     INNER JOIN IMTD with (nolock) on 
     	IMWE.ImportTemplate = IMTD.ImportTemplate and 
     	IMWE.Identifier = IMTD.Identifier and 
     	IMWE.RecordType = IMTD.RecordType 
     WHERE IMWE.ImportId = @importid and 
     	IMWE.ImportTemplate = @template and 
     	IMWE.RecordType = @headrectype 
     order by IMWE.RecordSeq
     
     OPEN HeaderCursor
     SELECT @HeaderCursorOpen = 1
     FETCH NEXT FROM HeaderCursor INTO @headrecseq
     SELECT @hcstatus = @@FETCH_STATUS
     
     	WHILE @hcstatus = 0
     	BEGIN  --outer while
     		SELECT @headerr = 0, @detailerr = 0
     		SELECT @IMWMinsert = null
     		--Develop header record
     		--Get the key value
     		SELECT @headerkeycol = UploadVal 
			FROM dbo.IMWE with (nolock) 
			WHERE ImportTemplate = @template and RecordType = @headrectype
     			and	Identifier = @headerkeyident and RecordSeq = @headrecseq and ImportId = @importid

			--Validate the CMRef 
			--get identifiers 
			SET @HeaderCMCoID = dbo.bfIMTemplateDefaults(@template, @headform, 'CMCo', @headrectype, 'Y')
			SET @HeaderCMAcctID = dbo.bfIMTemplateDefaults(@template, @headform, 'CMAcct', @headrectype, 'Y')
			SET @HeaderCMRefID = dbo.bfIMTemplateDefaults(@template, @headform, 'CMRef', @headrectype, 'N')
			
			--CMCo
			SELECT @HeaderCMCo =  IMWE.UploadVal 
			FROM dbo.IMWE
			WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @headrectype AND IMWE.RecordSeq = @headrecseq
					AND IMWE.Identifier = @HeaderCMCoID
			--CMAcct
			SELECT @HeaderCMAcct =  IMWE.UploadVal 
			FROM dbo.IMWE
				WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @headrectype AND IMWE.RecordSeq = @headrecseq
					AND IMWE.Identifier = @HeaderCMAcctID
			--CMRef
			SELECT @HeaderCMRef =  IMWE.UploadVal FROM dbo.IMWE
				WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @headrectype AND IMWE.RecordSeq = @headrecseq
					AND IMWE.Identifier = @HeaderCMRefID

			
			-- Payment Batch
		   IF exists(SELECT 1 FROM dbo.APPB with (nolock) WHERE PayMethod = 'C' and ChkType = 'I' and CMCo = @HeaderCMCo and CMAcct = @HeaderCMAcct
				and case isNumeric(CMRef) WHEN 1 THEN convert(float,CMRef) ELSE 0 END = @HeaderCMRef)
			BEGIN 
				SELECT @rcode = 1, @headerr = 1
				SELECT @errmsg = 'Entries in a Payment Batch have already been assigned Check#: ' +  isnull(@HeaderCMRef,'') + '!'
				INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message, Identifier)
				VALUES (@importid, @template, @firstform, @headrecseq, @errmsg, @ident)
				GOTO GetNextHeaderReqSeq
			END
			-- Payment History
		   IF EXISTS (SELECT 1 FROM dbo.APPH WHERE PayMethod='C' and ChkType = 'I' and CMCo = @HeaderCMCo and CMAcct = @HeaderCMAcct
			   and case isNumeric(CMRef) when 1 THEN convert(float,CMRef) ELSE 0 END = @HeaderCMRef)
			BEGIN
			  SELECT @rcode = 1, @headerr = 1
				SELECT @errmsg = 'Entries in Payment History have already been assigned Check#: ' +  isnull(@HeaderCMRef,'') + '!'
				INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message, Identifier)
				VALUES (@importid, @template, @firstform, @headrecseq, @errmsg, @ident)
				GOTO GetNextHeaderReqSeq
			END
		   --  CM Detail  
		   IF EXISTS (SELECT 1 FROM dbo.CMDT with (nolock) WHERE CMCo = @HeaderCMCo and CMAcct = @HeaderCMAcct and CMTransType = 1	
					and case isNumeric(CMRef) WHEN 1 THEN convert(float,CMRef) ELSE 0 END = @HeaderCMRef)
    		BEGIN
				SELECT @rcode = 1, @headerr = 1
				SELECT @errmsg = 'Check #: ' + isnull(@HeaderCMRef,'') + ' already exists as CM Detail!'
				INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message, Identifier)
				VALUES (@importid, @template, @firstform, @headrecseq, @errmsg, @ident)
				GOTO GetNextHeaderReqSeq
    		END


     		--Get the first identifier for this RecordSequence
     		SELECT @ident = min(Identifier) 
			FROM dbo.IMWE with (nolock) 
			WHERE IMWE.ImportId = @importid and 
     			IMWE.ImportTemplate = @template and IMWE.RecordType = @headrectype and 
     			IMWE.RecordSeq = @headrecseq
     
     		WHILE @ident is not null
     		BEGIN  --inner header req while
     
     			SELECT @importcolumn = null, @importvalue = null
     			IF EXISTS(SELECT 1 
								FROM INFORMATION_SCHEMA.COLUMNS c
								JOIN DDUD d ON c.TABLE_NAME = d.TableName AND c.COLUMN_NAME = d.ColumnName
								WHERE (c.CHARACTER_MAXIMUM_LENGTH > 60 OR c.CHARACTER_MAXIMUM_LENGTH  = -1) 
							          AND d.Form = @headform AND d.Identifier = @ident AND d.TableName = @headtable)
				BEGIN
					SELECT @importvalue = (SELECT UploadVal FROM IMWENotes WITH (NOLOCK)
     										WHERE IMWENotes.ImportId = @importid AND 
     										IMWENotes.ImportTemplate = @template AND 
     										IMWENotes.RecordType = @headrectype AND 
		 									IMWENotes.Identifier = @ident AND 
	     									IMWENotes.RecordSeq = @headrecseq)
     
     				SELECT @importcolumn = (SELECT DDUD.ColumnName 
											FROM dbo.IMWENotes WITH (NOLOCK) 
     										LEFT OUTER JOIN dbo.DDUD WITH (NOLOCK) ON IMWENotes.Form = DDUD.Form AND 
     										DDUD.TableName = @headtable AND 
     										DDUD.Identifier = IMWENotes.Identifier 
		 									WHERE IMWENotes.ImportId = @importid AND 
     										IMWENotes.ImportTemplate = @template AND 
     										IMWENotes.RecordType = @headrectype AND 
		 									IMWENotes.Identifier = @ident AND 
	     									IMWENotes.RecordSeq = @headrecseq)
				END
				ELSE
				  BEGIN
     				SELECT @importvalue = (SELECT IMWE.UploadVal FROM IMWE with (nolock)
     										WHERE IMWE.ImportId = @importid and 
     										IMWE.ImportTemplate = @template and 
     										IMWE.RecordType = @headrectype and 
		 									IMWE.Identifier = @ident and 
	     									IMWE.RecordSeq = @headrecseq)
     
     				SELECT @importcolumn = (SELECT DDUD.ColumnName FROM IMWE with (nolock) 
     										LEFT OUTER JOIN dbo.DDUD with (nolock) on IMWE.Form = DDUD.Form and 
     										DDUD.TableName = @headtable and 
     										DDUD.Identifier = IMWE.Identifier 
     										WHERE IMWE.ImportId = @importid and 
     										IMWE.ImportTemplate = @template and 
     										IMWE.RecordType = @headrectype and 
		 									IMWE.Identifier = @ident and 
	     									IMWE.RecordSeq = @headrecseq)
				  END
     			--Get the destination Company
     			IF @ident = @coident SELECT @co = @importvalue
     
				IF ISNULL(@co,'') = ''
				BEGIN
					--Write back to IMWE
					update IMWE
					SET UploadVal = '*MISSING REQUIRED VALUE*'
					WHERE ImportId = @importid and ImportTemplate = @template and Identifier = @coident and RecordSeq = @headrecseq
    	
    				SELECT @errmsg = 'Batch Company is null'

					INSERT IMWM ( ImportId, ImportTemplate, Form, RecordSeq, Identifier, Error, Message)
    				VALUES (@importid, @template, @firstform, @headrecseq, @ident, @errcode, @errmsg)
				
    				--dump this record seq.  go onto next one	
					SELECT @rcode = 1, @headerr = 1
    				GOTO GetNextHeaderReqSeq
				END
     			--get the batch info stuff
     			IF @importcolumn = 'Mth'
     				SELECT @batchmth = @importvalue
     			IF @importcolumn = 'BatchId'
     				SELECT @batchid = @importvalue
				--new batch seq code
     			IF upper(@importcolumn) = 'BATCHSEQ'  
     			BEGIN
     				exec @rc = bspIMGetLastBatchSeq @co, @batchmth, @batchid, @headtable, @maxbatchid output, @errmsg output
     				IF @rc = 0
     				BEGIN
     					SELECT @importvalue = convert(varchar(100), @maxbatchid + 1)
     					SELECT @batchseq = @importvalue
     				END
     				ELSE
     				BEGIN
     					SELECT @rcode = 1, @headerr = 1
     					SELECT @errmsg = 'Unable get last Batch Seq.  ' + @errmsg
     					INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message, Identifier)
     					VALUES (@importid, @template, @firstform, @headrecseq, @errmsg, @ident)
     					GOTO bspexit
     				END
     			END
     
     			--determine if column is required....
     			IF @importvalue = '' or @importvalue is null
     			BEGIN	
     				if (SELECT COLUMNPROPERTY( OBJECT_ID(@headrectype),@importcolumn,'AllowsNull')) = 0 
     				--update upload value...message that Table.Column cannot be null
     				--stop developing this record, go to next record sequence
     				--write message to IMWM
     				BEGIN 
     					SELECT @rcode = 1, @headerr = 1
       					SELECT @errmsg = 'Identifier ' + convert(varchar(10), @ident) + '.  Column : ' + @importcolumn + ' does not allow null values!' 
     					INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message, Identifier)
     					VALUES (@importid, @template, @firstform, @headrecseq, @errmsg, @ident)
     
     					GOTO GetNextHeaderReqSeq
     				END
     			ELSE
     				--set and emtry string to null
     				SELECT @importvalue = null
     			END
     
     
     			IF @importcolumn is not null
     			BEGIN
     				SELECT @coltype = ColType 
     				FROM dbo.DDUD with (nolock) 
     				WHERE Form = @headform and Identifier = @ident
     
     				IF @importvalue IS NOT NULL
     				BEGIN
     					--Catch fields with embedded single quotes...
     					IF CHARINDEX(char(@quote),@importvalue) > 0
     					BEGIN
     						--replace single quotes with single back-quotes
     						SELECT @importvalue = REPLACE(@importvalue, char(@quote), '`')
     					END
     					
     					IF @coltype = 'varchar' or @coltype = 'text'
     					IF isnull(@importvalue,'') <> '' 
     					BEGIN
     						SELECT @importvalue = char(@quote) + @importvalue + char(@quote)
     					END
     					ELSE
     					BEGIN
     						SELECT @importvalue = 'char(null)'
     					END
     
     				IF @coltype = 'char' 
     				IF isnull(@importvalue,'') <> '' 
     				BEGIN
     					SELECT @importvalue = char(@quote) + @importvalue + char(@quote)
     				END
     				ELSE
     				BEGIN
     					SELECT @importvalue = 'char(null)'
     				END
     
     				IF @coltype = 'smalldatetime' 
     					IF isnull(@importvalue,'') <> '' 
     					BEGIN
     						SELECT @importvalue = char(@quote) + ltrim(@importvalue) + char(@quote)
     					END
     					ELSE
     					BEGIN
     						SELECT @importvalue = 'char(null)'
     					END
     
     				IF @coltype = 'tinyint' or @coltype = 'int' or @coltype = 'numeric' 
     				BEGIN
     					IF isnull(@importvalue,'') = '' SELECT @importvalue = 'char(null)'
     				END
     
     				IF @coltype IN ('bigint','int','smallint','tinyint','decimal','numeric','money','smallmoney','float','real')
     				BEGIN
					  SET @importvalue = replace(@importvalue, ',', '') 
     				  IF isnumeric(@importvalue) <> 1 and @importvalue is not null and @importvalue <> 'char(null)'
     				  BEGIN
     					SELECT @rcode = 1, @headerr = 1
     					SELECT @errmsg = 'Identifier ' + convert(varchar(10), @ident) + '.  Column : ' + @importcolumn + ' does not allow non-numeric values!' 
     	
     			        UPDATE IMWE
     				  	SET UploadVal = '*VALUE NOT NUMERIC*'
     		          	WHERE ImportId = @importid and ImportTemplate = @template 
     						and Identifier = @ident and RecordSeq = @headrecseq and Form = @firstform
     	
     					INSERT IMWM (ImportId, ImportTemplate, Form, RecordSeq, Message, Identifier)
     					VALUES (@importid, @template, @firstform, @headrecseq, @errmsg, @ident)
     				
     					GOTO GetNextHeaderReqSeq
     				  END
     				END
     
     				IF @valuelist is not null
     					SELECT @valuelist = @valuelist + ',' + @importvalue
     				ELSE
     					SELECT @valuelist = 'values (' + @importvalue
     	
     				IF @columnlist is null
     					SELECT @columnlist = 'Insert into ' + @headtable + ' (' + @importcolumn
     				ELSE
     					SELECT @columnlist = @columnlist + ',' + @importcolumn
     
     			  END
     			END	
     
     			--get the next identifier
				SELECT @ident = MIN(Identifier) 
								FROM (SELECT MIN(Identifier) AS Identifier 
										FROM IMWE WITH (NOLOCK) 
										WHERE IMWE.ImportId = @importid AND 
     									IMWE.ImportTemplate = @template AND IMWE.RecordType = @headrectype AND 
     									IMWE.RecordSeq = @headrecseq AND IMWE.Identifier > @ident
				UNION ALL
				SELECT MIN(Identifier) AS Identifier 
				FROM dbo.IMWENotes WITH (NOLOCK) 
				WHERE IMWENotes.ImportId = @importid AND 
     			IMWENotes.ImportTemplate = @template AND IMWENotes.RecordType = @headrectype AND 
     			IMWENotes.RecordSeq = @headrecseq AND IMWENotes.Identifier > @ident) AS IMWEUnion 
     		END
     
     
     		SELECT @headerinsert = @columnlist + ') ' + @valuelist + ')'
     
     		--lock the batch
     		SELECT @batchlock = 'update HQBC set InUseBy = ' + char(@quote) + SUSER_SNAME() + 
     			char(@quote) + ' where Co = ' + convert(varchar(3),@co) + ' and Mth = ' + 
     			char(@quote) + convert(varchar(30), @batchmth) + char(@quote) + ' and BatchId = ' + 
     			CONVERT(varchar(6),@batchid) 
     
     		BEGIN TRANSACTION 
     		SELECT @intrans = 1
     
     		EXEC(@batchlock)
   
   			DELETE 
			FROM IMWM 
			WHERE ImportId = @importid and Error = 9999
   			INSERT into IMWM(ImportId, ImportTemplate, Form, RecordSeq, Error, Message, SQLStatement)
   			VALUES (@importid, @template, @headform, @headrecseq, 9999, '', @headerinsert)
     
			SELECT @errcode = 0
    
			BEGIN TRY
     		--execute the insert APPB statement
     		EXEC(@headerinsert)

			END TRY
     
		  BEGIN CATCH
			SELECT @errcode = ERROR_NUMBER(), @ErrorMessage = ERROR_MESSAGE(), @rcode = 1
			-- Test whether the transaction is uncommittable.
			IF (XACT_STATE()) <> 0
				BEGIN
					ROLLBACK TRANSACTION;
					SET @intrans = 0
				END

			UPDATE IMWM
			SET Error = @errcode, Message = @ErrorMessage
			WHERE ImportId = @importid and ImportTemplate = @template and Form = @headform and RecordSeq = @headrecseq
	    
			IF @@rowcount <> 1
			  BEGIN
			  INSERT IMWM ( ImportId, ImportTemplate, Form, RecordSeq, Error, Message)
			  VALUES (@importid, @template, @headform, @headrecseq, @errcode, @ErrorMessage)
    		  END
		  END CATCH

     		IF @errcode = 0
     		BEGIN
     			--unlock the batch
     			SELECT @batchunlock = 'update HQBC set InUseBy = null where Co = ' + convert(varchar(3),@co) + ' and Mth = ' + 
     			char(@quote) + convert(varchar(30), @batchmth) + char(@quote) + ' and BatchId = ' + 
     			convert(varchar(6),@batchid) 
     
     			EXEC(@batchunlock)
     
     			IF @@error <> 0
     			BEGIN
     				--insert was sucessful but could not unlock the batch, 
     				--abort the whole transaction. may want to consider bumping out
     				--of the whole procedure.
     				SELECT @headerr = 1
     				SELECT @errcode = @@error
     				GOTO GetNextHeaderReqSeq
     			END
     		END
     		ELSE
     		BEGIN
     			--insert failed, abort transaction
     			SELECT @headerr = 1
     			GOTO GetNextHeaderReqSeq
     		END
     
     		SELECT @headerinsert = null
     		
     
     		--Clear out the columnlist and valuelist
     		SELECT @columnlist = null, @valuelist = null, @coltype = null
     	
     
    --Now work on the line item detail records
    --Get the identifier for the key column
DetailInsert:
   		SELECT @detailkeyident = a.Identifier
   		FROM IMTD a jOIN DDUD b on a.Identifier = b.Identifier
   		WHERE a.ImportTemplate=@template AND b.ColumnName = 'RecKey'
   		and a.RecordType = @detailrectype and b.Form = @detailform

			-- get identifiers 
			SET @ExpMthID			= dbo.bfIMTemplateDefaults(@template, @detailform, 'ExpMth', @detailrectype, 'Y')
			IF @ExpMthID = 0 SET @ExpMthID = dbo.bfIMTemplateDefaults(@template, @detailform, 'ExpMth', @detailrectype, 'N')
			SET @APTransID			= dbo.bfIMTemplateDefaults(@template, @detailform, 'APTrans', @detailrectype, 'Y')
			IF @APTransID = 0 SET @APTransID = dbo.bfIMTemplateDefaults(@template, @detailform, 'APTrans', @detailrectype, 'N')
			SET @InvDateID			= dbo.bfIMTemplateDefaults(@template, @detailform, 'InvDate', @detailrectype, 'Y')
			IF  @InvDateID = 0 SET @InvDateID = dbo.bfIMTemplateDefaults(@template, @detailform, 'InvDate', @detailrectype, 'N')
			SET @RetainageFlagID	= dbo.bfIMTemplateDefaults(@template, @detailform, 'RetainageFlag', @detailrectype, 'Y')
			IF  @RetainageFlagID = 0 SET @RetainageFlagID = dbo.bfIMTemplateDefaults(@template, @detailform, 'RetainageFlag', @detailrectype, 'N')
			SET @APRefID			= dbo.bfIMTemplateDefaults(@template, @detailform, 'APRef', @detailrectype, 'N')
			IF  @APRefID = 0 SET @APRefID = dbo.bfIMTemplateDefaults(@template, @detailform, 'APRef', @detailrectype, 'Y')
			SET @AmtToPayID			= dbo.bfIMTemplateDefaults(@template, @detailform, 'AmountToPay', @detailrectype, 'N')
			IF  @AmtToPayID = 0 SET @AmtToPayID = dbo.bfIMTemplateDefaults(@template, @detailform, 'AmountToPay', @detailrectype, 'Y')
			SET @SLID				= dbo.bfIMTemplateDefaults(@template, @detailform, 'Subcontract', @detailrectype, 'N')
			IF  @SLID = 0 SET @SLID = dbo.bfIMTemplateDefaults(@template, @detailform, 'Subcontract', @detailrectype, 'Y')
		

     		--Get Set of detail records associated with the header record's key value
     		DECLARE DetailCursor CURSOR FOR
     		SELECT distinct IMWE.RecordSeq 
     		FROM IMWE with (nolock) left outer join DDUD with (nolock) on 	
     			IMWE.Form = DDUD.Form and 
     			DDUD.TableName = @detailtable and 
     			DDUD.Identifier = IMWE.Identifier 
     		iNNER JOIN IMTD with (nolock) on 
     			IMWE.ImportTemplate = IMTD.ImportTemplate and 
     			IMWE.Identifier = IMTD.Identifier and 
     			IMWE.RecordType = IMTD.RecordType  
     		WHERE IMWE.ImportId = @importid and 
     		IMWE.ImportTemplate = @template and 
     		IMWE.RecordType = @detailrectype and 
     		IMWE.Identifier = @detailkeyident and
     		IMWE.UploadVal = @headerkeycol
     		ORDER BY IMWE.RecordSeq
     
     
     		OPEN DetailCursor
    		SELECT @DetailCursorOpen = 1
     		FETCH NEXT FROM DetailCursor INTO @detailrecseq
     		SELECT @dcstatus = @@FETCH_STATUS
     
     		WHILE @dcstatus = 0
     		BEGIN
     			SELECT @detailkeycol = UploadVal 
     			FROM IMWE with (nolock) 
     			WHERE ImportTemplate = @template and 
     			RecordType = @detailrectype and 
     			RecordSeq = @detailrecseq and 
     			Identifier = @detailkeyident and 
     			ImportId = @importid


--				Get rest of key values 
				-- ExpMth
				SELECT @ExpMth =  IMWE.UploadVal 
				FROM dbo.IMWE
				WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
					AND IMWE.Identifier = @ExpMthID
				-- APTrans
				SELECT @APTrans =  IMWE.UploadVal 
				FROM dbo.IMWE 
				WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
					AND IMWE.Identifier = @APTransID
				--APRef
				SELECT @APRef =  IMWE.UploadVal 
				FROM dbo.IMWE
				WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
					AND IMWE.Identifier = @APRefID

				-- if this is a Textura import get retainage flag
				IF @TexturaYN = 'Y'
				BEGIN
				-- RetainageFlag
				SELECT @RetainageFlag =  IMWE.UploadVal 
				FROM dbo.IMWE
				WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
					AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
					AND IMWE.Identifier = @RetainageFlagID
				END

				-- if bAPTB already exists go to APDB insert
				IF EXISTS
						(
							SELECT * 
							FROM dbo.APTB (nolock) 
							WHERE Co=@co and Mth=@batchmth and BatchId=@batchid and
								BatchSeq=@batchseq and ExpMth=@ExpMth and APTrans=@APTrans and APRef=@APRef
						) 
				GOTO APDBInsert

				-- If this is a Textura Retainage only payment go directly to APDB insert.  APDB Insert process will
				-- create both the bAPTB and bAPDB for Textura retainage only payments.
				IF @TexturaYN = 'Y' AND ISNULL(@RetainageFlag,'N') = 'R' GOTO APDBInsert
	
				-- If payment is not a Textura retainage payment, handle as normal invoice payment
     			--Get the first identifier for this RecordSequence
     			SELECT @detailident = MIN(Identifier) 
     			FROM dbo.IMWE with (nolock) 
     			WHERE IMWE.ImportId = @importid and 
     			IMWE.ImportTemplate = @template and 
     			IMWE.RecordType = @detailrectype and 
     			IMWE.RecordSeq = @detailrecseq 
     
     			IF @detailkeycol = @headerkeycol
     			BEGIN
     			WHILE @detailident is not null
     			BEGIN
     				SELECT @importcolumn = null, @importvalue = null, @coltype = null
					IF EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS c
							   JOIN DDUD d ON c.TABLE_NAME = d.TableName AND c.COLUMN_NAME = d.ColumnName
							   WHERE (c.CHARACTER_MAXIMUM_LENGTH > 60 OR c.CHARACTER_MAXIMUM_LENGTH  = -1) 
							          AND d.Form = @detailform AND d.Identifier = @detailident AND d.TableName = @detailtable)
					BEGIN
	     				SELECT @importcolumn = (SELECT dbo.DDUD.ColumnName FROM IMWENotes WITH (NOLOCK) 
		 										LEFT OUTER JOIN dbo.DDUD WITH (NOLOCK) ON IMWENotes.Form = DDUD.Form AND 
     												DDUD.TableName = @detailtable AND 
     												DDUD.Identifier = IMWENotes.Identifier 
		 										WHERE IMWENotes.ImportId = @importid AND 
     												IMWENotes.ImportTemplate = @template AND 
     												IMWENotes.RecordType = @detailrectype AND 
     												IMWENotes.Identifier = @detailident AND 
     												IMWENotes.RecordSeq = @detailrecseq)
     
	     				SELECT @importvalue = (SELECT IMWENotes.UploadVal 
												FROM dbo.IMWENotes WITH (NOLOCK)   
		 										LEFT OUTER JOIN dbo.DDUD WITH (NOLOCK) ON IMWENotes.Form = DDUD.Form AND 
     												DDUD.TableName = @detailtable AND 
     												DDUD.Identifier = IMWENotes.Identifier 
		 										WHERE IMWENotes.ImportId = @importid AND 
     												IMWENotes.ImportTemplate = @template AND 
     												IMWENotes.RecordType = @detailrectype AND 
     												IMWENotes.Identifier = @detailident AND 
     												IMWENotes.RecordSeq = @detailrecseq)
					END
					ELSE
					  BEGIN
	     				SELECT @importcolumn = (SELECT DDUD.ColumnName 
												FROM dbo.IMWE with (nolock) 
		 										LEFT OUTER JOIN dbo.DDUD with (nolock) on IMWE.Form = DDUD.Form and 
     												DDUD.TableName = @detailtable and 
     												DDUD.Identifier = IMWE.Identifier 
		 										WHERE IMWE.ImportId = @importid and 
     												IMWE.ImportTemplate = @template and 
     												IMWE.RecordType = @detailrectype and 
     												IMWE.Identifier = @detailident and 
     												IMWE.RecordSeq = @detailrecseq)
     
	     				SELECT @importvalue = (SELECT IMWE.UploadVal FROM IMWE with (nolock)  
		 										LEFT OUTER JOIN dbo.DDUD with (nolock) on IMWE.Form = DDUD.Form and 
     												DDUD.TableName = @detailtable and 
     												DDUD.Identifier = IMWE.Identifier 
		 										WHERE IMWE.ImportId = @importid and 
     												IMWE.ImportTemplate = @template and 
     												IMWE.RecordType = @detailrectype and 
     												IMWE.Identifier = @detailident and 
     												IMWE.RecordSeq = @detailrecseq)
					  END
     				IF @importcolumn is not null
     				BEGIN
     					IF @importcolumn = 'BatchId'
     						SELECT @importvalue = @batchid
     
     					IF @importcolumn = 'Mth'
     						SELECT @importvalue = @batchmth
     
     					IF @importcolumn = 'BatchSeq'
     						SELECT @importvalue = @batchseq
     
     					IF @importvalue = '' or @importvalue is null
     					BEGIN	
     						IF (SELECT COLUMNPROPERTY( OBJECT_ID(@detailrectype),@importcolumn,'AllowsNull')) = 0 
     						--update upload value...message that Table.Column cannot be null
     						--stop developing this record, go to next record sequence
     						BEGIN 
     							SELECT @rcode = 1, @detailerr = 1
     							SELECT @errmsg =  'Column : ' + @importcolumn + ' does not allow null values! See Identifier ' 
     												+ convert(varchar(10), @detailident)
     
     							--Build error message to input after transaction rollback, otherwise gets rolled back!
     							SELECT @IMWMinsert = 'insert IMWM (ImportId, ImportTemplate, Form, RecordSeq, Error, Message, Identifier) ' +
     								'values (' + char(@quote) + @importid + char(@quote) + ',' + char(@quote) + @template + char(@quote) + ',' + 
     								char(@quote) + @secondform + char(@quote) + ',' + convert(varchar(10),@detailrecseq) + ',' + 
     								convert(varchar(10),@detailerr) + ',' + char(@quote) + @errmsg + char(@quote) + ',' + convert(varchar(10), @detailident) + ')'
								
     							GOTO GetNextHeaderReqSeq	--Exit on first detail error, because we can't store more than one insert statement for IMWM.
     						END
     						ELSE
     							SELECT @importvalue = null
     					END
     					--Catch fields with embedded single quotes...
     					IF CHARINDEX(char(@quote),@importvalue) > 0
     					BEGIN
     						--replace single quotes with single back-quotes
     						SELECT @importvalue = REPLACE(@importvalue, char(@quote), '`')
     					END
     
     					--Varchar, Char, and Smalldatetime data types need to be encapsulated in '''
     					SELECT @coltype = ColType 
     					FROM dbo.DDUD 
						WHERE Form = @detailform and Identifier = @detailident
     
     					IF @coltype = 'varchar' OR @coltype = 'text'
     					BEGIN
     						IF isnull(@importvalue,'') <> '' 
     						BEGIN
     							SELECT @importvalue = char(@quote) + @importvalue + char(@quote)
     						END
     						ELSE
     					BEGIN
     							SELECT @importvalue = 'char(null)'
     						END
     					END
     
     					--if @coltype = 'char' SELECT @importvalue = char(@quote) + @importvalue + char(@quote)
     					IF @coltype = 'char' 
     					BEGIN
     						IF isnull(@importvalue,'') <> '' 
     						BEGIN
     							SELECT @importvalue = char(@quote) + @importvalue + char(@quote)
     						END
     					ELSE
     					BEGIN
     						SELECT @importvalue = 'char(null)'
     					END
     				END
     
     				--if @coltype = 'smalldatetime' SELECT @importvalue = char(@quote) + ltrim(@importvalue) + char(@quote)
     				IF @coltype = 'smalldatetime' 
     				BEGIN
     					IF isnull(@importvalue,'') <> '' 
     					BEGIN
							SELECT @importvalue = char(@quote) + ltrim(@importvalue) + char(@quote)
     					END
     					ELSE
     					BEGIN
     						SELECT @importvalue = 'char(null)'
     					END
     				END
     
     				IF @coltype = 'tinyint' or @coltype = 'int' or @coltype = 'numeric' 
     				BEGIN
     					IF isnull(@importvalue,'') = '' SELECT @importvalue = 'char(null)'
     				END
     
     				IF @coltype IN ('bigint','int','smallint','tinyint','decimal','numeric','money','smallmoney','float','real')
     				BEGIN
					  SET @importvalue = replace(@importvalue, ',', '') --CC issue #127127
     				  IF isnumeric(@importvalue) <> 1 and @importvalue IS NOT NULL AND @importvalue <> 'char(null)'
     				  BEGIN
     					SELECT @rcode = 1, @detailerr = 1
     					SELECT @errmsg =  'Column : ' + @importcolumn + ' does not allow non-numeric values! See Identifier ' 
     										+ convert(varchar(10), @detailident)
     					
     					--Build error message to input after transaction rollback, otherwise gets rolled back!
     					SELECT @IMWMinsert = 'insert IMWM (ImportId, ImportTemplate, Form, RecordSeq, Error, Message, Identifier) ' +
     						'values (' + char(@quote) + @importid + char(@quote) + ',' + char(@quote) + @template + char(@quote) + ',' + 
     						char(@quote) + @secondform + char(@quote) + ',' + convert(varchar(10),@detailrecseq) + ',' + 
     						convert(varchar(10),@detailerr) + ',' + char(@quote) + @errmsg + char(@quote) + ',' + convert(varchar(10), @detailident) + ')'
				
     					GOTO GetNextHeaderReqSeq	--Save time by exiting now, but remaining details may have errors.
     
     				  END
     				END
     
     				IF @importvalue IS NOT NULL
     				BEGIN
     					IF @detailvallist IS NOT NULL
     						SELECT @detailvallist = @detailvallist + ',' + @importvalue
     					ELSE
     						SELECT @detailvallist = 'values (' + @importvalue 
     
     					IF @detailcollist is not null
     						SELECT @detailcollist = @detailcollist + ',' + @importcolumn
     					ELSE
     						SELECT @detailcollist = 'insert into ' + @detailtable + ' (' + @importcolumn 
     			  	END
     			END
     
     			--Get the next identifier for this RecordSequence
				SELECT @detailident = MIN(Identifier) 
				FROM (SELECT MIN(Identifier) AS Identifier 
						FROM dbo.IMWE WITH (NOLOCK) 
						WHERE IMWE.ImportId = @importid AND 
     					IMWE.ImportTemplate = @template AND IMWE.RecordType = @detailrectype AND 
     					IMWE.RecordSeq = @detailrecseq AND IMWE.Identifier > @detailident
							UNION ALL
						SELECT MIN(Identifier) AS Identifier 
						FROM dbo.IMWENotes WITH (NOLOCK) 
						WHERE IMWENotes.ImportId = @importid AND 
     						IMWENotes.ImportTemplate = @template AND IMWENotes.RecordType = @detailrectype AND 
     						IMWENotes.RecordSeq = @detailrecseq AND IMWENotes.Identifier > @detailident) AS IMWEUnion 
     		END	--develop detail 
     
     		SELECT @detailinsert = @detailcollist + ') ' + @detailvallist + ')'
     
   			DELETE FROM IMWM WHERE ImportId = @importid and Error = 9999
   			INSERT into IMWM(ImportId, ImportTemplate, Form, RecordSeq, Error, Message, SQLStatement)
   			VALUES (@importid, @template, @headform, @detailrecseq, 9999, '', @detailinsert)
   
			SELECT @errcode = 0

			BEGIN TRY
     		EXEC(@detailinsert)

			END TRY 
		   
			BEGIN CATCH
			SELECT @errcode = ERROR_NUMBER(), @ErrorMessage = ERROR_MESSAGE(), @rcode = 1

			-- Test whether the transaction is uncommittable.
			IF XACT_STATE() <>0
				BEGIN
					ROLLBACK TRANSACTION;
					SET @intrans = 0
				END

				Update IMWM
				SET Error = @errcode, Message = @ErrorMessage
				WHERE ImportId = @importid and ImportTemplate = @template and Form = @detailform and RecordSeq = @detailrecseq
		    
				IF @@rowcount <> 1
				  BEGIN
				  INSERT IMWM ( ImportId, ImportTemplate, Form, RecordSeq, Error, Message)
				  VALUES (@importid, @template, @detailform, @detailrecseq, @errcode, @ErrorMessage)
				  END
			END CATCH
     
     		IF @errcode <> 0
     		BEGIN
     			SELECT @detailerr = 1
     			GOTO GetNextHeaderReqSeq
     		END
     
     		SELECT @detailcollist = null
     		SELECT @detailvallist = null
     		SELECT @detailinsert = null
     
     	END
	
	APDBInsert:
		-- prepare to insert bAPDB records 
		-- get rest of IMWE values to pass

		-- InvDate
		SELECT @InvDate =  IMWE.UploadVal 
		FROM dbo.IMWE 
		WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
			AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
			AND IMWE.Identifier = @InvDateID

		-- AmtToPay
		SELECT @AmtToPay =  IMWE.UploadVal  
		FROM dbo.IMWE
		WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
			AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
			AND IMWE.Identifier = @AmtToPayID

		-- if this is a Textura import get SL
		IF @TexturaYN = 'Y'
		BEGIN
			SELECT @SL =  IMWE.UploadVal 
			FROM dbo.IMWE
			WHERE IMWE.ImportTemplate = @template AND IMWE.ImportId = @importid 
				AND IMWE.RecordType = @detailrectype AND IMWE.RecordSeq = @detailrecseq
				AND IMWE.Identifier = @SLID
		END
  
		SELECT @errcode = 0

		-- execute sp to insert APDB records for invoices or create APTB/APDB for released retainage
		BEGIN TRY
     		EXEC @apdbrcode = vspIMUploadAPDB @co, @batchmth, @batchid,@batchseq,
			@ExpMth,@APTrans,@APRef,@InvDate, @RetainageFlag,@AmtToPay,@SL,@TexturaYN, @errmsg output
			IF @apdbrcode=1
			BEGIN
			-- RAISERROR with severity 11-19 will cause execution to jump to the CATCH block
			RAISERROR (@errmsg, -- Message text.
			   16, -- Severity.
			   1 -- State.
			   );
			END
			
		END TRY 
		   
		BEGIN CATCH
			SELECT @errcode = ERROR_NUMBER(), @rcode = 1
			-- Test whether the transaction is uncommittable.
			IF XACT_STATE() <>0 
			BEGIN
					ROLLBACK TRANSACTION;
					SET @intrans = 0
			END
			-- write to error log
			SELECT @ErrorMessage = ERROR_MESSAGE()
			INSERT dbo.IMWM ( ImportId, ImportTemplate, Form, RecordSeq, Error, Message)
			VALUES (@importid, @template, @detailform, @detailrecseq, 0, @ErrorMessage)

			IF @errcode <> 0
     		BEGIN
     			SELECT @detailerr = 1, @apdbrcode = 0
     			GOTO GetNextHeaderReqSeq
     		END

		END CATCH
     
     GetNextDetailReqSeq:
     
     	IF @detailerr = 0
     	BEGIN 
     		--only delete if detailkey and headerkey match
     		IF @detailkeycol = @headerkeycol
     		BEGIN
     			SELECT @deletestmt = 'Delete IMWE where ImportId = ' + char(@quote) + @importid + char(@quote) + 
     			' and RecordSeq = ' + convert(varchar(5),@detailrecseq) + ' and RecordType = ' + char(@quote) + 
     			@detailrectype + char(@quote)  
     
     			EXEC(@deletestmt)
     			SELECT @deletestmt = null
				
				SELECT @deletestmt = 'DELETE IMWENotes WHERE ImportId = ' + CHAR(@quote) + @importid + CHAR(@quote) + 
     			' AND RecordSeq = ' + CONVERT(VARCHAR(5),@detailrecseq) + ' AND RecordType = ' + CHAR(@quote) + 
     			@detailrectype + CHAR(@quote)  
     
     			EXEC(@deletestmt)
     			SELECT @deletestmt = NULL	
     		END
     	END
     	ELSE
     	BEGIN
     		SELECT @errdesc = description FROM master.dbo.sysmessages WHERE error = @errcode
     	END
     
     	SELECT @detailcollist = null, @detailvallist = null
     
     	FETCH NEXT FROM DetailCursor INTO @detailrecseq
     	SELECT @dcstatus = @@FETCH_STATUS
     
     END
     
     --get next header record
     GetNextHeaderReqSeq:
    	IF @DetailCursorOpen = 1
    	BEGIN
    	 	CLOSE DetailCursor
    		SELECT @DetailCursorOpen = 0
     		DEALLOCATE DetailCursor
     	END
    
     	SELECT @detailcollist = null
     	SELECT @detailvallist = null
     	SELECT @detailinsert = null
     	
     	IF @headerr = 0 and @detailerr = 0
     	BEGIN 
     
     		IF @intrans = 1
     		BEGIN
     			COMMIT TRANSACTION
     			SELECT @intrans = 0	
     		END
     		--Delete Record FROM IMWE
     		SELECT @deletestmt = 'Delete IMWE where ImportId = ' + char(@quote) + @importid + char(@quote) + 
     		' and RecordSeq = ' + convert(varchar(5),@headrecseq) + ' and RecordType = ' + char(@quote) +
     		@headrectype + char(@quote)
     
     		EXEC(@deletestmt)
     		SELECT @deletestmt = null
     
     		SELECT @deletestmt = 'DELETE IMWENotes WHERE ImportId = ' + CHAR(@quote) + @importid + CHAR(@quote) + 
     		' AND RecordSeq = ' + CONVERT(VARCHAR(5),@detailrecseq) + ' AND RecordType = ' + CHAR(@quote) + 
     		@detailrectype + CHAR(@quote)  
     
     		EXEC(@deletestmt)
     		SELECT @deletestmt = NULL	
     		--Update IMBC 
     		IF @batchid is not null
     		BEGIN
     			SELECT @imbccount = (SELECT count(ImportId) FROM IMBC WHERE ImportId = @importid and Co = @co and Mth = @batchmth and BatchId = @batchid)
     
     			IF @imbccount = 0
     			BEGIN
     				INSERT IMBC (ImportId, Co, Mth, BatchId, RecordCount) 
					VALUES (@importid, @co, @batchmth, @batchid, 1)
     			END
     
     			IF @imbccount = 1
     			BEGIN
     				UPDATE IMBC set RecordCount = RecordCount + 1 WHERE ImportId = @importid and Co = @co and Mth = @batchmth and BatchId = @batchid
     			END
     
     			SELECT @imbccount = null
     
     		END
     	END
     	ELSE
     	BEGIN
     		IF @intrans = 1
     		BEGIN
     			ROLLBACK TRANSACTION
     			SELECT @intrans = 0
     		END
    
			IF @IMWMinsert IS NOT NULL
			EXEC(@IMWMinsert)
			
     		SELECT @rcode = 1
     		SELECT @errmsg = 'Data errors.  Check IM Work Edit and IMWM.'
     
     	END
     
     	SELECT @columnlist = null, @valuelist = null, @headerr = 0
     
     	SELECT @IMWMinsert = null
     
     	FETCH NEXT FROM HeaderCursor INTO @headrecseq
     	SELECT @hcstatus = @@FETCH_STATUS
     
     END --END outer while
     
     
     bspexit:
     
     IF @HeaderCursorOpen = 1 
     BEGIN
    	 CLOSE HeaderCursor
    	 SELECT @HeaderCursorOpen = 0
    	 deallocate HeaderCursor
     END
     
     IF @ANSIWARN = 1
     SET ANSI_WARNINGS ON
     
     
     RETURN @rcode




GO
PRINT N'Refreshing [dbo].[JCPBCalculations]'
GO
EXEC sp_refreshview N'[dbo].[JCPBCalculations]'
GO
PRINT N'Refreshing [dbo].[brvJCCObyContractItem]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCObyContractItem]'
GO
PRINT N'Refreshing [dbo].[PRSM]'
GO
EXEC sp_refreshview N'[dbo].[PRSM]'
GO
PRINT N'Refreshing [dbo].[POTotals]'
GO
EXEC sp_refreshview N'[dbo].[POTotals]'
GO
PRINT N'Refreshing [dbo].[MSIDGrid]'
GO
EXEC sp_refreshview N'[dbo].[MSIDGrid]'
GO
PRINT N'Refreshing [dbo].[APTBGrid]'
GO
EXEC sp_refreshview N'[dbo].[APTBGrid]'
GO
PRINT N'Refreshing [dbo].[RPTY]'
GO
EXEC sp_refreshview N'[dbo].[RPTY]'
GO
PRINT N'Refreshing [dbo].[JBITNotes]'
GO
EXEC sp_refreshview N'[dbo].[JBITNotes]'
GO
PRINT N'Refreshing [dbo].[MSQDPM]'
GO
EXEC sp_refreshview N'[dbo].[MSQDPM]'
GO
PRINT N'Refreshing [dbo].[RPTYc]'
GO
EXEC sp_refreshview N'[dbo].[RPTYc]'
GO
PRINT N'Refreshing [dbo].[JBITRetgGrid]'
GO
EXEC sp_refreshview N'[dbo].[JBITRetgGrid]'
GO
PRINT N'Refreshing [dbo].[brvJCContStat]'
GO
EXEC sp_refreshview N'[dbo].[brvJCContStat]'
GO
PRINT N'Refreshing [dbo].[PMDocDistribution]'
GO
EXEC sp_refreshview N'[dbo].[PMDocDistribution]'
GO
PRINT N'Altering [dbo].[vspPMSendSearchAvailableDocuments]'
GO



/********************************************************/
ALTER procedure [dbo].[vspPMSendSearchAvailableDocuments]
/************************************************************************
* Created By:	TRL 10/19/2012 TK-18468 Added procedure to database
* Modified By:	GP  10/19/2012 Added FormCo and UniqueAttchID, also fixed cast of Rev errors
*				TRL 10/25/2012 TK-18827 Added SourceDocumentKeyID parameter
*				GP	10/12/2012 TK-19144 Removed check against KeyID, created another proc for selected records
*				TRL 11/28/2012 TK-19691  Added section for SUBITEM
*				GP	12/06/2012 TK-19818 Added DocType to select for PMSubmittalPackage
*				AJW 12/13/12 TK-20167 Refactored to include logic from vspPMSendSearchSelectedDocuments 
*						and add DDFH info and contact counts to results
*				AJW 05/09/2013 TFS-49469 Performance change
*
* This stored procedure will search for available document (form records) 
* that can be used to link documents for a message
*
*************************************************************************/
(@PMCo bCompany, @Project bProject, @FormName varchar(30)=NULL, @DocumentType bDocType=NULL,
@Firm bVendor=NULL, @Vendor bVendor=NULL, @SourceDocumentKeyID bigint = null,
@errmsg varchar(256)=NULL)

AS

SET NOCOUNT ON 

DECLARE @rcode tinyint, @templatetype varchar(max), @tmpformname varchar(max), @tablename varchar(max) 

select @rcode = 0

IF @PMCo IS NULL
BEGIN
	select @errmsg = 'Missing PM Company', @rcode=1
	goto vspexit
END

IF @Project IS NULL
BEGIN
	select @errmsg = 'Missing Project', @rcode=1
	goto vspexit
END

CREATE TABLE #DocumentTable(
  [Doc Type] VARCHAR(MAX),
  [Doc ID] VARCHAR(MAX),
  [Revision] VARCHAR(MAX),
  [Date] SMALLDATETIME,
  [Description] VARCHAR(MAX),
  [Firm] VARCHAR(MAX),
  [Firm Name] VARCHAR(MAX),
  [Vendor] VARCHAR(MAX),
  [Vendor Name] VARCHAR(MAX),
  [Doc Cat] VARCHAR(MAX),
  [FormName] VARCHAR(MAX),
  [KeyID] BIGINT,
  [FormCo] BIGINT,
  [UniqueAttchID] uniqueidentifier
)

SET @tmpformname = 'PMChangeOrderRequest'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--COR:  No Doc Type, No Revision, No Responible Firm, No Vendor
	SET @templatetype = 'COR'
	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT null AS [Doc Type], Convert(varchar,a.COR) AS [Doc ID], null AS [Revision], a.Date AS [Date],
		a.Description AS [Description], null AS [Firm], null AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype AS [Doc Cat], @tmpformname AS [FormName], a.KeyID AS [KeyID], a.PMCo as [FormCo], a.UniqueAttchID AS [UniqueAttchID]
	FROM dbo.PMChangeOrderRequest a
		INNER JOIN dbo.JCJM b ON  a.PMCo=b.JCCo and a.Contract=b.Contract
	WHERE a.PMCo=@PMCo AND b.Job = @Project AND @DocumentType IS NULL AND @Firm IS NULL AND @Vendor IS NULL
END

SET @tmpformname = 'PMContractChangeOrder'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
    --CCO:  No Doc Type, No Revision, No Responible Firm, No Vendor
	SET @templatetype = 'CCO'
	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT null AS [Doc Type], Convert(varchar,a.ID) AS [Doc ID], null AS [Revision], a.Date AS [Date], a.Description AS [Description], 
		  null AS [Firm], null AS [Firm Name], null AS [Vendor], null AS [Vendor Name], 
		  @templatetype as [Doc Cat], @tmpformname AS [FormName], a.KeyID AS [KeyID], a.PMCo as [FormCo], a.UniqueAttchID
	FROM dbo.PMContractChangeOrder a
		INNER JOIN dbo.JCJM b ON  a.PMCo=b.JCCo and a.Contract=b.Contract
	WHERE a.PMCo=@PMCo AND b.Job = @Project 
		AND @DocumentType IS NULL  AND @Firm IS NULL AND @Vendor IS NULL
END

SET @tmpformname = 'PMDrawingLogs'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--DRAWING:  Has Doc Type, No Revision, No Responible Firm, No Vendor
	SET @templatetype = 'DRAWING'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT h.DrawingType AS [Doc Type], h.Drawing AS [Doc ID], null AS [Revision], h.DateIssued AS [Date], h.Description AS [Description], 
		null AS [Firm], null AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], h.KeyID AS [KeyID], h.PMCo as [FormCo], h.UniqueAttchID
	FROM dbo.PMDG h 
		LEFT JOIN PMDR d on h.PMCo=d.PMCo AND h.Project=d.Project AND h.DrawingType=d.DrawingType AND h.Drawing=d.Drawing
	WHERE h.PMCo=@PMCo AND h.Project = @Project AND ISNULL(h.DrawingType,'')=IsNull(@DocumentType,ISNULL(h.DrawingType,''))
		AND @Firm IS NULL AND @Vendor IS NULL
	GROUP BY h.DrawingType,h.Drawing, h.DateIssued, h.Description, h.KeyID, h.PMCo, h.UniqueAttchID
END

SET @tmpformname = 'PMInspectionLogs'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--INSPECT:  Has Doc Type, No Revision, No Responible Firm, No Vendor
	SET @templatetype = 'INSPECT'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT  InspectionType AS [Doc Type], InspectionCode AS [Doc ID], null AS [Revision], InspectionDate AS [Date], Description AS [Description], 
		null AS [Firm], null AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], KeyID AS [KeyID], PMCo as [FormCo], UniqueAttchID
	FROM dbo.PMIL 
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(InspectionType,'')=ISNULL(@DocumentType,ISNULL(InspectionType,'')) 
		AND @Firm IS NULL AND @Vendor IS NULL
END

SET @tmpformname = 'PMProjectIssues'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--ISSUE:  No Doc Type, No Revision, No Responible Firm, No Vendor
	SET @templatetype = 'ISSUE'
	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT null AS [Doc Type], CONVERT(varchar,Issue) AS [Doc ID], null AS [Revision], DateInitiated AS [Date], Description AS [Description], 
		RelatedFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMIM.KeyID AS [KeyID], 
		PMIM.PMCo as [FormCo], PMIM.UniqueAttchID
	FROM dbo.PMIM 
		LEFT JOIN dbo.PMFM ON PMIM.VendorGroup=PMFM.VendorGroup AND PMIM.RelatedFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(RelatedFirm,'')=ISNULL(@Firm,ISNULL(RelatedFirm,''))
		AND @DocumentType IS NULL  AND @Vendor IS NULL
END

SET @tmpformname = 'PMOtherDocs'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--OTHER:  Has Doc Type, No Revision, Has Responible Firm, No Vendor
	SET @templatetype = 'OTHER'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT DocType AS [Doc Type], Document AS [Doc ID], null AS [Revision], DateDue AS [Date], Description AS [Description], 
		RelatedFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMOD.KeyID AS [KeyID], PMOD.PMCo as [FormCo], PMOD.UniqueAttchID
	FROM dbo.PMOD 
		LEFT JOIN dbo.PMFM ON PMOD.VendorGroup=PMFM.VendorGroup AND PMOD.RelatedFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(DocType,'')=ISNULL(@DocumentType,ISNULL(DocType,''))  
		AND ISNULL(RelatedFirm,'') = ISNULL(@Firm,ISNULL(RelatedFirm,'')) AND @Vendor IS NULL
END

SET @tmpformname = 'PMPCOS'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--PCO:  No Doc Type, No Revision, Has Responible Firm, No Vendor
	SET @templatetype = 'PCO'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT PCOType AS [Doc Type], PCO AS [Doc ID], null AS [Revision], ApprovalDate AS [Date], Description AS [Description], 
		NULL AS [Firm], NULL AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMOP.KeyID AS [KeyID], PMOP.PMCo as [FormCo], PMOP.UniqueAttchID
	FROM dbo.PMOP 
		LEFT JOIN dbo.PMFM ON PMOP.VendorGroup=PMFM.VendorGroup AND PMOP.ResponsibleFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(PCOType,'')=ISNULL(@DocumentType,ISNULL(PCOType,'')) 
		AND @Firm IS NULL
END

/* PURCHASE is not currently a supported doctype Place holder in case we implement it someday */
--SET @tmpformname = 'PMPOHeader'
--IF dbo.vfToString(@FormName) in (@tmpformname,'')
--BEGIN
--	--PURHASE/PO:  No Doc Type, No Revision, No Responible Firm, Has Vendor
--	SET @templatetype = 'PURCHASE'
--  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
--		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
--	SELECT NULL AS [Doc Type], PO AS [Doc ID], null AS [Revision], OrderDate AS [Date], Description AS [Description], 
--		NULL AS [Firm], null AS [Firm Name], POHDPM.Vendor AS [Vendor], APVM.Name AS [Vendor Name],
--		@templatetype as [Doc Cat], @tmpformname AS [FormName], POHDPM.KeyID AS [KeyID], POHDPM.PMCo as [FormCo], POHDPM.UniqueAttchID
--	FROM dbo.POHDPM
--		LEFT JOIN dbo.APVM ON APVM.VendorGroup=POHDPM.VendorGroup AND APVM.Vendor=POHDPM.Vendor
--	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(POHDPM.Vendor,'') = ISNULL(@Vendor,ISNULL(POHDPM.Vendor,''))
--		AND @DocumentType IS NULL AND @Firm IS NULL 
--END

SET @tmpformname = 'PMPOCO'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--PURHASECO/POCO:  No Doc Type, Has Revision, No Responible Firm, Has Vendor
	SET @templatetype = 'PURCHASECO'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT NULL AS [Doc Type], a.PO AS [Doc ID], CAST(a.POCONum AS VARCHAR(10)) AS [Revision], a.Date AS [Date], a.Description AS [Description], 
		NULL AS [Firm], null AS [Firm Name], b.Vendor AS [Vendor], c.Name AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], a.KeyID AS [KeyID], a.PMCo as [FormCo], a.UniqueAttchID
	FROM dbo.PMPOCO a
		LEFT JOIN dbo.POHDPM b ON a.PMCo=b.PMCo AND a.Project =b.Project AND a.PO=b.PO AND a.POCo=b.POCo 
		LEFT JOIN dbo.APVM c ON b.VendorGroup=c.VendorGroup AND b.Vendor=c.Vendor
	WHERE a.PMCo=@PMCo AND a.Project = @Project  AND ISNULL(b.Vendor,'') = ISNULL(@Vendor,ISNULL(b.Vendor,''))
		AND @DocumentType IS NULL AND @Firm IS NULL 
END

SET @tmpformname = 'PMRFI'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--RFI:  Has Doc Type, No Revision, Has Responible Firm, No Vendor
	SET @templatetype = 'RFI'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT  RFIType AS [Doc Type], RFI AS [Doc ID], null AS [Revision], RFIDate AS [Date], Subject AS [Description], 
		ReqFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMRI.KeyID AS [KeyID], PMRI.PMCo as [FormCo], PMRI.UniqueAttchID
	FROM dbo.PMRI 
		LEFT JOIN dbo.PMFM ON PMRI.VendorGroup=PMFM.VendorGroup AND PMRI.ReqFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(RFIType,'')=ISNULL(@DocumentType,ISNULL(RFIType,'')) AND ISNULL(ReqFirm,'')=ISNULL(@Firm,ISNULL(ReqFirm,'')) 
		AND @Vendor IS NULL
END

SET @tmpformname = 'PMRFQ'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--RFQ:  Has Doc Type, Has Revision, No Responible Firm, No Vendor
	SET @templatetype = 'RFQ'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT PCOType AS [Doc Type], PCO AS [Doc ID], CAST(RFQ AS VARCHAR(10)) AS [Revision], RFQDate AS [Date], Description AS [Description], 
		NULL AS [Firm], NULL AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], KeyID AS [KeyID], PMCo as [FormCo], UniqueAttchID
	FROM dbo.PMRQ 
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(PCOType,'')=ISNULL(@DocumentType,ISNULL(PCOType,'')) 
		AND @Firm IS NULL AND @Vendor IS NULL
END

SET @tmpformname = 'PMSLHeader'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--SUBCONTRACT/SL:  No Doc Type, No Revision, No Responible Firm, Has Vendor
	SET @templatetype = 'SUB'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT NULL AS [Doc Type], SL AS [Doc ID], null AS [Revision], OrigDate AS [Date], Description AS [Description], 
		NULL AS [Firm], null AS [Firm Name], SLHDPM.Vendor AS [Vendor], APVM.Name AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], SLHDPM.KeyID AS [KeyID], SLHDPM.PMCo as [FormCo], SLHDPM.UniqueAttchID
	FROM dbo.SLHDPM
		LEFT JOIN dbo.APVM ON APVM.VendorGroup=SLHDPM.VendorGroup AND APVM.Vendor=SLHDPM.Vendor
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(SLHDPM.Vendor,'') =ISNULL(@Vendor, ISNULL(SLHDPM.Vendor,''))
		AND @DocumentType IS NULL AND @Firm IS NULL 
END

SET @tmpformname = 'PMSLHeader' -- Sub with items is an exception to the rule where @FormName = DDFH.Form 
IF dbo.vfToString(@FormName) in ('PMSLHeaderItem','')
BEGIN
	--SUBITEM:  No Doc Type, No Revision, No Responible Firm, Has Vendor
	SET @templatetype = 'SUBITEM'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT NULL AS [Doc Type], SL AS [Doc ID], null AS [Revision], OrigDate AS [Date], Description AS [Description], 
		NULL AS [Firm], null AS [Firm Name], SLHDPM.Vendor AS [Vendor], APVM.Name AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], SLHDPM.KeyID AS [KeyID], SLHDPM.PMCo as [FormCo], SLHDPM.UniqueAttchID
	FROM dbo.SLHDPM
		LEFT JOIN dbo.APVM ON APVM.VendorGroup=SLHDPM.VendorGroup AND APVM.Vendor=SLHDPM.Vendor
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(SLHDPM.Vendor,'') = ISNULL(@Vendor,ISNULL(SLHDPM.Vendor,''))
		AND @DocumentType IS NULL AND @Firm IS NULL
END

SET @tmpformname = 'PMSubcontractCO'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--SUBCO:  No Doc Type, Has Revision, No Responible Firm, Has Vendor
	SET @templatetype = 'SUBCO'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT NULL AS [Doc Type], a.SL AS [Doc ID], CAST(a.SubCO AS VARCHAR(10)) AS [Revision], a.Date AS [Date], a.Description AS [Description], 
		NULL AS [Firm], null AS [Firm Name], b.Vendor AS [Vendor], c.Name AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], a.KeyID AS [KeyID], a.PMCo as [FormCo], a.UniqueAttchID
	FROM dbo.PMSubcontractCO a
		INNER JOIN dbo.SLHDPM b ON a.PMCo=b.PMCo AND a.Project =b.Project  AND a.SLCo=b.SLCo AND a.SL=b.SL
		LEFT JOIN dbo.APVM c ON b.VendorGroup=c.VendorGroup AND b.Vendor=c.Vendor
	WHERE a.PMCo=@PMCo AND a.Project = @Project  AND ISNULL(b.Vendor,'') = ISNULL(@Vendor,ISNULL(b.Vendor,''))
		AND @DocumentType IS NULL AND @Firm IS NULL
END

SET @tmpformname = 'PMSubmittalRegisterGrid'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--SBMTL:  Has Doc Type, Has Revision, Has Responible Firm, No Vendor
	SET @templatetype = 'SBMTL'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT  DocumentType AS [Doc Type], SubmittalNumber AS [Doc ID], CAST(SubmittalRev AS VARCHAR(10)) AS [Revision], ActivityDate AS [Date], Description AS [Description], 
		ResponsibleFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMSubmittal.KeyID AS [KeyID], PMSubmittal.PMCo as [FormCo], 
		PMSubmittal.UniqueAttchID
	FROM dbo.PMSubmittal 
		LEFT JOIN dbo.PMFM ON PMSubmittal.VendorGroup=PMFM.VendorGroup AND PMSubmittal.ResponsibleFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(ResponsibleFirm,'')=ISNULL(@Firm,IsNULL(ResponsibleFirm,'')) 
		AND IsNULL(DocumentType,'')=ISNULL(@DocumentType,IsNULL(DocumentType,'')) 
		AND @Vendor IS NULL
END

SET @tmpformname = 'PMSubmittalPackage'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--SBMTLPCKG:  No Doc Type, Has Revision, No Responible Firm, No Vendor
	SET @templatetype = 'SBMTLPCKG'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT DocType AS [Doc Type], Package AS [Doc ID], CAST(PackageRev AS VARCHAR(10)) AS [Revision], ActivityDate AS [Date], Description AS [Description], 
		ApprovingFirm AS [Firm], null AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat],@tmpformname AS [FormName], PMSubmittalPackage.KeyID AS [KeyID], 
		PMSubmittalPackage.PMCo as [FormCo], PMSubmittalPackage.UniqueAttchID
	FROM dbo.PMSubmittalPackage 
		LEFT JOIN dbo.PMFM ON PMSubmittalPackage.VendorGroup=PMFM.VendorGroup AND PMSubmittalPackage.ApprovingFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(ApprovingFirm,'')=ISNULL(@Firm,ISNULL(ApprovingFirm,''))
		AND ISNULL(DocType,'')=ISNULL(@DocumentType,ISNULL(DocType,'')) AND @Vendor IS NULL
END

SET @tmpformname = 'PMSubmittal'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--SUBMIT: Has Doc Type, Has Revision, Has Responible Firm, No Vendor
	SET @templatetype = 'SUBMIT'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT SubmittalType AS [Doc Type], Submittal AS [Doc ID], CAST(Rev AS VARCHAR(10)) AS [Revision], DateReqd AS [Date], Description AS [Description], 
		ResponsibleFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMSM.KeyID AS [KeyID], PMSM.PMCo as [FormCo], PMSM.UniqueAttchID
	FROM dbo.PMSM 
		LEFT JOIN dbo.PMFM ON PMSM.VendorGroup=PMFM.VendorGroup AND PMSM.ResponsibleFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(ResponsibleFirm,'')=ISNULL(@Firm,isnull(ResponsibleFirm,''))
		AND ISNULL(SubmittalType,'')=ISNULL(@DocumentType,ISNULL(SubmittalType,'')) AND @Vendor IS NULL
END

SET @tmpformname = 'PMTestLogs'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--TEST:  Has Doc Type, No Revision, No Responible Firm, No Vendor
	SET @templatetype = 'TEST'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT TestType AS [Doc Type], TestCode AS [Doc ID], NULL AS [Revision], TestDate AS [Date], Description AS [Description], 
		TestFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMTL.KeyID AS [KeyID], PMTL.PMCo as [FormCo], PMTL.UniqueAttchID
	FROM dbo.PMTL 
		LEFT JOIN dbo.PMFM ON PMTL.VendorGroup=PMFM.VendorGroup AND PMTL.TestFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  AND ISNULL(TestType,'')=ISNULL(@DocumentType,ISNULL(TestType,'')) AND ISNULL(TestFirm,'')=ISNULL(@Firm,ISNULL(TestFirm,''))
		AND @Vendor IS NULL
END

SET @tmpformname = 'PMTransmittal'
IF dbo.vfToString(@FormName) in (@tmpformname,'')
BEGIN
	--TRANSMIT:  No Doc Type, No Revision, Has Responible Firm, No Vendor
	SET @templatetype = 'TRANSMIT'
  	INSERT #DocumentTable([Doc Type],[Doc ID],[Revision],[Date],[Description],[Firm],[Firm Name],[Vendor],
		[Vendor Name],[Doc Cat],[FormName], [KeyID],[FormCo],[UniqueAttchID])
	SELECT NULL AS [Doc Type], Transmittal AS [Doc ID], NULL AS [Revision], TransDate AS [Date], Subject AS [Description], 
		ResponsibleFirm AS [Firm], PMFM.FirmName AS [Firm Name], null AS [Vendor], null AS [Vendor Name],
		@templatetype as [Doc Cat], @tmpformname AS [FormName], PMTM.KeyID AS [KeyID], PMTM.PMCo as [FormCo], PMTM.UniqueAttchID
	FROM dbo.PMTM 
		LEFT JOIN dbo.PMFM ON PMTM.VendorGroup=PMFM.VendorGroup AND PMTM.ResponsibleFirm=PMFM.FirmNumber
	WHERE PMCo=@PMCo AND Project = @Project  
		AND @DocumentType IS NULL AND @Vendor IS NULL
END

-- return results from TableVariable Joining to PMCT and DDFH
SELECT t.Description as [Category], d.[Doc Type], d.[Doc ID], d.Revision, d.Date, d.Description, d.Firm, d.[Firm Name],
	d.Vendor, d.[Vendor Name], d.[Doc Cat], d.[FormName],
	f.ViewName AS [TableName], d.KeyID, d.FormCo, d.UniqueAttchID
	,f.AssemblyName AS [AssemblyName], f.FormClassName AS [FormClassName],
	 --SBMTL & SBMTLPKCG currently don't require any distribution to be set up for doc creation so ret 1 from them
	CASE WHEN d.[Doc Cat] in ('SBMTL','SBMTLPCKG') THEN 1 ELSE COUNT(v.DocKeyID) END as ContactCount
FROM #DocumentTable d
	JOIN DDFH f on f.Form=d.FormName
	JOIN PMCT t on d.[Doc Cat]=t.DocCat
	LEFT JOIN PMDocDistribution v on v.DocCat=d.[Doc Cat] and v.DocKeyID=d.KeyID
WHERE d.KeyID = isnull(@SourceDocumentKeyID,d.KeyID)
	AND isnull(v.CC,'N') = 'N' and isnull(v.Send,'Y') = 'Y' -- only Active To contacts should be counted
GROUP BY t.Description, d.[Doc Type], d.[Doc ID], d.Revision, d.Date, d.Description, d.Firm, d.[Firm Name],
	d.Vendor, d.[Vendor Name], d.[Doc Cat], d.[FormName],
	f.ViewName, d.KeyID, d.FormCo, d.UniqueAttchID
	,f.AssemblyName, f.FormClassName
ORDER BY [Category],[Doc Type],[Doc ID] desc,Revision,Date
vspexit:
	return @rcode



GO
PRINT N'Refreshing [dbo].[POVC]'
GO
EXEC sp_refreshview N'[dbo].[POVC]'
GO
PRINT N'Refreshing [dbo].[PMMFMOItemLookup]'
GO
EXEC sp_refreshview N'[dbo].[PMMFMOItemLookup]'
GO
PRINT N'Refreshing [dbo].[brvJCContStatItem]'
GO
EXEC sp_refreshview N'[dbo].[brvJCContStatItem]'
GO
PRINT N'Refreshing [dbo].[PRSQMaint]'
GO
EXEC sp_refreshview N'[dbo].[PRSQMaint]'
GO
PRINT N'Altering [dbo].[vspPRAUItemVal]'
GO
/****** Object:  Stored Procedure dbo.vspPRAUItemVal    Script Date: 8/28/99 9:33:18 AM ******/
ALTER  PROC [dbo].[vspPRAUItemVal]
/***********************************************************/
-- CREATED BY: EN 1/10/2011
-- MODIFIED BY: EN 02/27/2013  TFS-39858
--
-- USAGE:
-- Validates Australia PAYG Item Code against data in vPRAUItems which is a 
-- maintained by Viewpoint behind-the-scenes.  Table vPRAUItems dictates the 
-- available Items, the tab they are to be used on, and the order in which they
-- will appear in the PRAustraliaPAYG grid tabs and F4 lookups.  
-- This procedure determines if the Item Code is being used on the correct tab
-- and returns the Item Code Description if the Item Code is found to be valid.
--
-- INPUT PARAMETERS
--   @TaxYear	Tax Year
--   @Tab		Can be 'ATO', 'Super', or 'Misc'
--   @ItemCode	Code to validate
--
-- OUTPUT PARAMETERS
--   @Message	Error message if error occurs otherwise returns Item Description from vPRAUItems
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
-- TEST HARNESS
--
--	DECLARE	@ReturnCode int,
--			@Message varchar(60)
--
--	EXEC	@ReturnCode = [dbo].[vspPRAUItemVal]
--			@TaxYear = 2010,
--			@Tab = 'ATO',
--			@ItemCode = 'EF',
--			@Message = @Message OUTPUT
--
--	SELECT	@ReturnCode as 'Return Code', @Message as '@Message'
--
/******************************************************************/
(
@TaxYear char(4) = null,
@Tab char(5) = null, 
@ItemCode char(4) = null,
@Message varchar(60) output
)

AS
SET NOCOUNT ON

-- Lump Sum D is in PRAUItems for purposes of auto computation but is not valid for selection in ATO Items tab
IF @ItemCode = 'LSD '
BEGIN
	SELECT @Message = 'Not a valid item for selection.'
	RETURN 1
END

IF @TaxYear IS NULL
BEGIN
	SELECT @Message = 'Missing Tax Year!'
	RETURN 1
END

IF @Tab IS NULL
BEGIN
	SELECT @Message = 'Missing Tab Code!'
	RETURN 1
END

IF @ItemCode IS NULL
BEGIN
	SELECT @Message = 'Missing Item Code!'
	RETURN 1
END

--need to also check tax year range
SELECT @Message = ItemDescription 
FROM dbo.PRAUItems 
WHERE ItemCode = @ItemCode  
	  AND Tab = @Tab 
	  AND @TaxYear BETWEEN BeginTaxYear AND ISNULL(EndTaxYear, @TaxYear)

IF @@ROWCOUNT = 0
BEGIN
	SELECT @Message = 'Item is either invalid for this tab or for this tax year!'
	RETURN 1
END

RETURN 0

GO
PRINT N'Refreshing [dbo].[PCIntentToBidTemplate]'
GO
EXEC sp_refreshview N'[dbo].[PCIntentToBidTemplate]'
GO
PRINT N'Refreshing [dbo].[brvJCCostbyCTforACOI]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCostbyCTforACOI]'
GO
PRINT N'Altering [dbo].[vspPRAUPAYGItemSetup]'
GO

/****** Object:  Stored Procedure dbo.vspPRAUPAYGItemSetup    Script Date: 8/28/99 9:33:18 AM ******/
ALTER  PROC [dbo].[vspPRAUPAYGItemSetup]
/***********************************************************/
-- CREATED BY: LS 2/17/2011
-- MODIFIED BY: EN 05/22/2013 - User Story 50989 / Task 50990 Revise code to get Gross Payments dedns to ignore any with only dedicated earn codes of type LSAR/LSAT/LSB
--
-- USAGE:
-- Gathers the PAYG Setup information for the ATO Items, Superannuation Extra Items, and
-- the Miscellaneous Items.  It initializes the PAYG Setup by using the ATO Category 
-- assigned to each EDL Code. 
--
-- INPUT PARAMETERS
--   @PRCo		PR Company
--   @TaxYear	Tax Year
--
-- OUTPUT PARAMETERS
--   @Message	Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
-- TEST HARNESS
--
-- DECLARE	@ReturnCode int,
--			@Message varchar(60)

-- EXEC		@ReturnCode = [dbo].[vspPRAUPAYGItemSetup]
--			@PRCo = 204,
--			@TaxYear = '2010',
--			@Message = @Message OUTPUT

-- SELECT	@ReturnCode as 'Return Code', @Message as '@Messag
--
/******************************************************************/
(
@PRCo bCompany = null,
@TaxYear char(4) = null, 
@Message varchar(4000) output
)
AS
BEGIN
	SET NOCOUNT ON

	-- Check Parameters
	IF @PRCo IS NULL
	BEGIN
		SELECT @Message = 'Missing PR Company!'
		RETURN 1
	END

	IF @TaxYear IS NULL
	BEGIN
		SELECT @Message = 'Missing Tax Year!'
		RETURN 1
	END

	BEGIN TRY
		BEGIN TRAN
		-- Clear Current PAYG Setup
		DELETE FROM dbo.vPRAUEmployerATOItems WHERE PRCo = @PRCo AND TaxYear = @TaxYear
		DELETE FROM dbo.vPRAUEmployerSuperItems WHERE PRCo = @PRCo AND TaxYear = @TaxYear
		DELETE FROM dbo.vPRAUEmployerMiscItems WHERE PRCo = @PRCo AND TaxYear = @TaxYear

		-- Setup ATO Items (both Earnings, and Deductions / Liabilities)
		-- User Story 50989 / Task 50990: When getting Gross Payments dedns for Tax Witheld, ignore any with only dedicated earn codes of type LSAR/LSAT/LSB
		INSERT INTO dbo.vPRAUEmployerATOItems (PRCo, TaxYear, ItemCode, EDLType, EDLCode)
		SELECT	dl.PRCo, 
				@TaxYear AS TaxYear, 
				i.ItemCode, 
				dl.DLType AS EDLType, 
				dl.DLCode AS EDLCode 
		FROM dbo.bPRDL dl
		JOIN dbo.vPRAUItemsATOCategories a ON a.ATOCategory = dl.ATOCategory
		JOIN dbo.vPRAUItems i ON i.ItemCode = a.ItemCode
		WHERE	@TaxYear BETWEEN i.BeginTaxYear AND 
				ISNULL(i.EndTaxYear, @TaxYear) AND 
				i.Tab = 'ATO' AND 
				dl.PRCo = @PRCo AND
				(
				 NOT (a.ItemCode = 'GR  ' AND a.ATOCategory = 'T   ')
				 OR
				 (
				  (a.ItemCode = 'GR  ' AND a.ATOCategory = 'T   ') AND
				  EXISTS (SELECT TOP 1 1 FROM dbo.bPRDB db
						  JOIN dbo.bPREC ec ON ec.PRCo = db.PRCo AND (db.EDLType = 'E' AND ec.EarnCode = db.EDLCode)
						  WHERE db.PRCo = dl.PRCo AND 
								db.DLCode = dl.DLCode AND
								ISNULL(ec.ATOCategory, '') NOT IN ('LSAR', 'LSAT', 'LSB '))
				 )
			    )

		UNION

		SELECT e.PRCo, @TaxYear AS TaxYear, i.ItemCode, 'E' AS EDLType, e.EarnCode AS EDLCode FROM dbo.bPREC e
			JOIN dbo.vPRAUItemsATOCategories a ON a.ATOCategory = e.ATOCategory
			JOIN dbo.vPRAUItems i ON i.ItemCode = a.ItemCode
			WHERE @TaxYear BETWEEN i.BeginTaxYear AND ISNULL(i.EndTaxYear, @TaxYear) 
				AND i.Tab = 'ATO'
				AND e.PRCo = @PRCo
				
		-- Setup Superannuation Items (only DL Types)
		INSERT INTO dbo.vPRAUEmployerSuperItems (PRCo, TaxYear, ItemCode, DLType, DLCode)
		SELECT dl.PRCo, @TaxYear, i.ItemCode, dl.DLType, dl.DLCode FROM dbo.bPRDL dl
			JOIN dbo.vPRAUItemsATOCategories a ON a.ATOCategory = dl.ATOCategory
			JOIN dbo.vPRAUItems i ON i.ItemCode = a.ItemCode
			WHERE @TaxYear BETWEEN i.BeginTaxYear AND ISNULL(i.EndTaxYear, @TaxYear) 
				AND i.Tab = 'Super'
				AND dl.PRCo = @PRCo

		-- Setup Miscellaneous Items (both Earnings, and Deductions / Liabilities)
		INSERT INTO dbo.vPRAUEmployerMiscItems (PRCo, TaxYear, ItemCode, EDLType, EDLCode)
		SELECT dl.PRCo, @TaxYear AS TaxYear, i.ItemCode, dl.DLType AS EDLType, dl.DLCode AS EDLCode FROM dbo.bPRDL dl
			JOIN dbo.vPRAUItemsATOCategories a ON a.ATOCategory = dl.ATOCategory
			JOIN dbo.vPRAUItems i ON i.ItemCode = a.ItemCode
			WHERE @TaxYear BETWEEN i.BeginTaxYear AND ISNULL(i.EndTaxYear, @TaxYear) 
				AND i.Tab = 'Misc'
				AND dl.PRCo = @PRCo
		UNION
		SELECT e.PRCo, @TaxYear AS TaxYear, i.ItemCode, 'E' AS EDLType, e.EarnCode AS EDLCode FROM dbo.bPREC e
			JOIN dbo.vPRAUItemsATOCategories a ON a.ATOCategory = e.ATOCategory
			JOIN dbo.vPRAUItems i ON i.ItemCode = a.ItemCode
			WHERE @TaxYear BETWEEN i.BeginTaxYear AND ISNULL(i.EndTaxYear, @TaxYear) 
				AND i.Tab = 'Misc'
				AND e.PRCo = @PRCo

		-- Success, Commit the changes
		COMMIT TRAN
	END TRY
	BEGIN CATCH
		-- Rollback Transaction, if error is caught
		SET @Message = ERROR_MESSAGE()
		IF @@TRANCOUNT > 0 BEGIN ROLLBACK TRAN END
		RAISERROR (@Message, 15, 1)
	END CATCH

END


GO
PRINT N'Refreshing [dbo].[POVMUnionAllPOSM]'
GO
EXEC sp_refreshview N'[dbo].[POVMUnionAllPOSM]'
GO
PRINT N'Refreshing [dbo].[PCIntentToBidTemplateScopes]'
GO
EXEC sp_refreshview N'[dbo].[PCIntentToBidTemplateScopes]'
GO
PRINT N'Refreshing [dbo].[brvJCCostRevChgOrders]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCostRevChgOrders]'
GO
PRINT N'Creating [dbo].[vspPRAUPAYGItemVal]'
GO

/****** Object:  Stored Procedure dbo.vspPRAUPAYGItemVal    Script Date: 8/28/99 9:33:18 AM ******/
CREATE  PROC [dbo].[vspPRAUPAYGItemVal]
/***********************************************************/
-- CREATED BY: EN 5/21/2013
-- MODIFIED BY: 
--
-- USAGE:
-- Validates the Item # to make sure it is valid for the expected tab.
--
-- INPUT PARAMETERS
--   @TaxYear	Tax Year
--	 @ItemCode	ItemCode
--	 @Tab		'ATO' or 'Misc' or 'Super'
--
-- OUTPUT PARAMETERS
--   @Message	Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
-- TEST HARNESS
--
-- DECLARE	@ReturnCode int,
--			@Message varchar(60)

-- EXEC		@ReturnCode = [dbo].[vspPRAUPAYGItemVal]
--			@TaxYear = '2014',
--			@ItemCode = 1,
--			@Tab = 'ATO',
--			@Message = @Message OUTPUT

-- SELECT	@ReturnCode as 'Return Code', @Message as 'Error Message'
--
/******************************************************************/
(
 @TaxYear char(4) = null,
 @ItemCode char(4) = null,
 @Tab char(5) = null,
 @ErrorMsg varchar(255) output
)

AS

BEGIN TRY

	SET NOCOUNT ON
  
	DECLARE @Return_Value tinyint

	SET @Return_Value = 0
	
	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @TaxYear IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Tax Year!'
		GOTO vspExit
	END
	
	IF @ItemCode IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Item Code!'
		GOTO vspExit
	END
	
	IF @Tab IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Tab Value!'
		GOTO vspExit
	END

	-- determine if item code is valid
	IF NOT EXISTS	(SELECT 1 FROM dbo.vPRAUItems
					 WHERE @TaxYear BETWEEN BeginTaxYear AND ISNULL(EndTaxYear, @TaxYear) AND
						   ItemCode = @ItemCode AND
						   Tab = @Tab)
	BEGIN
		--partial summaries exist but none with this end date ... return error
		SET @Return_Value = 1
		SET @ErrorMsg = 'Invalid Item Code!'
		GOTO vspExit
	END

	--need to also check tax year range
	SELECT @ErrorMsg = ItemDescription 
	FROM dbo.PRAUItems 
	WHERE ItemCode = @ItemCode  
		  AND Tab = @Tab 
		  AND @TaxYear BETWEEN BeginTaxYear AND ISNULL(EndTaxYear, @TaxYear)

	IF @@ROWCOUNT = 0
	BEGIN
		SELECT @ErrorMsg = 'Item is either invalid for this tab or for this tax year!'
		RETURN 1
	END

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value
GO
PRINT N'Refreshing [dbo].[PMDGGrid]'
GO
EXEC sp_refreshview N'[dbo].[PMDGGrid]'
GO
PRINT N'Refreshing [dbo].[brvJCCostRevDrill]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCostRevDrill]'
GO
PRINT N'Creating [dbo].[vspPREmplPWPDateVal]'
GO
CREATE         procedure [dbo].[vspPREmplPWPDateVal]
/************************************************************************
* CREATED:	EN  EN 4/5/2013 Story 44310 / Task 45407
* MODIFIED:	
*
* Validates the Employee Periods Without Pay FirstDate/LastDate
* date range to ensure that LastDate is not a date prior to 
* FirstDate and that there are not conflicts with date ranges
* already existing for the employee in dbo.vPREmplPeriodsWithoutPay.
*
* INPUT PARAMETERS
*   @PRCo			PR Company to validate against
*   @Employee		Employee to validate against
*	@Seq			vPREmplPeriodsWithoutPay Seq of entry being validated
*	@FirstDate		beginning date of range to be validated
*	@LastDate		ending date of range to be validated
*
* OUTPUT PARAMETERS
*   @@ErrorMsg		error message if error occurs
*
* RETURN VALUE
*   0         success
*   1         Failure
  *************************************************************************/   
(@PRCo bCompany = NULL, 
 @Employee bEmployee = NULL, 
 @Seq smallint = NULL, 
 @FirstDate bDate = NULL,
 @LastDate bDate = NULL,
 @ErrorMsg varchar(255) = '' OUTPUT)
  
AS

BEGIN TRY

	SET NOCOUNT ON
  
	DECLARE @Return_Value tinyint

	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing PR Company!'
		GOTO vspExit
	END
		
	IF @Employee IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Employee!'
		GOTO vspExit
	END

	IF @Seq IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Seq!'
		GOTO vspExit
	END

	-----------------------------------------------------------------
	-- NO NEED TO CONTINUE IF EITHER FIRST OR LAST DATE IS MISSING --
	-----------------------------------------------------------------
	IF @FirstDate IS NULL OR @LastDate IS NULL
	BEGIN
		SET @Return_Value = 0
		GOTO vspExit
	END

	---------------------------------------------
	-- Compare order of FirstDate and LastDate --
	---------------------------------------------
	IF DATEDIFF(DAY, @FirstDate, @LastDate) < 0
	BEGIN
		SELECT @ErrorMsg = 'Last Date cannot be earlier than First Date '
		SELECT @Return_Value = 1
		GOTO vspExit
	END

	----------------------------------------------------------
	-- Verify that date ranges do not intersect or conflict --
	----------------------------------------------------------
	IF EXISTS  (SELECT	* 
				FROM	dbo.vPREmplPeriodsWithoutPay
				 
				WHERE	PRCo = @PRCo AND 
						Employee = @Employee AND 
						Seq <> @Seq AND
						(FirstDate BETWEEN @FirstDate AND @LastDate OR
						 LastDate BETWEEN @FirstDate AND @LastDate)
			   )
	OR EXISTS  (SELECT	*
				FROM	dbo.vPREmplPeriodsWithoutPay
				WHERE	PRCo = @PRCo AND 
						Employee = @Employee AND 
						Seq <> @Seq AND
						(FirstDate <= @FirstDate AND LastDate >= @LastDate)
			   )
	BEGIN
		SELECT @ErrorMsg = 'Date range conflicts with an existing date range '
		SELECT @Return_Value = 1
		GOTO vspExit
	END

	END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value
GO
PRINT N'Refreshing [dbo].[HRCMTestStatus]'
GO
EXEC sp_refreshview N'[dbo].[HRCMTestStatus]'
GO
PRINT N'Refreshing [dbo].[PMMOTotal]'
GO
EXEC sp_refreshview N'[dbo].[PMMOTotal]'
GO
PRINT N'Refreshing [dbo].[PMDGUnionPMDR]'
GO
EXEC sp_refreshview N'[dbo].[PMDGUnionPMDR]'
GO
PRINT N'Refreshing [dbo].[JBLR]'
GO
EXEC sp_refreshview N'[dbo].[JBLR]'
GO
PRINT N'Refreshing [dbo].[brvJCCostRevenue]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCostRevenue]'
GO
PRINT N'Refreshing [dbo].[POXBGrid]'
GO
EXEC sp_refreshview N'[dbo].[POXBGrid]'
GO
PRINT N'Refreshing [dbo].[PMDHGrid]'
GO
EXEC sp_refreshview N'[dbo].[PMDHGrid]'
GO
PRINT N'Refreshing [dbo].[APUIPONotes]'
GO
EXEC sp_refreshview N'[dbo].[APUIPONotes]'
GO
PRINT N'Refreshing [dbo].[brvJCCostRevenueOverride]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCostRevenueOverride]'
GO
PRINT N'Refreshing [dbo].[PMNRReviewer]'
GO
EXEC sp_refreshview N'[dbo].[PMNRReviewer]'
GO
PRINT N'Refreshing [dbo].[JBMD]'
GO
EXEC sp_refreshview N'[dbo].[JBMD]'
GO
PRINT N'Refreshing [dbo].[brvJCCostRevFY]'
GO
EXEC sp_refreshview N'[dbo].[brvJCCostRevFY]'
GO
PRINT N'Refreshing [dbo].[APULGrid]'
GO
EXEC sp_refreshview N'[dbo].[APULGrid]'
GO
PRINT N'Refreshing [dbo].[JBMO]'
GO
EXEC sp_refreshview N'[dbo].[JBMO]'
GO
PRINT N'Refreshing [dbo].[brvJCDailyCost]'
GO
EXEC sp_refreshview N'[dbo].[brvJCDailyCost]'
GO
PRINT N'Refreshing [dbo].[PMOAPct]'
GO
EXEC sp_refreshview N'[dbo].[PMOAPct]'
GO
PRINT N'Refreshing [dbo].[DDMFc]'
GO
EXEC sp_refreshview N'[dbo].[DDMFc]'
GO
PRINT N'Refreshing [dbo].[PMIHGrid]'
GO
EXEC sp_refreshview N'[dbo].[PMIHGrid]'
GO
PRINT N'Refreshing [dbo].[udxrefAPVendor]'
GO
EXEC sp_refreshview N'[dbo].[udxrefAPVendor]'
GO
PRINT N'Refreshing [dbo].[APULGridTotal]'
GO
EXEC sp_refreshview N'[dbo].[APULGridTotal]'
GO
PRINT N'Refreshing [dbo].[RQVQ]'
GO
EXEC sp_refreshview N'[dbo].[RQVQ]'
GO
PRINT N'Refreshing [dbo].[brvJCEstCostItem]'
GO
EXEC sp_refreshview N'[dbo].[brvJCEstCostItem]'
GO
PRINT N'Refreshing [dbo].[MSPCTruck]'
GO
EXEC sp_refreshview N'[dbo].[MSPCTruck]'
GO
PRINT N'Refreshing [dbo].[PMJCJMFuturePMOI]'
GO
EXEC sp_refreshview N'[dbo].[PMJCJMFuturePMOI]'
GO
PRINT N'Refreshing [dbo].[udxrefARCustomer]'
GO
EXEC sp_refreshview N'[dbo].[udxrefARCustomer]'
GO
PRINT N'Refreshing [dbo].[brvJCIDProjRev]'
GO
EXEC sp_refreshview N'[dbo].[brvJCIDProjRev]'
GO
PRINT N'Creating [dbo].[vspPR_AU_Death]'
GO

CREATE  PROC [dbo].[vspPR_AU_Death]
/***********************************************************/
-- CREATED BY: EN 3/12/2013  TFS-39858
-- MODIFIED BY:	DAN SO 05/21/2013 - Story 50738 - return Eligible amount
--
-- USAGE:
-- Tax routine to compute tax on Early Retirement earnings in the case of death.
--
-- This wrapper calls stored procedure vspPR_AU_ETP_TaxComputations which was designed to handle
-- the tax computation for any possible ETP situation.  In this case the stored procedure will
-- be called for the instance of death.
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @PREndDate					End Date of payroll period being processed
--   @SubjectAmt				Subject Amount on which to base the computation
--
-- OUTPUT PARAMETERS
--	 @TaxAmount					Computed tax amount
--	 @EligibleAmt				Amount to be taxed
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PREndDate bDate = NULL,
 @SubjectAmt bDollar = 0,
 @TaxAmount bDollar OUTPUT,
 @EligibleAmt bDollar OUTPUT,	-- 50738 --
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @PREndDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Payroll Ending Date!'
			GOTO vspExit
		END

	---------------------------------------
	-- CALL vspPR_AU_ETP_TaxComputations --
	---------------------------------------
	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_TaxComputations]
			@PRCo,
			@Employee,
			@PREndDate,
			@ATOETPType = 'ETPD',
			@SubjectAmt = @SubjectAmt,
			@TotalAmtWithheld = @TaxAmount OUTPUT,
			@ETPTaxableAmt = @EligibleAmt OUTPUT,	-- 50738 --
			@ErrorMsg = @ErrorMsg OUTPUT

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[PMJCJMTotals]'
GO
EXEC sp_refreshview N'[dbo].[PMJCJMTotals]'
GO
PRINT N'Refreshing [dbo].[APURHdr]'
GO
EXEC sp_refreshview N'[dbo].[APURHdr]'
GO
PRINT N'Refreshing [dbo].[JBTATempAddonSeqs]'
GO
EXEC sp_refreshview N'[dbo].[JBTATempAddonSeqs]'
GO
PRINT N'Refreshing [dbo].[brvJCInsPhase]'
GO
EXEC sp_refreshview N'[dbo].[brvJCInsPhase]'
GO
PRINT N'Creating [dbo].[vspPR_AU_Invalidity]'
GO

CREATE  PROC [dbo].[vspPR_AU_Invalidity]
/***********************************************************/
-- CREATED BY: EN 3/12/2013  TFS-39858
-- MODIFIED BY: DAN SO 05/21/2013 - Story 50738 - return Eligible amount
--
-- USAGE:
-- Tax routine to compute tax on Early Retirement earnings in the case of invalidity.
--
-- This wrapper calls stored procedure vspPR_AU_ETP_TaxComputations which was designed to handle
-- the tax computation for any possible ETP situation.  In this case the stored procedure will
-- be called for the instance of invalidity.
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @PREndDate					End Date of payroll period being processed
--   @SubjectAmt				Subject Amount on which to base the computation
--
-- OUTPUT PARAMETERS
--	 @TaxAmount					Computed tax amount
--	 @EligibleAmt				Amount to be taxed
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PREndDate bDate = NULL,
 @SubjectAmt bDollar = 0,
 @TaxAmount bDollar OUTPUT,
 @EligibleAmt bDollar OUTPUT,	-- 50738 --
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @PREndDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Payroll Ending Date!'
			GOTO vspExit
		END

	---------------------------------------
	-- CALL vspPR_AU_ETP_TaxComputations --
	---------------------------------------
	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_TaxComputations]
			@PRCo,
			@Employee,
			@PREndDate,
			@ATOETPType = 'ETPV',
			@SubjectAmt = @SubjectAmt,
			@TotalAmtWithheld = @TaxAmount OUTPUT,
			@ETPTaxableAmt = @EligibleAmt OUTPUT,	-- 50738 --
			@ErrorMsg = @ErrorMsg OUTPUT

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[PMMFPOCONumLookup]'
GO
EXEC sp_refreshview N'[dbo].[PMMFPOCONumLookup]'
GO
PRINT N'Refreshing [dbo].[APURRevAppRej]'
GO
EXEC sp_refreshview N'[dbo].[APURRevAppRej]'
GO
PRINT N'Refreshing [dbo].[brvJCJobMaster]'
GO
EXEC sp_refreshview N'[dbo].[brvJCJobMaster]'
GO
PRINT N'Creating [dbo].[vspPR_AU_Marginal_PAYG]'
GO

CREATE  PROC [dbo].[vspPR_AU_Marginal_PAYG]
/***********************************************************/
-- CREATED BY: EN 3/22/2013  Story 39859 / Task 42411
-- MODIFIED BY: EN 4/5/2013 Story 44310 / Task 45407  Added solution for ignoring days without pay
--
-- USAGE:
-- Tax routine to compute tax on Early Retirement earnings in the case of Annual Leave category ETPA
-- and Long Service Leave type ETPL.  

-- NOTE: THIS SAME PROCESS CAN BE USED TO COMPUTE TAX ON AN ANNUAL BONUS WITH ONE EXCEPTION ...
--		 THE FLAT TAX ON AMOUNTS UNDER A CERTAIN THRESHOLD WOULD NOT APPLY IN AN ANNUAL BONUS SITUATION
--
-- This procedure uses stored procedure vspPR_AU_PAYGxx to compute tax by fictionally adding
-- the amount to be taxed onto an employee's regular wages to ensure that a realistic tax bracket is
-- used in the computation.
--
--
-- Steps to compute tax on an ETP Leave payment:
-- If the Leave Amount is less than $300, total tax is a flat 31.5% of the Leave Amount.  
-- However, if the Leave Amount is $300 or greater
--  1)	From PRFI locate the deduction code used for federal PAYG tax.
--  2)	From PRDT get the total Subject Amount and Tax Amount for the PAYG deduction code for the number 
--      of pay periods equivalent to a year.  Do not include the current pay period.  
--      [This will account for any lapses of employment due to maternity leave or whatever so the actual 
--       date range of these PRDT entries could cover more than a year.]
--  3)	Divide the Subject Amount and PAYG Tax Amount values by the number of pay periods in a year (P) 
--      to get the average Subject Amount (A) and PAYG Tax Amount (B) values.
--  4)	Divide the Leave Amount (L) by the number of pay periods in a year to get the amount that would 
--      be attributed to a pay period if the Leave Amount were paid out over a one year period (C = L / P).
--  5)	Look up the name of the current PAYG tax routine in use, using PRDL to look up the Routine Name 
--      based on the PAYG deduction code and using PRRM to look up the Stored Procedure name attributed to 
--      the Routine Name.
--  6)	Add the average Subject Amount and the per pay period Leave Amount (A + C) and for that amount use 
--      the PAYG tax routine to compute what the tax (D) would be for the employees pay period frequency.
--  7)	Determine the tax attributed to the per pay period Leave Amount by subtracting the average PAYG Tax 
--      Amount from the tax computed in the previous step (E = D  B).
--  8)	Multiply the tax attributed to the per pay period Leave Amount by the number of pay period in a year 
--      to arrive at the total tax to be withheld from the Leave Amount (total tax = E x P).
--
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--	 @PRGroup					Employee's PR Group
--   @PREndDate					End Date of payroll period being processed
--	 @NumberOfPayPdsAnnually	# of pay periods in a year based on this employee's pay frequency
--   @SubjectAmount				Subject Amount on which to base the computation
--
-- OUTPUT PARAMETERS
--	 @TaxAmount					Computed tax amount
--   @ErrorMsg					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PRGroup bGroup = NULL,
 @PREndDate bDate = NULL,
 @NumberOfPayPdsAnnually tinyint = 0,
 @SubjectAmount bDollar = 0,
 @TaxAmount bDollar OUTPUT,
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing PR Company!'
		GOTO vspExit
	END
		
	IF @Employee IS NULL
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing Employee!'
		GOTO vspExit
	END

	IF @NumberOfPayPdsAnnually = 0
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Missing # of Pay Periods per year!'
		GOTO vspExit
	END
	IF @NumberOfPayPdsAnnually NOT IN (52,26,12)
	BEGIN
		SET @Return_Value = 1
		SET @ErrorMsg = 'Pay Frequency must be Weekly, Biweekly (Fortnightly), or Monthly.'
		GOTO vspExit
	END

	
	-----------------------------------------------------------------------------------------------------------------------
	-- IF SUBJECT AMOUNT IS LESS THAN THE LEAVE LIMIT, APPLY A FLAT % TAX RATE (PARAMS FOUND IN dbo.vPRAULimitsAndRates) --
	-----------------------------------------------------------------------------------------------------------------------
	DECLARE @MaxEffectiveDate bDate,
			@LeaveLimit bDollar,
			@LeaveMaxPct bPct

	SELECT	@MaxEffectiveDate = MAX(EffectiveDate)

	FROM	dbo.vPRAULimitsAndRates
	WHERE	EffectiveDate <= @PREndDate 


	SELECT	@LeaveLimit = LeaveFlatRateLimit,
			@LeaveMaxPct = LeaveFlatRatePct

	FROM	dbo.vPRAULimitsAndRates
	WHERE	EffectiveDate = @MaxEffectiveDate

	IF @SubjectAmount < @LeaveLimit
	BEGIN
		SELECT @TaxAmount = ROUND(@SubjectAmount * @LeaveMaxPct, 0)
		GOTO vspExit
	END


	---------------------------------------------------------
	-- 1) GET DEDUCTION CODE USED FOR THE FEDERAL PAYG TAX --
	---------------------------------------------------------
	DECLARE @PAYGDednCode bEDLCode

	SELECT @PAYGDednCode = TaxDedn
	FROM PRFI
	WHERE PRCo = @PRCo


	--------------------------------------------------------------------------------------------
	-- 2) GET THE TOTAL PAYG SUBJECT AND TAX AMOUNTS FOR THE PAST YEAR'S WORTH OF PAY PERIODS --
	--	  This process involves first making a list of pay periods that conflict with period  --
	--	  without pay (like if the employee worked for part of a pay period so was not paid   --
	--	  an amount that correctly reflects regular wages for a pay period) and then ignoring --
	--	  those pay periods when getting a year's worth of wages.						      --
	--------------------------------------------------------------------------------------------
	DECLARE @AnnualRegularWages bDollar,
			@AnnualPAYGTax bDollar,
			@NumberOfPayPdsToAverage tinyint

	;WITH PayPeriodsToIgnore (PRGroup, PREndDate)
	AS
	(
		SELECT  DISTINCT PRPC.PRGroup, PRPC.PREndDate
		FROM	dbo.bPRPC PRPC
		
		JOIN	dbo.bPRDT PRDT ON PRDT.PRCo = PRPC.PRCo AND
								  PRDT.PRGroup = PRPC.PRGroup AND
								  PRDT.PREndDate = PRPC.PREndDate
								  
		JOIN	dbo.vPREmplPeriodsWithoutPay PWP ON PWP.PRCo = PRDT.PRCo AND
													PWP.Employee = PRDT.Employee
	
		WHERE	PRPC.PRCo = @PRCo AND
				PRDT.Employee = @Employee AND
				
				(PRPC.BeginDate BETWEEN FirstDate AND LastDate OR
				 PRPC.PREndDate BETWEEN FirstDate AND LastDate)
				OR
				(PRPC.BeginDate <= FirstDate AND PRPC.PREndDate >= LastDate)
	),
	OneYearOfWages (SubjectAmount, TaxAmount)
	AS
	(
		SELECT TOP (@NumberOfPayPdsAnnually) SUM(PRDT.SubjectAmt), SUM(PRDT.Amount) --getting the SUM ensures that mult pay seqs in a pay pd are counted as 1
		FROM	dbo.bPRDT PRDT
		WHERE	PRDT.PRCo = @PRCo 
				AND PRDT.Employee = @Employee 
				AND PRDT.EDLType = 'D' 
				AND PRDT.EDLCode = @PAYGDednCode 
				AND NOT (PRDT.PRGroup = @PRGroup AND PRDT.PREndDate = @PREndDate)
				AND NOT EXISTS (SELECT * FROM PayPeriodsToIgnore IGNORE WHERE IGNORE.PRGroup = PRDT.PRGroup AND
																			  IGNORE.PREndDate = PRDT.PREndDate)
		GROUP BY PRCo, PRGroup, PREndDate, Employee
		ORDER BY PREndDate DESC
	)

	SELECT	@AnnualRegularWages = SUM(SubjectAmount), 
			@AnnualPAYGTax = SUM(TaxAmount),
			@NumberOfPayPdsToAverage = COUNT(*)
	FROM OneYearOfWages


	--------------------------------------------------------------------------
	-- 3) COMPUTE THE AVERAGE PAYG SUBJECT AND TAX AMOUNTS FOR A PAY PERIOD --
	--------------------------------------------------------------------------
	DECLARE @AverageRegularWages bDollar,
			@AveragePAYGTax bDollar

	SELECT	@AverageRegularWages = ROUND(@AnnualRegularWages / @NumberOfPayPdsToAverage, 0),
			@AveragePAYGTax = ROUND(@AnnualPAYGTax / @NumberOfPayPdsToAverage, 0)


	--------------------------------------------------------------------------------------------------------
	-- 4) COMPUTE LEAVE AMOUNT FOR ONE PAY PERIOD ASSUMING THE LEAVE AS BEING PAID OVER A ONE YEAR PERIOD --
	--------------------------------------------------------------------------------------------------------
	DECLARE @SubjectPerPayPeriod bDollar

	SELECT	@SubjectPerPayPeriod = ROUND(@SubjectAmount / @NumberOfPayPdsToAverage, 0)

	
	--------------------------------------------------------------
	-- 5) GET CURRENT STORED PROCEDURE NAME OF PAYG TAX ROUTINE --
	--------------------------------------------------------------
	DECLARE @PAYGStoredProcName varchar(34)

	SELECT	@PAYGStoredProcName = 'dbo.' + PRRM.ProcName
	FROM	dbo.PRDL
	JOIN	dbo.PRRM ON PRRM.PRCo = PRDL.PRCo AND PRRM.Routine = PRDL.Routine
	WHERE	PRDL.PRCo = @PRCo AND PRDL.DLCode = @PAYGDednCode


	---------------------------------------------------------------------------------------------
	-- GET EMPLOYEE'S PAYG FILING STATUS (bPRED) INFO NEEDED TO PASS INTO THE PAYG TAX ROUTINE --
	---------------------------------------------------------------------------------------------
	DECLARE	@Scale tinyint, 
			@Status char(1), 
			@AdditionalExemptions tinyint, 
			@FTB_Offset bDollar 

	SELECT	@Scale = 0, 
			@Status = 'S', 
			@AdditionalExemptions = 0, 
			@FTB_Offset = 0

	SELECT	@Scale = RegExempts, 
			@Status = FileStatus, 
			@AdditionalExemptions = AddExempts, 
			@FTB_Offset = MiscAmt
    FROM	dbo.bPRED
    WHERE	PRCo = @PRCo 
			AND Employee = @Employee 
			AND DLCode = @PAYGDednCode


	------------------------------------------------------------------------
	-- GET EMPLOYEE (bPREH) INFO NEEDED TO PASS INTO THE PAYG TAX ROUTINE --
	------------------------------------------------------------------------
	DECLARE	@NonResidentAlienYN bYN	
	
	SELECT	@NonResidentAlienYN = 'N'

	SELECT	@NonResidentAlienYN = NonResAlienYN 
	FROM	dbo.PREH
   	WHERE	PRCo = @PRCo 
			AND Employee = @Employee


	----------------------------------------------------------------------------------------------
	-- 6) COMPUTE WHAT TAX WOULD BE FOR ONE PAY PERIOD ON THE SUBJECT AMOUNT PLUS REGULAR WAGES --
	----------------------------------------------------------------------------------------------
	DECLARE @TaxIncludingRegularWages bDollar,
			@SubjectPlusRegular bDollar

	SELECT  @SubjectPlusRegular = @SubjectPerPayPeriod + @AverageRegularWages

	EXEC	@Return_Value	= @PAYGStoredProcName
			@subjamt		= @SubjectPlusRegular,
			@ppds			= @NumberOfPayPdsAnnually,
			@Scale			= @Scale,
			@status			= @Status,
			@addlexempts	= @AdditionalExemptions,
			@nonresalienyn	= @NonResidentAlienYN,
			@ftb_offset		= @FTB_Offset,
			@amt			= @TaxIncludingRegularWages OUTPUT,
			@msg			= @ErrorMsg OUTPUT

	IF @Return_Value <> 0 GOTO vspExit


	-----------------------------------------
	-- 7 & 8) DETERMINE TAX PER PAY PERIOD --
	-----------------------------------------
	SELECT @TaxAmount = (ROUND(@TaxIncludingRegularWages,0) - @AveragePAYGTax) * @NumberOfPayPdsToAverage

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[PMMFPOItemLookup]'
GO
EXEC sp_refreshview N'[dbo].[PMMFPOItemLookup]'
GO
PRINT N'Refreshing [dbo].[APURRevTot]'
GO
EXEC sp_refreshview N'[dbo].[APURRevTot]'
GO
PRINT N'Refreshing [dbo].[brvJCJobMatDetlDesc]'
GO
EXEC sp_refreshview N'[dbo].[brvJCJobMatDetlDesc]'
GO
PRINT N'Creating [dbo].[vspPR_AU_Redundancy]'
GO

CREATE  PROC [dbo].[vspPR_AU_Redundancy]
/***********************************************************/
-- CREATED BY: EN 3/12/2013  TFS-39858
-- MODIFIED BY: DAN SO 05/21/2013 - Story 50738 - return Eligible amount
--
-- USAGE:
-- Tax routine to compute tax on Early Retirement earnings in the case of redundancy.
--
-- This wrapper calls stored procedure vspPR_AU_ETP_TaxComputations which was designed to handle
-- the tax computation for any possible ETP situation.  In this case the stored procedure will
-- be called for the instance of redundancy.
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @PREndDate					End Date of payroll period being processed
--   @SubjectAmt				Subject Amount on which to base the computation
--
-- OUTPUT PARAMETERS
--	 @TaxAmount					Computed tax amount
--	 @EligibleAmt				Amount to be taxed
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PREndDate bDate = NULL,
 @SubjectAmt bDollar = 0,
 @TaxAmount bDollar OUTPUT,
 @EligibleAmt bDollar OUTPUT,	-- 50738 --
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @PREndDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Payroll Ending Date!'
			GOTO vspExit
		END

	---------------------------------------
	-- CALL vspPR_AU_ETP_TaxComputations --
	---------------------------------------
	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_TaxComputations]
			@PRCo,
			@Employee,
			@PREndDate,
			@ATOETPType = 'ETPR',
			@SubjectAmt = @SubjectAmt,
			@TotalAmtWithheld = @TaxAmount OUTPUT,
			@ETPTaxableAmt = @EligibleAmt OUTPUT,	-- 50738 --
			@ErrorMsg = @ErrorMsg OUTPUT

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[APVA]'
GO
EXEC sp_refreshview N'[dbo].[APVA]'
GO
PRINT N'Refreshing [dbo].[brvJCJobPhase]'
GO
EXEC sp_refreshview N'[dbo].[brvJCJobPhase]'
GO
PRINT N'Creating [dbo].[vspPR_AU_Standard]'
GO

CREATE  PROC [dbo].[vspPR_AU_Standard]
/***********************************************************/
-- CREATED BY: EN 3/12/2013  TFS-39858
-- MODIFIED BY: DAN SO 05/21/2013 - Story 50738 - return Eligible amount
--
-- USAGE:
-- Tax routine to compute tax on Early Retirement earnings in the case of voluntary (standard)
-- redundancy.
--
-- This wrapper calls stored procedure vspPR_AU_ETP_TaxComputations which was designed to handle
-- the tax computation for any possible ETP situation.  In this case the stored procedure will
-- be called for the instance of voluntary redundancy.
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @PREndDate					End Date of payroll period being processed
--   @SubjectAmt				Subject Amount on which to base the computation
--
-- OUTPUT PARAMETERS
--	 @TaxAmount					Computed tax amount
--	 @EligibleAmt				Amount to be taxed
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PREndDate bDate = NULL,
 @SubjectAmt bDollar = 0,
 @TaxAmount bDollar OUTPUT,
 @EligibleAmt bDollar OUTPUT,	-- 50738 --
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @PREndDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Payroll Ending Date!'
			GOTO vspExit
		END

	---------------------------------------
	-- CALL vspPR_AU_ETP_TaxComputations --
	---------------------------------------
	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_TaxComputations]
			@PRCo,
			@Employee,
			@PREndDate,
			@ATOETPType = 'ETP',
			@SubjectAmt = @SubjectAmt,
			@TotalAmtWithheld = @TaxAmount OUTPUT,
			@ETPTaxableAmt = @EligibleAmt OUTPUT,	-- 50738 --
			@ErrorMsg = @ErrorMsg OUTPUT

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[MSQHPM]'
GO
EXEC sp_refreshview N'[dbo].[MSQHPM]'
GO
PRINT N'Refreshing [dbo].[PMPCOItemDetailsPOSLItems]'
GO
EXEC sp_refreshview N'[dbo].[PMPCOItemDetailsPOSLItems]'
GO
PRINT N'Refreshing [dbo].[brvJCJobPhaseMissing]'
GO
EXEC sp_refreshview N'[dbo].[brvJCJobPhaseMissing]'
GO
PRINT N'Creating [dbo].[vspPR_AU_Unfair]'
GO

CREATE  PROC [dbo].[vspPR_AU_Unfair]
/***********************************************************/
-- CREATED BY: EN 3/12/2013  TFS-39858
-- MODIFIED BY: DAN SO 05/21/2013 - Story 50738 - return Eligible amount
--
-- USAGE:
-- Tax routine to compute tax on Early Retirement earnings in the case of harassment,
-- discrimination or unfair dismissal.
--
-- This wrapper calls stored procedure vspPR_AU_ETP_TaxComputations which was designed to handle
-- the tax computation for any possible ETP situation.  In this case the stored procedure will
-- be called for the instance of harrassment, discrimination or unfair dismissal.
--
-- INPUT PARAMETERS
--   @PRCo						PR Company
--	 @Employee					Employee
--   @PREndDate					End Date of payroll period being processed
--   @SubjectAmt				Subject Amount on which to base the computation
--
-- OUTPUT PARAMETERS
--	 @TaxAmount					Computed tax amount
--	 @EligibleAmt				Amount to be taxed
--   @Message					Error message if error occurs	
--
-- RETURN VALUE
--   0			Success
--   1			Failure
--
/******************************************************************/
(
 @PRCo bCompany = NULL,
 @Employee bEmployee = NULL,
 @PREndDate bDate = NULL,
 @SubjectAmt bDollar = 0,
 @TaxAmount bDollar OUTPUT,
 @EligibleAmt bDollar OUTPUT,	-- 50738 --
 @ErrorMsg varchar(255) OUTPUT
)
AS

BEGIN TRY
	SET NOCOUNT ON

	DECLARE	@Return_Value int

	SELECT @Return_Value = 0


	----------------------------
	-- CHECK INPUT PARAMETERS --
	----------------------------
	IF @PRCo IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing PR Company!'
			GOTO vspExit
		END
		
	IF @Employee IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Employee!'
			GOTO vspExit
		END

	IF @PREndDate IS NULL
		BEGIN
			SET @Return_Value = 1
			SET @ErrorMsg = 'Missing Payroll Ending Date!'
			GOTO vspExit
		END

	---------------------------------------
	-- CALL vspPR_AU_ETP_TaxComputations --
	---------------------------------------
	EXEC	@Return_Value = [dbo].[vspPR_AU_ETP_TaxComputations]
			@PRCo,
			@Employee,
			@PREndDate,
			@ATOETPType = 'ETPU',
			@SubjectAmt = @SubjectAmt,
			@TotalAmtWithheld = @TaxAmount OUTPUT,
			@ETPTaxableAmt = @EligibleAmt OUTPUT,	-- 50738 --
			@ErrorMsg = @ErrorMsg OUTPUT

END TRY

--------------------
-- ERROR HANDLING --
--------------------
BEGIN CATCH
	SET @Return_Value = 1
	SET @ErrorMsg = ERROR_PROCEDURE() + ': ' + ERROR_MESSAGE()	
END CATCH

------------------
-- EXIT ROUTINE --
------------------
vspExit:
	RETURN @Return_Value


GO
PRINT N'Refreshing [dbo].[PMPFList]'
GO
EXEC sp_refreshview N'[dbo].[PMPFList]'
GO
PRINT N'Refreshing [dbo].[brvJCMinProjMth]'
GO
EXEC sp_refreshview N'[dbo].[brvJCMinProjMth]'
GO
PRINT N'Creating [dbo].[vspSLClaimBalForwardCreate]'
GO




CREATE proc [dbo].[vspSLClaimBalForwardCreate]
/***********************************************************
* CREATED BY:	GF 03/28/2013 TFS-45348 SL Claims Enhancement addition
* MODIFIED BY:	
* 
*
* USAGE:
* called from a script or run manually to create a balance forward claim
* for legacy subcontracts. The intent of this procedure to create a claim zero 0
* for the subcontract that will have all the AP that is not from the claim
* process. The claim item values will be loaded from AP. Doing this will allow
* new claims to be processed for subcontracts that were in progress prior to
* the claims enhancement release (6.6.0).
*
* Balance Forward Claim:
*
*
* INPUT PARAMETERS
* @SLCo				SL Company to validate
* @Subcontract		Subcontract to validate
*
*
* OUTPUT PARAMETERS
*
* @msg				error message IF error occurs during the creation of balance forward claim or item
*
* RETURN VALUE
*   0         success
*   1         Failure
*****************************************************/
(@SLCo bCompany = 0,
 @Subcontract varchar(30) = NULL,
 @Msg varchar(255) OUTPUT)
AS
SET NOCOUNT ON

DECLARE @rcode INT,  @ClaimDate bDate, @ClaimDesc bItemDesc, @SLItem bItem,
		@APRef bAPReference, @InvDesc bDesc, @InvDate bDate, @ExClaimDate bDate,
		@ClaimKeyId BIGINT



SET @rcode = 0
SET @ClaimDesc = 'Balance Forward Claim'


---------------------
-- VALIDATE VALUES --
---------------------
IF @SLCo IS NULL
	BEGIN
	SELECT @Msg = 'Missing SL Company!', @rcode = 1
	GOTO vspexit
	END

IF @Subcontract IS NULL
	BEGIN
	SELECT @Msg = 'Missing Subcontract!', @rcode = 1
	GOTO vspexit
	END

---- check if balance forward claim exists
IF EXISTS(SELECT 1 FROM dbo.vSLClaimHeader WHERE SLCo = @SLCo AND SL = @Subcontract AND ClaimNo = 0)
	BEGIN
 	SELECT @Msg = 'Balance forward claim exists for subcontract. SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END  

---- validate subcontract
IF NOT EXISTS(SELECT 1 FROM dbo.bSLHD WHERE SLCo=@SLCo AND SL=@Subcontract)
	BEGIN
	SELECT @Msg = 'Subcontract does not exist in Subcontract Header. SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END

---- validate subcontract status - must not be pending
IF EXISTS(SELECT 1 FROM dbo.bSLHD WHERE SLCo=@SLCo AND SL=@Subcontract AND Status = 3)
	BEGIN
	SELECT @Msg = 'Subcontract status is pending. Claims not allowed! SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END

---- subcontract must not be in open SL Entry batch
IF EXISTS(SELECT 1 FROM dbo.bSLHB WHERE Co=@SLCo AND SL=@Subcontract)
	BEGIN
	SELECT @Msg = 'Subcontract exists in an open SL Entry Batch. Batch must be cleared or posted first! SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END

---- subcontract must not be in open SL Entry batch
IF EXISTS(SELECT 1 FROM dbo.bSLCB WHERE Co=@SLCo AND SL=@Subcontract)
	BEGIN
	SELECT @Msg = 'Subcontract exists in an open SL Change Order Batch. Batch must be cleared or posted first! SLCo: ' + + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END

---- subcontract cannot be in an open AP Transaction Entry Batch
IF EXISTS(SELECT 1 FROM dbo.bAPLB WHERE Co = @SLCo AND SL = @Subcontract)
	BEGIN
  	SELECT @Msg = 'Subcontract exists in an open AP Transaction Entry batch. Batch must be cleared or posted first! SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END  

---- Subcontract cannot be on an AP Unapproved Invoice
IF EXISTS(SELECT 1 FROM dbo.bAPUL WHERE APCo = @SLCo AND SL = @Subcontract AND SLKeyID IS NULL)
	BEGIN
  	SELECT @Msg = 'Subcontract exists on an AP Unapproved Invoice and needs to be deleted or processed first! SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END 

---- check for APTL records for this subcontract not aasigned to a claim
---- we only want to create a claim for subcontracts in APTL not associated to a claim
IF NOT EXISTS(SELECT 1 FROM dbo.bAPTL WHERE APCo = @SLCo AND SL = @Subcontract AND SLKeyID IS NULL)
	BEGIN
	SELECT @Msg = 'Subcontract does not have any APTL entries not associated with a claim. Balance forward claim not required! SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END
    
---- get the last AP Invoice Entry information for the subcontract. Will be used as claim header information
SELECT TOP 1 @SLItem	= APTL.SLItem
			 ,@InvDesc	= APTH.Description
			 ,@InvDate  = APTH.InvDate
			 ,@APRef	= APTH.APRef
FROM dbo.bAPTL APTL
INNER JOIN dbo.bAPTH APTH ON APTH.APCo = APTL.APCo AND APTH.Mth = APTL.Mth AND APTH.APTrans = APTL.APTrans
WHERE APTL.APCo = @SLCo
	AND APTL.SL = @Subcontract
ORDER BY APTL.Mth DESC, APTL.APTrans DESC
IF @@ROWCOUNT = 0
	BEGIN
  	SELECT @Msg = 'Error retrieving APTH/APTL information for balance forward claim! SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract), @rcode = 1
	GOTO vspexit
	END

---- get claim date for first Claim for subcontract - MAY NOT BE EXISTING
SELECT TOP 1 @ExClaimDate = ClaimDate
FROM dbo.vSLClaimHeader
WHERE SLCo = @SLCo
	AND SL = @Subcontract
ORDER BY ClaimNo ASC
IF @@ROWCOUNT = 0 SET @ExClaimDate = NULL


---- what date should we use for the balance forward claim?
---- the claim date is critical within the pervious value process
---- the claim no less than current claim AND Claim Date >= Current Claim Date is considered previous
SET @ClaimDate = NULL
IF @ExClaimDate IS NOT NULL SET @ClaimDate = @ExClaimDate
IF @ClaimDate IS NULL AND @InvDate IS NOT NULL SET @ClaimDate = @InvDate
IF @ClaimDate IS NULL SET @ClaimDate = dbo.vfDateOnly()




/*******************************************************/
/* CREATE THE BALANCE FORWARD CLAIM                    */
/* WILL BE DONE IN A TRANSACTION IN CASE ERROR OCCURS. */
/*******************************************************/


BEGIN TRY
	---- start a transaction, commit after fully processed
    BEGIN TRANSACTION;

		---- insert SL Claim header record - the approved retention will be set to zero
		---- and we will update after the SL Claim Items are added
		INSERT INTO dbo.vSLClaimHeader
				( SLCo, SL, ClaimNo, Description, ClaimDate, RecvdClaimDate, InvoiceDate, APRef,
				  CertifyDate, ClaimStatus, InvoiceDesc, CertifiedBy, ApproveRetention
				)
		SELECT @SLCo, @Subcontract, 0, @ClaimDesc, @ClaimDate, NULL, @InvDate, @APRef, NULL, 10, @InvDesc, NULL, 0

		---- get claim key id for AP updates
		SET @ClaimKeyId = SCOPE_IDENTITY()


		---- create claim items from APTL - one record per subcontract item
		INSERT INTO dbo.vSLClaimItem
		        (
				 SLCo, SL, ClaimNo, SLItem, ClaimToDateUnits, ClaimToDateAmt, ClaimUnits, ClaimAmount,
				 ApproveUnits, ApproveAmount, ApproveRetPct, ApproveRetention, TaxAmount, Description,
				 UM, CurUnitCost, CurUnits, CurCost, TaxGroup, TaxCode, TaxType
				)
		SELECT @SLCo, @Subcontract, 0, SLIT.SLItem, ISNULL(InvUnitTotal, 0), ISNULL(InvGrossTotal,0), ISNULL(InvUnitTotal, 0), ISNULL(InvGrossTotal,0)
				, ISNULL(InvUnitTotal, 0), ISNULL(InvGrossTotal,0)
				, SLIT.WCRetPct, ISNULL(InvRetTotal, 0), ISNULL(InvTaxTotal, 0), NULL
				, SLIT.UM, SLIT.CurUnitCost, 0, 0
				, SLIT.TaxGroup, SLIT.TaxCode, SLIT.TaxType
		FROM dbo.bSLIT SLIT

			CROSS APPLY  
				(
				SELECT  SUM(ISNULL(APTL.Retainage, 0)) InvRetTotal
					   ,SUM(ISNULL(APTL.TaxAmt, 0)) InvTaxTotal
					   ,SUM(ISNULL(APTL.GrossAmt, 0)) InvGrossTotal
					   ,SUM(ISNULL(APTL.Units, 0)) InvUnitTotal
				 FROM dbo.bAPTL APTL WITH (NOLOCK)
				 WHERE APTL.APCo = SLIT.SLCo 
				 AND APTL.SL = SLIT.SL 
				 AND APTL.SLItem = SLIT.SLItem
				 AND APTL.SLKeyID IS NULL
				 HAVING (
						 SUM(ISNULL(APTL.GrossAmt, 0)) <> 0
							OR SUM(ISNULL(APTL.TaxAmt, 0)) <> 0
							OR SUM(ISNULL(APTL.Retainage, 0)) <> 0
						)
				 ) APTL

		WHERE SLIT.SLCo = @SLCo
			AND SLIT.SL = @Subcontract


		---- update invoice date in claim header if none existed
		update dbo.vSLClaimHeader
			SET ApproveRetention = ISNULL(ItemRetentionTotal, 0)
		FROM dbo.vSLClaimHeader HEAD
			CROSS APPLY  
				(
				 SELECT  SUM(ISNULL(ITEM.ApproveRetention, 0)) ItemRetentionTotal
				 FROM dbo.vSLClaimItem ITEM
				 WHERE ITEM.SLCo = HEAD.SLCo 
				 AND ITEM.SL = HEAD.SL
				 AND ITEM.ClaimNo = HEAD.ClaimNo
				 ) ITEM    
		where SLCo = @SLCo
			AND SL = @Subcontract
			AND ClaimNo = 0


		---- update APTL with the claim key id for invoices associated with this subcontract
		---- update APTL
		UPDATE dbo.bAPTL
				SET SLKeyID = @ClaimKeyId
		WHERE APCo = @SLCo
			AND SL = @Subcontract
			AND SLKeyID IS NULL
		      
		---- update APTH with the claim key id for invoices associated with this subcontract
		---- update APTH
		UPDATE dbo.bAPTH
			SET SLKeyID = @ClaimKeyId
   		FROM dbo.bAPTH APTH
		WHERE APTH.APCo = @SLCo
			AND APTH.SLKeyID IS NULL
			AND EXISTS(SELECT 1 FROM dbo.bAPTL APTL WHERE APTL.APCo = APTH.APCo AND APTL.Mth = APTH.Mth
							AND APTL.APTrans = APTH.APTrans AND APTL.SLKeyID = @ClaimKeyId)
 
		    

	---- update to AP has completed. commit transaction
	COMMIT TRANSACTION
    


END TRY
BEGIN CATCH
    -- Test XACT_STATE:
        -- If 1, the transaction is committable.
        -- If -1, the transaction is uncommittable and should 
        --     be rolled back.
        -- XACT_STATE = 0 means that there is no transaction and
        --     a commit or rollback operation would generate an error.
	IF XACT_STATE() <> 0
		BEGIN
		ROLLBACK TRANSACTION
		SET @Msg = CAST(ERROR_MESSAGE() + ' SLCo: ' + dbo.vfToString(@SLCo) + ' SL: ' + dbo.vfToString(@Subcontract) AS VARCHAR(200)) 
		SET @rcode = 1
		END
END CATCH






vspexit:
	RETURN @rcode




GO
PRINT N'Refreshing [dbo].[VASecurityByForm]'
GO
EXEC sp_refreshview N'[dbo].[VASecurityByForm]'
GO
PRINT N'Refreshing [dbo].[PMPM1]'
GO
EXEC sp_refreshview N'[dbo].[PMPM1]'
GO
PRINT N'Adding constraints to [dbo].[bPMOL]'
GO
ALTER TABLE [dbo].[bPMOL] WITH NOCHECK ADD CONSTRAINT [CK_bPMOL_POSL] CHECK ((NOT ([PO] IS NOT NULL AND [Subcontract] IS NOT NULL)))
GO
PRINT N'Adding foreign keys to [dbo].[vSLClaimItem]'
GO
ALTER TABLE [dbo].[vSLClaimItem] WITH NOCHECK  ADD CONSTRAINT [FK_vSLClaimItem_bSLHD] FOREIGN KEY ([SLCo], [SL]) REFERENCES [dbo].[bSLHD] ([SLCo], [SL])
ALTER TABLE [dbo].[vSLClaimItem] WITH NOCHECK  ADD CONSTRAINT [FK_vSLClaimItem_bSLIT] FOREIGN KEY ([SLCo], [SL], [SLItem]) REFERENCES [dbo].[bSLIT] ([SLCo], [SL], [SLItem])
ALTER TABLE [dbo].[vSLClaimItem] WITH NOCHECK  ADD CONSTRAINT [FK_vSLClaimItem_vSLClaimHeader] FOREIGN KEY ([SLCo], [SL], [ClaimNo]) REFERENCES [dbo].[vSLClaimHeader] ([SLCo], [SL], [ClaimNo])
GO
PRINT N'Adding foreign keys to [dbo].[vAPAUPayeeTaxPaymentATO]'
GO
ALTER TABLE [dbo].[vAPAUPayeeTaxPaymentATO] ADD CONSTRAINT [FK_vAPAUPayeeTaxPaymentATO_vAPAUPayerTaxPaymentATO] FOREIGN KEY ([APCo], [TaxYear]) REFERENCES [dbo].[vAPAUPayerTaxPaymentATO] ([APCo], [TaxYear]) ON DELETE CASCADE
GO
PRINT N'Altering trigger [dbo].[btAPTHu] on [dbo].[bAPTH]'
GO

ALTER trigger [dbo].[btAPTHu] on [dbo].[bAPTH] for UPDATE as
/*-----------------------------------------------------------------
* Created:  10/30/98 EN
* Modified: 12/02/98 KB
*			03/08/99 JRE - added if update()
*           EN 01/22/00 - insert bHQMA if PayAddInfo is changed
*           EN 4/14/00 - CMAcct validation not allowing for null value
*           DANF 10/23/00 - Added 1099 1-18
*			MV 03/19/03 - #17124 new Transaction fields added to HQMA audit.
*			MV 04/17/03 - #17124 rej 1 fix
*			JIME 11/03/04  - #26016 add if updates and change count(*) to if exists
*			MV 03/11/08 - #127347 International addresses
*			GG 06/06/08 - #128324 Fixed State/Country validation
*			MV 09/08/08 - #129741 Isnull wrapped HoldCode audit
*			JonathanP 01/09/08 - #128879 - Added code to skip procedure if only UniqueAttachID changed.
*			GP 06/06/10 - #135813 changed bSL to varchar(30)
*			GP 07/27/11 - TK-07144 changed bPO to varchar(30)
*			KK 01/17/12 - TK-11581 Added "S"(Credit Service) as an acceptable value for PayMethod
*			KK 02/19/12 - TK-12973 Removed validation check on CM Account to allow any value
*				CHS	05/30/2012	- B-08928 make 1099 changes to Australia
*			GF 02/19/2013 TFS-41050 change to update V1099YN flag only not via batch
*			GF 03/29/2013 TFS-45348 if only column that changed is SLKeyID, skip validation and audit. Creating balance forward claims
*
*	This trigger rejects update in bAPTH (Trans Header)
*	if any of the following error conditions exist:
*
*		Cannot change Co
*		Cannot change Mth
*		Cannot change APTrans
*
*	Validate same as in insert trigger.
*	Insert bHQMA entries for changed values if AuditTrans='Y' in bAPCO.
*/----------------------------------------------------------------
DECLARE @errmsg varchar(255), 
		@numrows int, 
		@validcnt int, 
		@validcnt2 int, 
		@nullcnt int,
		@apco bCompany, 
		@linetype tinyint, 
		@jcco bCompany, 
		@job bJob, 
		@phasegroup bGroup, 
   		@phase bPhase, 
   		@jcctype bJCCType, 
   		@inco bCompany, 
   		@loc bLoc, 
   		@matlgroup bGroup, 
   		@material bMatl, 
   		@emco bCompany, 
   		@equip bEquip, 
   		@emgroup bGroup, 
   		@costcode bCostCode, 
   		@emctype bEMCType, 
   		@wo bWO, 
   		@woitem bItem, 
   		@po varchar(30), 
   		@poitem bItem, 
   		@itemtype tinyint,
   		@sl varchar(30), 
   		@slitem bItem
 
SELECT @numrows = @@rowcount
IF @numrows = 0 RETURN

SET NOCOUNT ON

--If the only column that changed was UniqueAttachID, then skip validation.        
IF dbo.vfOnlyColumnUpdated(COLUMNS_UPDATED(), 'bAPTH', 'UniqueAttchID') = 1
BEGIN 
	goto Trigger_Skip
END    

---- TFS-45348 if the only column that changed was SLKeyID, then skip validation and auditing
IF dbo.vfOnlyColumnUpdated(COLUMNS_UPDATED(), 'bAPTH', 'SLKeyID') = 1
	BEGIN 
	goto Trigger_Skip
	END   

---- TFS-41050 If the only column that changed was V1099YN, then skip validation.        
IF dbo.vfOnlyColumnUpdated(COLUMNS_UPDATED(), 'bAPTH', 'V1099YN') = 1
	BEGIN
	GOTO Audit_Check
	END  

-- verify primary key not changed
IF UPDATE(APCo) 
OR UPDATE(Mth) 
OR UPDATE(APTrans)
BEGIN
	SELECT @validcnt = COUNT(*) FROM deleted d, inserted i
	WHERE d.APCo = i.APCo AND d.Mth = i.Mth AND d.APTrans = i.APTrans
	IF @numrows <> @validcnt
	BEGIN
		SELECT @errmsg = 'Cannot change Primary Key'
		GOTO error
	END
END
   
-- validate Vendor
IF UPDATE (Vendor)
BEGIN
   	SELECT @validcnt = COUNT(*) FROM bAPVM v WITH(NOLOCK)
    JOIN inserted i ON v.VendorGroup = i.VendorGroup AND v.Vendor = i.Vendor
    IF @validcnt <> @numrows
    BEGIN
    	SELECT @errmsg = 'Invalid Vendor'
    	GOTO error
    END
END
   
   -- validate HoldCode
IF UPDATE(HoldCode)
BEGIN
   	SELECT @nullcnt = COUNT(*) FROM inserted 
   	WHERE HoldCode IS NULL
   	SELECT @validcnt = COUNT(*) FROM bHQHC h WITH(NOLOCK)
    JOIN inserted i ON ISNULL(h.HoldCode,'') = ISNULL(i.HoldCode,'')
    WHERE i.HoldCode IS NOT NULL
    IF @nullcnt + @validcnt <> @numrows
    BEGIN
    	SELECT @errmsg = 'Invalid Hold Code'
    	GOTO error
	END
END
   
   -- validate PayMethod
IF UPDATE(PayMethod)
BEGIN
   	SELECT @validcnt = COUNT(*) FROM inserted 
   	WHERE PayMethod = 'C' OR PayMethod = 'E' OR PayMethod = 'S'
    IF @validcnt <> @numrows
    BEGIN
		SELECT @errmsg = 'Invalid payment method'
    	GOTO error
    END
END
   
   -- validate CMCo
IF UPDATE(CMCo)
BEGIN
   	SELECT @validcnt = COUNT(*) FROM bCMCO c WITH(NOLOCK) 
   	JOIN inserted i ON c.CMCo = i.CMCo
    IF @validcnt <> @numrows
    BEGIN
		SELECT @errmsg = 'Invalid CM company'
		GOTO error
   END
END
   
---- validate CMAcct
--IF UPDATE(CMAcct)
-- 	begin
--    SELECT @validcnt = COUNT(*) FROM inserted where CMAcct is not null
--	SELECT @validcnt2 = COUNT(*) FROM bCMAC a with (nolock)
-- 	JOIN inserted i ON a.CMCo = i.CMCo and a.CMAcct = i.CMAcct where i.CMAcct is not null
-- 	IF @validcnt <> @validcnt2
-- 		BEGIN
-- 		SELECT @errmsg = 'Invalid CM account'
-- 		GOTO error
-- 		END
-- 	end
    	
-- validate PayState/PayCountry
IF UPDATE(PayState) OR UPDATE(PayCountry)
BEGIN
	SELECT @validcnt = COUNT(1) FROM dbo.bHQCountry c WITH(NOLOCK) 
	JOIN inserted i ON i.PayCountry = c.Country
	SELECT @nullcnt = COUNT(1) FROM inserted WHERE PayCountry IS NULL
	IF @validcnt + @nullcnt <> @numrows
	BEGIN
		SELECT @errmsg = 'Invalid Pay Country'
		GOTO error
	END
	-- validate Country/State combinations
	SELECT @validcnt = COUNT(1) -- Country/State combos are unique
	FROM inserted i
	JOIN dbo.bHQCO c (NOLOCK) ON c.HQCo = i.APCo	-- join to get Default Country
	JOIN dbo.bHQST s (NOLOCK) ON ISNULL(i.PayCountry,c.DefaultCountry) = s.Country AND i.PayState = s.State
	SELECT @nullcnt = COUNT(1) FROM inserted 
	WHERE PayState IS NULL
	IF @validcnt + @nullcnt <> @numrows
	BEGIN
		SELECT @errmsg = 'Invalid Pay Country and State combination'
		GOTO error
	END
END

--#26016
IF UPDATE(PrePaidMth) 
OR UPDATE(PrePaidDate) 
OR UPDATE(PrePaidChk)
OR UPDATE(PrePaidSeq)
BEGIN
   	IF EXISTS (SELECT 1 FROM inserted i WHERE i.PrePaidYN = 'N'
   	AND (i.PrePaidMth IS NOT NULL 
   		OR i.PrePaidDate IS NOT NULL 
   		OR i.PrePaidChk IS NOT NULL 
   		OR i.PrePaidSeq IS NOT NULL))
    BEGIN
		SELECT @errmsg = 'Prepaid info must be null if not prepaid'
		GOTO error
    END
END
   
--#26016 --CHS	05/30/2012	- B-08928 make 1099 changes to Australia 
IF UPDATE(V1099YN) OR UPDATE(V1099Type)
BEGIN
   	IF EXISTS(SELECT 1 
   				FROM inserted i
					JOIN dbo.bHQCO c (NOLOCK) ON c.HQCo = i.APCo	-- join to get Default Country   				
				WHERE i.V1099YN = 'Y'
					AND c.DefaultCountry <> 'AU'
					AND NOT EXISTS(SELECT * FROM bAPTT t WHERE t.V1099Type=i.V1099Type))

   	BEGIN
    	SELECT @errmsg = 'Invalid 1099 type'
		GOTO error
	END
END
   
--#26016 --CHS	05/30/2012	- B-08928 make 1099 changes to Australia 
IF UPDATE(V1099YN) OR UPDATE(V1099Box)
BEGIN
	IF EXISTS(SELECT 1 
				FROM inserted i
					JOIN dbo.bHQCO c (NOLOCK) ON c.HQCo = i.APCo	-- join to get Default Country
    			WHERE V1099YN = 'Y' 
					AND c.DefaultCountry <> 'AU'    			
    				AND (V1099Box < 1 or V1099Box > 18))
    BEGIN
		SELECT @errmsg = '1099 box # must be 1 through 18'
    	GOTO error
    END
END 
   
---- TFS-41050
Audit_Check:  

-- Check bAPCO to see if auditing transaction. If not done.
IF NOT EXISTS(
				SELECT * 
				FROM inserted i 
				JOIN dbo.bAPCO c WITH (NOLOCK) ON i.APCo=c.APCo 
				WHERE c.AuditTrans = 'Y'
			)
	RETURN
   
   -- Insert records into HQMA for changes made to audited fields
   if update(VendorGroup)
   	insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6),i.APTrans), i.APCo, 'C',
    	'VendorGroup', convert(varchar(3),d.VendorGroup), convert(varchar(3),i.VendorGroup), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	and d.VendorGroup <> i.VendorGroup and a.AuditTrans = 'Y'
   
   if update (Vendor)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Vendor', convert(varchar(6),d.Vendor), convert(varchar(6),i.Vendor), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Vendor <> i.Vendor and a.AuditTrans = 'Y'
   
   if update(InvId)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'InvId', d.InvId, i.InvId, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where   d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.InvId <> i.InvId and a.AuditTrans = 'Y'
   
   if update(APRef)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'APRef', d.APRef, i.APRef, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.APRef <> i.APRef and a.AuditTrans = 'Y'
   
   if update(Description)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Description', d.Description, i.Description, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Description <> i.Description and a.AuditTrans = 'Y'
   
    if update(InvDate)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'InvDate', convert(char(8),d.InvDate), convert(char(8),i.InvDate), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.InvDate <> i.InvDate and a.AuditTrans = 'Y'
   
   if update(DiscDate)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'DiscDate', convert(char(8),d.DiscDate), convert(char(8),i.DiscDate), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
   
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.DiscDate <> i.DiscDate and a.AuditTrans = 'Y'
   
   if update(DueDate)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'DueDate', convert(char(8),d.DueDate), convert(char(8),i.DueDate), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.DueDate <> i.DueDate and a.AuditTrans = 'Y'
   
   if update(InvTotal)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'InvTotal', convert(varchar(16),d.InvTotal), convert(varchar(16),i.InvTotal), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.InvTotal <> i.InvTotal and a.AuditTrans = 'Y'
   
   if update(HoldCode)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'HoldCode',d.HoldCode, i.HoldCode, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and isnull(d.HoldCode,'') <> isnull(i.HoldCode,'') and a.AuditTrans = 'Y'
   
   if update(PayControl)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayControl', d.PayControl, i.PayControl, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and  d.PayControl <> i.PayControl and a.AuditTrans = 'Y'
   
    if update(PayMethod)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayMethod', d.PayMethod, i.PayMethod, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PayMethod <> i.PayMethod and a.AuditTrans = 'Y'
   
   if update(CMCo)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'CMCo', convert(varchar(3),d.CMCo), convert(varchar(3),i.CMCo), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.CMCo <> i.CMCo and a.AuditTrans = 'Y'
   
    if update(CMAcct)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'CMAcct', convert(varchar(4),d.CMAcct), convert(varchar(4),i.CMAcct), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.CMAcct <> i.CMAcct and a.AuditTrans = 'Y'
   
    if update(PrePaidYN)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PrePaidYN', d.PrePaidYN, i.PrePaidYN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PrePaidYN <> i.PrePaidYN and a.AuditTrans = 'Y'
   
    if update(PrePaidMth)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PrePaidMth', convert(char(8),d.PrePaidMth), convert(char(8),i.PrePaidMth), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PrePaidMth <> i.PrePaidMth and a.AuditTrans = 'Y'
   
   if update(PrePaidDate)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PrePaidDate', convert(char(8),d.PrePaidDate), convert(char(8),i.PrePaidDate), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PrePaidDate <> i.PrePaidDate and a.AuditTrans = 'Y'
   
   if update(PrePaidChk)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PrePaidChk', d.PrePaidChk, i.PrePaidChk, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PrePaidChk <> i.PrePaidChk and a.AuditTrans = 'Y'
   
   if update(PrePaidSeq)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PrePaidSeq', convert(varchar(3),d.PrePaidSeq), convert(varchar(3),i.PrePaidSeq), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PrePaidSeq <> i.PrePaidSeq and a.AuditTrans = 'Y'
   
   if update(PrePaidProcYN)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PrePaidProcYN', d.PrePaidProcYN, i.PrePaidProcYN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PrePaidProcYN <> i.PrePaidProcYN and a.AuditTrans = 'Y'
   
   if update(V1099YN)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'V1099YN', d.V1099YN, i.V1099YN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.V1099YN <> i.V1099YN and a.AuditTrans = 'Y'
   
   if update(V1099Type)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'V1099Type', d.V1099Type, i.V1099Type, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.V1099Type <> i.V1099Type and a.AuditTrans = 'Y'
   
   if update(V1099Box)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'V1099Box', convert(varchar(3),d.V1099Box), convert(varchar(3),i.V1099Box), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.V1099Box <> i.V1099Box and a.AuditTrans = 'Y'
   
   if update(PayOverrideYN)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayOverrideYN', d.PayOverrideYN, i.PayOverrideYN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PayOverrideYN <> i.PayOverrideYN and a.AuditTrans = 'Y'
   
   if update(PayName)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayName', d.PayName, i.PayName, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PayName <> i.PayName and a.AuditTrans = 'Y'
   
   if update(PayAddInfo)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayAddInfo', d.PayAddInfo, i.PayAddInfo, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PayAddInfo <> i.PayAddInfo and a.AuditTrans = 'Y'
   
   if update(PayAddress)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayAddress', d.PayAddress, i.PayAddress, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PayAddress <> i.PayAddress and a.AuditTrans = 'Y'
   
   if update(PayCity)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayCity', d.PayCity, i.PayCity, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PayCity <> i.PayCity and a.AuditTrans = 'Y'
   
   if update(PayState)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayState', d.PayState,i.PayState, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and  d.PayState <> i.PayState and a.AuditTrans = 'Y'
   
   if update(PayZip)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayZip', d.PayZip, i.PayZip, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and  d.PayZip <> i.PayZip and a.AuditTrans = 'Y'

	if update(PayCountry)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PayCountry', d.PayCountry, i.PayCountry, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and  d.PayCountry <> i.PayCountry and a.AuditTrans = 'Y'
   
   if update(OpenYN)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'OpenYN', d.OpenYN, i.OpenYN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.OpenYN <> i.OpenYN and a.AuditTrans = 'Y'
   
   if update(InUseMth)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'InUseMth', convert(char(8),d.InUseMth), convert(char(8),i.InUseMth), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.InUseMth <> i.InUseMth and a.AuditTrans = 'Y'
   
   if update(InUseBatchId)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'InUseBatchId', convert(varchar(6),d.InUseBatchId), convert(varchar(6),i.InUseBatchId), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.InUseBatchId <> i.InUseBatchId and a.AuditTrans = 'Y'
   
   if update(BatchId)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'BatchId', convert(varchar(6),d.BatchId), convert(varchar(6),i.BatchId), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.BatchId <> i.BatchId and a.AuditTrans = 'Y'
   
   if Update(Purge)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Purge', d.Purge, i.Purge, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Purge <> i.Purge and a.AuditTrans = 'Y'
   
   if update(InPayControl)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'InPayControl', d.InPayControl, i.InPayControl, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.InPayControl <> i.InPayControl and a.AuditTrans = 'Y'
   
   if update(PRCo)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'PR Company', d.PRCo, i.PRCo, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.PRCo <> i.PRCo and a.AuditTrans = 'Y'
   
   if update(Employee)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Employee', d.Employee, i.Employee, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Employee <> i.Employee and a.AuditTrans = 'Y'
   
   if update(DLcode)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'DL Code', d.DLcode, i.DLcode, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.DLcode <> i.DLcode and a.AuditTrans = 'Y'
   
   if update(TaxFormCode)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Form Code', d.TaxFormCode, i.TaxFormCode, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.TaxFormCode <> i.TaxFormCode and a.AuditTrans = 'Y'
   
   if update(TaxPeriodEndDate)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Period End Date', d.TaxPeriodEndDate, i.TaxPeriodEndDate, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.TaxPeriodEndDate <> i.TaxPeriodEndDate and a.AuditTrans = 'Y'
   
   if update(AmountType)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Amount Type', d.AmountType, i.AmountType, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.AmountType <> i.AmountType and a.AuditTrans = 'Y'
   
   if update(Amount)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Amount', d.Amount, i.Amount, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Amount <> i.Amount and a.AuditTrans = 'Y'
   
   if update(AmtType2)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Amount Type 2', d.AmtType2, i.AmtType2, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.AmtType2 <> i.AmtType2 and a.AuditTrans = 'Y'
   
   if update(Amount2)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Amount 2', d.Amount2, i.Amount2, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Amount2 <> i.Amount2 and a.AuditTrans = 'Y'
   
   if update(AmtType3)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Amount Type 32', d.AmtType3, i.AmtType3, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.AmtType3 <> i.AmtType3 and a.AuditTrans = 'Y'
   
   if update(Amount3)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Tax Amount 3', d.Amount3, i.Amount3, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.Amount3 <> i.Amount3 and a.AuditTrans = 'Y'
   
   if update(SeparatePayYN)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Separate Pay', d.SeparatePayYN, i.SeparatePayYN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.SeparatePayYN <> i.SeparatePayYN and a.AuditTrans = 'Y'
   
   if update(AddressSeq)
    insert into bHQMA select 'bAPTH', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans), i.APCo, 'C',
    	'Addtl Address Seq #', d.AddressSeq, i.AddressSeq, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where  d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
    	 and d.AddressSeq <> i.AddressSeq and a.AuditTrans = 'Y'
   
   
Trigger_Skip:   
   
   return        
   
   error:
    	select @errmsg = @errmsg + ' - cannot update Transaction Header!'
   	RAISERROR(@errmsg, 11, -1);
   	rollback transaction
   
   
   
   
   
  
 




GO
PRINT N'Altering trigger [dbo].[btAPTLu] on [dbo].[bAPTL]'
GO


 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
/****** Object:  Trigger dbo.btAPTLu    Script Date: 8/28/99 9:38:19 AM ******/
ALTER  trigger [dbo].[btAPTLu] on [dbo].[bAPTL] for UPDATE as
/*-----------------------------------------------------------------
    * Created By:	10/30/98 EN
    * Modified By: 12/31/98 EN
    *				8/16/99 GR - removed the check on equipment/costcode/costtype combination
    *				07/09/02 SR - 17738 pass @phasegroup to bspJCVPHASE
    *				10/18/02 - 18878 quoted identifier cleanup.
    *				GF 08/12/2003 - issue #22112 - performance
    *               MV 06/30/08 - #128288 - Taxtype 3 - VAT
    *				MV 02/12/09 - #123778 - clear invoice info in PORD if PO/PO Item changes
	*				MV 05/11/09 - #123778 - fix update to PORD begin/end
	*				MV 09/16/09 - #135081 - fix update to PORD again
	*				MV 11/25/09 - #136212 - don't update PORD unless po or item has changed
	*				GP 6/6/2010 - #135813 changed bSL to varchar(30)
	*				GF 11/02/2010 - issue #141957 record association
	*				AMR 01/17/11 - #142350, making case insensitive by removing unused vars and renaming same named variables
	*				MV 08/04/11 - TK-07233 AP project to use POItemLine
	*				MV 01/24/12 - TK-11873 audit On-Cost fields.
	*				GF 03/29/2013 TFS-45348 if only column that changed is SLKeyID, skip validation and audit. Creating balance forward claims
	*
    *
    *
    *	This trigger rejects update in bAPTL (Trans Line)
    *	if any of the following error conditions exist:
    *
    *		Cannot change Co
    *		Cannot change Mth
    *		Cannot change APTrans
    *		Cannot change APLine
    *
    *	Validate same as in insert trigger.
    *	Insert bHQMA entries for changed values if AuditTrans='Y' in bAPCO.
    */----------------------------------------------------------------
	DECLARE @errmsg varchar(255),
			@numrows int,
			@validcnt int,
			@nullcnt int
	DECLARE @apco bCompany,
			@linetype tinyint,
			@jcco bCompany,
			@job bJob,
			@phasegroup bGroup,
			@phase bPhase,
			@jcctype bJCCType,
			@inco bCompany,
			@loc bLoc,
			@matlgroup bGroup,
			@material bMatl,
			@emco bCompany,
			@equip bEquip,
			@emgroup bGroup,
			@costcode bCostCode,
			@emctype bEMCType,
			@wo bWO,
			@woitem bItem,
			@po varchar(30),
			@poitem bItem,
			@POItemLine int,
			@itemtype tinyint,
			@sl varchar(30),
			@slitem bItem,
			@pp bPhase,
			@descr varchar(30),
			@dept varchar(10),
			@projminpct real,
			-- #142350 - renaming @PhaseGroup
			@PhaseGroupOut tinyint,
			@vcontract bContract,
			@vitem bContractItem,
			@JCJPexists char(1),
			@rcode int,
			@stringct varchar(5),
			@override bYN,
			@phsgroup tinyint,
			@pphase bPhase,
			@billflag char(1),
			@um bUM,
			@itemunitflag bYN,
			@phaseunitflag bYN,
			@JCCHexists char(1),
			@costtypeout bJCCType,
			@oldpo varchar(30),
			@oldpoitem int,
			@OldPOItemLine int,
				----#141957
			@KeyID bigint,
			@oldlinetype tinyint
		   
   select @numrows = @@rowcount
   if @numrows = 0 return
   set nocount on
   

---- TFS-45348 if the only column that changed was SLKeyID, then skip validation and auditing
IF dbo.vfOnlyColumnUpdated(COLUMNS_UPDATED(), 'bAPTL', 'SLKeyID') = 1
	BEGIN 
	RETURN
	END   

   -- verify primary key not changed
   if update(APCo) or update(Mth) or update(APTrans) or update(APLine)
    	begin
    	select @errmsg = 'Cannot change Primary Key'
    	goto error
    	end
   
   -- check Transaction Header
   SELECT @validcnt = count(*) FROM bAPTH h with (nolock)
   JOIN inserted i ON h.APCo = i.APCo and h.Mth = i.Mth and h.APTrans = i.APTrans
   IF @validcnt <> @numrows
    	BEGIN
    	SELECT @errmsg = 'Transaction Header does not exist'
    	GOTO error
    	END
   
   -- validate GL Company
   if update(GLCo)
       begin
        SELECT @validcnt = count(*) FROM bGLCO c with (nolock) JOIN inserted i ON c.GLCo = i.GLCo
        IF @validcnt <> @numrows
        	BEGIN
        	SELECT @errmsg = 'Invalid GL Company'
        	GOTO error
        	END
       end
   
   if update(GLAcct) or update(GLCo)
   	begin
   	-- validate GL Account
       SELECT @validcnt = count(*) FROM bGLAC v with (nolock)
		JOIN inserted i ON v.GLCo = i.GLCo and v.GLAcct = i.GLAcct
   	IF @validcnt <> @numrows
   		BEGIN
   		SELECT @errmsg = 'Invalid GL Account'
   		GOTO error
   		END
   	end
   
   -- validate supplier
   if update(Supplier) or update(VendorGroup)
       begin
       select @nullcnt = count(*) from inserted where Supplier is null
       SELECT @validcnt = count(*) FROM inserted i
       JOIN bAPVM v with (nolock) ON v.VendorGroup=i.VendorGroup and v.Vendor=i.Supplier
       if @nullcnt + @validcnt <> @numrows
        	BEGIN
        	SELECT @errmsg = 'Invalid Supplier'
        	GOTO error
        	END
       end
   
   -- validate PayType
   if update(PayType)
       begin
       SELECT @validcnt = count(*) FROM bAPPT p with (nolock)
       JOIN inserted i ON p.APCo = i.APCo and p.PayType = i.PayType
       IF @validcnt <> @numrows
        	BEGIN
        	SELECT @errmsg = 'Invalid payment type'
        	GOTO error
        	END
       end
   
   -- validate tax information
   if update(TaxCode) or update(TaxGroup) or update(TaxType)
       begin
       select @nullcnt = count(*) from inserted where TaxGroup is null or TaxCode is null
       SELECT @validcnt = count(*) FROM bHQTX t with (nolock)
       JOIN inserted i ON i.TaxGroup = t.TaxGroup and i.TaxCode = t.TaxCode
       IF @nullcnt + @validcnt <> @numrows
        	BEGIN
        	SELECT @errmsg = 'Invalid tax group/tax code'
   		GOTO error
   		END
   
   	SELECT @validcnt = count(*) FROM inserted 
   	WHERE TaxGroup is not null and TaxCode is not null and TaxType <> 1 and TaxType <> 2 and TaxType <> 3
       IF @validcnt <> 0
        	BEGIN
        	SELECT @errmsg = 'Invalid tax type'
        	GOTO error
        	END
       end
   
-- validate for various line types
if @numrows = 1
	BEGIN
	select @apco = i.APCo, @linetype = i.LineType, @jcco = i.JCCo, @job = i.Job,
			@phasegroup = i.PhaseGroup, @phase = i.Phase, @jcctype = i.JCCType, @inco = i.INCo,
			@loc = i.Loc, @matlgroup = i.MatlGroup, @material = i.Material, @emco = i.EMCo,
			@equip = i.Equip, @emgroup = i.EMGroup, @costcode = i.CostCode, @emctype = i.EMCType,
			@wo = i.WO, @woitem = i.WOItem, @po = i.PO, @poitem = i.POItem, @POItemLine = i.POItemLine,
			@itemtype = i.ItemType,@sl = i.SL, @slitem = i.SLItem,
			----#141957
			@KeyID = i.KeyID, @oldlinetype = d.LineType
	from INSERTED i JOIN deleted d ON d.KeyID = i.KeyID
	END
else
	BEGIN
   	-- use a cursor to process each inserted row
    declare bAPTL_insert cursor LOCAL FAST_FORWARD
   	for select i.APCo, i.LineType, i.JCCo, i.Job, i.PhaseGroup, i.Phase, i.JCCType, i.INCo, i.Loc, i.MatlGroup, 
   		i.Material, i.EMCo, i.Equip, i.EMGroup, i.CostCode, i.EMCType, i.WO, i.WOItem, i.PO, i.POItem, i.POItemLine,
   		i.ItemType, i.SL, i.SLItem,
   		----#141957
   		i.KeyID, d.LineType
   	from INSERTED i JOIN deleted d ON d.KeyID = i.KeyID
   
   	open bAPTL_insert
   
   	fetch next from bAPTL_insert into @apco, @linetype, @jcco, @job, @phasegroup, @phase, @jcctype,
   		@inco, @loc, @matlgroup, @material, @emco, @equip, @emgroup, @costcode, @emctype, @wo, @woitem, 
   		@po, @poitem, @POItemLine, @itemtype, @sl, @slitem,
   		----#141957
   		@KeyID, @oldlinetype
   
   	if @@fetch_status <> 0
    		begin
    		select @errmsg = 'Cursor error'
    		goto error
    		end
    	end
   
   
   insert_check:
   if @linetype = 1
    	BEGIN
   	-- validate JC Company
       if update(JCCo)
           begin
        	SELECT @validcnt = count(*) FROM bJCCO with (nolock) where JCCo = @jcco
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid JC Company'
        		GOTO error
        		END
           end
   
       if update(Job) or update(JCCo)
           begin
        	-- validate Job
        	SELECT @validcnt = count(*) FROM bJCJM with (nolock) where JCCo = @jcco and Job = @job
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid job'
        		GOTO error
        		END
           end
   
   	-- validate standard phase
   	-- note bspJCVPHASE also validates bJCCO and bJCJM
       if update(Job) or update(JCCo) or update(Phase)
           begin
        	exec @rcode=bspJCVPHASE @jcco, @job, @phase, @phasegroup, 'N', @pp output, @descr output,
   					@PhaseGroupOut output, @vcontract output, @vitem output, @dept output,
   					@projminpct output, @JCJPexists output, @errmsg output
        	if @rcode<>0 goto error
           end
   
       if update(Job) or update(JCCo) or update(Phase) or update(JCCType)
           begin
        	-- validate Cost Type
         	select @override='N', @stringct = convert(varchar(5),@jcctype)
         	exec @rcode = bspJCVCOSTTYPE @jcco, @job,@phasegroup, @phase, @stringct, @override,
   					@phsgroup output, @pphase output, @descr output, @billflag output, @um output,
   					@itemunitflag output, @phaseunitflag output, @JCCHexists output, 
   					@costtypeout output, @errmsg output
         	if @rcode <> 0 goto error
           end
    	END
   
   if @linetype = 2
    	BEGIN
    	-- validate IN Company
       if update(INCo)
           begin
        	SELECT @validcnt = count(*) FROM bINCO with (nolock) where INCo = @inco
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid IN Company'
        		GOTO error
        		END
           end
   
       if update(Loc) or update(INCo)
           begin
        	-- validate Location
        	SELECT @validcnt = count(*) FROM bINLM with (nolock) where INCo = @inco and Loc = @loc
   		IF @validcnt = 0
   	     	BEGIN
   	     	SELECT @errmsg = 'Invalid location'
   	     	GOTO error
   	     	END
           end
   
       if update(Material) or update(Loc) or update(INCo)
           begin
        	-- validate Material
        	SELECT @validcnt = count(*) FROM bHQMT with (nolock) where MatlGroup = @matlgroup and Material = @material
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid material'
        		GOTO error
        		END
           end
    	END
   
   if @linetype = 4
    	BEGIN
    	-- validate EM Company
       if update(EMCo)
           begin
        	SELECT @validcnt = count(*) FROM bEMCO with (nolock) where EMCo = @emco
        	IF @validcnt = 0
       		BEGIN
        		SELECT @errmsg = 'Invalid EM Company'
        		GOTO error
        		END
           end
   
        if update(Equip) or update(EMCo)
           begin
       	-- validate Equipment
        	SELECT @validcnt = count(*) FROM bEMEM with (nolock) where EMCo = @emco and Equipment = @equip
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid equipment'
        		GOTO error
        		END
           end
   
        if update(CostCode) or  update(Equip) or update(EMCo)
           begin
        	-- validate Cost Code
        	SELECT @validcnt = count(*) FROM bEMCC with (nolock) where EMGroup = @emgroup and CostCode = @costcode
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid cost code'
        		GOTO error
        		END
           end
   
        if update(EMCType) or update(CostCode) or update(Equip) or update(EMCo)
           begin
        	-- validate EM Cost Type
        	SELECT @validcnt = count(*) FROM bEMCT with (nolock) where EMGroup = @emgroup and CostType = @emctype
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid EM cost type'
        		GOTO error
        		END
           end
   
         if update(EMCType) or update(CostCode) or update(Equip) or update(EMCo)
           begin
        	SELECT @validcnt = count(*) FROM bEMCX with (nolock) where EMGroup = @emgroup 
   		and CostType = @emctype and CostCode = @costcode
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid cost type/cost code combination'
        		GOTO error
        		END
           end
    	END
   
   if @linetype = 5
    	BEGIN
    	-- validate EM Company
       if update(EMCo)
           begin
        	SELECT @validcnt = count(*) FROM bEMCO with (nolock) where EMCo = @emco
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid EM Company'
        		GOTO error
        		END
           end
   
       if update(EMCo) or update(Equip)
           begin
        	-- validate Equipment
        	SELECT @validcnt = count(*) FROM bEMEM with (nolock) where EMCo = @emco and Equipment = @equip
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid equipment'
        		GOTO error
        		END
           end
   
       if update(EMGroup) or update(CostCode) or update(Equip)
           begin
        	-- validate Cost Code
        	SELECT @validcnt = count(*) FROM bEMCC with (nolock) where EMGroup = @emgroup and CostCode = @costcode
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid cost code'
        		GOTO error
        		END
           end
   
    	-- validate EM Cost Type
       if update(EMGroup) or update(EMCType) or update(EMCo)
           begin
        	SELECT @validcnt = count(*) FROM bEMCT with (nolock) where EMGroup = @emgroup and CostType = @emctype
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid EM cost type'
        		GOTO error
        		END
           end
   
       if update(EMGroup) or update(EMCType) or update(EMCo) or update(CostCode)
           begin
 
        	SELECT @validcnt = count(*) FROM bEMCX with (nolock) where EMGroup = @emgroup and CostType = @emctype
        		and CostCode = @costcode
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid cost type/cost code combination'
        		GOTO error
        		END
           end
   
    	-- validate Work Order
       if update(EMCo) or update(WO)
           begin
        	SELECT @validcnt = count(*) FROM bEMWH with (nolock) where EMCo = @emco and WorkOrder = @wo
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid work order'
        		GOTO error
        		END
           end
   
    	-- validate Work Order Item
       if update(EMCo) or update(WO) or update(WOItem)
           begin
        	SELECT @validcnt = count(*) FROM bEMWI with (nolock) where EMCo = @emco and WorkOrder = @wo and WOItem = @woitem
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid work order item'
        		GOTO error
        		END
           end
    	END
   
	IF @linetype = 6
    BEGIN
       IF UPDATE(PO)
       BEGIN
        	-- validate PO
        	SELECT @validcnt = count(*) FROM bPOHD with (nolock) where POCo = @apco and PO = @po
        	IF @validcnt = 0
        	BEGIN
        		SELECT @errmsg = 'Invalid PO'
        		GOTO error
        	END
       END
   
       IF UPDATE(POItem) OR UPDATE(PO)
       BEGIN
        	-- validate PO Item
        	SELECT @validcnt = count(*) FROM bPOIT with (nolock) where POCo = @apco and PO = @po and POItem = @poitem
        	IF @validcnt = 0
        	BEGIN
        		SELECT @errmsg = 'Invalid PO item'
        		GOTO error
        	END
       END
       	
		IF UPDATE(POItemLine) OR UPDATE(POItem) OR UPDATE(PO)
		BEGIN
			-- validate PO Item Line
        	SELECT @validcnt = COUNT(*)
        	FROM dbo.vPOItemLine (NOLOCK)
        	WHERE POCo = @apco AND PO = @po AND POItem = @poitem AND POItemLine = @POItemLine
        	IF @validcnt = 0
        	BEGIN
        		SELECT @errmsg = 'Invalid PO item Line'
        		GOTO error
        	END
        	
			-- if the PO,POItem or POItemLine changes and there is a bPORD record linked to the old PO,POItem and POItemLine
			-- break the invoice link with bPORD.
			SELECT @oldpo= PO, @oldpoitem = POItem, @OldPOItemLine = POItemLine
			FROM deleted
			IF @oldpo <> @po OR @oldpoitem <> @poitem OR @OldPOItemLine <> @POItemLine 
			BEGIN
			IF EXISTS	(	
							SELECT 1 
							FROM dbo.bPORD r 
							JOIN deleted d ON r.POCo=d.APCo AND r.PO=d.PO AND r.POItem=d.POItem AND r.POItemLine=d.POItemLine AND
								(
									r.Receiver# IS NOT NULL AND r.Receiver#=d.Receiver#
								)
							WHERE r.POCo=d.APCo AND r.PO=d.PO AND r.POItem=d.POItem AND r.POItemLine=d.POItemLine
								AND r.APMth=d.Mth AND r.APTrans=d.APTrans AND r.APLine=d.APLine
						)
				BEGIN
				UPDATE dbo.bPORD SET APMth= null, APTrans=null, APLine=null
				FROM dbo.bPORD r 
				JOIN deleted d ON r.POCo=d.APCo AND r.PO=d.PO AND r.POItem=d.POItem AND r.POItemLine=d.POItemLine AND r.Receiver#=d.Receiver#
				WHERE r.POCo=d.APCo AND r.PO=d.PO AND r.POItem=d.POItem AND r.POItemLine=d.POItemLine 
					AND APMth=d.Mth and r.APTrans=d.APTrans and r.APLine=d.APLine 
				END
			END
		END
   
    	-- validate Item Type
       IF UPDATE(POItem) OR update(PO) OR UPDATE(POItemLine)
       BEGIN
        	SELECT @validcnt = count(*) 
        	FROM dbo.vPOItemLine (NOLOCK)
        	WHERE POCo = @apco AND PO = @po AND POItem = @poitem AND POItemLine=@POItemLine	AND ItemType = @itemtype
        	IF @validcnt = 0
        	BEGIN
        		SELECT @errmsg = 'Invalid item type'
        		GOTO error
        	END
    	END
	END -- End PO validation
	
   if @linetype = 7
    	BEGIN
    	-- validate SL
       if update(SL)
           begin
        	SELECT @validcnt = count(*) FROM bSLHD with (nolock) where SLCo = @apco and SL = @sl
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid SL'
        		GOTO error
        		END
           end
   
    	-- validate SL Item
       if update(SL) or update(SLItem)
           begin
        	SELECT @validcnt = count(*) FROM bSLIT with (nolock) where SLCo = @apco and SL = @sl and SLItem = @slitem
        	IF @validcnt = 0
        		BEGIN
        		SELECT @errmsg = 'Invalid SL item'
        		GOTO error
        		END
           end
    	END

---- #141957 insert relationships into relationship table
---- PO line type
---- possible that line type was changed or PO in this case we need to delete old relationship first
IF @oldlinetype = 6
	BEGIN
	IF EXISTS(SELECT TOP 1 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'vPMRelateRecord')
			AND EXISTS(SELECT TOP 1 1 from sysobjects where id = object_id(N'[dbo].[vspPMAssocAPInvoice]')
			AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
		BEGIN
		EXEC dbo.vspPMAssocAPInvoice @KeyID, 'D', @oldlinetype
		END
	END

IF @linetype = 6
	BEGIN
	IF EXISTS(SELECT TOP 1 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'vPMRelateRecord')
			AND EXISTS(SELECT TOP 1 1 from sysobjects where id = object_id(N'[dbo].[vspPMAssocAPInvoice]')
			AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
		BEGIN
		EXEC dbo.vspPMAssocAPInvoice @KeyID, 'I', @linetype
		END
	END

---- #141957 insert relationships into PM relationship table
---- SL line type
---- possible that line type was changed or SL in this case we need to delete old relationship first
IF @oldlinetype = 7
	BEGIN
	IF EXISTS(SELECT TOP 1 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'vPMRelateRecord')
			AND EXISTS(SELECT TOP 1 1 from sysobjects where id = object_id(N'[dbo].[vspPMAssocAPInvoice]')
			AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
		BEGIN
		EXEC dbo.vspPMAssocAPInvoice @KeyID, 'D', @oldlinetype
		END
	END

IF @linetype = 7
	BEGIN
	IF EXISTS(SELECT TOP 1 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'vPMRelateRecord')
			AND EXISTS(SELECT TOP 1 1 from sysobjects where id = object_id(N'[dbo].[vspPMAssocAPInvoice]')
			AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
		BEGIN
		EXEC dbo.vspPMAssocAPInvoice @KeyID, 'I', @linetype
		END
	END


if @numrows > 1
	begin
   	fetch next from bAPTL_insert into @apco, @linetype, @jcco, @job, @phasegroup, @phase, @jcctype,
   		@inco, @loc, @matlgroup, @material, @emco, @equip, @emgroup, @costcode, @emctype, @wo, @woitem, 
   		@po, @poitem, @POItemLine, @itemtype, @sl, @slitem,
   		----#141957
   		@KeyID, @oldlinetype

	if @@fetch_status = 0
		goto insert_check
	else
		begin
		close bAPTL_insert
		deallocate bAPTL_insert
		end
	end
   
   
-- Check bAPCO to see if auditing transaction. If not done.
if not exists(select * from inserted i join bAPCO c with (nolock) on i.APCo=c.APCo where c.AuditTrans = 'Y')
return
   
   
   -- Insert records into HQMA for changes made to audited fields
   if update(LineType)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'LineType', convert(varchar(3),d.LineType), convert(varchar(3),i.LineType), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.LineType <> i.LineType and a.AuditTrans = 'Y'
   
   if update(PO)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'PO', d.PO, i.PO, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.PO <> i.PO and a.AuditTrans = 'Y'
   
   if update(POItem)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'POItem', convert(varchar(5),d.POItem), convert
   	(varchar(5),i.POItem), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.POItem <> i.POItem and a.AuditTrans = 'Y'
    	
    IF UPDATE(POItemLine)
     INSERT INTO dbo.bHQMA SELECT 'bAPTL', ' Mth: ' + CONVERT(CHAR(8), i.Mth,1)
    		 + ' APTrans: ' + CONVERT (VARCHAR(6), i.APTrans)
    		 + ' APLine: ' + CONVERT (VARCHAR(5),i.APLine), i.APCo, 'C',
    		'POItemLine', CONVERT (VARCHAR(5),d.POItemLine), 
    		CONVERT (VARCHAR(5),i.POItemLine),
    		GETDATE(),
    		SUSER_SNAME()
     FROM inserted i
     JOIN deleted d ON d.APCo = i.APCo AND d.Mth = i.Mth AND d.APTrans = i.APTrans AND d.APLine = i.APLine
     JOIN dbo.bAPCO a (NOLOCK) ON a.APCo = i.APCo
     WHERE d.POItemLine <> i.POItemLine AND a.AuditTrans = 'Y'
   
   if update(ItemType)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'ItemType', convert(varchar(5),d.ItemType), convert(varchar(5),i.ItemType), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.ItemType <> i.ItemType and a.AuditTrans = 'Y'
   
   if update(SL)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'SL', d.SL, i.SL, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.SL <> i.SL and a.AuditTrans = 'Y'
   
   if update(SLItem)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'SLItem', convert(varchar(5),d.SLItem), convert(varchar(5),i.SLItem), getdate(), SUSER_SNAME()
    	from inserted i
    join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.SLItem <> i.SLItem and a.AuditTrans = 'Y'
   
   if update(JCCo)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'JCCo', convert(varchar(3),d.JCCo), convert(varchar(3),i.JCCo), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.JCCo <> i.JCCo and a.AuditTrans = 'Y'
   
   if update(Job)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)		
    + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Job', convert(varchar(9),d.Job), convert(varchar(9),i.Job), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Job <> i.Job and a.AuditTrans = 'Y'
   
   if update(PhaseGroup)
    insert into  bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'PhaseGroup', convert(varchar(3),d.PhaseGroup), convert(varchar(3),i.PhaseGroup), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
     join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.PhaseGroup <> i.PhaseGroup and a.AuditTrans = 'Y'
   
   if update(Phase)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Phase', convert(varchar(13),d.Phase), convert(varchar(13),i.Phase), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Phase <> i.Phase and a.AuditTrans = 'Y'
   
   if update(JCCType)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'JCCType', convert(varchar(3),d.JCCType), convert(varchar(3),i.JCCType), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.JCCType <> i.JCCType and a.AuditTrans = 'Y'
   
   if update(EMCo)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'EMCo', convert(varchar(3),d.EMCo), convert(varchar(3),i.EMCo), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.EMCo <> i.EMCo and a.AuditTrans = 'Y'
   
   if update(WO)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'WO', d.WO, i.WO, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.WO <> i.WO and a.AuditTrans = 'Y'
   
   if update(WOItem)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'WOItem', convert(varchar(5),d.WOItem), convert(varchar(5),i.WOItem), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.WOItem <> i.WOItem and a.AuditTrans = 'Y'
   
   if update(Equip)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Equip', d.Equip, i.Equip, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Equip <> i.Equip and a.AuditTrans = 'Y'
   
   if update(EMGroup)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'EMGroup', convert(varchar(3),d.EMGroup), convert(varchar(3),i.EMGroup), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.EMGroup <> i.EMGroup and a.AuditTrans = 'Y'
   
   if update(CostCode)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'CostCode', d.CostCode, i.CostCode, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.CostCode <> i.CostCode and a.AuditTrans = 'Y'
   
   if update(EMCType)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'EMCType', convert(varchar(3),d.EMCType), convert(varchar(3),i.EMCType), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.EMCType <> i.EMCType and a.AuditTrans = 'Y'
   
   if update(INCo)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'INCo', convert(varchar(3),d.INCo), convert(varchar(3),i.INCo), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.INCo <> i.INCo and a.AuditTrans = 'Y'
   
   if update(Loc)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Loc', convert(varchar(10),d.Loc), convert(varchar(10),i.Loc), getdate(), SUSER_SNAME()
    	from inserted i
   	join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Loc <> i.Loc and a.AuditTrans = 'Y'
   
   if update(MatlGroup)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'MatlGroup', convert(varchar(3),d.MatlGroup), convert(varchar(3),i.MatlGroup), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.MatlGroup <> i.MatlGroup and a.AuditTrans = 'Y'
   
   if update(Material)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Material', d.Material, i.Material, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Material <> i.Material and a.AuditTrans = 'Y'
   
   if update(GLCo)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'GLCo', convert(varchar(3),d.GLCo), convert(varchar(3),i.GLCo), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.GLCo <> i.GLCo and a.AuditTrans = 'Y'
   
   if update(GLAcct)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'GLAcct', convert(varchar(10),d.GLAcct), convert(varchar(10),i.GLAcct), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.GLAcct <> i.GLAcct and a.AuditTrans = 'Y'
   
   if update(Description)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Description', d.Description, i.Description, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Description <> i.Description and a.AuditTrans = 'Y'
   
   if update(UM)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'UM', d.UM, i.UM, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.UM <> i.UM and a.AuditTrans = 'Y'
   
   if update(Units)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Units', convert(varchar(15),d.Units), convert(varchar(15),i.Units), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Units <> i.Units and a.AuditTrans = 'Y'
   
   if update(UnitCost)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	' UnitCost' , convert(varchar(20),d.UnitCost), convert(varchar(20),i.UnitCost), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.UnitCost <> i.UnitCost and a.AuditTrans = 'Y'
   
   if update(ECM)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'ECM', d.ECM, i.ECM, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.ECM <> i.ECM and a.AuditTrans = 'Y'
   
   if update(VendorGroup)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'VendorGroup', convert(varchar(3),d.VendorGroup), convert(varchar(3),i.VendorGroup), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.VendorGroup <> i.VendorGroup and a.AuditTrans = 'Y'
   
   if update(Supplier)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Supplier', convert(varchar(6),d.Supplier), convert(varchar(6),i.Supplier), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Supplier <> i.Supplier and a.AuditTrans = 'Y'
   
   if update(PayType)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'PayType', convert(varchar(3),d.PayType), convert(varchar(3),i.PayType), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.PayType <> i.PayType and a.AuditTrans = 'Y'
   
   if update(GrossAmt)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'GrossAmt', convert(varchar(16),d.GrossAmt), convert(varchar(16),i.GrossAmt), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.GrossAmt <> i.GrossAmt and a.AuditTrans = 'Y'
   
   if update(MiscAmt)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'MiscAmt', convert(varchar(16),d.MiscAmt), convert(varchar(16),i.MiscAmt), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.MiscAmt <> i.MiscAmt and a.AuditTrans = 'Y'
   
   if update(MiscYN)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'MiscYN', d.MiscYN, i.MiscYN, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.MiscYN <> i.MiscYN and a.AuditTrans = 'Y'
   
   if update(TaxGroup)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'TaxGroup', convert(varchar(3),d.TaxGroup), convert(varchar(3),i.TaxGroup), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.TaxGroup <> i.TaxGroup and a.AuditTrans = 'Y'
   
   if update(TaxCode)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'TaxCode', d.TaxCode, i.TaxCode, getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.TaxCode <> i.TaxCode and a.AuditTrans = 'Y'
   
   if update(TaxType)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'TaxType', convert(char(1),d.TaxType), convert(char(1),i.TaxType), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.TaxType <> i.TaxType and a.AuditTrans = 'Y'
   
   if update(TaxBasis)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'TaxBasis', convert(varchar(16),d.TaxBasis), convert(varchar(16),i.TaxBasis), getdate(), SUSER_SNAME()
    	from inserted i
       join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.TaxBasis <> i.TaxBasis and a.AuditTrans = 'Y'
   
   if update(TaxAmt)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'TaxAmt', convert(varchar(16),d.TaxAmt), convert(varchar(16),i.TaxAmt), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.TaxAmt <> i.TaxAmt and a.AuditTrans = 'Y'
   
   if update(Retainage)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Retainage', convert(varchar(16),d.Retainage), convert(varchar(16),i.Retainage), getdate(), SUSER_SNAME()
    	from inserted i
   	join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Retainage <> i.Retainage and a.AuditTrans = 'Y'
   
   if update(Discount)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'Discount', convert(varchar(16),d.Discount), convert(varchar(16),i.Discount), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join  bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.Discount <> i.Discount and a.AuditTrans = 'Y'
   
   if update(BurUnitCost)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'BurUnitCost', convert(varchar(20),d.BurUnitCost), convert(varchar(20),i.BurUnitCost), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
        join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.BurUnitCost <> i.BurUnitCost and a.AuditTrans = 'Y'
   
   if update(BECM)
    insert into bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'BECM', d.BECM, i.BECM, getdate(), SUSER_SNAME()
    	from inserted i
       join deleted d on d.APCo = i.APCo and d.Mth = i.Mth
   	and d.APTrans = i.APTrans and d.APLine = i.APLine
       join bAPCO a with (nolock) on a.APCo = i.APCo
    	where d.BECM <> i.BECM and a.AuditTrans = 'Y'
   
   IF UPDATE(SubjToOnCostYN)
   INSERT INTO dbo.bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'SubjToOnCostYN', d.SubjToOnCostYN, i.SubjToOnCostYN, getdate(), SUSER_SNAME()
   FROM inserted i
   JOIN deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
   WHERE d.SubjToOnCostYN <> i.SubjToOnCostYN 
   
   IF UPDATE(OnCostStatus)
   INSERT INTO dbo.bHQMA SELECT 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'OnCostStatus', convert(varchar(4),d.OnCostStatus), convert(varchar(4),i.OnCostStatus), getdate(), SUSER_SNAME()
   FROM inserted i
   JOIN deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans and d.APLine = i.APLine
   WHERE d.OnCostStatus <> i.OnCostStatus
    	
   IF UPDATE(ocApplyMth)
   INSERT INTO dbo.bHQMA SELECT 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'ocApplyMth', convert(varchar(8),d.ocApplyMth), convert(varchar(8),i.ocApplyMth), getdate(), SUSER_SNAME()
   FROM inserted i
   JOIN deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
   WHERE d.ocApplyMth <> i.ocApplyMth
   
   IF UPDATE(ocApplyTrans)
   INSERT INTO dbo.bHQMA SELECT 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'ocApplyTrans', convert(varchar(20),d.ocApplyTrans), convert(varchar(20),i.ocApplyTrans), getdate(), SUSER_SNAME()
   FROM inserted i
   JOIN deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans and d.APLine = i.APLine
   WHERE d.ocApplyTrans <> i.ocApplyTrans
   
   IF UPDATE(ocApplyLine)
   INSERT INTO dbo.bHQMA SELECT 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'ocApplyLine', convert(varchar(10),d.ocApplyLine), convert(varchar(10),i.ocApplyLine), getdate(), SUSER_SNAME()
   FROM inserted i
   JOIN deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans and d.APLine = i.APLine
   WHERE d.ocApplyLine <> i.ocApplyLine

	IF UPDATE(ATOCategory)
   INSERT INTO dbo.bHQMA select 'bAPTL', ' Mth: ' + convert(char(8), i.Mth,1)
    		 + ' APTrans: ' + convert(varchar(6), i.APTrans)
    		 + ' APLine: ' + convert(varchar(5),i.APLine), i.APCo, 'C',
    	'ATOCategory', d.ATOCategory, i.ATOCategory, getdate(), SUSER_SNAME()
   FROM inserted i
   JOIN deleted d on d.APCo = i.APCo and d.Mth = i.Mth and d.APTrans = i.APTrans
        	and d.APLine = i.APLine
   WHERE d.ATOCategory <> i.ATOCategory 
   
   
   return
   
   
   
   error:
   	select @errmsg = @errmsg + ' - cannot update Transaction Line!'
   	RAISERROR(@errmsg, 11, -1);
      	rollback transaction
   
   
  
 






GO
PRINT N'Altering trigger [dbo].[btPMSLi] on [dbo].[bPMSL]'
GO

/****** Object:  Trigger dbo.btPMSLi    Script Date: 8/28/99 9:38:24 AM ******/
ALTER  trigger [dbo].[btPMSLi] on [dbo].[bPMSL] for INSERT as
/*--------------------------------------------------------------
* Insert trigger for PMSL
* Created By:	LM 12/22/97  
* Modified By: GF 05/03/2000
*              GF 05/30/2001 - added validation for units <> 0 and UM='LS'
*              DANF 09/06/02 - 17738 Added Phase Group to bspJCADDCOSTTYPE
*				GF 10/09/2002 - changed dbl quotes to single quotes
*				GF 09/10/2003 - issue #22398 - added check for duplicate SL item with different
*								phase/costtype/um combination
*				GF 01/15/2007 - 6.x HQMA auditing
*				GF 03/13/2008 - issue #127436 changed logic to add project firm contact to use bPMSS info if possible
*				GF 07/24/2008 - issue #129065 need to check PMOL for existance by pending or approved not both
*				GF 09/19/2008 - issue #129811 subcontract tax
*				GF 03/12/2010 - issue #138547 - SLHD.Vendor must match PMSL.Vendor when SL assigned.
*				GF 06/28/2010 - issue #135813 SL expanded to 30 characters
*				GF 11/02/2010 - issue #141957 record association
*				GF 11/05/2010 - issue #141031 change to use date function.
*				GF 11/19/2010 - issue #141715 use pm company subcontract option for PMOL units and costs
*				GF 02/21/2011 - B-02385 create PMSubcontractCO record when adding SubCO to PMSL
*				GF 03/02/2011 - TK-01846 use impact budget and sub types when adding to PMOL
*				GF 03/26/2011 - TK-03289 SUBCO
*				GF 05/11/2011 - TK-05178 TK-05205
*				GF 06/20/2011 - TK-06121
*				GF 06/22/2011 - D-02339 use view not tables for links
*				GF 11/02/2011 TK-09613 do not allow subco for different jobs
*				JayR 03/27/2012 TK-00000 Change to use FKs and table constraints for some of the validation
*				GF 05/17/2012 TK-13889 if SubCO is assigned to an ACO, approve the SCO
*				GF 06/20/2012 TK-15931 cleanup, check PMOL for match and sync purchase values if found.
*				GF 07/03/2012 TK-16127 only approve SCO from an ACO and SCO does not exist
*				GF 11/09/2012 TK-18033 SL Claim Enhancement. Changed to Use ApprovalRequired
*				AW 03/15/2013 TFS 43659 - support new check box for creating a new SL
*
*--------------------------------------------------------------*/
declare @numrows int, @errmsg varchar(255), @validcnt int, @validcnt2 int, @validcnt3 int,
		@rcode int,
   		@pmco bCompany, @project bJob, @seq int, @phasegroup bGroup, @phase bPhase, 
   		@costtype bJCCType, @pmslum bUM, @um bUM, @slco bCompany, @vendorgroup bGroup, 
   		@vendor bVendor, @sl VARCHAR(30), @slcompgroup varchar(10), @description bItemDesc,
   		@recordtype char(1), 
   		@pcotype bPCOType, @pco bDocument, @pcoitem bPCOItem, @aco bDocument, @acoitem bACOItem, 
   		@units bUnits, @unitcost bUnitCost, @estcost bDollar, @sendyn bYN, 
   		@unithours bHrs, @esthours bHrs, @hourcost bUnitCost, @phaseum bUM, @retcode int, 
   		@retmsg varchar(150), @origdate bDate, @slitemdescription bItemDesc, @slitem bItem,
		@sendtofirm bVendor, @sendtocontact bEmployee, @slhd_vendor bVendor,
		@subItemPhase bPhase, @subItemCostType bJCCType, @subItemUM bUM,
		@SLID BIGINT, @ACOID BIGINT, @PCOID BIGINT, @slct1option TINYINT,
		----TK-01846 B-02385
		@SubCO SMALLINT	, @SubCO_Status VARCHAR(6), @BudgetType CHAR(1), @SubType CHAR(1),
		@PurchaseAmt bDollar, @PurchaseUnits bUnits, @PurchaseUM bUM, @PurchaseUnitCost bUnitCost,
		----TK-09613
		@SCO_JCCo bCompany, @SCO_Job bJob

select @numrows = @@rowcount
if @numrows = 0 return
set nocount on

---- Get current date 141031
set @origdate = dbo.vfDateOnly()

---- if assigned to a SL the VendorGroup/Vendor must match SL
-- There is a conflicting index so I did not switch this one to FKs for validation
SELECT @validcnt = COUNT(*) FROM inserted i LEFT JOIN dbo.bSLHD h ON
		h.SLCo=i.SLCo AND h.SL=i.SL AND h.VendorGroup=i.VendorGroup
		AND h.Vendor=i.Vendor WHERE i.SL IS NOT NULL
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.SL IS NULL
if @validcnt + @validcnt2 <> @numrows
	BEGIN
	SELECT @errmsg = 'Vendor is Invalid for Subcontract'
	goto error
	END



if @numrows = 1
	begin
   	select @pmco=PMCo, @project=Project, @seq=Seq
	from inserted
	end
else
	begin
   	---- use a cursor to process each inserted row
   	declare bPMSL_insert cursor LOCAL FAST_FORWARD for select PMCo, Project, Seq
   	from inserted
   
   	open bPMSL_insert
   
	fetch next from bPMSL_insert into @pmco, @project, @seq
	if @@fetch_status <> 0
		begin
   		select @errmsg = 'Cursor error'
   		goto error
   		end
	end


insert_check:
---- get inserted data
select @phasegroup=PhaseGroup, @phase=Phase, @costtype=CostType, @pmslum=UM, @slco=SLCo, 
   		@vendorgroup=VendorGroup, @vendor=Vendor, @sl=SL, @slitem=SLItem, @slitemdescription=SLItemDescription, 
   		@recordtype=RecordType, @pcotype=PCOType, @pco=PCO, @pcoitem=PCOItem, @aco=ACO, @acoitem=ACOItem, 
   		@units=Units, @unitcost=UnitCost, @estcost=Amount, @sendyn=SendFlag,
   		----B-02385
   		@SubCO = SubCO
from inserted where PMCo=@pmco and Project=@project and Seq=@seq

---- get compliance group from JCJM
select @slcompgroup = SLCompGroup from bJCJM with (nolock) where JCCo = @pmco and Job = @project

---- check if SL and SubCO not null that company and job are same
----TK-09613
IF @sl IS NOT NULL AND @SubCO IS NOT NULL
	BEGIN
	---- verify same JCCo and Job
	SET @SCO_JCCo = NULL
	SET @SCO_Job = NULL
	SELECT @SCO_JCCo = PMCo, @SCO_Job = Project
	FROM dbo.vPMSubcontractCO WHERE SLCo=@slco AND SL=@sl AND SubCO=@SubCO
	IF @@ROWCOUNT <> 0
		BEGIN
		IF @SCO_JCCo <> @pmco
   			BEGIN
   			SELECT @errmsg = 'Invalid SubCO, assigned to a different Company.'
   			GOTO error
   			END
		--IF @SCO_Job <> @project
  -- 			BEGIN
  -- 			SELECT @errmsg = 'Invalid SubCO, assigned to a different Job.'
  -- 			GOTO error
  -- 			END
   		END
	END
	
---- get beginning status for SubCO from PMSC B-02385
SET @SubCO_Status = NULL
select Top 1 @SubCO_Status = Status
FROM dbo.bPMSC WHERE DocCat = 'SUBCO' AND CodeType = 'B'
----TK-05205
IF @@ROWCOUNT = 0
	BEGIN
	SELECT @SubCO_Status = BeginStatus
	FROM dbo.bPMCO WHERE PMCo=@pmco
	END
	
---- glet sl cost type option #141715
SET @slct1option = 2
select @slct1option=SLCT1Option
from dbo.bPMCO with (nolock) where PMCo=@pmco
IF ISNULL(@slct1option,0) = 0 SET @slct1option = 2

--- validate pending change order
if @recordtype = 'C'
   	begin
   	if isnull(@pcotype,'') <> ''
   		begin
   		if not exists(select top 1 1 from bPMOI where PMCo=@pmco and Project=@project
   					and PCOType=@pcotype and PCO=@pco and PCOItem=@pcoitem)
   			begin
   			select @errmsg = 'PCO is invalid: PCOType: ' + isnull(@pcotype,'') + ' PCO: ' + isnull(@pco,'') + ' PCOItem: ' + isnull(@pcoitem,'') + ' !'
   			goto error
   			end
   		end

   	---- validate approved change order
   	if isnull(@aco,'') <> ''
   		begin
   		if not exists(select top 1 1 from bPMOI where PMCo=@pmco and Project=@project
   					and ACO=@aco and ACOItem=@acoitem)
   			begin
   			select @errmsg = 'ACO is invalid: ACO: ' + isnull(@aco,'') + ' ACOItem: ' + isnull(@acoitem,'') + ' !'
   			goto error
   			end
   		end
   	end


if @phase is not null
   	begin
   	---- validate standard phase - if it doesnt exist in JCJP try to add it
   	exec @rcode = dbo.bspJCADDPHASE @pmco, @project, @phasegroup, @phase, 'Y', null, @errmsg output
   	if @rcode<>0
   		begin
   		select @errmsg = @errmsg + ' - Error adding phase to job phases.'
   		GoTo error
   		End

   	---- validate Cost Type - if JCCH doesnt exist try to add it
   	exec @rcode = dbo.bspJCADDCOSTTYPE @jcco=@pmco, @job=@project, @phasegroup=@phasegroup, @phase=@phase,
    	                @costtype=@costtype, @um=@pmslum, @override= 'P', @msg=@errmsg output
   	if @rcode<>0
   		begin
   		select @errmsg = @errmsg + ' - Error adding cost type to JCCH.'
   		GoTo error
   		End
   	End


---- check for duplicate with different assigned phase/costtype/um combination
if @recordtype = 'O' and @sl is not null
   	begin
   	-- check for duplicate item record with different phase/costtype/um combination
   	if exists(select 1 from dbo.bPMSL with (nolock) where PMCo=@pmco and Project=@project and SLCo=@slco
   		and Vendor=@vendor and SL=@sl and SLItem=@slitem and Seq<>@seq and InterfaceDate is null
   		and RecordType='O' and (Phase<>@phase or CostType<>@costtype or UM<>@pmslum))
   		begin
   		select @errmsg = 'SL: ' + isnull(@sl,'') + ' SLItem: ' + convert(varchar(8),isnull(@slitem,0)) 
   					+ ' - Multiple records set up for same item with different Phase/CostType/UM combination.'
   	    goto error
   	    end
   	end

if @recordtype = 'C' and @sl is not null
   	begin
   	---- check for duplicate item record with different phase/costtype/um combination
   	if exists(select 1 from dbo.bPMSL with (nolock) where PMCo=@pmco and Project=@project and SLCo=@slco
   		and Vendor=@vendor and SL=@sl and SLItem=@slitem and Seq<>@seq and InterfaceDate is null
   		and RecordType='C' and (Phase<>@phase or CostType<>@costtype or UM<>@pmslum))
   		begin
   		select @errmsg = 'SL: ' + isnull(@sl,'') + ' SLItem: ' + convert(varchar(8),isnull(@slitem,0)) 
   					+ ' - Multiple records set up for same item with different Phase/CostType/UM combination.'
   	    goto error
   	    END
   	---- #138547
	---- get vendor from SLHD if SL exists. compare to PMSL vendor if one assigned. Must match
	select @slhd_vendor = Vendor from dbo.bSLHD h with (nolock) where h.SLCo=@slco and h.SL=@sl
	if @@rowcount <> 0
		BEGIN
		if isnull(@slhd_vendor,'') <> isnull(@vendor,'')
			BEGIN
			select @errmsg = 'SL: ' + isnull(@sl,'') + ' Vendor: ' + convert(varchar(10),isnull(@slhd_vendor,0)) 
   					+ ' does not match subcontract detail vendor: ' + convert(varchar(10),isnull(@vendor,0)) + '.'
   			goto error
			END
		END
   	end
   	---- #138547

---- Validate SL/insert SL
if @sl is not null
   	begin
	---- check SLIT for item, if found phase/costtype must exist
   	select @subItemPhase = Phase, @subItemCostType = JCCType, @subItemUM = UM
   	from dbo.bSLIT where SLCo=@slco and SL=@sl and SLItem=@slitem
   	if @@rowcount <> 0
   		begin
   		if @subItemPhase <> @phase or @subItemCostType <> @costtype or @subItemUM <> @pmslum
   			begin
			select @errmsg = 'SL: ' + isnull(@sl,'') + ' SLItem: ' + convert(varchar(8),isnull(@slitem,0)) 
   					+ ' - Multiple records set up for same item with different Phase/CostType/UM combination.'
			goto error
			END
		end
		
   	if not exists (select top 1 1 from dbo.bSLHD with (nolock) where SLCo=@slco and SL=@sl)
   		begin
   		----select @description = substring(@slitemdescription,1,30)
   		insert bSLHD (SLCo, SL, JCCo, Job, Description, VendorGroup, Vendor, Status, PayTerms, 
   				CompGroup, Purge, Approved, OrigDate
				----TK-18033
				,ApprovalRequired)
   		select @slco, @sl, @pmco, @project, @slitemdescription, @vendorgroup, @vendor, 3, m.PayTerms, 
   				@slcompgroup, 'N', 'N', @origdate
				----TK-18033
				,'N'
   		from bAPVM m with (nolock) where m.VendorGroup=@vendorgroup and m.Vendor=@vendor
   		if @@rowcount <> 1
   			begin
   			select @errmsg = ' Cannot insert into SLHD '
   			goto error
   			end
   		end

	---- insert SendTo info in bPMSS if needed
	if not exists(select 1 from dbo.bPMSS with (nolock) where PMCo=@pmco and Project=@project
					and SLCo=@slco and SL=@sl)
		begin
		exec @retcode = bspPMSSInitialize @pmco, @project, @slco, @sl, @retmsg output
		end

	---- insert Project Firm if needed check bPMSS to see if we have a send to firm and contact
	select @sendtofirm=SendToFirm, @sendtocontact=SendToContact
	from dbo.bPMSS with (nolock) where PMCo=@pmco and Project=@project and SLCo=@slco and SL=@sl
	and SendToFirm is not null and SendToContact is not null
	if @@rowcount <> 0
		begin
		if not exists(select 1 from dbo.bPMPF with (nolock) where PMCo=@pmco and Project=@project
				and FirmNumber=@sendtofirm and ContactCode=@sendtocontact)
			begin
			exec @retcode = bspPMPFirmContactDistAdd @pmco, @project, @vendorgroup, @sendtofirm, @sendtocontact, @retmsg output
			end
		end
	else
		begin
		if not exists(select 1 from dbo.bPMPF with (nolock) where PMCo=@pmco and Project=@project
					and VendorGroup=@vendorgroup and FirmNumber=@vendor)
			begin
			exec @retcode = bspPMSLFirmContactInit @pmco, @project, @vendorgroup, @vendor, @retmsg output
			end
		end
	end

---- Add a record to change order detail if this is a change order and not already in PMOL
----TK-01846
if @recordtype='C' AND @slct1option <> 1
   	begin
	if isnull(@pcotype,'') <> '' and isnull(@pco,'') <> ''
		BEGIN
		----TK-01846
		SELECT @BudgetType=BudgetType, @SubType=SubType
		FROM dbo.bPMOP where PMCo=@pmco and Project=@project and PCOType=@pcotype and PCO=@pco 
		
		---- check the pending detail for phase and cost type
   		if not exists (select top 1 1 from dbo.bPMOL where PMCo=@pmco 
   					and Project=@project and PCOType=@pcotype and PCO=@pco and PCOItem=@pcoitem
   					and PhaseGroup=@phasegroup and Phase=@phase and CostType=@costtype)
   			begin
   			SET @unithours = 0
   			SET	@esthours = 0
   			SET @hourcost = 0
   			select @phaseum=UM 
   			from dbo.bJCCH
   			where JCCo=@pmco 
   				and Job=@project 
   				and PhaseGroup=@phasegroup
   				and Phase=@phase 
   				and CostType=@costtype
   			---- if no JCCH record found use PMSL um
   			IF @@ROWCOUNT = 0 SET @phaseum = @pmslum
   			
   			---- set purchase values if PCO set up for subcontract impact type TK-05178
   			IF @SubType = 'Y'
   				BEGIN
   				SET @PurchaseUM = @pmslum
   				SET @PurchaseUnits = @units
   				SET @PurchaseUnitCost = @unitcost
				SET @PurchaseAmt = @estcost
				END
			ELSE
				BEGIN
				SET @PurchaseUM = NULL
   				SET @PurchaseUnits = 0
   				SET @PurchaseUnitCost = 0
				SET @PurchaseAmt = 0
				END
				
   			---- TK-06039
   			---- if the JCCH um <> PMSL UM then zero out estimate values
			if @phaseum <> @pmslum
   				 begin
   				 select @units=0, @unitcost=0
   				 END
   			
   			----#141715
			if @slct1option = 3
				begin
				SET @units = 0
				SET @unitcost=0
				SET @estcost = 0
				END

			---- TK-01846 we need to check the PCO impact types to set what we actual update to PMOL
			IF @BudgetType = 'N'
				BEGIN
				SET @units = 0
				SET @unitcost=0
				SET @estcost = 0
				END
				

   			---- insert change order detail record TK-01846
   			insert bPMOL (PMCo, Project, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup, Phase, CostType,
   						  EstUnits, UM, UnitHours, EstHours, HourCost, UnitCost, ECM, EstCost, SendYN,
   						  VendorGroup, Vendor, Subcontract, POSLItem, SubCO, SubCOSeq,
   						  PurchaseUnits, PurchaseUM, PurchaseUnitCost, PurchaseAmt)
   			values (@pmco, @project, @pcotype, @pco, @pcoitem, @aco, @acoitem, @phasegroup,
   					@phase, @costtype, @units, @phaseum, @unithours, @esthours, @hourcost, 
   					@unitcost, 'E', @estcost, @sendyn, @vendorgroup,
   					CASE WHEN @SubType = 'Y' THEN @vendor ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @sl ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @slitem ELSE NULL END,
   					CASE WHEN @SubType = 'Y' AND @SubCO IS NOT NULL THEN @SubCO ELSE NULL END,
   					CASE WHEN @SubType = 'Y' AND @SubCO IS NOT NULL THEN @seq ELSE NULL END,
   					----TK-06121
   					CASE WHEN @SubType = 'Y' THEN @PurchaseUnits ELSE 0 END,
   					CASE WHEN @SubType = 'Y' THEN @PurchaseUM ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @PurchaseUnitCost ELSE 0 END,
   					CASE WHEN @SubType = 'Y' THEN @PurchaseAmt ELSE 0 END
   					)
   			end
		end
	else
		begin
		---- check the approved detail for phase and cost type
   		if not exists (select top 1 1 from dbo.bPMOL with (nolock) where PMCo=@pmco 
   						and Project=@project and ACO=@aco and ACOItem=@acoitem 
   						and PhaseGroup=@phasegroup and Phase=@phase and CostType=@costtype)
   			BEGIN
   			
   			----TK-01846
			SET @BudgetType='Y'
			SET @SubType='Y'
			---- if the ACO is from the PCO then check bPMOP for Type flags TK-01846
			IF @pco IS NOT NULL
				BEGIN
				SELECT @BudgetType=BudgetType, @SubType=SubType
				FROM dbo.bPMOP where PMCo=@pmco and Project=@project and PCOType=@pcotype and PCO=@pco 
				END
			
			---- set estimate cost
   			SET @unithours = 0
   			SET @esthours = 0
   			SET @hourcost = 0
   			select @phaseum=UM 
   			from dbo.bJCCH 
   			where JCCo=@pmco 
   				and Job=@project 
   				and PhaseGroup=@phasegroup 
   				and Phase=@phase 
   				and CostType=@costtype
   			---- if no JCCH record found use PMSL um
   			IF @@ROWCOUNT = 0 SET @phaseum = @pmslum
   			
   			---- set purchase values if PCO set up for subcontract impact type TK-05178
   			IF @SubType = 'Y'
   				BEGIN
   				SET @PurchaseUM = @pmslum
   				SET @PurchaseUnits = @units
   				SET @PurchaseUnitCost = @unitcost
				SET @PurchaseAmt = @estcost
				END
			ELSE
				BEGIN
				SET @PurchaseUM = NULL
   				SET @PurchaseUnits = 0
   				SET @PurchaseUnitCost = 0
				SET @PurchaseAmt = 0
				END
				
   			---- TK-06039
   			---- if the JCCH um <> PMSL UM then zero out estimate values
			if @phaseum <> @pmslum
   				 begin
   				 select @units=0, @unitcost=0
   				 END
   			
   			----#141715
			if @slct1option = 3
				begin
				SET @units = 0
				SET @unitcost=0
				SET @estcost = 0
				END
   			
			---- TK-01846 we need to check the PCO impact types to set what we actual update to PMOL
			IF @BudgetType = 'N'
				BEGIN
				SET @units = 0
				SET @unitcost=0
				SET @estcost = 0
				END
				
   			---- insert change order detail record TK-01846
   			insert bPMOL (PMCo, Project, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup, Phase, CostType,
   						  EstUnits, UM, UnitHours, EstHours, HourCost, UnitCost, ECM, EstCost, SendYN,
   						  VendorGroup, Vendor, Subcontract, POSLItem, SubCO, SubCOSeq,
   						  PurchaseUnits, PurchaseUM, PurchaseUnitCost, PurchaseAmt)
   			values (@pmco, @project, @pcotype, @pco, @pcoitem, @aco, @acoitem, @phasegroup,
   					@phase, @costtype, @units, @phaseum, @unithours, @esthours, @hourcost, 
   					@unitcost, 'E', @estcost, @sendyn, @vendorgroup,
   					CASE WHEN @SubType = 'Y' THEN @vendor ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @sl ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @slitem ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @SubCO ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @seq ELSE NULL END,
   					----TK-06121
   					CASE WHEN @SubType = 'Y' THEN @PurchaseUnits ELSE 0 END,
   					CASE WHEN @SubType = 'Y' THEN @PurchaseUM ELSE NULL END,
   					CASE WHEN @SubType = 'Y' THEN @PurchaseUnitCost ELSE 0 END,
   					CASE WHEN @SubType = 'Y' THEN @PurchaseAmt ELSE 0 END
   					)
   			end
		end
   	end


---- assigned to a subcontract: #141957
---- TK-03289 create subcontract change order if needed
IF @sl IS NOT NULL AND @SubCO IS NOT NULL
	BEGIN
	IF NOT EXISTS(SELECT 1 FROM dbo.vPMSubcontractCO WHERE SLCo=@slco AND SL=@sl AND SubCO=@SubCO)
		BEGIN
		INSERT INTO dbo.vPMSubcontractCO (PMCo, Project, SubCO, Description, Status, Date, SLCo, SL, ReadyForAcctg)
		VALUES (@pmco, @project, @SubCO, @slitemdescription, @SubCO_Status, dbo.vfDateOnly(), @slco, @sl, 'N')
		----TK-16127 moved approve to here so only happens when a new SCO
		----TK-13889 if the SCO is being assigned from an ACO, then we need to approve the SCO
		IF ISNULL(@aco,'') <> ''
			BEGIN
			DECLARE @SCOKeyID BIGINT
			SELECT @SCOKeyID = KeyID
			FROM dbo.vPMSubcontractCO
			WHERE SLCo = @slco
				AND SL = @sl
				AND SubCO = @SubCO
			IF @@ROWCOUNT = 1
				BEGIN
				EXEC @retcode = dbo.vspPMSubcontractCOApproveSCOs @SCOKeyID, 'Y', NULL, @retmsg OUTPUT
				END
			END
		END
	END



---- TK-15931 Backfill values to PMOL if we find a match. There must be only one PMSL record.
IF @recordtype = 'C'
	BEGIN
	---- update subcontract values to PMOL
	UPDATE dbo.bPMOL
			SET SubCO				= @SubCO
			  , SubCOSeq			= CASE WHEN @SubCO IS NOT NULL THEN @seq ELSE NULL END
			  , PurchaseUnits		= @units
			  , PurchaseUM			= @pmslum
			  , PurchaseUnitCost	= @unitcost
			  , PurchaseAmt			= @estcost
			  , Subcontract			= @sl
			  , POSLItem			= @slitem
			  , Vendor				= @vendor
			  , VendorGroup			= @vendorgroup
	WHERE PMCo = @pmco
		AND Project = @project
		AND Phase = @phase
		AND CostType = @costtype
		AND ISNULL(PCOType,'') = ISNULL(@pcotype,'')
		AND ISNULL(PCO,'') = ISNULL(@pco,'')
		AND ISNULL(PCOItem,'') = ISNULL(@pcoitem,'')
		AND ISNULL(ACO,'') = ISNULL(@aco,'')
		AND ISNULL(ACOItem,'') = ISNULL(@acoitem,'')
		AND NOT EXISTS(SELECT 1 FROM dbo.PMSL s WHERE s.PMCo=@pmco AND s.Project = @project
				AND Phase = @phase
				AND CostType = @costtype
				AND (PCO IS NOT NULL OR ACO IS NOT NULL)
				AND ISNULL(PCOType,'') = ISNULL(@pcotype,'')
				AND ISNULL(PCO,'') = ISNULL(@pco,'')
				AND ISNULL(PCOItem,'') = ISNULL(@pcoitem,'')
				AND ISNULL(ACO,'') = ISNULL(@aco,'')
				AND ISNULL(ACOItem,'') = ISNULL(@acoitem,'')
				AND Seq <> @seq)	
	END



next_PMSL_record:
if @numrows > 1
   	begin
       fetch next from bPMSL_insert into @pmco, @project, @seq
   	if @@fetch_status = 0
   		goto insert_check
   	else
   		begin
   		close bPMSL_insert
   		deallocate bPMSL_insert
   		end
   	end


---- update the Record Type field based on whether or not there is a
---- change order associated with this sl
---- original record type
UPDATE dbo.bPMSL SET RecordType = 'O'
FROM inserted i INNER JOIN dbo.bPMSL p ON p.KeyID=i.KeyID
WHERE i.RecordType = 'C' AND i.ACO IS NULL AND i.PCO IS NULL
---- change record type
UPDATE dbo.bPMSL SET RecordType = 'C'
FROM inserted i INNER JOIN dbo.bPMSL p ON p.KeyID=i.KeyID
WHERE i.RecordType = 'O' AND (i.ACO IS NOT NULL or i.PCO IS NOT NULL)

---- insert vPMRelateRecord for various links PCO/ACO/SUBCO/SLHD TK-03289
---- PCO and SubCO
INSERT INTO dbo.vPMRelateRecord(RecTableName, RECID, LinkTableName, LINKID)
SELECT 'PMSubcontractCO', a.KeyID, 'PMOP', b.KeyID
FROM inserted i
INNER JOIN dbo.vPMSubcontractCO a ON a.SLCo=i.SLCo AND a.SL=i.SL AND a.SubCO=i.SubCO
INNER JOIN dbo.bPMOP b ON b.PMCo=i.PMCo AND b.Project=i.Project AND b.PCOType=i.PCOType AND b.PCO=i.PCO
WHERE i.SubCO IS NOT NULL AND i.PCO IS NOT NULL AND i.SL IS NOT NULL
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord c WHERE c.RecTableName='PMSubcontractCO' AND c.RECID=a.KeyID
				AND c.LinkTableName='PMOP' AND c.LINKID=b.KeyID)
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord d WHERE d.RecTableName='PMOP' AND d.RECID=b.KeyID
				AND d.LinkTableName='PMSubcontractCO' AND d.LINKID=a.KeyID)

---- ACO and SubCO
INSERT INTO dbo.vPMRelateRecord(RecTableName, RECID, LinkTableName, LINKID)
SELECT 'PMSubcontractCO', a.KeyID, 'PMOH', b.KeyID
FROM inserted i
INNER JOIN dbo.vPMSubcontractCO a ON a.SLCo=i.SLCo AND a.SL=i.SL AND a.SubCO=i.SubCO
INNER JOIN dbo.bPMOH b ON b.PMCo=i.PMCo AND b.Project=i.Project AND b.ACO=i.ACO
WHERE i.SubCO IS NOT NULL AND i.ACO IS NOT NULL AND i.SL IS NOT NULL
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord c WHERE c.RecTableName='PMSubcontractCO' AND c.RECID=a.KeyID
				AND c.LinkTableName='PMOH' AND c.LINKID=b.KeyID)
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord d WHERE d.RecTableName='PMOH' AND d.RECID=b.KeyID
				AND d.LinkTableName='PMSubcontractCO' AND d.LINKID=a.KeyID)

---- PCO and SL
INSERT INTO dbo.vPMRelateRecord(RecTableName, RECID, LinkTableName, LINKID)
SELECT 'PMOP', a.KeyID, 'SLHD', b.KeyID
FROM inserted i
INNER JOIN dbo.bPMOP a ON a.PMCo=i.PMCo AND a.Project=i.Project AND a.PCOType=i.PCOType AND a.PCO=i.PCO
INNER JOIN dbo.bSLHD b ON b.SLCo=i.SLCo AND b.SL=i.SL
WHERE i.SL IS NOT NULL AND i.PCO IS NOT NULL
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord c WHERE c.RecTableName='PMOP' AND c.RECID=a.KeyID
				AND c.LinkTableName='SLHD' AND c.LINKID=b.KeyID)
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord d WHERE d.RecTableName='SLHD' AND d.RECID=b.KeyID
				AND d.LinkTableName='PMOP' AND d.LINKID=a.KeyID)

---- ACO and SL
INSERT INTO dbo.vPMRelateRecord(RecTableName, RECID, LinkTableName, LINKID)
SELECT 'PMOH', a.KeyID, 'SLHD', b.KeyID
FROM inserted i
INNER JOIN dbo.bPMOH a ON a.PMCo=i.PMCo AND a.Project=i.Project AND a.ACO=i.ACO
INNER JOIN dbo.bSLHD b ON b.SLCo=i.SLCo AND b.SL=i.SL
WHERE i.SL IS NOT NULL AND i.ACO IS NOT NULL
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord c WHERE c.RecTableName='PMOH' AND c.RECID=a.KeyID
				AND c.LinkTableName='SLHD' AND c.LINKID=b.KeyID)
AND NOT EXISTS(SELECT 1 FROM dbo.vPMRelateRecord d WHERE d.RecTableName='SLHD' AND d.RECID=b.KeyID
				AND d.LinkTableName='PMOH' AND d.LINKID=a.KeyID)



-- Audit inserts
insert into bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
select 'bPMSL','PMCo: ' + isnull(convert(char(3),i.PMCo), '') + ' Project: ' + isnull(i.Project,'')
		+ ' Seq: ' + isnull(convert(varchar(10),i.Seq),'') + ' Phase: ' + isnull(i.Phase,'')
		+ ' CostType: ' + isnull(convert(varchar(3),i.CostType),''), i.PMCo, 'A', NULL, NULL, NULL, getdate(), SUSER_SNAME()
from inserted i join bPMCO c on c.PMCo = i.PMCo
where i.PMCo = c.PMCo and c.AuditPMSL = 'Y'


return


error:
	select @errmsg = isnull(@errmsg,'') + ' - cannot insert into PMSL'
	RAISERROR(@errmsg, 11, -1);
	rollback transaction





GO
PRINT N'Altering trigger [dbo].[btPMOLi] on [dbo].[bPMOL]'
GO



/****** Object:  Trigger dbo.btPMOLi    Script Date: 8/28/99 9:37:57 AM ******/
ALTER  trigger [dbo].[btPMOLi] on [dbo].[bPMOL] for INSERT as
/*--------------------------------------------------------------
*  Insert trigger for PMOL
*  Created By: JRE  5/11/98
*  Modified By: LM  9/29/98
*               GF  1/20/2000 - Use Retg % from JCCI as default if adding PMSL
*               GF 06/29/2001 - Re-wrote trigger - did not work for bulk inserts.
*				GF 04/01/2002 - Changed insert PMSL to get sequence first.
*				GF 10/09/2002 - changed dbl quotes to single quotes
*				GF 02/29/2008 - issue #127195 #127210 changed to use vspPMOACalcs
*				GF 01/25/2009 - issue #131843 do not add to PMSL if units=0, amount<>0, um<>'LS'
*				GF 01/30/2009 - issue #129669 add-on proportional cost distributions
*				GF 03/20/2009 - issue #132108 addons and markups not initialize for internal
*				GF 05/29/2009 - issue #133843 problem with external CO and markups not being set
*				GF 07/22/2009 - issue #129667 add material options with estimates
*				GF 08/31/2009 - issue #135377 missing fetch next when cursor created.
*				GF 06/29/2010 - issue #140152 material records in PMMF being created for all cost types. ANSI?
*				JG 02/17/2011 - V1# B-02366 copy vendor, sl/po, purchase amount to SL
*				GP 02/22/2011 - set purchase amount to 0 if null, was causing multiple NULL unit cost insert errors
*				DAN SO 03/16/2011 - V1# B-02356 - update SCO with PCOType/PCO/PCOItem
*				GP 03/23/2011 - fixed cursor fetch error, columns missing at final fetch
*				GF 03/25/2011 - TK-03354
*				JG 05/02/2011 - TK-04820 - Added Material Code when creating PMMF record
*				GF 05/07/2011 - TK-04937 re-write the PMMF-PMSL insert for assigning to PCO/ACO
*				GF 05/24/2011 - TK-05347 ready for accounting flag
*				GF 06/18/2011 - TK-06041 update PMSL/PMMF with purchase columns
*				GP 06/22/2011 - TK-06208 Added checks for @ImpactSL and @ImpactPO before inserting to PMSL and PMMF
*				DAN SO 06/24/2011 - TK-06237 - fixing PCO Copy error
*				DAN SO 6/27/2011 - TK-06210 - fixed bPMOL_insert does not exist error
*				GF 07/20/2011 - TK-06890 missed wrapping values with is null when inserting PMSL/PMMF records
*				GP 7/27/2011 - TK-07144 changed bPO to varchar(30)
*				GP 8/8/2011	- TK-07549 removed check for @ecm = 'C' in beginning of insert_check
*				GF 11/23/2011 - TK-10530 CI#145135
*				GF 02/10/2012 TK-12465 #145746 do not try to assign to existing PMSL record
*				GF 03/02/2012 TK-12995 #146001
*               JayR 10/15/2012 TK-16099 Fix overlapping variables.
*				ScottP 01/11/2013 TK-20713 Fix mismatch with Select and Fetch with ECM field
*				AJW 03/13/2013 TFS 43659 - support new check box for creating a new SL
*
*
*  Calculates pending amount for PMOI
*--------------------------------------------------------------*/
declare @numrows int, @rcode int, @errmsg varchar(255), @opencursor tinyint,
		@validcnt INT, @validcnt2 INT, @validcnt3 INT,
		@pmco bCompany, @project bJob, @pcotype bDocType, @pco bPCO, @pcoitem bPCOItem, @aco bACO,
		@acoitem bACOItem, @phasegroup bGroup, @phase bPhase, @costtype bJCCType, @estunits bUnits,
		@um bUM, @esthours bHrs, @unitcost bUnitCost, @ecm bECM, @estcost bDollar, @apco bCompany,
		@slcosttype bJCCType, @dfltwcpct bPct, @retcode int, @seq int, @mtlcosttype bJCCType,
		---- B-02366 B-02356 TK-03354 JG0502 TK-04937
		@VendorGroup bGroup, @vendor bVendor, @po varchar(30), @sl VARCHAR(30),
		@PurchaseAmount bDollar, @SubCO smallint, @SubCOSeq INT, @POSLItem bItem,
		@SLItemType TINYINT, @MatlCode bMatl, @POCONum SMALLINT, @POCONumSeq INT,
		@PMMF_POCONum SMALLINT, @PMMF_POCONumSeq INT, @KeyID BIGINT, @PMMF_KeyID BIGINT,
		@POIT_KeyID BIGINT, @Next_Seq INT, @DfltVendorGroup bGroup, @PMSL_SubCO SMALLINT,
		@PMSL_SubCOSeq INT, @PMSL_KeyID BIGINT, @SLIT_KeyID BIGINT, @UseMatlPhaseDesc CHAR(1),
		---- TK-06041
		@UsePhaseDesc CHAR(1), @PhaseDesc bItemDesc, @MaterialCode bMatl,
		@PurchaseUnits bUnits, @PurchaseUM bUM, @PurchaseUnitCost bUnitCost,
		@MaterialGroup bGroup, @ImpactSL bYN, @ImpactPO bYN,
		-- TFS 43659
		@CreateSL bYN

select @numrows = @@rowcount
if @numrows = 0 return
set nocount on

SET @rcode = 0
SET @opencursor = 0

------ if assigned to PO must have POItem
--SELECT @validcnt = COUNT(*) FROM inserted WHERE PO IS NOT NULL AND POSLItem IS NULL
--IF @validcnt <> 0
--	BEGIN
--	SET @errmsg = 'Missing PO Item'
--	GOTO error
--	END

------ if assigned to subcontract must have slItem
--SELECT @validcnt = COUNT(*) FROM inserted WHERE Subcontract IS NOT NULL AND POSLItem IS NULL
--IF @validcnt <> 0
--	BEGIN
--	SET @errmsg = 'Missing SL Item'
--	GOTO error
--	END

---- Validate Vendor
--SELECT @validcnt = count(*) from dbo.bAPVM r
--		JOIN inserted i ON i.VendorGroup = r.VendorGroup and i.Vendor = r.Vendor
--SELECT @validcnt2 = count(*) from inserted i where i.Vendor is null
--if @validcnt + @validcnt2 <> @numrows
--	BEGIN
--	SELECT @errmsg = 'Vendor is Invalid'
--	goto error
--	END

---- if assigned to a SL the VendorGroup/Vendor must match SL
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bPMCO c ON c.PMCo=i.PMCo
LEFT JOIN dbo.bSLHD h ON h.SLCo=c.APCo AND h.SL=i.Subcontract AND h.VendorGroup=i.VendorGroup AND h.Vendor=i.Vendor
WHERE i.Subcontract IS NOT NULL
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.Subcontract IS NULL
if @validcnt + @validcnt2 <> @numrows
	BEGIN
	SELECT @errmsg = 'Vendor is Invalid for Subcontract'
	goto error
	END

---- if assigned to a PO the VendorGroup/Vendor must match PO
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bPMCO c ON c.PMCo=i.PMCo
JOIN dbo.bPOHD h ON h.POCo=c.APCo AND h.PO=i.PO AND h.VendorGroup=i.VendorGroup AND h.Vendor=i.Vendor
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.PO IS NULL
if @validcnt + @validcnt2 <> @numrows
	BEGIN
	SELECT @errmsg = 'Vendor is Invalid for Purchase Order'
	goto error
	END

---- validate ACO change order item
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bPMOI o ON i.PMCo=o.PMCo AND i.Project=o.Project AND i.ACO=o.ACO AND i.ACOItem=o.ACOItem
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.ACOItem IS NULL
if @validcnt + @validcnt2 <> @numrows
	begin
	select @errmsg = 'Approved Change Order Item is Invalid'
	goto error
	end

---- validate PCO change order item
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bPMOI o ON i.PMCo=o.PMCo AND i.Project=o.Project AND i.PCOType=o.PCOType AND i.PCO=o.PCO AND i.PCOItem=o.PCOItem
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.PCOItem IS NULL
if @validcnt + @validcnt2 <> @numrows
	begin
	select @errmsg = 'Pending Change Order Item is Invalid'
	goto error
	end

---- validate not posting soft-closed job with JCCO flag
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bJCJM j ON j.JCCo=i.PMCo AND j.Job=i.Project
JOIN dbo.bJCCO c ON c.JCCo=i.PMCo
WHERE i.PMCo=j.JCCo and i.Project=j.Job and i.PMCo=c.JCCo
AND ((c.PostSoftClosedJobs = 'N' and j.JobStatus = 2)
OR   (c.PostClosedJobs = 'N' AND j.JobStatus = 3))
IF @validcnt <> 0
	BEGIN
	SELECT @errmsg = 'Cannot Post to Soft-Closed or Hard-Closed Job'
	goto error
	END


---- create cursor for PMOL inserted rows TK-04937
if @numrows = 1
	BEGIN
	select @pmco=PMCo, @project=Project, @pcotype=PCOType, @pco=PCO, @pcoitem=PCOItem, @aco=ACO,
			@acoitem=ACOItem, @phasegroup=PhaseGroup, @phase=Phase, @costtype=CostType,
			@estunits=EstUnits, @um=UM, @esthours=EstHours, @unitcost=UnitCost, @ecm=ECM,
			@estcost=EstCost,
			----TK-04971
			@VendorGroup=VendorGroup, @vendor=Vendor, @po=PO, @sl=Subcontract, @POSLItem=POSLItem,
			@PurchaseAmount=PurchaseAmt, @SubCO=SubCO, @SubCOSeq=SubCOSeq,
			---- TK-06041
			@POCONum=POCONum, @POCONumSeq=POCONumSeq, @KeyID=KeyID, @MaterialCode=MaterialCode,
			@PurchaseUnits=PurchaseUnits, @PurchaseUM=PurchaseUM, @PurchaseUnitCost=PurchaseUnitCost,
			@CreateSL=CreateSL
	from inserted
	
	END
else
   begin
   -- use a cursor to process each inserted row
   declare bPMOL_insert cursor LOCAL FAST_FORWARD
   for select PMCo, Project, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup, Phase, CostType,
              EstUnits, UM, EstHours, UnitCost, ECM, EstCost,
              ----TK-04971
              VendorGroup, Vendor, PO, Subcontract, POSLItem,
              PurchaseAmt, SubCO, SubCOSeq, POCONum, POCONumSeq, KeyID,
              ---- TK-06041
              MaterialCode, PurchaseUnits, PurchaseUM, PurchaseUnitCost,
			  CreateSL
   from inserted

   open bPMOL_insert
   set @opencursor=1
   
   ---- #135377
   fetch next from bPMOL_insert into @pmco, @project, @pcotype, @pco, @pcoitem, @aco, @acoitem, 
				@phasegroup, @phase, @costtype, @estunits, @um, @esthours, @unitcost, @ecm, @estcost,
				----TK-04971
				@VendorGroup, @vendor, @po, @sl, @POSLItem, @PurchaseAmount, @SubCO, @SubCOSeq,
				@POCONum, @POCONumSeq, @KeyID,
				---- TK-06041
				@MaterialCode, @PurchaseUnits, @PurchaseUM, @PurchaseUnitCost,@CreateSL
	if @@fetch_status <> 0
		begin
		select @errmsg = 'Cursor error'
		goto error
		end
   end
----TK-04937

insert_check:

---- get subcontract cost type and material cost type from PMCO
select @apco=p.APCo, @slcosttype=p.SLCostType, @mtlcosttype=p.MtlCostType,
		@DfltVendorGroup=a.VendorGroup, @UsePhaseDesc=PhaseDescYN,
		@UseMatlPhaseDesc=MatlPhaseDesc, @MaterialGroup=h.MatlGroup
FROM dbo.bPMCO p
INNER join dbo.bHQCO h on h.HQCo = p.PMCo
INNER join dbo.bHQCO a on a.HQCo = p.APCo -- TK-06237 --
where PMCo=@pmco

---- set Vendor Group to default if null
IF @VendorGroup IS NULL SET @VendorGroup = @DfltVendorGroup

---- TK-00000
IF ISNULL(@um,'') = '' SET @um = 'LS'

---- insert markups if a PCO
if isnull(@pcotype,'') <> '' and isnull(@pco,'') <> '' and isnull(@pcoitem,'') <> ''
	begin
	-- insert markups
	insert into dbo.bPMOM(PMCo,Project,PCOType,PCO,PCOItem,PhaseGroup,CostType,IntMarkUp,ConMarkUp)
	select distinct PMOL.PMCo, PMOL.Project, PMOL.PCOType, PMOL.PCO, PMOL.PCOItem,
				PMOL.PhaseGroup, PMOL.CostType, 0,
				---- 133843
				case when isnull(h.IntExt,'E') = 'E' then isnull(PMPC.Markup,0)
					 when isnull(t.InitAddons,'Y') = 'Y' then IsNull(PMPC.Markup,0)
					 else 0 end
	from dbo.bPMOL PMOL with (nolock)
	----#132046
	join dbo.bPMOP h with (nolock) on h.PMCo=@pmco and h.Project=@project and h.PCOType=@pcotype and h.PCO=@pco
	JOIN dbo.bPMDT t with (nolock) on t.DocType=h.PCOType
	left join dbo.bPMOM PMOM on PMOM.PMCo=PMOL.PMCo and PMOM.Project=PMOL.Project
		and PMOM.PCOType=PMOL.PCOType and PMOM.PCO=PMOL.PCO and PMOM.PCOItem=PMOL.PCOItem
		and PMOM.PhaseGroup=PMOL.PhaseGroup and PMOM.CostType=PMOL.CostType
	left join bPMPC PMPC on PMPC.PMCo=PMOL.PMCo and PMPC.Project=PMOL.Project
		and PMPC.PhaseGroup=PMOL.PhaseGroup and PMPC.CostType=PMOL.CostType
	where PMOL.PMCo=@pmco and PMOL.Project=@project and PMOL.PCOType=@pcotype and PMOL.PCO=@pco
	and PMOM.PMCo is null

	---- calculate pending amount
	exec @rcode = dbo.vspPMOACalcs @pmco, @project, @pcotype, @pco, @pcoitem
	end

----TK-04937
---- first check to see if the PMOL record added is assigned to a SL and SLITEM
---- if so see if an 'O' PMSL record exists that match the key fields. When one is
---- found, then assign PMOL record to that PMSL record and change the type to 'C' in PMSL.
---- then update the SubCO and SubCOSeq in PMOL. You cannot rely on the PCO, PCOItem
---- being assigned in PMSL. If entered directly from SCO, then was not initially setup
---- as from a change order
IF @sl IS NOT NULL AND @POSLItem IS NOT NULL
	BEGIN
	----IF @SubCO IS NULL
	----	BEGIN
	----	---- check for one PMSL record
	----	SET @PMSL_SubCO = NULL
	----	SET @PMSL_SubCOSeq = NULL
	----	SET @PMSL_KeyID = NULL
	----	SELECT TOP 1 @PMSL_SubCO=s.SubCO, @PMSL_SubCOSeq=s.Seq, @PMSL_KeyID=s.KeyID
	----	FROM dbo.bPMSL s WHERE s.PMCo=@pmco AND s.Project=@project AND s.RecordType='O'
	----			AND s.SL=@sl AND s.SLItem=@POSLItem AND s.Phase=@phase AND s.CostType=@costtype
	----			AND s.PCOItem IS NULL AND s.ACOItem IS NULL AND s.InterfaceDate IS NULL
	----			----TK-00000 SCO must not be approved
	----			AND NOT EXISTS(SELECT 1 FROM dbo.vPMSubcontractCO h WHERE h.SLCo=s.SLCo AND h.SL=s.SL AND h.SubCO=s.SubCO AND h.ReadyForAcctg = 'Y')
	----	IF @PMSL_KeyID IS NOT NULL
	----		BEGIN
	----		---- update the one record with PMOL info
	----		UPDATE dbo.bPMSL SET RecordType='C', PCOType=@pcotype, PCO=@pco, PCOItem=@pcoitem,
	----							 ACO=@aco, ACOItem=@acoitem,
	----							 ----TK-06041 -- TK-06237 --
	----							 UM=ISNULL(@PurchaseUM,@um), 
	----							 Units=ISNULL(@PurchaseUnits,0), 
	----							 UnitCost=ISNULL(@PurchaseUnitCost,0),
	----							 Amount=ISNULL(@PurchaseAmount,0)		  
	----		WHERE KeyID = @PMSL_KeyID	
			
	----		---- update the SubCO and SubCOSeq to the current PMOL record
	----		UPDATE dbo.bPMOL SET SubCO=@PMSL_SubCO, SubCOSeq=@PMSL_SubCOSeq
	----		WHERE KeyID = @KeyID
	----			AND SubCO <> @PMSL_SubCO
			
	----		---- done move to next row
	----		GOTO NEXTROW
	----		END 
	----	END
	----ELSE
	----	BEGIN
		-------------
		-- B-02356 --
		-------------
		IF @SubCO IS NOT NULL AND @SubCOSeq IS NOT NULL
			BEGIN
			---- validate record really exists in PMSL
			SET @PMSL_KeyID = NULL
			SELECT @PMSL_KeyID = KeyID
			FROM dbo.bPMSL WHERE PMCo=@pmco AND Project=@project
					AND PhaseGroup=@phasegroup AND Phase=@phase
					AND CostType=@costtype AND SubCO=@SubCO
					AND Seq=@SubCOSeq AND InterfaceDate IS NULL
			---- update PMSL
			IF @PMSL_KeyID IS NOT NULL
				BEGIN
				UPDATE dbo.bPMSL
						SET RecordType = 'C',
							PCOType = @pcotype, PCO = @pco,
							PCOItem = @pcoitem, ACO = @aco,
							ACOItem = @acoitem,
							----TK-06041 -- TK-06237 --
							UM=ISNULL(@PurchaseUM,@um),
							Units=ISNULL(@PurchaseUnits,0), 
							----TK-12995
							UnitCost = CASE WHEN ISNULL(@PurchaseUM,@um) = 'LS' THEN 0 ELSE ISNULL(@PurchaseUnitCost,0) END,
							Amount=ISNULL(@PurchaseAmount,0)
				WHERE KeyID=@PMSL_KeyID	
				END
			
			---- DONE move to next row
			GOTO NEXTROW
			END
		----END
	END

----TK-04937
---- first check to see if the PMOL record added is assigned to a PO and POITEM
---- if so see if an 'O' PMMF record exists that match the key fields. When one is
---- found, then assign PMOL record to that PMMF record and change the type to 'C' in PMMF.
---- then update the POCONum and POCONumSeq in PMOL. You cannot rely on the PCO, PCOItem
---- being assigned in PMMF. If entered directly from POCO, then was not initially setup
---- as from a change order
IF @po IS NOT NULL AND @POSLItem IS NOT NULL
	BEGIN
	----IF @POCONum IS NULL
	----	BEGIN
	----	---- check for one PMMF original record
	----	SET @PMMF_POCONum = NULL
	----	SET @PMMF_POCONumSeq = NULL
	----	SET @PMMF_KeyID = NULL
	----	SELECT TOP 1 @PMMF_POCONum=m.POCONum, @PMMF_POCONumSeq=m.Seq, @PMMF_KeyID=m.KeyID
	----	FROM dbo.bPMMF m WHERE m.PMCo=@pmco AND m.Project=@project AND m.RecordType='O'
	----			AND m.PO=@po AND m.POItem=@POSLItem AND m.Phase=@phase AND m.CostType=@costtype
	----			AND m.PCOItem IS NULL AND m.ACOItem IS NULL AND m.InterfaceDate IS NULL
	----			AND m.MaterialOption = 'P'
	----			----TK-00000 SCO must not be approved
	----			AND NOT EXISTS(SELECT 1 FROM dbo.vPMPOCO h WHERE h.POCo=m.POCo AND h.PO=m.PO AND h.POCONum=m.POCONum AND h.ReadyForAcctg = 'Y')		
				
	----	IF @PMMF_KeyID IS NOT NULL
	----		BEGIN

	----		---- update the one record with PMOL info
	----		UPDATE dbo.bPMMF SET RecordType='C', PCOType=@pcotype, PCO=@pco, PCOItem=@pcoitem,
	----							 ACO=@aco, ACOItem=@acoitem,
	----							 ----TK-06041
	----							 MaterialGroup=@MaterialGroup,
	----							 MaterialCode=@MaterialCode,
	----							  -- TK-06237 --
	----							 UM=ISNULL(@PurchaseUM,@um), 
	----							 Units=ISNULL(@PurchaseUnits,0), 
	----							 UnitCost=ISNULL(@PurchaseUnitCost,0),
	----							 Amount=ISNULL(@PurchaseAmount,0),
	----							 ECM=@ECM
	----		WHERE KeyID = @PMMF_KeyID	

	----		---- update the POCONum and POCONumSeq to the current PMOL record
	----		UPDATE dbo.bPMOL SET POCONum=@PMMF_POCONum, POCONumSeq=@PMMF_POCONumSeq
	----		WHERE KeyID = @KeyID AND POCONum <> @PMMF_POCONum
	----		---- done move to next row
	----		GOTO NEXTROW
	----		END 
	----	END
	----ELSE
	----	BEGIN
		IF @POCONum IS NOT NULL AND @POCONumSeq IS NOT NULL
			BEGIN
			---- validate record really exists in PMMF
			SET @PMMF_KeyID = NULL
			SELECT @PMMF_KeyID = KeyID
			FROM dbo.bPMMF WHERE PMCo=@pmco AND Project=@project
					AND PhaseGroup=@phasegroup AND Phase=@phase
					AND CostType=@costtype AND POCONum=@POCONum
					AND Seq=@POCONumSeq AND InterfaceDate IS NULL
			---- update PMMF
			IF @PMMF_KeyID IS NOT NULL
				BEGIN
				UPDATE dbo.bPMMF
						SET RecordType = 'C',
							PCOType = @pcotype, PCO = @pco,
							PCOItem = @pcoitem, ACO = @aco,
							ACOItem = @acoitem,
							----TK-06041
							MaterialGroup=@MaterialGroup,
							MaterialCode=@MaterialCode,
							-- TK-06237 --
							UM=ISNULL(@PurchaseUM,@um), 
							Units=ISNULL(@PurchaseUnits,0),
							----TK-12995
							UnitCost = CASE WHEN ISNULL(@PurchaseUM,@um) = 'LS' THEN 0 ELSE ISNULL(@PurchaseUnitCost,0) END,
							Amount=ISNULL(@PurchaseAmount,0)
				WHERE KeyID=@PMMF_KeyID	
				END
			
			---- DONE move to next row
			GOTO NEXTROW
			END
		--END
	END

---- if the cost type is not the subcontract cost type
---- or not the material cost type then add records based on PM Company parameters

IF @costtype NOT IN (ISNULL(@slcosttype,0), ISNULL(@mtlcosttype,0))
	BEGIN
   -- execute procedure to add JCCH records based on PM Company parameters
	exec @retcode = dbo.bspPMSubOrMatlChgAdd @pmco, @project, @phasegroup, @phase, @costtype,
						@estunits, @um, @unitcost, @estcost, @pcotype, @pco, @pcoitem, @aco,
						@acoitem, @vendor, NULL, @sl, @POSLItem, @PurchaseAmount, @errmsg output
	END

---- if not the subcontract cost type goto material check
if @costtype <> isnull(@slcosttype,0) goto PMMF_CHECK

---- check if PMSL record exists for phase and cost type
if exists (select 1 from dbo.bPMSL with (nolock) where PMCo=@pmco and Project=@project 
		and isnull(PCOType,'') = isnull(@pcotype,'') and isnull(PCO,'') = isnull(@pco,'') 
		and isnull(PCOItem,'') = isnull(@pcoitem,'') and isnull(ACO,'') = isnull(@aco,'') 
		and isnull(ACOItem,'') = isnull(@acoitem,'') and PhaseGroup=@phasegroup 
		and Phase=@phase and CostType=@costtype)
	BEGIN
	
	goto PMMF_CHECK
	END
else
	BEGIN
	----TK-06041 do we have purchase values to insert?? must be PCO side only
	IF @acoitem IS NULL AND @PurchaseUnits = 0 AND @PurchaseAmount = 0 AND @PurchaseUM IS NULL GOTO PMMF_CHECK

	---- get default retg pct from JCCI to use as a default
	select @dfltwcpct = isnull(i.RetainPCT,0), @PhaseDesc=p.Description
	from dbo.bJCJP p 
	join dbo.bJCCI i on i.JCCo = p.JCCo and i.Contract = p.Contract and i.Item = p.Item
	where p.JCCo=@pmco and p.Job=@project and p.PhaseGroup=@phasegroup and p.Phase=@phase

	---- Set unit cost to the purchase amount price
	IF @estunits <> 0
		BEGIN
		SELECT @unitcost = @estcost/@estunits
		END
	ELSE
		BEGIN
		SET @unitcost = 0
		END

	---- set units and unit cost to zero if UM = 'LS'
	IF @um IS NULL SET @um = 'LS'
	if @um = 'LS'
		begin
		select @estunits = 0, @unitcost = 0
		end

	--TK-06208 - Get Impact Type SL from PCO Header
	select @ImpactSL = SubType from dbo.bPMOP where PMCo = @pmco and Project = @project and PCOType = @pcotype and PCO = @pco

	----TK-06041 do old method if adding phase cost type detail from the ACO item
	IF @acoitem IS NOT NULL
		BEGIN
   		---- #131843 if units = 0, amount <> 0, and @um <> 'LS' then we do not want to add
		if isnull(@estunits,0) = 0 and isnull(@estcost,0) <> 0 and isnull(@um,'LS') <> 'LS'
			begin
			goto PMMF_CHECK
			END
		ELSE
			BEGIN
			insert dbo.bPMSL (PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup,
					Phase, CostType, SLCo, SLItemType, Units, UM, UnitCost, Amount, SendFlag, WCRetgPct, SMRetgPct)
			select @pmco, @project, isnull(max(bPMSL.Seq),0) + 1, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem,
					@phasegroup, @phase, @costtype, @apco, case when @CreateSL = 'Y' then 1 else 2 end,
					----TK-06890
					ISNULL(@estunits,0),
					@um,
					ISNULL(@unitcost,0), 
					ISNULL(@estcost,0),
					'Y', @dfltwcpct, @dfltwcpct
			from dbo.bPMSL where PMCo=@pmco and Project=@project
			END
		------ if FROM pco CHECK THE SL Impact flag
		--if @ImpactSL = 'Y'
		--	begin
		--	---- insert PMSL
		--	insert dbo.bPMSL (PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup,
		--			Phase, CostType, SLCo, SLItemType, Units, UM, UnitCost, Amount, SendFlag, WCRetgPct, SMRetgPct)
		--	select @pmco, @project, isnull(max(bPMSL.Seq),0) + 1, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem,
		--			@phasegroup, @phase, @costtype, @apco, 2, @estunits, @um, @unitcost, @estcost, 'Y',
		--			@dfltwcpct, @dfltwcpct
		--	from bPMSL where PMCo=@pmco and Project=@project
		--	END
			
		---- done goto to next row
		GOTO PMMF_CHECK
		END
			
	---- #131843 if units = 0, amount <> 0, and @um <> 'LS' then we do not want to add
	if isnull(@PurchaseUnits, 0) = 0 and isnull(@PurchaseAmount, 0) <> 0 and isnull(@PurchaseUM,'LS') <> 'LS'
		begin
		goto PMMF_CHECK
		end
	else if @ImpactSL = 'Y'
		BEGIN
		---- V1# B-02366
		---- first get next sequence
		SELECT @Next_Seq = ISNULL(MAX(Seq),0) + 1 FROM dbo.bPMSL WHERE PMCo=@pmco AND Project=@project
		---- insert PMSL with no sl info
		IF @sl IS NULL OR @POSLItem IS NULL
			BEGIN
			insert dbo.bPMSL (PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem,
					PhaseGroup, Phase, CostType, SLCo, SLItemType, Units, UM, UnitCost, Amount,
					SendFlag, WCRetgPct, SMRetgPct, VendorGroup, Vendor, SLItemDescription)
			select @pmco, @project, @Next_Seq, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem,
					@phasegroup, @phase, @costtype, @apco, case when @CreateSL = 'Y' then 1 else 2 end,
					----TK-06041 TK-06237 --
					ISNULL(@PurchaseUnits,0), 
					ISNULL(@PurchaseUM, 'LS'),
					----TK-12995
					CASE WHEN ISNULL(@PurchaseUM,@um) = 'LS' THEN 0 ELSE ISNULL(@PurchaseUnitCost,0) END, 
					ISNULL(@PurchaseAmount,0),
					'Y', @dfltwcpct, @dfltwcpct, @VendorGroup, @vendor,
					case when isnull(@UsePhaseDesc, 'N') = 'Y' then @PhaseDesc else NULL END
			END
		ELSE
			BEGIN
			---- check for existance in SLIT and join to SLIT for item values
			SET @SLIT_KeyID = NULL
			SELECT @SLIT_KeyID = KeyID
			FROM dbo.bSLIT WHERE SLCo=@apco AND SL=@sl AND SLItem=@POSLItem
			IF @SLIT_KeyID IS NOT NULL
				BEGIN				
				INSERT dbo.bPMSL (PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup,
						Phase, CostType, SLCo, SLItemType, Units, UM, UnitCost, Amount, SendFlag, WCRetgPct, SMRetgPct,
						VendorGroup, Vendor, SL, SLItem, TaxGroup, TaxType, TaxCode, SLItemDescription)
				SELECT @pmco, @project, @Next_Seq, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem, @phasegroup,
						@phase, @costtype, @apco, i.ItemType,
						----TK-06041 TK-06890
						ISNULL(@PurchaseUnits,0), i.UM,
						CASE WHEN i.UM = 'LS' THEN 0 ELSE i.CurUnitCost END,
						ISNULL(@PurchaseAmount,0), 'Y', i.WCRetPct, i.SMRetPct,
						@VendorGroup, @vendor, i.SL, i.SLItem, i.TaxGroup, i.TaxType, i.TaxCode,
						case when isnull(@UsePhaseDesc, 'N') = 'Y' then @PhaseDesc else NULL END
				FROM dbo.bSLIT i WHERE i.KeyID = @SLIT_KeyID AND i.ItemType IN (1,2)
				END
			ELSE
				BEGIN
				insert dbo.bPMSL (PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem,
						PhaseGroup, Phase, CostType, SLCo, SLItemType, Units, UM, UnitCost, Amount,
						SendFlag, WCRetgPct, SMRetgPct, VendorGroup, Vendor, SL, SLItem, SLItemDescription)
				select @pmco, @project, @Next_Seq, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem,
						@phasegroup, @phase, @costtype, @apco, case when @CreateSL = 'Y' then 1 else 2 end,
						----TK-06041 -- TK-06237 -- TK-06890
						ISNULL(@PurchaseUnits,0),
						ISNULL(@PurchaseUM, 'LS'),
						----TK-12995
						CASE WHEN ISNULL(@PurchaseUM,@um) = 'LS' THEN 0 ELSE ISNULL(@PurchaseUnitCost,0) END,
						ISNULL(@PurchaseAmount,0),
						'Y', @dfltwcpct, @dfltwcpct, @VendorGroup, @vendor, @sl, @POSLItem,
						case when isnull(@UsePhaseDesc, 'N') = 'Y' then @PhaseDesc else NULL END
				END
			END
		END
	END


---- purchase order and material cost type
PMMF_CHECK:

---- done if not material cost type #140152
if @costtype <> isnull(@mtlcosttype,0) goto NEXTROW

---- check if PMMF record exists for phase and cost type
if exists (select 1 from dbo.bPMMF with (nolock) where PMCo=@pmco and Project=@project 
		and isnull(PCOType,'') = isnull(@pcotype,'') and isnull(PCO,'') = isnull(@pco,'') 
		and isnull(PCOItem,'') = isnull(@pcoitem,'') and isnull(ACO,'') = isnull(@aco,'') 
		and isnull(ACOItem,'') = isnull(@acoitem,'') and PhaseGroup=@phasegroup 
		and Phase=@phase and CostType=@costtype)
	BEGIN
	goto NEXTROW
	END
else
	BEGIN
	
	----TK-06041 do we have purchase values to insert?? must be PCO side only
	IF @acoitem IS NULL AND @PurchaseUnits = 0 AND @PurchaseAmount = 0 AND @PurchaseUM IS NULL AND @MaterialCode IS NULL GOTO NEXTROW
	
	---- get default retg pct from JCCI to use as a default
	select @dfltwcpct = isnull(i.RetainPCT,0)
	from dbo.bJCJP p with (nolock)
	join dbo.bJCCI i with (nolock) on i.JCCo = p.JCCo and i.Contract = p.Contract and i.Item = p.Item
	where p.JCCo=@pmco and p.Job=@project and p.PhaseGroup=@phasegroup and p.Phase=@phase
	
	---- Set unit cost to the purchase amount price
	IF @estunits <> 0
		BEGIN
		SELECT @unitcost = @estcost/@estunits
		END
	ELSE
		BEGIN
		SET @unitcost = 0
		END

	---- set units and unit cost to zero if UM = 'LS'
	IF @um IS NULL SET @um = 'LS'
	if @um = 'LS'
		BEGIN
		select @estunits = 0, @unitcost = 0
		END
	
	--TK-06208 - Get Impact Type SL from PCO Header
	select @ImpactPO = POType from dbo.bPMOP where PMCo = @pmco and Project = @project and PCOType = @pcotype and PCO = @pco	
	
	---- #131843 if units = 0, amount <> 0, and @um <> 'LS' then we do not want to add
	----TK-06041 do old method if adding phase cost type detail from the ACO item
	IF @acoitem IS NOT NULL
		BEGIN
		---- #131843 if units = 0, amount <> 0, and @um <> 'LS' then we do not want to add
		if isnull(@estunits,0) = 0 and isnull(@estcost,0) <> 0 and isnull(@um,'LS') <> 'LS'
			begin
			goto NEXTROW
			end
		else ----if @ImpactPO = 'Y'
			begin
			insert into dbo.bPMMF(PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem, PhaseGroup,
					Phase, CostType, VendorGroup, MaterialOption, POCo, RecvYN, UM, Units, UnitCost,
					ECM, Amount, SendFlag, MaterialGroup)
			select @pmco, @project, isnull(max(bPMMF.Seq),0) + 1, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem, @phasegroup,
					@phase, @costtype, @VendorGroup, 'P', @apco, 'N',
					@um,
					ISNULL(@estunits,0),
					CASE WHEN @um = 'LS' THEN 0 ELSE ISNULL(@unitcost,0) END, 
					'E', ISNULL(@estcost,0), 'Y', @MaterialGroup
			from dbo.bPMMF where PMCo=@pmco and Project=@project
			end
		
		---- done goto to next row
		GOTO NEXTROW
		END
				
	---- adding from the PCO item we need to use the new purchase columns in PMOL to create PMMF
	if isnull(@PurchaseUnits, 0) = 0 and isnull(@PurchaseAmount, 0) <> 0 and isnull(@PurchaseUM,'LS') <> 'LS'
		BEGIN
		goto NEXTROW
		END
	else if @ImpactPO = 'Y'
		BEGIN
		---- first get next sequence
		SELECT @Next_Seq = ISNULL(MAX(Seq),0) + 1 FROM dbo.bPMMF WHERE PMCo=@pmco AND Project=@project
		---- insert PMMF with no PO info
		IF @po IS NULL OR @POSLItem IS NULL
			BEGIN
			insert into dbo.bPMMF(PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem,
					PhaseGroup, Phase, CostType, VendorGroup, MaterialOption, POCo, RecvYN, UM,
					Units, UnitCost, ECM, Amount, MaterialGroup, MaterialCode, SendFlag,
					Vendor, MtlDescription)
			select @pmco, @project, @Next_Seq, 'C', @pcotype, @pco, @pcoitem,
					@aco, @acoitem, @phasegroup, @phase, @costtype, @VendorGroup, 'P', @apco, 'N',
					----TK-06041 -- TK-06237 --
					ISNULL(@PurchaseUM, 'LS'), -- TK-06237 --
					ISNULL(@PurchaseUnits,0),
					CASE WHEN ISNULL(@PurchaseUM, 'LS') = 'LS' THEN 0 ELSE ISNULL(@PurchaseUnitCost,0) END,
					@ecm,
					ISNULL(@PurchaseAmount,0), @MaterialGroup, @MaterialCode, 'Y', @vendor,
					case when @UseMatlPhaseDesc = 'Y' then @PhaseDesc else null END
			END
		ELSE
			BEGIN
			---- check for existance in POIT and join to POIT for item values
			SET @POIT_KeyID = NULL
			SELECT @POIT_KeyID = KeyID
			FROM dbo.bPOIT WHERE POCo=@apco AND PO=@po AND POItem=@POSLItem
			IF @POIT_KeyID IS NOT NULL
				BEGIN
				INSERT INTO dbo.bPMMF(PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem,
						PhaseGroup, Phase, CostType, VendorGroup, MaterialOption, POCo, UM, Units,
						UnitCost, ECM, Amount, SendFlag, Vendor, PO, POItem,
						RecvYN, MaterialCode, MaterialGroup, MtlDescription, TaxGroup, TaxType, TaxCode)
				SELECT @pmco, @project, @Next_Seq, 'C', @pcotype, @pco, @pcoitem, @aco, @acoitem,
						@phasegroup, @phase, @costtype, @VendorGroup, 'P', @apco, i.UM,
						----TK-06041
						ISNULL(@PurchaseUnits,0), i.CurUnitCost, i.CurECM, ISNULL(@PurchaseAmount,0), 'Y',
						@vendor, @po, @POSLItem,
						i.RecvYN, i.Material, i.MatlGroup, i.Description, i.TaxGroup, i.TaxType, i.TaxCode
				from dbo.bPOIT i WHERE i.KeyID = @POIT_KeyID
				END
			ELSE
				BEGIN
				insert into dbo.bPMMF(PMCo, Project, Seq, RecordType, PCOType, PCO, PCOItem, ACO, ACOItem,
						PhaseGroup, Phase, CostType, VendorGroup, MaterialOption, POCo, RecvYN, UM,
						Units, UnitCost, ECM, Amount, MaterialGroup, MaterialCode, SendFlag, 
						Vendor, PO, POItem, MtlDescription)
				select @pmco, @project, @Next_Seq, 'C', @pcotype, @pco, @pcoitem,
						@aco, @acoitem, @phasegroup, @phase, @costtype, @VendorGroup, 'P', @apco, 'N',
						----TK-06041 -- TK-06237 --
						ISNULL(@PurchaseUM, 'LS'), -- TK-06237 --
						ISNULL(@PurchaseUnits,0),
						CASE WHEN ISNULL(@PurchaseUM, 'LS') = 'LS' THEN 0 ELSE ISNULL(@PurchaseUnitCost,0) END,
						@ecm, 
						ISNULL(@PurchaseAmount,0),
						@MaterialGroup, @MaterialCode, 'Y', @vendor, 
						@po, @POSLItem,
						case when @UseMatlPhaseDesc = 'Y' then @PhaseDesc else null END
				END
			END
		END
	END
----TK-04937

	-- TK-06210 - commented out --
   --fetch next from bPMOL_insert into @pmco, @project, @pcotype, @pco, @pcoitem, @aco, @acoitem, 
			--	@phasegroup, @phase, @costtype, @estunits, @um, @esthours, @unitcost, @ecm, @estcost,
			--	----TK-04971
			--	@VendorGroup, @vendor, @po, @sl, @POSLItem, @PurchaseAmount, @SubCO, @SubCOSeq,
			--	@POCONum, @POCONumSeq, @KeyID,
			--	---- TK-06041
			--	@MaterialCode, @PurchaseUnits, @PurchaseUM, @PurchaseUnitCost, @ECM


NEXTROW:

	if @numrows > 1
	   begin
	   fetch next from bPMOL_insert into @pmco, @project, @pcotype, @pco, @pcoitem, @aco, @acoitem, 
				@phasegroup, @phase, @costtype, @estunits, @um, @esthours, @unitcost, @ecm, @estcost,
				----TK-04971
				@VendorGroup, @vendor, @po, @sl, @POSLItem, @PurchaseAmount, @SubCO, @SubCOSeq,
				@POCONum, @POCONumSeq, @KeyID,
				---- TK-06041 & TK-06237 --
				@MaterialCode, @PurchaseUnits, @PurchaseUM, @PurchaseUnitCost,@CreateSL
	   if @@fetch_status = 0 
		goto insert_check
	else
		begin
		close bPMOL_insert
		deallocate bPMOL_insert
		set @opencursor = 0
		end
	end


---- update the ready for accounting flag to 'Y' in PMOH
---- when detail added to an ACO and the Send flag is 'Y'
---- and the ACO ready for accounting flag is 'N' TK-05347
---- GF 11/23/2011 TK-10530 CI#145135
UPDATE dbo.bPMOH SET ReadyForAcctg = 'Y'
FROM inserted i
INNER JOIN dbo.bPMOH h ON h.PMCo=i.PMCo AND h.Project=i.Project AND h.ACO=i.ACO
WHERE i.ACO IS NOT NULL AND h.ReadyForAcctg = 'N' AND i.SendYN = 'Y'




return
   
    --------------------
	-- ERROR HANDLING --
	-------------------- 
   error:

   	if @opencursor = 1
   	    begin
   	    close bPMOL_insert
   	    deallocate bPMOL_insert
   		set @opencursor = 0
   	    end
   
   	select @errmsg = isnull(@errmsg,'') + ' - cannot insert into PMOL!'
       RAISERROR(@errmsg, 11, -1);
       rollback transaction


GO
PRINT N'Altering trigger [dbo].[btPMOLu] on [dbo].[bPMOL]'
GO






/****** Object:  Trigger dbo.btPMOLu    Script Date: 8/28/99 9:37:57 AM ******/
ALTER trigger [dbo].[btPMOLu] on [dbo].[bPMOL] for UPDATE as
/*--------------------------------------------------------------
* Update trigger for PMOL
* Modified By:	GF 06/29/2011 TK-06482 d-02349
*				DAN SO 07/07/2011 - TK-06553 - Added PCOType and PCO to some update statements
*				GP 07/08/2011 - TK-06688 - Added check before nulling out POCONum or SubCOSeq to remove link from PCO, 
*								also added link back when re-added to form
*				GP 7/27/2011 - TK-07144 changed bPO to varchar(30)
*				GF 11/23/2011 - TK-10530 CI#145133
*				GF 02/12/2012 TK-12469 PMOL purchase values may be zero - not allowed in PMSL or PMMF
*				GF 02/12/2012 TK-12381 #145741 get SL Item information for update to PMSL when SL and Item assigned
*				gf 02/20/2012 TK-12469 #145650 when assigning subco or poconum do not update purchase values in PMSL or PMMF
*				GF 03/06/2012 TK-12996 #146016 Sync changes between PCO Item detail and SubCO
*				GF 03/09/2012 TK-13116 #146042 problems with the old vs new values check for update to PMSL/PMMF
*				JayR 03/24/2012 TK-00000 Convert part of this to using constraints
*				GF 06/20/2112 TK-15946 cleanup
*				AJW 03/13/2013 TFS 43659 - support new check box for creating a new SL
*
* Does some standard validation first. Then creates a cursor
* to update PCO information.
*
* 1. check PCO Item markups and add-ons, then calculates pending amount for PMOI.
* 2. we want to sync PMSL record to the changes made in PMOL for purchase info if we can.
* 3. we want to sync PMMF record to the changes made in PMOL for purchase info if we can.
* 
*--------------------------------------------------------------*/
declare @numrows int, @errmsg varchar(255), @rcode int, @opencursor tinyint,
		@validcnt INT, @validcnt2 INT,
   		@PMCo bCompany, @Project bJob, @PCOType bDocType, @PCO bPCO, @PCOItem bPCOItem,
   		@Phase bPhase, @CostType bJCCType, @units bUnits, @um bUM, @unitcost bUnitCost,
   		@amount bDollar, @sendYN bYN, @aco bPCO, @acoitem bPCOItem, @apco bCompany,
   		---- B-02356 TK-04937 TK-04830 TK-04971
   		@VendorGroup bGroup, @Vendor bVendor, @PO varchar(30), @Subcontract VARCHAR(30),
   		@ECM CHAR(1), @PurchaseAmt bDollar, @SubCO smallint, @SubCOSeq INT, @POSLItem bItem,
		@SLItemType TINYINT, @MatlCode bMatl, @POCONum SMALLINT, @POCONumSeq INT,
		@PMMF_POCONum SMALLINT, @PMMF_POCONumSeq INT, @KeyID BIGINT, @PMMF_KeyID BIGINT,
		@POIT_KeyID BIGINT, @Next_Seq INT, @DfltVendorGroup bGroup, @PhaseGroup bGroup,
		---- TK-06122 TK-06482
		@SLType CHAR(1), @POType CHAR(1), @OldPurchaseAmt bDollar, @OldMaterialCode bMatl,
		@OldPurchaseUnits bUnits, @OldPurchaseUM bUM, @OldPurchaseUnitCost bUnitCost,
		@OldPO varchar(30), @OldSubcontract VARCHAR(30), @OldVendor bVendor, @OldPOSLItem bItem,
		@OldSubCO SMALLINT, @OldSubCOSeq INT, @OldPOCONum SMALLINT, @OldPOCONumSeq INT,
		@OldECM CHAR(1), @MaterialCode bMatl, @PurchaseUnits bUnits, @PurchaseUM bUM,
		@PurchaseUnitCost bUnitCost, @PMSLSeq INT, @PMMFSeq INT,
		---- TK-12381
		@WCRetPct bPct, @SMRetPct bPct, @TaxGroup bGroup, @TaxType TINYINT,
		@TaxCode bTaxCode,
		--43659
   		@CreateSL bYN, @OldCreateSL bYN

SET @numrows = @@rowcount
if @numrows = 0 return
set nocount on
   
SET @opencursor = 0
   
---- check for change to primary key
if UPDATE(PMCo)
	begin
	select @errmsg = 'Company is not allowed to be updated'
	goto error
	end

if UPDATE(Project)
	begin
	select @errmsg = 'Company is not allowed to be updated'
	goto error
	end

if UPDATE(PhaseGroup)
	begin
	select @errmsg = 'Phase Group is not allowed to be updated'
	goto error
	end

if UPDATE(Phase)
	begin
	select @errmsg = 'Phase is not allowed to be updated'
	goto error
	end

if UPDATE(CostType)
	begin
	select @errmsg = 'Cost Type is not allowed to be updated'
	goto error
	end

---- JG 06/28/2011 - Rem'd outline
---- skip if updating ECM - project copy, imports
--if UPDATE(ECM) return
	
	
---- if assigned to a SL the VendorGroup/Vendor must match SL
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bPMCO c ON c.PMCo=i.PMCo
LEFT JOIN dbo.bSLHD h ON h.SLCo=c.APCo AND h.SL=i.Subcontract AND h.VendorGroup=i.VendorGroup AND h.Vendor=i.Vendor
WHERE i.Subcontract IS NOT NULL
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.Subcontract IS NULL
if @validcnt + @validcnt2 <> @numrows
	BEGIN
	SELECT @errmsg = 'Vendor is Invalid for Subcontract'
	goto error
	END

---- if assigned to a PO the VendorGroup/Vendor must match PO
SELECT @validcnt = COUNT(*) FROM inserted i
JOIN dbo.bPMCO c ON c.PMCo=i.PMCo
JOIN dbo.bPOHD h ON h.POCo=c.APCo AND h.PO=i.PO AND h.VendorGroup=i.VendorGroup AND h.Vendor=i.Vendor
SELECT @validcnt2 = COUNT(*) FROM inserted i WHERE i.PO IS NULL
if @validcnt + @validcnt2 <> @numrows
	BEGIN
	SELECT @errmsg = 'Vendor is Invalid for Purchase Order'
	goto error
	END




---- declare cursor on insert for updates to PMSL, PMMF, markups, and addons.
if @numrows = 1
	BEGIN
	SELECT @PMCo=i.PMCo, @Project=i.Project, @PCOType=i.PCOType, @PCO=i.PCO, @PCOItem=i.PCOItem,
		   @aco=i.ACO, @acoitem=i.ACOItem, @PhaseGroup=i.PhaseGroup, @Phase=i.Phase,
		   @CostType=i.CostType, @units=i.EstUnits, @um=i.UM, @unitcost=i.UnitCost, 
		   @amount=i.EstCost, @sendYN=i.SendYN, @ECM=i.ECM,
		   ----TK-04971 TK-06122 TK-06482
		   @VendorGroup=i.VendorGroup, @Vendor=i.Vendor, @PO=i.PO, @Subcontract=i.Subcontract,
		   @POSLItem=i.POSLItem, @PurchaseAmt=i.PurchaseAmt, @SubCO=i.SubCO,
		   @SubCOSeq=i.SubCOSeq, @POCONum=i.POCONum, @POCONumSeq=i.POCONumSeq, @KeyID=i.KeyID,
		   @PurchaseUM=i.PurchaseUM, @PurchaseUnitCost=i.PurchaseUnitCost,
		   @PurchaseUnits=i.PurchaseUnits, @MaterialCode=i.MaterialCode,@CreateSL=i.CreateSL, 
		   ----OLD
		   @OldPurchaseAmt=d.PurchaseAmt, @OldMaterialCode=d.MaterialCode,
		   @OldPurchaseUnits=d.PurchaseUnits, @OldPurchaseUM=d.PurchaseUM,
		   @OldPurchaseUnitCost=d.PurchaseUnitCost, @OldPO=d.PO, @OldSubcontract=d.Subcontract,
		   @OldVendor=d.Vendor, @OldPOSLItem=d.POSLItem, @OldSubCO=d.SubCO, @OldSubCOSeq=d.SubCOSeq,
		   @OldPOCONum=d.POCONum, @OldPOCONumSeq=d.POCONumSeq, @OldECM=d.ECM,@OldCreateSL=d.CreateSL

	FROM inserted i
	INNER JOIN deleted d on i.KeyID=d.KeyID
	END
ELSE
	BEGIN
	---- use a cursor to process each updated row
	DECLARE bPMOL_insert cursor LOCAL FAST_FORWARD
		FOR SELECT i.PMCo, i.Project, i.PCOType, i.PCO, i.PCOItem, i.ACO, i.ACOItem,
				   i.PhaseGroup, i.Phase, i.CostType, i.EstUnits, i.UM, i.UnitCost,
				   i.EstCost, i.SendYN, i.ECM,
				   ----TK-04971 TK-06122 TK-06482
				   i.VendorGroup, i.Vendor, i.PO, i.Subcontract, i.POSLItem, i.PurchaseAmt,
				   i.SubCO, i.SubCOSeq, i.POCONum, i.POCONumSeq, i.KeyID,
				   i.PurchaseUM, i.PurchaseUnitCost, i.PurchaseUnits, i.MaterialCode,i.CreateSL,
				   ----OLD
				   d.PurchaseAmt, d.MaterialCode, d.PurchaseUnits, d.PurchaseUM,
				   d.PurchaseUnitCost, d.PO, d.Subcontract, d.Vendor, d.POSLItem,
				   d.SubCO, d.SubCOSeq, d.POCONum, d.POCONumSeq, d.ECM,d.CreateSL
	FROM inserted i
	INNER JOIN deleted d on i.KeyID=d.KeyID

	---- open cursor
   	OPEN bPMOL_insert
   	SET @opencursor = 1
   	
   	FETCH NEXT FROM bPMOL_insert INTO @PMCo, @Project, @PCOType, @PCO, @PCOItem, @aco, @acoitem,
   				@PhaseGroup, @Phase, @CostType, @units, @um, @unitcost,
   				@amount, @sendYN, @ECM,
   				----TK-04971 TK-06122 TK-06482
				@VendorGroup, @Vendor, @PO, @Subcontract, @POSLItem, @PurchaseAmt,
				@SubCO, @SubCOSeq, @POCONum, @POCONumSeq, @KeyID,
				@PurchaseUM, @PurchaseUnitCost, @PurchaseUnits, @MaterialCode,@CreateSL,
				----OLD
			    @OldPurchaseAmt, @OldMaterialCode, @OldPurchaseUnits, @OldPurchaseUM,
			    @OldPurchaseUnitCost, @OldPO, @OldSubcontract, @OldVendor, @OldPOSLItem,
			    @OldSubCO, @OldSubCOSeq, @OldPOCONum, @OldPOCONumSeq, @OldECM,@OldCreateSL
				
   	if @@fetch_status <> 0
   		BEGIN
   		select @errmsg = 'Cursor error'
   		goto error
   		END
   	END



---- process detail row
bPMOL_insert:

---- we only care about PCO side of the line detail, skip if just ACO
IF ISNULL(@PCO,'') = '' GOTO NEXT_ROW

---- from copy or import skip
IF @OldECM = 'C' AND @ECM = 'E' GOTO NEXT_ROW

---- get PM and HQ company information
SELECT @apco=p.APCo, @DfltVendorGroup=h.VendorGroup
FROM dbo.bPMCO p
INNER JOIN dbo.bHQCO h on h.HQCo = p.PMCo
WHERE PMCo=@PMCo

---- if the PCO item exists we need to insert markups and calculate add-ons.
if ISNULL(@PCOItem,'') <> ''
	BEGIN
   	---- Validate PMOI
   	IF NOT EXISTS(SELECT TOP 1 1 FROM dbo.bPMOI WHERE PMCo=@PMCo and Project=@Project 
   					and PCOType=@PCOType and PCO=@PCO and PCOItem=@PCOItem)
		BEGIN
		SELECT @errmsg = 'Change order item ' + ISNULL(RTRIM(@PCOItem),'') + ' not found'
		GOTO error
		END
   
	---- insert markups
	insert into dbo.bPMOM(PMCo,Project,PCOType,PCO,PCOItem,PhaseGroup,CostType,IntMarkUp,ConMarkUp)
	select distinct PMOL.PMCo, PMOL.Project, PMOL.PCOType, PMOL.PCO, PMOL.PCOItem,
			PMOL.PhaseGroup, PMOL.CostType, 0,
			case when isnull(h.IntExt,'E') = 'E' then isnull(PMPC.Markup,0)
				 when isnull(t.InitAddons,'Y') = 'Y' then IsNull(PMPC.Markup,0)
				 else 0 end
	from dbo.bPMOL PMOL with (nolock)
	----#132046
	join dbo.bPMOP h with (nolock) on h.PMCo=@PMCo and h.Project=@Project and h.PCOType=@PCOType and h.PCO=@PCO
	join dbo.bPMDT t with (nolock) on t.DocType=h.PCOType
	left join dbo.bPMOM PMOM on PMOM.PMCo=PMOL.PMCo and PMOM.Project=PMOL.Project
	and PMOM.PCOType=PMOL.PCOType and PMOM.PCO=PMOL.PCO and PMOM.PCOItem=PMOL.PCOItem
	and PMOM.PhaseGroup=PMOL.PhaseGroup and PMOM.CostType=PMOL.CostType
	left join bPMPC PMPC on PMPC.PMCo=PMOL.PMCo and PMPC.Project=PMOL.Project
	and PMPC.PhaseGroup=PMOL.PhaseGroup and PMPC.CostType=PMOL.CostType
	where PMOL.PMCo=@PMCo and PMOL.Project=@Project and PMOL.PCOType=@PCOType and PMOL.PCO=@PCO
	and PMOM.PMCo is null

   	---- calculate pending amount
   	exec @rcode = dbo.vspPMOACalcs @PMCo, @Project, @PCOType, @PCO, @PCOItem
	END


---- from this point on we are only managing PMOL purchase values
---- and syncing the PM Subcontract Detail (PMSL) OR PM Material Detail (PMMF)
---- in sync. If no of the relevant columns have been changed then we
---- can skip this section and move to the next row in the cursor.

---- first check for changes between old and new values for purchase columns
----TK-13116
IF ISNULL(@ECM,'') = ISNULL(@OldECM,'')
	AND ISNULL(@PO,'') = ISNULL(@OldPO,'')
	AND ISNULL(@Subcontract,'') = ISNULL(@OldSubcontract,'')
	AND ISNULL(@Vendor,0) = ISNULL(@OldVendor,0)
	AND ISNULL(@POSLItem,0) = ISNULL(@OldPOSLItem,0)
	AND ISNULL(@SubCO,0) = ISNULL(@OldSubCO,0)
	AND ISNULL(@SubCOSeq,0) = ISNULL(@OldSubCOSeq,0)
	AND ISNULL(@POCONum,0) = ISNULL(@OldPOCONum,0)
	AND ISNULL(@POCONumSeq,0) = ISNULL(@OldPOCONumSeq,0)
	AND ISNULL(@MaterialCode,'') = ISNULL(@OldMaterialCode,'')
	AND ISNULL(@PurchaseAmt,0) = ISNULL(@OldPurchaseAmt,0)
	AND ISNULL(@PurchaseUnits,0) = ISNULL(@OldPurchaseUnits,0)
	AND ISNULL(@PurchaseUM,'') = ISNULL(@OldPurchaseUM,'')
	AND ISNULL(@PurchaseUnitCost,0) = ISNULL(@OldPurchaseUnitCost,0)
	BEGIN
	GOTO NEXT_ROW
	END
	
---- something has change that we need to update to PMSL/PMMF
---- get the impact types for the PCO. NO UPDATES IF NO IMPACT
SELECT @SLType=SubType, @POType=POType
FROM dbo.bPMOP
WHERE PMCo=@PMCo 
	AND Project=@Project 
	AND PCOType=@PCOType
	AND PCO=@PCO

---- skip if no impact
IF ISNULL(@SLType,'N') = 'N' AND ISNULL(@POType,'N') = 'N' GOTO NEXT_ROW

---- PMSL UPDATE
---- PM Subcontract Detail sync (PMSL)
IF ISNULL(@SLType,'N') = 'N' GOTO PMMF_UPDATE


---- now lets update the PMSL record not assigned to a
---- SubCO if we can find one. We want to update the
---- minimum sequence found in PMSL. Possible more than
---- one record exists in PMSL that matches the criteria
---- but we only want to update one.
---- Must be type 'C' change order and not interfaced
SET @PMSLSeq = NULL
SELECT @PMSLSeq = MIN(Seq)
FROM dbo.bPMSL 
WHERE PMCo = @PMCo
	AND Project		= @Project
	AND PCOType		= @PCOType
	AND PCO			= @PCO
	AND PCOItem		= @PCOItem
	AND Phase		= @Phase
	AND CostType	= @CostType
	AND RecordType	= 'C'
	AND InterfaceDate IS NULL
	AND ISNULL(Vendor,'')	= ISNULL(@OldVendor,'')
	AND ISNULL(SL,'')		= ISNULL(@OldSubcontract,'') 
	AND ISNULL(SLItem,'')	= ISNULL(@OldPOSLItem,'')

---- no match found
IF @@ROWCOUNT = 0 GOTO PMMF_UPDATE

---- do we have a sequence SKIP IF NO
IF @PMSLSeq IS NULL GOTO PMMF_UPDATE

---- TK-12381 get SL Item information
SET @SLItemType = 2
SET @WCRetPct = 0
SET @SMRetPct = 0
SET @TaxGroup = NULL
SET @TaxType = NULL
SET @TaxCode = NULL

---- get PMSL data first
SELECT @SLItemType = PMSL.SLItemType, @WCRetPct = PMSL.WCRetgPct,
		@SMRetPct = PMSL.SMRetgPct, @TaxGroup = PMSL.TaxGroup,
		@TaxType = PMSL.TaxType, @TaxCode = PMSL.TaxCode
FROM dbo.bPMSL PMSL
WHERE PMCo = @PMCo
	AND Project = @Project
	AND Seq		= @PMSLSeq

---- get SLIT data second
IF @Subcontract IS NOT NULL AND @POSLItem IS NOT NULL 
	AND EXISTS(SELECT 1 FROM dbo.bSLIT WHERE SLCo=@apco AND SL = @Subcontract AND SLItem = @POSLItem)
	BEGIN
	SELECT @SLItemType = SLIT.ItemType, @WCRetPct = SLIT.WCRetPct,
			@SMRetPct = SLIT.SMRetPct, @TaxGroup = SLIT.TaxGroup,
			@TaxType = SLIT.TaxType, @TaxCode = SLIT.TaxCode
	FROM dbo.bSLIT SLIT
	WHERE SLIT.SLCo=@apco
		AND SLIT.SL = @Subcontract
		AND SLIT.SLItem = @POSLItem
	END
ELSE
	BEGIN
	---- if not in SLIT, but the SL or SL Item has changed, may be a new item 
	---- and we need to set type item type 2-Change Order
	IF @Subcontract IS NOT NULL AND @POSLItem IS NOT NULL 
		AND NOT EXISTS(SELECT 1 FROM dbo.bPMSL WHERE SLCo=@apco AND SL = @Subcontract AND SLItem = @POSLItem)
		BEGIN
		SET @SLItemType = 2
		END
	END
	
---- set update for PMSL when the PMOL record changes and we have a PMSL sequence
UPDATE dbo.bPMSL
		SET  Vendor		= @Vendor, 
			 SL			= @Subcontract, 
			 SLItem		= @POSLItem,
			 ----TK-12381
			 SLItemType = CASE WHEN @CreateSL = 'Y' THEN ISNULL(@SLItemType,1) ELSE ISNULL(@SLItemType,2) END,
			 WCRetgPct  = ISNULL(@WCRetPct,0),
			 SMRetgPct  = ISNULL(@SMRetPct,0),
			 TaxGroup   = @TaxGroup,
			 TaxType    = @TaxType,
			 TaxCode	= @TaxCode,
			 ----TK-12469
			 UM			= ISNULL(@PurchaseUM, bPMSL.UM),
			 Units		= ISNULL(@PurchaseUnits ,bPMSL.Units),
			 UnitCost	= ISNULL(@PurchaseUnitCost, bPMSL.UnitCost),
			 Amount		= ISNULL(@PurchaseAmt, bPMSL.Amount),
			 SubCO		= @SubCO
WHERE PMCo = @PMCo
	AND Project = @Project
	AND Seq		= @PMSLSeq
	AND InterfaceDate IS NULL
	
---- DONE WITH PMSL UPDATE FOR NOW
GOTO NEXT_ROW


----------------------
---- PMMF SIDE
----------------------
PMMF_UPDATE:
---- PM Material Detail sync (PMMF)
IF ISNULL(@POType,'N') = 'N' GOTO NEXT_ROW

---- This was implemented to fix a problem in the 
---- PCO Item Detail update to the POCONum field.
---- If we null out the POCONum then PM PO Change Order Detail 
---- form will no longer see the record (they share the bPMMF table).
---- Instead we want to unassign the POCO record from the PCO by
---- nulling out those values. TK-06688
IF ISNULL(@PO,'') <> '' AND ISNULL(@POCONumSeq,'') = '' AND (ISNULL(@POCONumSeq,'') <> ISNULL(@OldPOCONumSeq,''))
BEGIN
	UPDATE dbo.bPMMF
	SET PCOType = NULL, PCO = NULL, PCOItem = NULL, RecordType = 'O'
	WHERE PMCo = @PMCo AND Project = @Project 
		AND PCOType = @PCOType AND PCO = @PCO 
		AND PCOItem = @PCOItem AND PhaseGroup = @PhaseGroup 
		AND Phase = @Phase AND CostType = @CostType
		AND InterfaceDate IS NULL
END

---- first lets see if we need to null out the POCONum
---- in PMMF from the PMOL. This would occur if the @OldPOCONumSeq
---- has changed from the @POCONumSeq. 
IF ISNULL(@OldPOCONumSeq,'') <> ISNULL(@POCONumSeq,'')
	BEGIN
	IF ISNULL(@OldPOCONumSeq,'') <> ''
		BEGIN	
		UPDATE dbo.bPMMF SET POCONum = NULL
		WHERE PMCo=@PMCo
			AND Project=@Project
			AND Seq = @OldPOCONumSeq
			-- TK-06553 --
			AND POCONum = @OldPOCONum
			AND PCOType=@PCOType
			AND PCO=@PCO
			AND InterfaceDate IS NULL
		END
	END

---- if we have a POCONum and POCONumSeq then we can update
---- the PMMF record directly using these values
IF @POCONum IS NOT NULL AND @POCONumSeq IS NOT NULL
	BEGIN
	UPDATE dbo.bPMMF
		SET  Vendor			= @Vendor,
			 PO				= @PO, 
			 POItem			= @POSLItem,
			 ----TK-12469
			 --UM				= ISNULL(@PurchaseUM, bPMMF.UM),
			 --Units			= ISNULL(@PurchaseUnits ,bPMMF.Units),
			 --UnitCost		= ISNULL(@PurchaseUnitCost, bPMMF.UnitCost),
			 --Amount			= ISNULL(@PurchaseAmt, bPMMF.Amount),
			 --ECM			= ISNULL(@ECM,'E'),
			 --MaterialCode	= isnull(@MaterialCode, bPMMF.MaterialCode),
			 POCONum		= @POCONum,
			 PCOType		= @PCOType,		-- added update for PCOType, PCO, and PCOItem
			 PCO			= @PCO,			-- due to nulling them above when SubCO is removed. TK-06688
			 PCOItem		= @PCOItem
	WHERE PMCo = @PMCo 
		AND Project=@Project
		AND Seq=@POCONumSeq
		AND InterfaceDate IS NULL
		
	---- WE ARE DONE MOVE TO NEXT
	GOTO NEXT_ROW
	END


---- now lets update the PMMF record not assigned to a
---- POCONum if we can find one. We want to update the
---- minimum sequence found in PMMF. Possible more than
---- one record exists in PMMF that matches the criteria
---- but we only want to update one.
---- Must be type 'C' change order and not interfaced
SET @PMMFSeq = NULL
SELECT @PMMFSeq = MIN(Seq)
FROM dbo.bPMMF 
WHERE PMCo = @PMCo
	AND Project			= @Project
	AND PCOType			= @PCOType
	AND PCO				= @PCO
	AND PCOItem			= @PCOItem
	AND Phase			= @Phase
	AND CostType		= @CostType
	AND RecordType		= 'C'
	AND MaterialOption	= 'P'
	AND InterfaceDate IS NULL
	AND ISNULL(Vendor,'')	= ISNULL(@OldVendor,'')
	AND ISNULL(PO,'')		= ISNULL(@OldPO,'') 
	AND ISNULL(POItem,'')	= ISNULL(@OldPOSLItem,'')
	
---- no match found
IF @@ROWCOUNT = 0 GOTO NEXT_ROW

---- do we have a sequence SKIP IF NO
IF @PMMFSeq IS NULL GOTO NEXT_ROW


---- set update for PMMF when the PMOL record changes and we have a PMMF sequence
UPDATE dbo.bPMMF
		SET  Vendor			= @Vendor, 
			 PO				= @PO, 
			 POItem			= @POSLItem,
			 ----TK-12469
			 UM				= ISNULL(@PurchaseUM, bPMMF.UM),
			 Units			= ISNULL(@PurchaseUnits ,bPMMF.Units),
			 UnitCost		= ISNULL(@PurchaseUnitCost, bPMMF.UnitCost),
			 Amount			= ISNULL(@PurchaseAmt, bPMMF.Amount),
			 ECM			= ISNULL(@ECM,'E'),
			 MaterialCode	= isnull(@MaterialCode, bPMMF.MaterialCode),
			 POCONum		= @POCONum
WHERE PMCo = @PMCo
	AND Project = @Project
	AND Seq		= @PMMFSeq
	AND InterfaceDate IS NULL
	
---- DONE WITH PMSL UPDATE FOR NOW
GOTO NEXT_ROW



 
------------------------
---- NEXT ROW IN CURSOR
------------------------
NEXT_ROW:
if @numrows > 1
	BEGIN	    
   	FETCH NEXT FROM bPMOL_insert INTO @PMCo, @Project, @PCOType, @PCO, @PCOItem, @aco, @acoitem,
   				@PhaseGroup, @Phase, @CostType, @units, @um, @unitcost,
   				@amount, @sendYN, @ECM,
   				----TK-04971 TK-06122 TK-06482
				@VendorGroup, @Vendor, @PO, @Subcontract, @POSLItem, @PurchaseAmt,
				@SubCO, @SubCOSeq, @POCONum, @POCONumSeq, @KeyID,
				@PurchaseUM, @PurchaseUnitCost, @PurchaseUnits, @MaterialCode,@CreateSL,
				----OLD
			    @OldPurchaseAmt, @OldMaterialCode, @OldPurchaseUnits, @OldPurchaseUM,
			    @OldPurchaseUnitCost, @OldPO, @OldSubcontract, @OldVendor, @OldPOSLItem,
			    @OldSubCO, @OldSubCOSeq, @OldPOCONum, @OldPOCONumSeq, @OldECM,@OldCreateSL
				
	if @@fetch_status = 0
		goto bPMOL_insert
	else
		BEGIN
		close bPMOL_insert
		deallocate bPMOL_insert
		set @opencursor = 0
		END
	END

if update(SendYN)
	begin
	insert into bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPMOL','PMCo: ' + isnull(convert(char(3),i.PMCo), '') + ' Project: ' + isnull(i.Project,'')
		+ ' PCOType: ' + isnull(i.PCOType,'') + ' PCO: ' + isnull(i.PCO,'')
		+ ' PCOItem: ' + isnull(i.PCOItem,'') + ' Phase: ' + ISNULL(i.Phase,'')
		+ ' CostType: ' + isnull(convert(char(3),i.CostType),'')
		, i.PMCo, 'C',
		'SendYN', d.SendYN, i.SendYN, getdate(), SUSER_SNAME()
	from inserted i
	join deleted d on d.KeyID = i.KeyID
	where isnull(d.SendYN,'') <> isnull(i.SendYN,'')
	END
	
---- update the ready for accounting flag to 'Y' in PMOH
---- when detail added to an ACO and the Send flag is 'Y'
---- and the ACO ready for accounting flag is 'N' TK-05347
---- GF 11/23/2011 - TK-10530 CI#145133
UPDATE dbo.bPMOH SET ReadyForAcctg = 'Y'
FROM inserted i
INNER JOIN deleted d ON d.KeyID = i.KeyID
INNER JOIN dbo.bPMOH h ON h.PMCo=i.PMCo AND h.Project=i.Project AND h.ACO=i.ACO
WHERE i.ACO IS NOT NULL AND h.ReadyForAcctg = 'N' AND i.SendYN = 'Y'
AND ISNULL(i.SendYN,'N') <> ISNULL(d.SendYN,'N')



RETURN



error:
	if @opencursor = 1
		BEGIN
		close bPMOL_insert
		deallocate bPMOL_insert
		set @opencursor = 0
		END
   
   	select @errmsg = isnull(@errmsg,'') + ' - cannot update into PMOL'
   	RAISERROR(@errmsg, 11, -1);
   	rollback transaction





GO
PRINT N'Altering trigger [dbo].[btPREHu] on [dbo].[bPREH]'
GO
ALTER   trigger [dbo].[btPREHu] on [dbo].[bPREH] for UPDATE as
/*-----------------------------------------------------------------
* Created: kb 10/28/98
* Modified: GG 07/20/99    - fixed Craft/Class validation
*   		JE 10/11/99    - fixed key changes where clause
*		 	EN 2/7/00	- maintain DDDU for PR group security
*			GG 02/28/00 - fixed join with bPRGS for Security update
*      		EN 4/12/00 - validate that Crafts exist for non-null Classes
*      		EN 9/28/00 - include ability to select category status J (for NY DOT reporting)
*      		EN 10/09/00 - Checking for key changes incorrectly
*      		RM 03/15/01 - Clear TermDate if HireDate is more current
*		 	GG 11/02/01 - #15188 - Added Direct Deposit validation
*		 	GG 11/07/01 - #15198 - Removed HR TermDate update
*		 	GG 12/18/01 - #15655 - fix SortName validation
*		 	EN 1/23/02 - #16023 - added auditing code for fields DefaultPaySeq, DDPaySeq, and Suffix
*		 	EN 1/29/02 - #16023 - fixed audit code for all non-null fields to write to HQMA if field is changed to or from null
*      		EN 2/12/02 - #16023 - slight mod to isnull for PaySeq field ... changed isnull default from -1 to ''
*		 	GG 03/01/02 - skip Data Security updates if bEmployee is not a secure datatype
*		 	EN 8/15/02 - issue 17502 added auditing code for field TradeSeq
*      		09/30/02 DANF - Added Document Exporting (14550)
*			mh 5/7/03 Issue 19538
*			mh 8/14/03 Issue 22166 - corrected Category Status error message
*			EN 02/12/03 - issue 23061  added isnull check, with (nolock), and dbo
*			EN 3/3/04 - issue 20564  validate Shift
*			10/03/05 GG - #29019 - make sure SortName is upper case before testing for uniqueness
*			MH 10/6/05 - #28967 - update PRGroup changes to HRRM - data security cleanup
*			EN 3/9/06 - issue 120402  fixed to include full year in date when insert BirthDate, HireDate, TermDate, and LastUpdated date to HQMA
*			mh 2/7/07 - 123806 - Switch DDDT to DDDTShared
*			GG 5/2/07 - #30116 - data security review, cleanup
*			mh 9/26/07 - #29630 - Adding cross update for OTSched, OTOpt, Shift.
*			mh 3/11/2008 - #127081 - Added Country validation in addition to cross update and audit code
*							for Country.
*			EN 3/21/08 - #127081  modified HQST validation to include country for TaxState, InsState and UnempState
*			GG 06/05/08 - #128324 - State/Country validation fix
*			EN 7/07/08 - #127015 - add code for HDAmt, F1Amt, LCFStock and LCPStock to HQMA auditing
*			MH 8/6/2008 - #129198 - added cross update to bHRRM for HDAmt, F1Amt, LCFStock, LCPStock
*			MH 01/09/2009 - #131214 - Corrected to not delete term reason in HRRM if only changing term date to another date.
*									Should continue to delete term reason is term date removed.
*			mh 02/14/2009 - #125436 - Added audit entry for PayMethodDelivery.  Rejecting updates if Email is null
*					and PayMethodDelivery is not 'N-None'
*			EN 4/17/2009 #133253  Added with (nolock) to bHRRM to prevent deadlocks
*			mh 02/10/2010 #124598 - Added code to update bPRAE with earnings code change in bPREH
*									where the earnings code exists in bPRAE and newly added flag
*									UpdatePRAEYN = 'Y'.  Added auditing for new column UpdatePRAEYN.  
*			TJL 02/16/10 - #135490, Add new fields for Work Office Tax State and Work Office Local Code 
*			AR 11/4/2010 -#129574 - sp_makewebtask is deprecated so removing call to proc
*			MV	04/11/11 - Backlog Item# B-04112 - Add cellphone to HR cross update.
*			CHS	09/26/2011	- B-06080 allow duplication of 333-333-333, 444-444-444, 111-111-111, and 000-000-000.
*			MV	08/13/2012	-	B-10397 audit ArrearsActiveYN 
*			DAN SO 02/19/2013 - TFS-40964 - Audit newly added columns - RecentRehireDate, RecentSeparationDate, SeparationRedundancyRetirement
*
*	Update trigger for PR Employee Master
*
*	Adds record to HQ Master Audit.
*/----------------------------------------------------------------
   
declare @errmsg varchar(255), @numrows int, @validcnt int, @validcnt2 int, 
	@prco bCompany, @employee bEmployee, @prgroup bGroup, @nullcnt int
   
--19538
declare @active int, @hrco bCompany, @hrref bHRRef
   
select @numrows = @@rowcount
if @numrows = 0 return
set nocount on
   
/* check for key changes */
if update(PRCo)
	begin
    select @validcnt = count(*) from deleted d join inserted i on d.PRCo = i.PRCo
    if @validcnt <> @numrows
   		begin
        select @errmsg = 'Cannot change PR Company'
        goto error
        end
    end
if update(Employee)
    begin
    select @validcnt = count(*) from deleted d join inserted i on d.PRCo = i.PRCo and d.Employee = i.Employee
    if @validcnt <> @numrows
   		begin
        select @errmsg = 'Cannot change Employee'
        goto error
        end
    end
   
/*check for uniqueness in Sort Name*/
if update(SortName)
   	begin
	-- #29019 check for upper case before uniqueness
	if exists(select top 1 1 from inserted where SortName <> upper(SortName))
   		begin
   		select @errmsg = 'Sort Name must be uppercase'
   		goto error
   		end
   	select @validcnt = count(*) from dbo.bPREH a (nolock)
	join inserted i on i.PRCo = a.PRCo and a.SortName = i.SortName
   	if @validcnt<>@numrows
   		begin
   		select @errmsg = 'Sort Name is not unique'
   		goto error
   		end
   	end

if update([State]) or update(Country)
	begin
	select @validcnt = count(1) 
	from dbo.bHQCountry c with (nolock) 
	join inserted i on i.Country = c.Country
	select @nullcnt = count(1) from inserted where Country is null
	if @validcnt + @nullcnt <> @numrows
		begin
		select @errmsg = 'Invalid Country'
		goto error
		end
	-- validate Country/State combinations
	select @validcnt = count(1) -- Country/State combos are unique
	from inserted i
	join dbo.bHQCO c (nolock) on c.HQCo = i.PRCo	-- join to get Default Country
	join dbo.bHQST s (nolock) on isnull(i.Country,c.DefaultCountry) = s.Country and i.State = s.State
	select @nullcnt = count(1) from inserted where [State] is null
	if @validcnt + @nullcnt <> @numrows
		begin
		select @errmsg = 'Invalid Country and State combination'
		goto error
		end
	end

/* validate Sex */
if UPDATE(Sex)
   	begin
   	select @validcnt = count(*) from inserted i where i.Sex='M' or i.Sex='F'
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Sex must be ''M'' or ''F'''
   		goto error
   		end
   	end
   	
/*check for uniqueness in SSN*/
if update(SSN)
   	begin
		declare @Country char(2), @SSN char(11)
		
		select @validcnt = count(*), @Country = c.DefaultCountry, @SSN = i.SSN
		from dbo.bPREH a (nolock)
		join inserted i	on a.SSN = upper(i.SSN) and a.PRCo = i.PRCo
		JOIN dbo.bHQCO c (NOLOCK) ON c.HQCo = i.PRCo	-- join to get Default Country
		group by c.DefaultCountry, i.SSN
				
		if @validcnt <> @numrows
			begin
			IF @Country <> 'AU' OR (@Country = 'AU' AND @SSN NOT IN ('333-333-333', '444-444-444', '111-111-111', '000-000-000'))
				BEGIN
				select @errmsg = '@validcnt = ' + cast(@validcnt as varchar(10)) + '@numrows = ' + cast(@numrows as varchar(10)) + 'SSN already exists for an employee in this company'
				goto error				
				END

			end	

   	end
   	
if update(Race)
   	begin
   	select @validcnt = count(*) from dbo.bPRRC c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.Race=i.Race
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Race Code'
   		goto error
   		end
   	end
/* validate PR Group */
if update(PRGroup)
   	begin
   	select @validcnt = count(*) from dbo.bPRGR c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.PRGroup=i.PRGroup
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid PR Group'
   		goto error
   		end
   	end
/* validate PR Department */
if update(PRDept)
   	begin
   	select @validcnt = count(*) from dbo.bPRDP c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.PRDept=i.PRDept
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid PR Department'
   		goto error
   		end
   	end
/* validate PR Craft and Class */
if update(Craft) or update(Class)
   	begin
   	select @nullcnt = count(*) from inserted i where i.Craft is null
   	select @validcnt = count(*) from dbo.bPRCM c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.Craft=i.Craft
   	if @nullcnt + @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Craft'
   		goto error
   		end
   	/* validate PR Class */
	select @validcnt = count(*) from inserted i where i.Craft is null and i.Class is not null
    if @validcnt <> 0
    	begin
        select @errmsg = 'Missing Craft'
        goto error
        end
	select @validcnt2 = count(*) from inserted i where i.Class is not null
    if @validcnt2<>0
       	begin
       	select @validcnt = count(*) from dbo.bPRCC c (nolock) join inserted i on c.PRCo = i.PRCo and c.Craft=i.Craft and c.Class=i.Class
       		where i.Class is not null
       	if @validcnt <> @validcnt2
       		begin
       		select @errmsg = 'Invalid Craft Class'
       		goto error
       		end
       	end
	end
/* validate PR Insurance */
if update(InsCode)
	begin
   	select @validcnt = count(*) from dbo.bHQIC c with (nolock) join inserted i on c.InsCode=i.InsCode
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Insurance Code'
   		goto error
   		end
   	end
/* validate Tax State */
if update(TaxState)
   	begin
   	select @validcnt = count(*) from inserted where TaxState is not null
    select @validcnt2 = count(*) from inserted i join dbo.bHQCO c with (nolock) on c.HQCo=i.PRCo
		join dbo.bHQST s with (nolock) on c.DefaultCountry=s.Country and s.State=i.TaxState
   	if @validcnt2 <> @validcnt
		begin
		select @errmsg = 'Invalid Tax State'
		goto error
		end
   	end
/* validate Unemp State */
if update(UnempState)
   	begin
    select @validcnt = count(*) from inserted i join dbo.bHQCO c with (nolock) on c.HQCo=i.PRCo
		join dbo.bHQST s with (nolock) on c.DefaultCountry=s.Country and s.State=i.UnempState
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Unemployment State'
   		goto error
   		end
   	end
/* validate Insurance State */
if update(InsState)
   	begin
    select @validcnt = count(*) from inserted i join dbo.bHQCO c with (nolock) on c.HQCo=i.PRCo
		join dbo.bHQST s with (nolock) on c.DefaultCountry=s.Country and s.State=i.InsState
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Insurance State'
   		goto error
   		end
   	end
/* validate Local Code*/
if update(LocalCode)
   	begin
   	select @nullcnt = count(*) from inserted i where i.LocalCode is null
	select @validcnt = count(*) from dbo.bPRLI c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.LocalCode = i.LocalCode
   	if @nullcnt + @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Local Code'
   		goto error
   		end
   	end
/* validate Work Office Tax State */
if update(WOTaxState)
   	begin
   	select @validcnt = count(*) from inserted where WOTaxState is not null
    select @validcnt2 = count(*) from inserted i join dbo.bHQCO c with (nolock) on c.HQCo=i.PRCo
		join dbo.bHQST s with (nolock) on c.DefaultCountry=s.Country and s.State=i.WOTaxState
   	if isnull(@validcnt2,0) <> isnull(@validcnt,0)
		begin
		select @errmsg = 'Invalid Work Office Tax State'
		goto error
		end
   	end
/* validate Work Office Local Code*/
if update(WOLocalCode)
   	begin
   	select @nullcnt = count(*) from inserted i where i.WOLocalCode is null
	select @validcnt = count(*) from dbo.bPRLI c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.LocalCode = i.WOLocalCode
   	if isnull(@nullcnt,0) + isnull(@validcnt,0) <> isnull(@numrows,0)
   		begin
   		select @errmsg = 'Invalid Work Office Local Code'
   		goto error
   		end
   	end  	
/* validate GLCo */
if update(GLCo)
   	begin
   	select @nullcnt = count(*) from inserted i where i.GLCo is null
   	select @validcnt = count(*) from dbo.bGLCO c (nolock)
	join inserted i on c.GLCo = i.GLCo
   	if @nullcnt + @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid GL Company'
   		goto error
   		end
   	end
/* validate JCCo */
if update(JCCo) or update(Job)
   	begin
   	select @validcnt2 = count(*) from inserted i where i.JCCo is not null
   	if @validcnt2<>0
   		begin
   		select @validcnt = count(*) from dbo.bJCCO c with (nolock)
		join inserted i on c.JCCo = i.JCCo
		where i.JCCo is not null
   		if @validcnt <> @validcnt2
   			begin
   			select @errmsg = 'Invalid JC Company'
   			goto error
   			end
   		end
   	select @validcnt2 = count(*) from inserted i where i.JCCo is not null and i.Job is not null
   	if @validcnt2<>0
   		begin
   		/* validate Job */
   		select @validcnt = count(*) from dbo.bJCJM c with (nolock)
		join inserted i on c.JCCo = i.JCCo and c.Job=i.Job
        where i.JCCo is not null and i.Job is not null
   		if @validcnt <> @validcnt2
   			begin
   			select @errmsg = 'Invalid Job'
   			goto error
   			end
   		end
   	end
/* validate Crew */
if update(Crew)
   	begin
   	select @nullcnt = count(*) from inserted i where i.Crew is null
	select @validcnt = count(*) from dbo.bPRCR c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.Crew = i.Crew
   	if @nullcnt + @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Crew'
   		goto error
   		end
   	end
/* validate Earnings Code */
if update(EarnCode)
   	begin
   	select @validcnt = count(*) from dbo.bPREC c (nolock) 
	join inserted i on c.PRCo = i.PRCo and c.EarnCode = i.EarnCode
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Earnings Code'
   		goto error
   		end
   	end
/* validate Overtime Option*/
if update(OTOpt)
   	begin
   	select @validcnt = count(*) from inserted where OTOpt in ('N','D','W','C','J')
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Overtime Option must be ''N'', ''D'', ''W'', ''C'' or ''J'''
   		goto error
   		end
   	end
/* validate Overtime Schedule */
if update(OTSched)
   	begin
   	select @nullcnt = count(*) from inserted i where i.OTSched is null
	select @validcnt = count(*) from dbo.bPROT c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.OTSched = i.OTSched
   	if @nullcnt + @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid OT Schedule'
   		goto error
   		end
   	end
/* validate Occupational Category*/
if update(OccupCat)
   	begin
   	select @nullcnt = count(*) from inserted i where i.OccupCat is null
	select @validcnt = count(*) from dbo.bPROP c (nolock)
	join inserted i on c.PRCo = i.PRCo and c.OccupCat = i.OccupCat
   	if @nullcnt + @validcnt <> @numrows
   		begin
   		select @errmsg = 'Invalid Occupational Category' 
   		goto error
   		end
   	end
/* validate Category Status*/
if update(CatStatus)
   	begin
   	select @nullcnt = count(*) from inserted i where i.CatStatus is null
	select @validcnt = count(*) from inserted where CatStatus in ('A','T','J','N')
	if @nullcnt + @validcnt <> @numrows
   		begin
   		--Issue 22166
   		select @errmsg = 'Category Status must be ''A'', ''J'', ''T'', or ''N'''
   		goto error
   		end
   	end
/* validate Direct Deposit Option*/
if update(DirDeposit) or update(RoutingId) or update(BankAcct) or update(AcctType)
   	begin
   	select @validcnt = count(*) from inserted where DirDeposit in ('N','P','A')
   	if @validcnt <> @numrows
   		begin
   		select @errmsg = 'Direct Deposit Option must be ''N'', ''P'', ''A'''
   		goto error
   		end
   	-- validate required info for Direct Deposits
   	if exists(select top 1 1 from inserted
   		where DirDeposit in ('P','A') and (RoutingId is null or BankAcct is null or AcctType is null))
   			begin
   			select @errmsg = 'Routing Transit#, Bank Acct, and Account Type are required with PreNote or Active Direct Deposits'
   			goto error
   			end
   	-- validate Direct Deposit Account Type
   	if exists(select top 1 1 from inserted where DirDeposit in ('P','A') and AcctType not in ('C','S'))
   		begin
   		select @errmsg = 'Direct Deposit Account Type must be ''C'' or ''S'''
   		goto error
   		end
   	end
   
if exists(select top 1 1 from inserted 
	where PayMethodDelivery in ('E','A') and Email is null)
	begin
	select @errmsg = 'EMail address is required when Method of Pay Stub Delivery is ''Email'''
	goto error
	end

-- validate Shift
select @validcnt = count(*) from inserted where Shift is null
select @validcnt2 = count(*) from inserted where Shift > 0 and Shift < 256
if @validcnt2 + @validcnt <> @numrows
   	begin
   	select @errmsg = 'Shift must be an integer between 1 and 255'
   	goto error
   	end
 
-- #28967 - PRGroup change cross updates HR and refreshes data level security
if update(PRGroup)
	begin
	-- update PRGroup on any HR Resource entries with matching PR Co# and Employee #s
 	update dbo.bHRRM
 	set PRGroup = i.PRGroup
 	from dbo.bHRRM h with (nolock)
 	join inserted i on h.PRCo = i.PRCo and h.PREmp = i.Employee 
	where i.PRGroup <> h.PRGroup

	-- check if Employee is a secure datatype
	if (select count(*) from dbo.DDDTShared (nolock) where Datatype = 'bEmployee' and Secure = 'Y') > 0
		begin
   		-- remove security entries for all users assigned to the old PRGroup
 		delete dbo.vDDDU 
 		from dbo.vDDDU u
		join deleted d on u.Qualifier = d.PRCo and u.Instance = convert(char(30), d.Employee)
 		where u.Datatype = 'bEmployee'
			and VPUserName in (select VPUserName from dbo.bPRGS g with (nolock)
								where g.PRCo = d.PRCo and g.PRGroup = d.PRGroup)
 
		-- add security entries for all users assigned to the new PRGroup
 		insert dbo.vDDDU (Datatype, Qualifier, Instance, VPUserName)
 		select 'bEmployee', i.PRCo, convert(char(30),i.Employee), s.VPUserName
 		from inserted i
 		join dbo.bPRGS s on i.PRCo = s.PRCo and i.PRGroup = s.PRGroup
			and not exists (select 1 from dbo.vDDDU u (nolock)
				where u.Qualifier = i.PRCo and u.Instance = convert(char(30),i.Employee)
				and u.Datatype = 'bEmployee' and u.VPUserName = s.VPUserName)
		end
	end



--6.x recode - Cross update remaining fields based on HRCO
	if exists(select 1 from bHRRM h with (nolock) join inserted i on h.PRCo = i.PRCo and h.PREmp = i.Employee)
	begin
		--Employee exists in HRRM. 

		--Update Name
		if (update(LastName) or update(FirstName) or update(MidName) or update(SortName) or update(BirthDate)
		or update(Race) or update(Sex) or update(Suffix))
		begin
			update dbo.bHRRM
			set LastName = i.LastName, FirstName = i.FirstName, MiddleName = i.MidName, 
			Suffix=i.Suffix, SortName = i.SortName, BirthDate = i.BirthDate, 
			Race = i.Race, Sex = i.Sex
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateNameYN = 'Y'
			where h.LastName <> i.LastName or isnull(h.FirstName,'') <> isnull(i.FirstName,'') 
			or isnull(h.MiddleName,'') <> isnull(i.MidName,'') or isnull(h.Suffix,'') <> isnull(i.Suffix,'')
			or isnull(h.SortName,'') <> isnull(i.SortName,'') or isnull(h.BirthDate,'') <> isnull(i.BirthDate,'')
			or h.Race <> i.Race or h.Sex <> i.Sex
		end

		--Update Address
		if (update([Address]) or update(City) or update([State]) or update(Zip) or update(Phone) or update(Email) or
		update(Address2) or update(Country) or update(CellPhone))
		begin
			update dbo.bHRRM
			set Address = i.Address, City = i.City, State = i.State, Zip = i.Zip,
			Address2 = i.Address2, Phone = i.Phone, Email = i.Email, Country = i.Country,
			CellPhone = i.CellPhone
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateAddressYN = 'Y'
			where isnull(h.Address,'') <> isnull(i.Address,'') or isnull(h.City,'') <> isnull(i.City,'') 
			or isnull(h.State,'') <> isnull(i.State,'') or isnull(h.Zip, '') <> isnull(i.Zip,'')
			or isnull(h.Address2, '') <> isnull(i.Address2, '') or isnull(h.Phone,'') <> isnull(i.Phone,'')
			or isnull(h.Email,'') <> isnull(i.Email,'') or isnull(h.Country,'') <> isnull(i.Country, '')
			or isnull(h.CellPhone,'') <> isnull(i.CellPhone,'')
		end

		--Update Hire Date
		if update(HireDate)
		begin
			update dbo.bHRRM
			set HireDate = i.HireDate
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateHireDateYN = 'Y'
			where isnull(h.HireDate,'1/1/00') <> isnull(i.HireDate,'1/1/00') 
		end

		--Update TermDate
		if update (TermDate)
		begin
			declare @termreason varchar(10)

			update dbo.bHRRM
			set TermDate = i.TermDate, TermReason = (case isnull(i.TermDate,'') when '' then @termreason else h.TermReason end)
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateHireDateYN = 'Y'
			where isnull(h.TermDate,'1/1/00') <> isnull(i.TermDate,'1/1/00')
		end

		--Update Active Flag
		if (update(ActiveYN))
		begin
			update dbo.bHRRM
			set ActiveYN = i.ActiveYN
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateActiveYN = 'Y'
			where h.ActiveYN <> i.ActiveYN
		end
		
		--Update Timecard Defaults
		if (update(PRDept) or update(Craft) or update(Class) or update(InsCode) or update(TaxState)
			or update(UnempState) or update(InsState) or update(LocalCode) or update(EarnCode) or 
			update(Shift) or update(HDAmt) or update(F1Amt) or update(LCFStock) or update(LCPStock) or
			update(WOTaxState) or update(WOLocalCode))
		begin
			update dbo.bHRRM
			set PRDept = i.PRDept, StdCraft = i.Craft, StdClass = i.Class, StdInsCode = i.InsCode,
			StdTaxState = i.TaxState, StdUnempState = i.UnempState, StdInsState = i.InsState, 
			StdLocal = i.LocalCode, EarnCode = i.EarnCode, Shift = i.Shift, HDAmt = i.HDAmt,
			F1Amt = i.F1Amt, LCFStock = i.LCFStock, LCPStock = i.LCPStock,
			WOTaxState = i.WOTaxState, WOLocalCode = i.WOLocalCode
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateTimecardYN = 'Y'
			where i.PRDept <> isnull(h.PRDept, '') or isnull(i.Craft, '') <> isnull(h.StdCraft,'') or
			isnull(i.Class, '') <> isnull(h.StdClass,'') or isnull(i.InsCode,'') <> isnull(h.StdInsCode, '') or
			isnull(i.TaxState, '') <> isnull(h.StdTaxState, '') or isnull(i.UnempState,'') <> isnull(h.StdUnempState, '') or
			isnull(i.InsState,'') <> isnull(h.StdInsState,'') or isnull(i.LocalCode, '') <> isnull(h.StdLocal, '') or
			isnull(i.EarnCode,'') <> isnull(h.EarnCode, '') or isnull(i.Shift,'') <> isnull(h.Shift, '')or
			isnull(i.HDAmt, -999) <> isnull(h.HDAmt, -999) or isnull(i.F1Amt, -999) <> isnull(h.F1Amt, -999) or
			isnull(i.LCFStock, -999) <> isnull(h.LCFStock, -999) or isnull(i.LCPStock, -999) <> isnull(h.LCPStock, -999) or
			isnull(i.WOTaxState, '') <> isnull(h.WOTaxState, '') or isnull(i.WOLocalCode, '') <> isnull(h.WOLocalCode, '')
		end

		--Update W4 Info (Not HRWI - that is handled in its triggers)
		if (update(NonResAlienYN))
		begin
			update dbo.bHRRM
			set NonResAlienYN = i.NonResAlienYN
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateW4YN = 'Y'
			where h.NonResAlienYN <> i.NonResAlienYN
		end

		--Update Occup Cat
		if (update(OccupCat) or update(CatStatus) or update(OTOpt) or update(OTSched))
		begin
			update dbo.bHRRM
			set OccupCat = i.OccupCat, CatStatus = i.CatStatus, OTOpt = i.OTOpt, OTSched = i.OTSched
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateOccupCatYN = 'Y'
			where isnull(h.OccupCat,'') <> isnull(i.OccupCat, '') or isnull(h.CatStatus,'') <> isnull(i.CatStatus, '') or
			isnull(h.OTOpt,'') <> isnull(i.OTOpt, '') or isnull(h.OTSched,'') <> isnull(i.OTSched, '')
		end

		--Update SSN
		if (update(SSN))
		begin
			update dbo.bHRRM
			set SSN = i.SSN
			from inserted i
			join dbo.bHRRM h with (nolock) on i.PRCo = h.PRCo and i.Employee = h.PREmp
			join dbo.bHRCO o (nolock) on h.HRCo = o.HRCo and o.UpdateSSNYN = 'Y'
			where i.SSN <> isnull(h.SSN,'')
		end

	end --cross updates

--Issue 124598 - If updating earnings code and UpdatePRAEYN = 'Y' then check to see if 
--earnings code exists in PRAE.  If so, update the Rate/Amount value in PRAE with 
--bPREH.SalaryAmt value.  Code assumes Salary earnings code has been set up properly
--and is not split between sequences or set up multiple times in bPRAE for an Employee
	if update(EarnCode) or update(SalaryAmt) or update(UpdatePRAEYN)
	begin
		update dbo.bPRAE
		set RateAmt = i.SalaryAmt
		from inserted i
		join bPRAE e with (nolock) on i.PRCo = e.PRCo and i.Employee = e.Employee
		and i.EarnCode = e.EarnCode
		where i.UpdatePRAEYN = 'Y' and i.SalaryAmt <> e.RateAmt
	end
   
/* Document exporting */
declare @group tinyint, @opencursor int, @rcode int, @stdxmlformat bYN, @userstoredrroc varchar(30),
	@hqco bCompany, @hqdxcursor int, @sql varchar(300), @exportdirectory varchar(256), @msg varchar(255)
   
if exists(select top 1 i.PRCo from inserted i 
			join dbo.bHQDX d with (nolock) on d.Co = i.PRCo and d.Package = 'Employees' 
				and d.TriggerName = 'Update' and d.Enable = 'Y')
	begin
    -- Execute Export document for each customer in Inserted
   	if @numrows = 1
		begin
   		-- if only one row inserted, no cursor is needed
   		select @hqco = i.PRCo, @employee = i.Employee
   		from inserted i
   		join dbo.bHQDX d with (nolock) on d.Co = i.PRCo and d.Package = 'Employees' 
			and d.TriggerName = 'Update' and d.Enable = 'Y'
   		if @@rowcount = 0 goto btexit
   		end
   	else
   		begin
   		-- use a cursor to process inserted rows
   		declare bPREH_cursor cursor for
   		select i.PRCo, i.Employee
   		from inserted i
   		join dbo.bHQDX d with (nolock) on d.Co = i.PRCo and d.Package = 'Employees'
			and d.TriggerName = 'Update' and d.Enable = 'Y'
   		
   		open bPREH_cursor
   		select @opencursor = 1
   		
   		-- get 1st row inserted
   		fetch next from bPREH_cursor into @hqco , @employee
   		if @@fetch_status <> 0 goto btexit
   		end
   		
	PREH_export:	-- Export Employee Document
		select @stdxmlformat=null, @userstoredrroc=null, @exportdirectory = null
   
 		select @stdxmlformat=StdXMLFormat, @userstoredrroc=UserStoredProc, @exportdirectory=ExportDirectory 
   		from dbo.bHQDX d with (nolock)
   		where d.Co = @hqco and d.Package = 'Employees' and d.TriggerName = 'Update' and d.Enable = 'Y'
    
   		-- 129574 - sp_makewebtask is deprecated so removing call to proc		
     IF ISNULL(@stdxmlformat, '') <> 'Y' 
        BEGIN
            IF ISNULL(@userstoredrroc, '') <> '' 
                BEGIN	
                    SELECT  @sql = 'declare @xrcode int '
                    SELECT  @group = PRGroup
                    FROM    inserted
                    WHERE   PRCo = @hqco
                            AND Employee = @employee
                    SELECT  @sql = @sql + 'exec @xrcode = ' + @userstoredrroc
                            + ' ' 
                    SELECT  @sql = @sql + CONVERT(varchar(300), @employee)
                            + ',' 
                    SELECT  @sql = @sql + CONVERT(varchar(300), @group) + ',' 
                    SELECT  @sql = @sql + CONVERT(varchar(300), @hqco) + ',' 
                    SELECT  @sql = @sql + CHAR(39) + ISNULL(@exportdirectory,
                                                            '') + CHAR(39)
                            + ',' 
                    SELECT  @sql = @sql + CHAR(39) + '*' + CHAR(39)
   
                    EXEC(@sql)
                END
        END
   		
		-- get next row
   		if @numrows > 1
   			begin
   		   	fetch next from bPREH_cursor into @group , @employee
   		    if @@fetch_status = 0 goto PREH_export
   			end
   		end

   btexit:   /* End Document exporting */
   
/* Audit updates */
if update(LastName)
   	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'LastName', d.LastName, i.LastName, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.LastName <> d.LastName and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(FirstName)
	begin
    insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'FirstName', d.FirstName, i.FirstName, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where isnull(i.FirstName,'') <> isnull(d.FirstName,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(MidName)
	begin
    insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'MidName', d.MidName, i.MidName, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.MidName,'') <> isnull(d.MidName,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(SortName)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee), 
		i.PRCo, 'C', 'SortName', d.SortName, i.SortName, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.SortName <> d.SortName and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Address)
	begin
    insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Address', d.Address, i.Address, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.Address,'') <> isnull(d.Address,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(City)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'City', d.City, i.City, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.City,'') <> isnull(d.City,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(State)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'State', d.State, i.State, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.State,'') <> isnull(d.State,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Zip)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Zip', d.Zip, i.Zip, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.Zip,'') <> isnull(d.Zip,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end

if update(Country)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Country', d.Country, i.Country, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.Country,'') <> isnull(d.Country,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end

if update(Address2)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Address2', d.Address2, i.Address2, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.Address2,'') <> isnull(d.Address2,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Phone)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Phone', d.Phone, i.Phone,	getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where isnull(i.Phone,'') <> isnull(d.Phone,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(SSN)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'SSN', d.SSN, i.SSN, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.SSN <> d.SSN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Race)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Race', d.Race, i.Race, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where i.Race <> d.Race and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Sex)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Sex', d.Sex, i.Sex, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
    where i.Sex <> d.Sex and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(BirthDate)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'BirthDate', convert(varchar,d.BirthDate,101), convert(varchar,i.BirthDate,101), getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
    where isnull(i.BirthDate,'') <> isnull(d.BirthDate,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(HireDate)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'HireDate', convert(varchar,d.HireDate,101), convert(varchar,i.HireDate,101), getdate(), SUSER_SNAME()
    	from inserted i
        join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
        join dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
    where isnull(i.HireDate,'') <> isnull(d.HireDate,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(TermDate)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'TermDate', convert(varchar,d.TermDate,101), convert(varchar,i.TermDate,101), getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
    where isnull(i.TermDate,'') <> isnull(d.TermDate,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(PRGroup)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'PRGroup', convert(varchar,d.PRGroup), convert(varchar,i.PRGroup),	getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.PRGroup <> d.PRGroup and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(PRDept)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'PRDept', d.PRDept, i.PRDept, getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.PRDept <> d.PRDept and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Craft)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Craft', d.Craft, i.Craft,	getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.Craft,'') <> isnull(d.Craft,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Class)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Class', d.Class, i.Class,	getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.Class,'') <> isnull(d.Class,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(InsCode)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','InsCode', d.InsCode, i.InsCode, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.InsCode <> d.InsCode and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(TaxState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'TaxState', d.TaxState, i.TaxState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.TaxState,'') <> isnull(d.TaxState,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(UnempState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'UnempState', d.UnempState, i.UnempState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.UnempState <> d.UnempState and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(InsState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'InsState', d.InsState, i.InsState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.InsState <> d.InsState and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(LocalCode)
	begin
    insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'LocalCode', d.LocalCode, i.LocalCode, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.LocalCode,'') <> isnull(d.LocalCode,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(WOTaxState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'WOTaxState', d.WOTaxState, i.WOTaxState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.WOTaxState,'') <> isnull(d.WOTaxState,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(WOLocalCode)
	begin
    insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'WOLocalCode', d.WOLocalCode, i.WOLocalCode, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.WOLocalCode,'') <> isnull(d.WOLocalCode,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(GLCo)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'GLCo', convert(varchar,d.GLCo), convert(varchar,i.GLCo), getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.GLCo,0) <> isnull(d.GLCo,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(UseState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'UseState', d.UseState, i.UseState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.UseState <> d.UseState and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(UseUnempState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'UseUnempState', d.UseUnempState, i.UseUnempState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.UseUnempState <> d.UseUnempState and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(UseInsState)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'UseInsState', d.UseInsState, i.UseInsState, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.UseInsState <> d.UseInsState and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(UseLocal)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'UseLocal', d.UseLocal, i.UseLocal, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.UseLocal <> d.UseLocal and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end	
if update(UseIns)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar(10),i.Employee),
		i.PRCo, 'C', 'UseIns', d.UseIns, i.UseIns, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where i.UseIns <> d.UseIns and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(JCCo)
	begin
	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'JCCo', convert(varchar,d.JCCo), convert(varchar,i.JCCo), getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where isnull(i.JCCo,0) <> isnull(d.JCCo,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Job)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Job', d.Job, i.Job, getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.Job,'') <> isnull(d.Job,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Crew)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Crew', d.Crew, i.Crew, getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
	join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where isnull(i.Crew,'') <> isnull(d.Crew,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(LastUpdated)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'LastUpdated', convert(varchar,d.LastUpdated,101), convert(varchar,i.LastUpdated,101), getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
	join dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
   	where isnull(i.LastUpdated,'') <> isnull(d.LastUpdated,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(EarnCode)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'EarnCode', convert(varchar,d.EarnCode), convert(varchar,i.EarnCode), getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.EarnCode <> d.EarnCode and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(HrlyRate)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'HrlyRate', convert(varchar,d.HrlyRate), convert(varchar,i.HrlyRate), getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where i.HrlyRate <> d.HrlyRate and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(SalaryAmt)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'SalaryAmt', convert(varchar,d.SalaryAmt), convert(varchar,i.SalaryAmt), getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where i.SalaryAmt <> d.SalaryAmt and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(OTOpt)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','OTOpt', d.OTOpt, i.OTOpt, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.OTOpt <> d.OTOpt and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(OTSched)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'OTSched', convert(varchar,d.OTSched), convert(varchar,i.OTSched),	getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where isnull(i.OTSched,0) <> isnull(d.OTSched,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(JCFixedRate)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','JCFixedRate', convert(varchar,d.JCFixedRate), convert(varchar,i.JCFixedRate), getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.JCFixedRate <> d.JCFixedRate and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(EMFixedRate)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','EMFixedRate', convert(varchar,d.EMFixedRate), convert(varchar,i.EMFixedRate), getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where i.EMFixedRate <> d.EMFixedRate and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
end
if update(YTDSUI)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','YTDSUI', convert(varchar,d.YTDSUI), convert(varchar,i.YTDSUI),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.YTDSUI <> d.YTDSUI and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(OccupCat)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'OccupCat', d.OccupCat, i.OccupCat, getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.OccupCat,'') <> isnull(d.OccupCat,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(CatStatus)
	begin
	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'CatStatus', d.CatStatus, i.CatStatus,	getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where isnull(i.CatStatus,'') <> isnull(d.CatStatus,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(DirDeposit)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'DirDeposit', d.DirDeposit, i.DirDeposit, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where i.DirDeposit <> d.DirDeposit and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(RoutingId)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'RoutingId', d.RoutingId, i.RoutingId,	getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.RoutingId,'') <> isnull(d.RoutingId,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(BankAcct)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','BankAcct', d.BankAcct, i.BankAcct,	getdate(), SUSER_SNAME()
    from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
	where isnull(i.BankAcct,'') <> isnull(d.BankAcct,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(AcctType)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'AcctType', d.AcctType, i.AcctType, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.AcctType,'') <> isnull(d.AcctType,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(ActiveYN)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'ActiveYN', d.ActiveYN, i.ActiveYN, getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
   	where i.ActiveYN <> d.ActiveYN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(PensionYN)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','PensionYN', d.PensionYN, i.PensionYN,	getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.PensionYN <> d.PensionYN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(CertYN)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'CertYN', d.CertYN, i.CertYN, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.CertYN <> d.CertYN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(ChkSort)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'ChkSort', d.ChkSort, i.ChkSort, getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.ChkSort,'') <> isnull(d.ChkSort,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(DefaultPaySeq)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'DefaultPaySeq', d.DefaultPaySeq, i.DefaultPaySeq, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.DefaultPaySeq <> d.DefaultPaySeq and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(DDPaySeq)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','DDPaySeq', convert(varchar,d.DDPaySeq), convert(varchar,i.DDPaySeq), getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.DDPaySeq,0) <> isnull(d.DDPaySeq,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Suffix)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Suffix', d.Suffix, i.Suffix, getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.Suffix,'') <> isnull(d.Suffix,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(TradeSeq)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'TradeSeq', convert(varchar,d.TradeSeq), convert(varchar,i.TradeSeq), getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.TradeSeq,0) <> isnull(d.TradeSeq,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(CSLimit)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'CSLimit', convert(varchar,d.CSLimit), convert(varchar,i.CSLimit),	getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.CSLimit,-1) <> isnull(d.CSLimit,-1) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(CSGarnGroup)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'CSGarnGroup', convert(varchar,d.CSGarnGroup), convert(varchar,i.CSGarnGroup),	getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.CSGarnGroup,0) <> isnull(d.CSGarnGroup,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(CSAllocMethod)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'CSAllocMethod', d.CSAllocMethod, i.CSAllocMethod,	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.CSAllocMethod,'') <> isnull(d.CSAllocMethod,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(Shift)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'Shift', convert(varchar,d.Shift), convert(varchar,i.Shift), getdate(), SUSER_SNAME()
   	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where isnull(i.Shift,0) <> isnull(d.Shift,0) and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(NonResAlienYN)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C', 'NonResAlienYN', d.NonResAlienYN, i.NonResAlienYN, getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
    where i.NonResAlienYN <> d.NonResAlienYN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(HDAmt)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','HDAmt', convert(varchar,d.HDAmt), convert(varchar,i.HDAmt),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.HDAmt <> d.HDAmt and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(F1Amt)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','F1Amt', convert(varchar,d.F1Amt), convert(varchar,i.F1Amt),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.F1Amt <> d.F1Amt and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(LCFStock)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','LCFStock', convert(varchar,d.LCFStock), convert(varchar,i.LCFStock),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.LCFStock <> d.LCFStock and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
if update(LCPStock)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','LCPStock', convert(varchar,d.LCPStock), convert(varchar,i.LCPStock),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.LCPStock <> d.LCPStock and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end
   
if update(PayMethodDelivery)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','PayMethodDelivery', convert(varchar,d.PayMethodDelivery), convert(varchar,i.PayMethodDelivery),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.PayMethodDelivery <> d.PayMethodDelivery and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end

-- Issue 124598
if update(UpdatePRAEYN)
	begin
   	insert dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	select 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','UpdatePRAEYN', convert(varchar,d.UpdatePRAEYN), convert(varchar,i.UpdatePRAEYN),	getdate(), SUSER_SNAME()
	from inserted i
    join deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    join dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	where i.UpdatePRAEYN <> d.UpdatePRAEYN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
	end

IF UPDATE(ArrearsActiveYN)
BEGIN
	INSERT dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	SELECT 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
		i.PRCo, 'C','ArrearsActiveYN', convert(varchar,d.ArrearsActiveYN), convert(varchar,i.ArrearsActiveYN),	getdate(), SUSER_SNAME()
	FROM inserted i
    JOIN deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    JOIN dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	WHERE i.ArrearsActiveYN <> d.ArrearsActiveYN and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
END

-- TFS-40964 -- RecentRehireDate -- 
IF UPDATE(RecentRehireDate)
BEGIN
   	INSERT dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	SELECT 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
			i.PRCo, 'C', 'RecentRehireDate', convert(varchar,d.RecentRehireDate,101), convert(varchar,i.RecentRehireDate,101), getdate(), SUSER_SNAME()
    FROM inserted i
    JOIN deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    JOIN dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
    WHERE isnull(i.RecentRehireDate,'') <> isnull(d.RecentRehireDate,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
END

-- TFS-40964 -- RecentSeparationDate --
IF UPDATE(RecentSeparationDate)
BEGIN
   	INSERT dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	SELECT 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
			i.PRCo, 'C', 'RecentSeparationDate', convert(varchar,d.RecentSeparationDate,101), convert(varchar,i.RecentSeparationDate,101), getdate(), SUSER_SNAME()
    FROM inserted i
    JOIN deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    JOIN dbo.bPRCO a with (nolock) on i.PRCo = a.PRCo
    WHERE isnull(i.RecentSeparationDate,'') <> isnull(d.RecentSeparationDate,'') and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
END

-- TFS-40964 -- SeparationRedundancyRetirement --
IF UPDATE(SeparationRedundancyRetirement)
BEGIN
	INSERT dbo.bHQMA(TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
	SELECT 'bPREH', 'PR Co#: ' + convert(varchar,i.PRCo) + ' Empl#: ' + convert(varchar,i.Employee),
			i.PRCo, 'C','SeparationRedundancyRetirement', convert(varchar,d.SeparationRedundancyRetirement), convert(varchar,i.SeparationRedundancyRetirement),	getdate(), SUSER_SNAME()
	FROM inserted i
    JOIN deleted d on i.PRCo = d.PRCo and i.Employee = d.Employee
    JOIN dbo.bPRCO a (nolock) on i.PRCo = a.PRCo
   	WHERE i.SeparationRedundancyRetirement <> d.SeparationRedundancyRetirement and a.AuditEmployees = 'Y' and i.AuditYN = 'Y'
END

return

error:
	select @errmsg = isnull(@errmsg,'') + ' - cannot update PR Employee Header!'
	RAISERROR(@errmsg, 11, -1);
	rollback transaction

GO
PRINT N'Altering trigger [dbo].[btSLCOi] on [dbo].[bSLCO]'
GO


 
ALTER trigger [dbo].[btSLCOi] on [dbo].[bSLCO] for INSERT as
/*--------------------------------------------------------------
* Created: EN  12/30/99 
* Modified: GG 04/20/07 - #30116 - data security review
*			  TRL 02/18/08 --#21452	
*			SCOTTP 05/29/2013 TFS-51580 Added AllowExceededClaimEntryYN column to Audit table
*
*  Insert trigger for SLCO
*
*  Validate SL Company in bHQCo.
*  AuditCoParams must be 'Y'.
*
*  Insert audit entries for changed values into bHQMA.
*--------------------------------------------------------------*/
declare @numrows int, @errmsg varchar(255), @validcnt int

select @numrows = @@rowcount
if @numrows = 0 return
set nocount on

/* validate HQ Company */
select @validcnt = count(*) from dbo.bHQCO c (nolock) join inserted i on c.HQCo = i.SLCo
if @validcnt <> @numrows
	begin
	select @errmsg = 'Invalid SLCompany#, must setup in HQ first'
	goto error
	end
   
/* validate AuditCoParams */
select @validcnt = count(*) from inserted where AuditCoParams = 'Y'
if @validcnt <> @numrows
	begin
	select @errmsg = 'Option to audit company parameters must be checked.'
	goto error
	end
   
/* add HQ Master Audit entry */
insert dbo.bHQMA (TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
select 'bSLCO',  'SL Co#: ' + convert(char(3), SLCo), SLCo, 'A', null, null, null, getdate(), SUSER_SNAME()
from inserted

--#21452
insert dbo.bHQMA (TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
select 'bSLCO',  'SL Co#: ' + convert(char(3), SLCo), SLCo, 'A', 'Attach Batch Reports YN', AttachBatchReportsYN, null, getdate(), SUSER_SNAME()
from inserted

insert dbo.bHQMA (TableName, KeyString, Co, RecType, FieldName, OldValue, NewValue, DateTime, UserName)
select 'bSLCO',  'SL Co#: ' + convert(char(3), SLCo), SLCo, 'A', 'Allow Exceeded Claim Entry YN', AllowExceededClaimEntryYN, null, getdate(), SUSER_SNAME()
from inserted

--#30116 - initialize Data Security
declare @dfltsecgroup smallint
select @dfltsecgroup = DfltSecurityGroup
from dbo.DDDTShared (nolock) where Datatype = 'bSLCo' and Secure = 'Y'
if @dfltsecgroup is not null
	begin
	insert dbo.vDDDS (Datatype, Qualifier, Instance, SecurityGroup)
	select 'bSLCo', i.SLCo, i.SLCo, @dfltsecgroup
	from inserted i 
	where not exists(select 1 from dbo.vDDDS s (nolock) where s.Datatype = 'bSLCo' and s.Qualifier = i.SLCo 
						and s.Instance = convert(char(30),i.SLCo) and s.SecurityGroup = @dfltsecgroup)
	end 
   
return

error:
	select @errmsg = @errmsg + ' - cannot insert SL Company'
	RAISERROR(@errmsg, 11, -1);
	rollback transaction
   
   
   
   
   
  
 





GO
PRINT N'Altering trigger [dbo].[btSLCOu] on [dbo].[bSLCO]'
GO


 

ALTER trigger [dbo].[btSLCOu] on [dbo].[bSLCO] for UPDATE as
/*--------------------------------------------------------------
*
*  Update trigger for SLCO
*  Created By: 	EN  12/30/99
*	Modified By:	MV 6/24/03 - #21560 - add flags to audit
*			  TRL 02/18/08 --#21452	
*				DC 3/24/09 - #129889 - AUS SL - Track Claimed  and Certified amounts
*				GF 10/18/2012 TK-18032 column removed - no audit
*				GF 12/19/2012 TK-20315 added EnforceSLCatchup column to table
*				SCOTTP 05/29/2013 TFS-51580 Added AllowExceededClaimEntryYN column to Audit table
* 
*
*  Reject key changes.
*  AuditCoParams must be 'Y'.
*  Insert audit entries for changed values into bHQMA.
*--------------------------------------------------------------*/

declare @numrows int, @errmsg varchar(255), @validcount INT

select @numrows = @@rowcount
if @numrows = 0 return

select @validcount=0

set nocount on
   
/* check for key changes */
select @validcount = count(*) from deleted d, inserted i
where d.SLCo = i.SLCo
if @validcount <> @numrows
	begin
	select @errmsg = 'Cannot change SL Company'
	goto error
	end

/* validate AuditCoParams */
select @validcount = count(*) from inserted where AuditCoParams = 'Y'
if @validcount <> @numrows
	begin
	select @errmsg = 'Option to audit company parameters must be checked.'
	goto error
	end
   
/* HQMA audit posting */
If update(AuditSLs)
	BEGIN
	insert into bHQMA select 'bSLCO', 'SL Co#: ' + convert(char(3),i.SLCo), i.SLCo, 'C',
		'Audit SL :', d.AuditSLs, i.AuditSLs, getdate(), SUSER_SNAME()
	from inserted i, deleted d
	where i.SLCo = d.SLCo and i.AuditSLs <> d.AuditSLs
	END
If update(CmtdDetailToJC)
	BEGIN
	insert into bHQMA select 'bSLCO', 'SL Co#: ' + convert(char(3),i.SLCo), i.SLCo, 'C',
		'Update Cmtd Cost Detail to JC:', d.CmtdDetailToJC, i.CmtdDetailToJC, getdate(), SUSER_SNAME()
	from inserted i, deleted d
	where i.SLCo = d.SLCo and i.CmtdDetailToJC <> d.CmtdDetailToJC
	END
If update(AuditSLCompliance)
	BEGIN
	insert into bHQMA select 'bSLCO', 'SL Co#: ' + convert(char(3),i.SLCo), i.SLCo, 'C',
		'Audit SL Compliance: ', d.AuditSLCompliance, i.AuditSLCompliance, getdate(), SUSER_SNAME()
	from inserted i, deleted d
	where i.SLCo = d.SLCo and i.AuditSLCompliance <> d.AuditSLCompliance
	END
--#21452
If update(AttachBatchReportsYN)
	begin
	insert into bHQMA select 'bSLCO', 'SL Co#: ' + convert(char(3),i.SLCo), i.SLCo, 'C',
	'Attach Batch Reports: ', d.AttachBatchReportsYN, i.AttachBatchReportsYN, getdate(), SUSER_SNAME()
	from inserted i, deleted d
	where i.SLCo = d.SLCo and i.AttachBatchReportsYN <> d.AttachBatchReportsYN
	end
If update(AllowExceededClaimEntryYN)
	begin
	insert into bHQMA select 'bSLCO', 'SL Co#: ' + convert(char(3),i.SLCo), i.SLCo, 'C',
	'Allow Exceeded Claim Entry: ', d.AllowExceededClaimEntryYN, i.AllowExceededClaimEntryYN, getdate(), SUSER_SNAME()
	from inserted i, deleted d
	where i.SLCo = d.SLCo and i.AllowExceededClaimEntryYN <> d.AllowExceededClaimEntryYN
	end
	
---- TK-20315
If update(EnforceSLCatchup)
	begin
	insert into bHQMA select 'bSLCO', 'SL Co#: ' + convert(char(3),i.SLCo), i.SLCo, 'C',
	'Enforce SL Catchup: ', d.EnforceSLCatchup, i.EnforceSLCatchup, getdate(), SUSER_SNAME()
	from inserted i, deleted d
	where i.SLCo = d.SLCo and i.EnforceSLCatchup <> d.EnforceSLCatchup
	end


return


error:
	select @errmsg = @errmsg + ' - cannot update SL Company '
	RAISERROR(@errmsg, 11, -1);
	rollback transaction
   
   
   
   
   
   
  
 





GO
PRINT N'Altering trigger [dbo].[vtPRCraftClassAllowanceu] on [dbo].[vPRCraftClassAllowance]'
GO
ALTER TRIGGER [dbo].[vtPRCraftClassAllowanceu] ON [dbo].[vPRCraftClassAllowance] FOR UPDATE AS
/*-----------------------------------------------------------------
* Created:		KK  11/09/2012
* Modified:		KK  04/29/2013 TFS-46570 Added ShiftRateOverride column to vPRCraftClassAllowance
*
*	This trigger validates updates to vPRCraftClassAllowance
*
*	Adds HQ Master Audit entry.
*/-----------------------------------------------------------------

IF @@ROWCOUNT = 0 RETURN
DECLARE @errmsg varchar(255)

/************** Record updates in HQMA *******************/
SET NOCOUNT ON

/************* Validate fields before updating ************/    
--Company, Craft, Class and AllowanceTypeName are Key fields and cannot update
IF UPDATE (PRCo)
BEGIN
	SELECT @errmsg = 'PR Company cannot be updated, it is a key value - cannot update PR Craft Class Allowance!'
	RAISERROR(@errmsg, 11, -1);
   	ROLLBACK TRANSACTION
   	RETURN
END

IF UPDATE(Craft)
BEGIN
	SELECT @errmsg = 'Craft cannot be updated, it is a key value - cannot update PR Craft Class Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(Class)
BEGIN
	SELECT @errmsg = 'Class cannot be updated, it is a key value - cannot update PR Craft Class Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(AllowanceTypeName)
BEGIN
	SELECT @errmsg = 'AllowanceTypeName cannot be updated, it is a key value - cannot update PR Craft Class Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

--IF EXISTS (SELECT * FROM inserted i JOIN dbo.bPRCO a WITH(NOLOCK) ON a.PRCo = i.PRCo WHERE a.AuditAllowances = 'Y')
IF UPDATE (EarnCode)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftClassAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Class:' + CONVERT(varchar(10),i.Class)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'EarnCode',			
				CONVERT(varchar(5),d.EarnCode), 
				CONVERT(varchar(5),i.EarnCode),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Class = d.Class
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.EarnCode <> d.EarnCode
END 

IF UPDATE (AllowanceRulesetName)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftClassAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Class:' + CONVERT(varchar(10),i.Class)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'AllowanceRulesetName',			
				CONVERT(varchar(16),d.AllowanceRulesetName), 
				CONVERT(varchar(16),i.AllowanceRulesetName),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Class = d.Class
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.AllowanceRulesetName <> d.AllowanceRulesetName
END 

IF UPDATE (ShiftRateOverride)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftClassAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Class:' + CONVERT(varchar(10),i.Class)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'ShiftRateOverride',			
				CONVERT(varchar(16),d.ShiftRateOverride), 
				CONVERT(varchar(16),i.ShiftRateOverride),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Class = d.Class
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.ShiftRateOverride <> d.ShiftRateOverride
END 

RETURN

 



GO
PRINT N'Altering trigger [dbo].[vtPRCraftClassTemplateAllowanceu] on [dbo].[vPRCraftClassTemplateAllowance]'
GO
ALTER TRIGGER [dbo].[vtPRCraftClassTemplateAllowanceu] ON [dbo].[vPRCraftClassTemplateAllowance] FOR UPDATE AS
/*-----------------------------------------------------------------
* Created:		KK  11/09/2012
* Modified:		KK  04/29/2013 TFS-46570 Added ShiftRateOverride column to vPRCraftClassTemplateAllowance	
*
*	This trigger validates updates to vPRCraftClassTemplateAllowance
*
*	Adds HQ Master Audit entry.
*/-----------------------------------------------------------------

IF @@ROWCOUNT = 0 RETURN
DECLARE @errmsg varchar(255)

/************** Record updates in HQMA *******************/
SET NOCOUNT ON

/************* Validate fields before updating ************/    
--Company, Craft, Class and AllowanceTypeName are Key fields and cannot update
IF UPDATE (PRCo)
BEGIN
	SELECT @errmsg = 'PR Company cannot be updated, it is a key value - cannot update PR Craft Class Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
   	ROLLBACK TRANSACTION
   	RETURN
END

IF UPDATE(Craft)
BEGIN
	SELECT @errmsg = 'Craft cannot be updated, it is a key value - cannot update PR Craft Class Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(Class)
BEGIN
	SELECT @errmsg = 'Class cannot be updated, it is a key value - cannot update PR Craft Class Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(Template)
BEGIN
	SELECT @errmsg = 'Template cannot be updated, it is a key value - cannot update PR Craft Class Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(AllowanceTypeName)
BEGIN
	SELECT @errmsg = 'AllowanceTypeName cannot be updated, it is a key value - cannot update PR Craft Class Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

--IF EXISTS (SELECT * FROM inserted i JOIN dbo.bPRCO a WITH(NOLOCK) ON a.PRCo = i.PRCo WHERE a.AuditAllowances = 'Y')
IF UPDATE (EarnCode)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftClassTemplateAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Class:' + CONVERT(varchar(10),i.Class)
					+ ' Template:' + CONVERT(varchar(4),i.Template)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'EarnCode',			
				CONVERT(varchar(2),d.EarnCode), 
				CONVERT(varchar(2),i.EarnCode),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Class = d.Class
				AND i.Template = d.Template
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.EarnCode <> d.EarnCode
END 

IF UPDATE (AllowanceRulesetName)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftClassTemplateAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Class:' + CONVERT(varchar(10),i.Class)
					+ ' Template:' + CONVERT(varchar(4),i.Template)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'AllowanceRulesetName',			
				CONVERT(varchar(16),d.AllowanceRulesetName), 
				CONVERT(varchar(16),i.AllowanceRulesetName),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Class = d.Class
				AND i.Template = d.Template
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.AllowanceRulesetName <> d.AllowanceRulesetName
END 

IF UPDATE (ShiftRateOverride)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftClassTemplateAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Class:' + CONVERT(varchar(10),i.Class)
					+ ' Template:' + CONVERT(varchar(4),i.Template)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'ShiftRateOverride',			
				CONVERT(varchar(16),d.ShiftRateOverride), 
				CONVERT(varchar(16),i.ShiftRateOverride),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Class = d.Class
				AND i.Template = d.Template
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.ShiftRateOverride <> d.ShiftRateOverride
END 

RETURN

 



GO
PRINT N'Altering trigger [dbo].[vtPRCraftMasterAllowanceu] on [dbo].[vPRCraftMasterAllowance]'
GO
ALTER TRIGGER [dbo].[vtPRCraftMasterAllowanceu] ON [dbo].[vPRCraftMasterAllowance] FOR UPDATE AS

/*-----------------------------------------------------------------
* Created:		KK  11/08/2012
* Modified:		KK  04/29/2013 TFS-46570 Added ShiftRateOverride column to vPRCraftMasterAllowance
*
*	This trigger validates UPDATES to vPRCraftMasterAllowance 
*	
*/-----------------------------------------------------------------
    
DECLARE @errmsg varchar(255), 
		@numrows int   
SELECT @numrows = @@rowcount
IF @numrows = 0 RETURN

SET NOCOUNT ON    
    
/************* Validate fields before updating ************/    

--Company and DL Code and Employee are Key fields and cannot update
IF UPDATE(PRCo)
BEGIN
	SELECT @errmsg = 'PR Company cannot be updated, it is a key value '
	GOTO ERROR
END

IF UPDATE(Craft)
BEGIN
	SELECT @errmsg = 'Craft cannot be updated, it is a key value '
	GOTO ERROR
END

IF UPDATE(AllowanceTypeName)
BEGIN
	SELECT @errmsg = 'AllowanceTypeName cannot be updated, it is a key value '
	GOTO ERROR
END 


/************* Update HQ Master Audit entry **********************************/
IF UPDATE (EarnCode)
BEGIN
	INSERT INTO dbo.bHQMA (TableName,		
						   KeyString, 
						   Co,				
						   RecType, 
						   FieldName,		
						   OldValue, 
						   NewValue,		
						   DateTime, 
						   UserName)
	SELECT 'vPRCraftMasterAllowance',	
			'Craft:' + i.Craft + ' AllowanceTypeName:' + i.AllowanceTypeName, 
			i.PRCo,			
			'C', 
			'EarnCode',			
			d.EarnCode, 
			i.EarnCode,			
			GETDATE(), 
			SUSER_SNAME()
	FROM inserted i
		JOIN deleted d 
		ON i.PRCo = d.PRCo 
		AND i.Craft = d.Craft 
		AND i.AllowanceTypeName = d.AllowanceTypeName
	WHERE i.EarnCode <> d.EarnCode
END
		
IF UPDATE (AllowanceRulesetName)
BEGIN
	INSERT INTO dbo.bHQMA (TableName,		
						   KeyString,
						   Co,
						   RecType,
						   FieldName,
						   OldValue,
						   NewValue,
						   DateTime,
						   UserName)
	SELECT 'vPRCraftMasterAllowance',	
			'Craft:' + i.Craft + ' AllowanceTypeName:' + i.AllowanceTypeName, 
			i.PRCo,			
			'C', 
			'AllowanceRulesetName',			
			d.AllowanceRulesetName, 
			i.AllowanceRulesetName,			
			GETDATE(), 
			SUSER_SNAME()
	FROM inserted i
		JOIN deleted d 
		ON i.PRCo = d.PRCo 
		AND i.Craft = d.Craft 
		AND i.AllowanceTypeName = d.AllowanceTypeName
	WHERE i.AllowanceRulesetName <> d.AllowanceRulesetName
END
		
IF UPDATE (ShiftRateOverride)
BEGIN
	INSERT INTO dbo.bHQMA (TableName,		
						   KeyString,
						   Co,
						   RecType,
						   FieldName,
						   OldValue,
						   NewValue,
						   DateTime,
						   UserName)
	SELECT 'vPRCraftMasterAllowance',	
			'Craft:' + i.Craft + ' AllowanceTypeName:' + i.AllowanceTypeName, 
			i.PRCo,			
			'C', 
			'ShiftRateOverride',			
			d.ShiftRateOverride, 
			i.ShiftRateOverride,			
			GETDATE(), 
			SUSER_SNAME()
	FROM inserted i
		JOIN deleted d 
		ON i.PRCo = d.PRCo 
		AND i.Craft = d.Craft 
		AND i.AllowanceTypeName = d.AllowanceTypeName
	WHERE i.ShiftRateOverride <> d.ShiftRateOverride
END
     
RETURN 
ERROR:
SELECT @errmsg = ISNULL(@errmsg,'') + ' - cannot UPDATE PR Craft Master Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
     
     
     
    
    
    
   
   
   
   
   
   
   
   
GO
PRINT N'Altering trigger [dbo].[vtPRCraftTemplateAllowanceu] on [dbo].[vPRCraftTemplateAllowance]'
GO
ALTER TRIGGER [dbo].[vtPRCraftTemplateAllowanceu] ON [dbo].[vPRCraftTemplateAllowance] FOR UPDATE AS
/*-----------------------------------------------------------------
* Created:		KK  11/09/2012
* Modified:		KK  04/29/2013 TFS-46570 Added ShiftRateOverride column to vPRCraftTemplateAllowance
*
*	This trigger validates updates to vPRCraftTemplateAllowance
*
*	Adds HQ Master Audit entry.
*/-----------------------------------------------------------------

IF @@ROWCOUNT = 0 RETURN
DECLARE @errmsg varchar(255)

/************** Record updates in HQMA *******************/
SET NOCOUNT ON

/************* Validate fields before updating ************/    
--Company, Craft, Class and AllowanceTypeName are Key fields and cannot update
IF UPDATE (PRCo)
BEGIN
	SELECT @errmsg = 'PR Company cannot be updated, it is a key value - cannot update PR Craft Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
   	ROLLBACK TRANSACTION
   	RETURN
END

IF UPDATE(Craft)
BEGIN
	SELECT @errmsg = 'Craft cannot be updated, it is a key value - cannot update PR Craft Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(Template)
BEGIN
	SELECT @errmsg = 'Template cannot be updated, it is a key value - cannot update PR Craft Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

IF UPDATE(AllowanceTypeName)
BEGIN
	SELECT @errmsg = 'AllowanceTypeName cannot be updated, it is a key value - cannot update PR Craft Template Allowance!'
	RAISERROR(@errmsg, 11, -1);
	ROLLBACK TRANSACTION
	RETURN
END

--IF EXISTS (SELECT * FROM inserted i JOIN dbo.bPRCO a WITH(NOLOCK) ON a.PRCo = i.PRCo WHERE a.AuditAllowances = 'Y')
IF UPDATE (EarnCode)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftTemplateAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Template:' + CONVERT(varchar(4),i.Template)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'EarnCode',			
				CONVERT(varchar(2),d.EarnCode), 
				CONVERT(varchar(2),i.EarnCode),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Template = d.Template
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.EarnCode <> d.EarnCode
END 

IF UPDATE (AllowanceRulesetName)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftTemplateAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Template:' + CONVERT(varchar(4),i.Template)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'AllowanceRulesetName',			
				CONVERT(varchar(16),d.AllowanceRulesetName), 
				CONVERT(varchar(16),i.AllowanceRulesetName),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Template = d.Template
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.AllowanceRulesetName <> d.AllowanceRulesetName
END 

IF UPDATE (ShiftRateOverride)
BEGIN
	INSERT INTO dbo.bHQMA
		SELECT  'vPRCraftTemplateAllowance',
			    'Craft:' + CONVERT(varchar(10),i.Craft)
					+ ' Template:' + CONVERT(varchar(4),i.Template)
					+ ' AllowanceTypeName:' + CONVERT(varchar(16),i.AllowanceTypeName),
				i.PRCo, 
				'C', 
				'ShiftRateOverride',			
				CONVERT(varchar(16),d.ShiftRateOverride), 
				CONVERT(varchar(16),i.ShiftRateOverride),			
				GETDATE(), 
				SUSER_SNAME()
		   FROM inserted i
		   JOIN deleted d 
		     ON i.PRCo = d.PRCo
				AND i.Craft = d.Craft 
				AND i.Template = d.Template
				AND i.AllowanceTypeName = d.AllowanceTypeName 
		  WHERE i.ShiftRateOverride <> d.ShiftRateOverride
END 

RETURN

 



GO
PRINT N'Altering permissions on [dbo].[vfAPAUATOAddressGet]'
GO
GRANT SELECT ON  [dbo].[vfAPAUATOAddressGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vAPAUPayeeTaxPaymentATO]'
GO
GRANT SELECT ON  [dbo].[vAPAUPayeeTaxPaymentATO] TO [public]
GRANT INSERT ON  [dbo].[vAPAUPayeeTaxPaymentATO] TO [public]
GRANT DELETE ON  [dbo].[vAPAUPayeeTaxPaymentATO] TO [public]
GRANT UPDATE ON  [dbo].[vAPAUPayeeTaxPaymentATO] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vAPAUPayerTaxPaymentATO]'
GO
GRANT SELECT ON  [dbo].[vAPAUPayerTaxPaymentATO] TO [public]
GRANT INSERT ON  [dbo].[vAPAUPayerTaxPaymentATO] TO [public]
GRANT DELETE ON  [dbo].[vAPAUPayerTaxPaymentATO] TO [public]
GRANT UPDATE ON  [dbo].[vAPAUPayerTaxPaymentATO] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vPRAULimitsAndRates]'
GO
GRANT REFERENCES ON  [dbo].[vPRAULimitsAndRates] TO [public]
GRANT SELECT ON  [dbo].[vPRAULimitsAndRates] TO [public]
GRANT INSERT ON  [dbo].[vPRAULimitsAndRates] TO [public]
GRANT DELETE ON  [dbo].[vPRAULimitsAndRates] TO [public]
GRANT UPDATE ON  [dbo].[vPRAULimitsAndRates] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vPREmplPeriodsWithoutPay]'
GO
GRANT REFERENCES ON  [dbo].[vPREmplPeriodsWithoutPay] TO [public]
GRANT SELECT ON  [dbo].[vPREmplPeriodsWithoutPay] TO [public]
GRANT INSERT ON  [dbo].[vPREmplPeriodsWithoutPay] TO [public]
GRANT DELETE ON  [dbo].[vPREmplPeriodsWithoutPay] TO [public]
GRANT UPDATE ON  [dbo].[vPREmplPeriodsWithoutPay] TO [public]
GO
PRINT N'Altering permissions on [dbo].[APAUPayeeTaxPaymentATO]'
GO
GRANT SELECT ON  [dbo].[APAUPayeeTaxPaymentATO] TO [public]
GRANT INSERT ON  [dbo].[APAUPayeeTaxPaymentATO] TO [public]
GRANT DELETE ON  [dbo].[APAUPayeeTaxPaymentATO] TO [public]
GRANT UPDATE ON  [dbo].[APAUPayeeTaxPaymentATO] TO [public]
GO
PRINT N'Altering permissions on [dbo].[APAUPayerTaxPaymentATO]'
GO
GRANT SELECT ON  [dbo].[APAUPayerTaxPaymentATO] TO [public]
GRANT INSERT ON  [dbo].[APAUPayerTaxPaymentATO] TO [public]
GRANT DELETE ON  [dbo].[APAUPayerTaxPaymentATO] TO [public]
GRANT UPDATE ON  [dbo].[APAUPayerTaxPaymentATO] TO [public]
GO
PRINT N'Altering permissions on [dbo].[PREmplPeriodsWithoutPay]'
GO
GRANT SELECT ON  [dbo].[PREmplPeriodsWithoutPay] TO [public]
GRANT INSERT ON  [dbo].[PREmplPeriodsWithoutPay] TO [public]
GRANT DELETE ON  [dbo].[PREmplPeriodsWithoutPay] TO [public]
GRANT UPDATE ON  [dbo].[PREmplPeriodsWithoutPay] TO [public]
GO
PRINT N'Altering permissions on [dbo].[PRAULimitsAndRates]'
GO
GRANT SELECT ON  [dbo].[PRAULimitsAndRates] TO [public]
GRANT INSERT ON  [dbo].[PRAULimitsAndRates] TO [public]
GRANT DELETE ON  [dbo].[PRAULimitsAndRates] TO [public]
GRANT UPDATE ON  [dbo].[PRAULimitsAndRates] TO [public]
GO
PRINT N'Altering permissions on [dbo].[udxrefAPVendor]'
GO
GRANT SELECT ON  [dbo].[udxrefAPVendor] TO [public]
GRANT INSERT ON  [dbo].[udxrefAPVendor] TO [public]
GRANT DELETE ON  [dbo].[udxrefAPVendor] TO [public]
GRANT UPDATE ON  [dbo].[udxrefAPVendor] TO [public]
GO
PRINT N'Altering permissions on [dbo].[udxrefARCustomer]'
GO
GRANT SELECT ON  [dbo].[udxrefARCustomer] TO [public]
GRANT INSERT ON  [dbo].[udxrefARCustomer] TO [public]
GRANT DELETE ON  [dbo].[udxrefARCustomer] TO [public]
GRANT UPDATE ON  [dbo].[udxrefARCustomer] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vwMckNewProject]'
GO
GRANT SELECT ON  [dbo].[vwMckNewProject] TO [public]
GRANT INSERT ON  [dbo].[vwMckNewProject] TO [public]
GRANT DELETE ON  [dbo].[vwMckNewProject] TO [public]
GRANT UPDATE ON  [dbo].[vwMckNewProject] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPAUATOAmendedDateVal]'
GO
GRANT EXECUTE ON  [dbo].[vspAPAUATOAmendedDateVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPTaxablePaymentUpdate]'
GO
GRANT EXECUTE ON  [dbo].[vspAPTaxablePaymentUpdate] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPAUATOPayeeTaxPaymentsInit]'
GO
GRANT EXECUTE ON  [dbo].[vspAPAUATOPayeeTaxPaymentsInit] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_Standard]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_Standard] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_Pre83TaxFreeGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_Pre83TaxFreeGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_RedundancyTaxFreeGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_RedundancyTaxFreeGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_TaxYearWagesGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_TaxYearWagesGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_Redundancy]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_Redundancy] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_Death]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_Death] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_CapAmtsGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_CapAmtsGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_UnderPreservationAgeYN]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_UnderPreservationAgeYN] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_LimitsAndRatesGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_LimitsAndRatesGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPTaxablePaymentGridFill]'
GO
GRANT EXECUTE ON  [dbo].[vspAPTaxablePaymentGridFill] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPREmplPWPDateVal]'
GO
GRANT EXECUTE ON  [dbo].[vspPREmplPWPDateVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_Unfair]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_Unfair] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPRAUPAYGItemVal]'
GO
GRANT EXECUTE ON  [dbo].[vspPRAUPAYGItemVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_Marginal_PAYG]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_Marginal_PAYG] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPAUATOPayerTaxYearVal]'
GO
GRANT EXECUTE ON  [dbo].[vspAPAUATOPayerTaxYearVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPAUATOExportGet]'
GO
GRANT EXECUTE ON  [dbo].[vspAPAUATOExportGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_Invalidity]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_Invalidity] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPMSLGetNextSLVal]'
GO
GRANT EXECUTE ON  [dbo].[vspPMSLGetNextSLVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPAUATOClearAmendedEFile]'
GO
GRANT EXECUTE ON  [dbo].[vspAPAUATOClearAmendedEFile] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPRDaysWithoutPayGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPRDaysWithoutPayGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_TaxComputations]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_TaxComputations] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_TaxRatesGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_TaxRatesGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPMSLGetNextSLSeq]'
GO
GRANT EXECUTE ON  [dbo].[vspPMSLGetNextSLSeq] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspPR_AU_ETP_InvalidityTaxFreeGet]'
GO
GRANT EXECUTE ON  [dbo].[vspPR_AU_ETP_InvalidityTaxFreeGet] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPTaxableTaxYearVal]'
GO
GRANT EXECUTE ON  [dbo].[vspAPTaxableTaxYearVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspAPTaxableCreditorVal]'
GO
GRANT EXECUTE ON  [dbo].[vspAPTaxableCreditorVal] TO [public]
GO
PRINT N'Altering permissions on [dbo].[vspSLClaimBalForwardCreate]'
GO
GRANT EXECUTE ON  [dbo].[vspSLClaimBalForwardCreate] TO [public]
GO
