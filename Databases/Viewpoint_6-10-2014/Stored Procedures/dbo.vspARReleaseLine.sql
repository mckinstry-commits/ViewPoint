SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE proc [dbo].[vspARReleaseLine]
/********************************************************
* CREATED BY: 	TJL 06/08/05 - Issue #27715, written for 6x
* MODIFIED BY:	TJL 06/18/08 - Issue #128371, ARRelease International Sales Tax
*
*
* USAGE:
* Initiated by ARRelease form during manual entry and called from procedure vspARRelease
* during Auto Release calculations.
*
* INPUT PARAMETERS:
*
* OUTPUT PARAMETERS:
*	Error message
*
* RETURN VALUE:
* 	0 	    Success
*	1 & message Failure
**********************************************************/
@ARCo bCompany, @BatchMth bMonth, @BatchId bBatchID, @BatchSeq int,	@Mth bMonth, @ARTrans bTrans, 
	@ReleasePct bPct, @ReleaseRetg bDollar = 0, @RelRetgTax bDollar = 0, @FromARForm bYN = 'N',
	@errmsg varchar(512) output
as

set nocount on

declare @count int

/* General variables */
declare @rcode int, @ARLine smallint, @RelRetgPct numeric(5,2), @FirstLine int, @NextARLine int,
	@passes tinyint, @RevValueFlag tinyint, @opencursorARTL tinyint

/* Retg Amount variables */
declare @OpenRetg bDollar, @RetgLeft bDollar, @PostRetg bDollar, @OpenRetgTax bDollar, @PostRetgTax bDollar, @RetgTaxLeft bDollar,
	@PostAmt bDollar, @pass1OpenRetg bDollar 

select @rcode = 0, @opencursorARTL = 0, @passes = 0, @RevValueFlag = 0

if @ARCo is null
	begin
	select @errmsg='Must supply an AR Company', @rcode=1
	goto vspexit
	end
if @BatchMth is null
	begin
	select @errmsg='Must supply a batch month', @rcode=1
	goto vspexit
	end
if @BatchId is null
	begin
	select @errmsg='Must supply a batchid', @rcode=1
	goto vspexit
	end
if @BatchSeq is null
	begin
	select @errmsg='Must supply a batch sequence', @rcode=1
	goto vspexit
	end

/* Get Payment transaction number for a transaction that has been added back
into the batch. */
--select @retgtrans = min(ARTrans)
--from bARBL with (nolock)
--where Co = @ARCo and Mth = @BatchMth and BatchId = @BatchId and BatchSeq = @BatchSeq

/* Get OpenRetgTax value when user has applied values directly to the ARRelease grid. */
if @FromARForm = 'Y'
	begin
	select @RelRetgTax = (isnull(sum(RetgTax),0)) * @ReleasePct
	from ARTL with (nolock)
	where ARCo = @ARCo and ApplyMth = @Mth and ApplyTrans = @ARTrans
	end

/* Keep a running Total of how much Retg/RetgTax is left to release in each bucket. */ 
select @RetgLeft = @ReleaseRetg, @RetgTaxLeft = @RelRetgTax

CycleThruLines:

/* Declare cursor on the ARLine(s) for this transaction */
declare bcARTL cursor local fast_forward for
select l.ARLine
from bARTH h with (nolock)
join bARTL l with (nolock) on l.ARCo = h.ARCo and l.Mth = h.Mth and l.ARTrans = h.ARTrans
where h.ARCo = @ARCo and h.Mth = @Mth and h.ARTrans = @ARTrans and h.Source like 'AR%'  	-- do not include retainage created by JB

/* Open cursor */
open bcARTL
select @opencursorARTL = 1
select @passes = @passes + 1	--For Neg/Rev Polarity lines/column handling

fetch next from bcARTL into @ARLine
while @@fetch_status = 0
	Begin	/* Begin Line Loop */
 	select @PostAmt=0, @PostRetg=0, @PostRetgTax=0, @pass1OpenRetg = 0

	/* Calculate the retainage for all the lines in AR that are applied to the cursor's ARLine
	 this calculation includes + or - adjustments that have been applied to the original line */
	select @OpenRetg = isnull(sum(Retainage),0), @OpenRetgTax = isnull(sum(RetgTax),0)
	from ARTL with (nolock)
	where ARCo = @ARCo and ApplyMth = @Mth and ApplyTrans = @ARTrans and ApplyLine = @ARLine

	select @pass1OpenRetg = @OpenRetg		--Used to calculate Line Retg Release Pct during Pass 2

   /**************************** NEGATIVE/REVERSE POLARITY LINE OR COLUMN HANDLING ONLY *******************************/
   	/* Combine with This BatchSeq values to be posted.  The combined values below will be 0.00 during this pass!
   	   They are ONLY considered when a Reverse Polarity value (Usually Neg column Or Neg Line) has been
   	   encountered.  In which case, we are cycling thru the Lines of this invoice a 2nd
   	   time to distribute the extra release amount generated by posting negative values across lines.  
	   This is a very real situation and a second pass cannot be avoided. */
   	if @RevValueFlag = 1 and @passes = 2
   		begin	/* Begin Reverse Polarity handling */
   	 	select 	@OpenRetg = @OpenRetg - IsNull(sum(bARBL.Retainage),0),
				@OpenRetgTax = @OpenRetgTax - IsNull(sum(bARBL.RetgTax),0)
   	   	from bARBL with (nolock)
   	   	where bARBL.Co = @ARCo and bARBL.ApplyMth = @Mth and bARBL.ApplyTrans = @ARTrans and bARBL.ApplyLine = @ARLine
   			and bARBL.Mth = @BatchMth and bARBL.BatchId = @BatchId and bARBL.BatchSeq = @BatchSeq	/* Include this seq */
   		end		/* End Reverse Polarity Handling */
   /**************************** END NEGATIVE/REVERSE LINE OR COLUMN HANDLING ONLY *******************************/

   /********************** EVALUATE AND SET POST AMOUNTS BASED ON INPUTTED APPLY AMOUNTS *******************/
   
   	/* Accumulate Invoice AmtDue totals during the 1st pass of all lines.  It may
   	   be used later to determine if Overpayment of this invoice is allowed. */

   	/* Set post amounts. */
   	select @PostRetg = case
   			when @OpenRetg = 0 then 0
   			when (@ReleaseRetg > 0 and @OpenRetg < 0) or (@ReleaseRetg < 0 and @OpenRetg > 0) then @OpenRetg --Neg/Rev column handling
   			when abs(@OpenRetg) <= abs(@RetgLeft) and @RetgLeft <> 0 then @OpenRetg
   	 		when abs(@OpenRetg) > abs(@RetgLeft) and @RetgLeft <> 0 then @RetgLeft
   	     	else 0
   	 		end,
		/* RetgTax requires special handling.  There is no exposed input for the user on the ARRelease grid.  
		   RetgTax release amount is determined automatically for the user behind the scenes. */
		@PostRetgTax = case
   			when @PostRetg = 0 then 0
   			when (@ReleaseRetg > 0 and @OpenRetg < 0) or (@ReleaseRetg < 0 and @OpenRetg > 0) then @OpenRetgTax --Neg/Rev column handling
   			when abs(@OpenRetgTax) <= abs(@RetgTaxLeft) and abs(@OpenRetgTax) <= abs(@PostRetg) and @RetgTaxLeft <> 0 then @OpenRetgTax
			when abs(@OpenRetgTax) <= abs(@RetgTaxLeft) and abs(@OpenRetgTax) > abs(@PostRetg) and @RetgTaxLeft <> 0 then @PostRetg
   	 		when abs(@OpenRetgTax) > abs(@RetgTaxLeft) and abs(@RetgTaxLeft) <= abs(@PostRetg) and @RetgTaxLeft <> 0 then @RetgTaxLeft
			when abs(@OpenRetgTax) > abs(@RetgTaxLeft) and abs(@RetgTaxLeft) > abs(@PostRetg) and @RetgTaxLeft <> 0 then @PostRetg
   	     	else 0
   	 		end

	/* @PostAmt is dependent upon @PostRetg must be determined last. */
	select @PostAmt = @PostRetg

	/* PostRetgTax value is determined by the PostRetg value BUT after both have been calculated we need to evaluate,
	   one more time, to ensure that once these values get posted for the line, there remains enough in the RetgLeft bucket to 
	   cover any remaining amounts in the RetgTaxLeft bucket.  Without this check you can end up with 0.00 in the RetgLeft bucket
	   and some value in the RetgTaxLeft bucket that never gets posted to RetgTax.  In effect, your payment on RetgTax
	   is not the same Percent ratio as that of your retainage payment.  This check helps eliminate this problem.
	   Posted Retainage Value for the Line is:
		MAX Value:  Will be the PostRetg value minus the RetgTaxLeft value after posting.  Leaving enough for remaining RetgTaxLeft.
		MIN Value:  Will be the value of the PostRetgTax.  PostRetg can never be less then the PostRetgTax value on a line. */
	if abs(@RetgLeft - @PostRetg) < abs(@RetgTaxLeft - @PostRetgTax)  --Do we still have more Retainage then RetgTax left to post?
		begin
		select @PostRetg = case when abs(@PostRetg - (@RetgTaxLeft - @PostRetgTax)) > abs(@PostRetgTax) then
			@PostRetg - (@RetgTaxLeft - @PostRetgTax) else @PostRetgTax end
		end

   	/* Negative/Reverse Polarity Line/Column handling.  Will later be used to determine of a 2nd
   	   Pass is required to release extra cash generated by zeroing out these values. */
   	if ((@ReleaseRetg > 0 and @OpenRetg < 0) or (@ReleaseRetg < 0 and @OpenRetg > 0)) select @RevValueFlag = 1

PostRoutine:
	if @passes = 1
   		begin	/* Begin Pass One batch insert */
		/*First try to update batch */
		update bARBL
		set Amount = @PostAmt, 
			Retainage = @PostRetg,
			RetgTax = @PostRetgTax,
			RetgPct = case when @OpenRetg = 0 then 0 else @PostRetg/@OpenRetg end
		where Co = @ARCo and Mth = @BatchMth and BatchId = @BatchId and BatchSeq = @BatchSeq 
			and	ApplyMth = @Mth and ApplyTrans = @ARTrans and ApplyLine = @ARLine

		if isnull(@@rowcount,0) = 0 and (isnull(@PostAmt,0) <> 0 or isnull(@PostRetg,0) <> 0 or isnull(@PostRetgTax,0) <> 0)
			begin
			select @NextARLine=isnull(Max(ARLine),0) + 1
			from bARBL with (nolock)
			where Co = @ARCo and Mth = @BatchMth and BatchId = @BatchId and BatchSeq = @BatchSeq and ARLine < 10000
		
			/* Insert into batch */
			insert into bARBL(Co, Mth, BatchId, BatchSeq, ARLine, TransType, ARTrans, RecType,
				LineType, Description, Amount, 
				RetgPct, 
				Retainage, RetgTax, GLCo, GLAcct, 
	    		TaxGroup, TaxCode, ApplyMth, ApplyTrans, ApplyLine, JCCo, Contract, Item)
			select ARCo, @BatchMth, @BatchId, @BatchSeq, @NextARLine, 'A', null, RecType,
		 		'R', 'Release Retainage', @PostAmt, 
				case when @OpenRetg = 0 then 0 else @PostRetg/@OpenRetg end, 
				@PostRetg, @PostRetgTax, GLCo, GLAcct, 
	   			TaxGroup, TaxCode, Mth, ARTrans, ARLine, JCCo, Contract, Item
			from bARTL with (nolock)
			where ARCo = @ARCo and Mth = @Mth and ARTrans = @ARTrans and ARLine = @ARLine

			/* If the update or insert has failed, exit immediately. */
			if isnull(@@rowcount,0) = 0
		  		begin
		  		select @errmsg = 'Updating Batch Detail Table has failed on'
				select @errmsg = @errmsg + ' Mth: ' + isnull(convert(varchar(8),@Mth,1),'') 
				select @errmsg = @errmsg + ' ARTrans: ' + isnull(convert(varchar(6),@ARTrans), ''), @rcode=1
		  		goto vspexit
		  		end
			end
   		end		/* End Pass One batch insert */

   	if @passes = 2
   		begin	/* Begin Pass two batch update for Reverse/Negative Polariyt Line/Column handling. */
		if isnull(@PostAmt,0) <> 0 or isnull(@PostRetg,0) <> 0 or isnull(@PostRetgTax,0) <> 0
			begin
   			/* DO NOT clear out values, we are adding to what already exists from the first pass. */
			update bARBL
			set Amount = Amount + @PostAmt, 
				Retainage = Retainage + @PostRetg,
				RetgTax = RetgTax + @PostRetgTax,
				RetgPct = case when @pass1OpenRetg = 0 then 0 else (Retainage + @PostRetg)/@pass1OpenRetg end
			where Co = @ARCo and Mth = @BatchMth and BatchId = @BatchId and BatchSeq = @BatchSeq 
				and	ApplyMth = @Mth and ApplyTrans = @ARTrans and ApplyLine = @ARLine

			if isnull(@@rowcount,0) = 0 and (isnull(@PostAmt,0) <> 0 or isnull(@PostRetg,0) <> 0 or isnull(@PostRetgTax,0) <> 0)
				begin
				select @NextARLine=isnull(Max(ARLine),0) + 1
				from bARBL with (nolock)
				where Co = @ARCo and Mth = @BatchMth and BatchId = @BatchId and BatchSeq = @BatchSeq and ARLine < 10000
			
				/* Insert into batch */
				insert into bARBL(Co, Mth, BatchId, BatchSeq, ARLine, TransType, ARTrans, RecType,
					LineType, Description, Amount, 
					RetgPct,	
					Retainage, RetgTax, GLCo, GLAcct, 
	    			TaxGroup, TaxCode, ApplyMth, ApplyTrans, ApplyLine, JCCo, Contract, Item)
				select ARCo, @BatchMth, @BatchId, @BatchSeq, @NextARLine, 'A', null, RecType,
		 			'R', 'Release Retainage', @PostAmt, 
					case when @pass1OpenRetg = 0 then 0 else @PostRetg/@pass1OpenRetg end,	--Quick fix 6.2.0, no issue. Was incorrectly using (when @OpenRetg = 0) here
					@PostRetg, @PostRetgTax, GLCo, GLAcct, 
	   				TaxGroup, TaxCode, Mth, ARTrans, ARLine, JCCo, Contract, Item
				from bARTL with (nolock)
				where ARCo = @ARCo and Mth = @Mth and ARTrans = @ARTrans and ARLine = @ARLine

				/* If the update or insert has failed, exit immediately. */
				if isnull(@@rowcount,0) = 0
	  				begin
	  				select @errmsg = 'Updating Batch Detail Table has failed on'
					select @errmsg = @errmsg + ' Mth: ' + isnull(convert(varchar(8),@Mth,1),'') 
					select @errmsg = @errmsg + ' ARTrans: ' + isnull(convert(varchar(6),@ARTrans), ''), @rcode=1
	  				goto vspexit
	  				end
				end
			end
   		end		/* End Pass two batch update for Reverse/Negative Line/Column handling. */

   	/* Update the running totals. */
   	select @RetgLeft = @RetgLeft - @PostRetg, @RetgTaxLeft = @RetgTaxLeft - @PostRetgTax
 
   	/* If any Leftover amounts exist (Invoice is overreleased), the overpaid amount will be placed
       on first line. */
   	if @FirstLine is null select @FirstLine = @ARLine
    
   	/* Get next line. */
   	fetch next from bcARTL into @ARLine
   
   	End   /* End Line Loop */

/* Cleanup after each pass as is appropriate */
if @opencursorARTL = 1
   	begin
	close bcARTL
	deallocate bcARTL
	select @opencursorARTL = 0
   	end
   
if @passes = 2 select @RevValueFlag = 0

ReversePolarity_Line:
	/* Can ONLY occur once and ONLY if Negative/Reverse polarity values have been encountered on 1st pass. */
	if @RevValueFlag = 1 and (@RetgLeft <> 0 or @RetgTaxLeft <> 0)
   		begin
   		goto CycleThruLines		--Cannot avoid a 2nd pass under this condition
   		end

/********************* THE FOLLOWING SHOULD NEVER OCCUR DUE TO FORM RESTRICTIONS **************************/
OverRelease: 
   if @FirstLine is not null and (@RetgLeft <> 0 or @RetgTaxLeft <> 0)
    	begin	/* Begin OverRelease Processing */
   		/* Retainage has 0.00 balance, begin OverRelease */
		update bARBL
		set Retainage = -(@RetgLeft) + Retainage,
			RetgTax = -(@RetgTaxLeft) + RetgTax
   		where Co = @ARCo and Mth = @BatchMth and BatchId = @BatchId and BatchSeq = @BatchSeq and
       		ApplyMth = @Mth and ApplyTrans = @ARTrans and ApplyLine = @FirstLine
   
		select @errmsg = 'This will over release retainage on the invoice and will be applied to Line #1.', @rcode = 7
		select @RetgTaxLeft = 0
    	end		/* End OverRelease Processing */
    
vspexit:

if isnull(@RetgTaxLeft, 0) <> 0
	begin 
	select @RelRetgPct = @ReleasePct * 100
	if @errmsg is not null select @errmsg = @errmsg + char(13) + char(10) + char(13) + char(10)
	select @errmsg = isnull(@errmsg, '') + 'Retainage tax was not released by the full ' + convert(varchar(6), @RelRetgPct) + '%.  '
	select @errmsg = @errmsg + 'Use the Release Retainage Detail form to verify or change the Retainage Tax released amount on this invoice.'
	select @rcode = 7
	end

if @opencursorARTL = 1
   	begin
	close bcARTL
	deallocate bcARTL
	select @opencursorARTL = 0
   	end
   
if @rcode <> 0 select @errmsg = @errmsg
return @rcode


GO
GRANT EXECUTE ON  [dbo].[vspARReleaseLine] TO [public]
GO
